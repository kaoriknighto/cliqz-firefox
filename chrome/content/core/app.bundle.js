!function(e){function t(e){Object.defineProperty(this,e,{enumerable:!0,get:function(){return this[v][e]}})}function r(e){if("undefined"!=typeof System&&System.isModule?System.isModule(e):"[object Module]"===Object.prototype.toString.call(e))return e;var t={default:e,__useDefault:e};if(e&&e.__esModule)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return new o(t)}function o(e){Object.defineProperty(this,v,{value:e}),Object.keys(e).forEach(t,this)}function n(e){return"@node/"===e.substr(0,6)?c(e,r(m(e.substr(6))),{}):p[e]}function u(e){var t=n(e);if(!t)throw new Error('Module "'+e+'" expected, but not contained in build.');if(t.module)return t.module;var r=t.linkRecord;return i(t,r),a(t,r,[]),t.module}function i(e,t){if(!t.depLoads){t.declare&&d(e,t),t.depLoads=[];for(var r=0;r<t.deps.length;r++){var o=n(t.deps[r]);t.depLoads.push(o),o.linkRecord&&i(o,o.linkRecord);var u=t.setters&&t.setters[r];u&&(u(o.module||o.linkRecord.moduleObj),o.importerSetters.push(u))}return e}}function d(t,r){var o=r.moduleObj,n=t.importerSetters,u=!1,i=r.declare.call(e,function(e,t){if(!u){if("object"==typeof e)for(var r in e)"__useDefault"!==r&&(o[r]=e[r]);else o[e]=t;u=!0;for(var i=0;i<n.length;i++)n[i](o);return u=!1,t}},{id:t.key});"function"!=typeof i?(r.setters=i.setters,r.execute=i.execute):(r.setters=[],r.execute=i)}function l(e,t,r){return p[e]={key:e,module:void 0,importerSetters:[],linkRecord:{deps:t,depLoads:void 0,declare:r,setters:void 0,execute:void 0,moduleObj:{}}}}function f(e,t,r,o){var n={};return p[e]={key:e,module:void 0,importerSetters:[],linkRecord:{deps:t,depLoads:void 0,declare:void 0,execute:o,executingRequire:r,moduleObj:{default:n,__useDefault:n},setters:void 0}}}function s(e,t,r){return function(o){for(var n=0;n<e.length;n++)if(e[n]===o){var u,i=t[n],d=i.linkRecord;return u=d?-1===r.indexOf(i)?a(i,d,r):d.moduleObj:i.module,"__useDefault"in u?u.__useDefault:u}}}function a(t,r,n){if(n.push(t),t.module)return t.module;var u;if(r.setters){for(var i=0;i<r.deps.length;i++){var d=r.depLoads[i],l=d.linkRecord;l&&-1===n.indexOf(d)&&(u=a(d,l,l.setters?n:[]))}r.execute.call(y)}else{var f={id:t.key},c=r.moduleObj;Object.defineProperty(f,"exports",{configurable:!0,set:function(e){c.default=c.__useDefault=e},get:function(){return c.__useDefault}});var p=s(r.deps,r.depLoads,n);if(!r.executingRequire)for(var i=0;i<r.deps.length;i++)p(r.deps[i]);var v=r.execute.call(e,p,c.__useDefault,f);void 0!==v?c.default=c.__useDefault=v:f.exports!==c.__useDefault&&(c.default=c.__useDefault=f.exports);var m=c.__useDefault;if(m&&m.__esModule)for(var b in m)Object.hasOwnProperty.call(m,b)&&(c[b]=m[b])}var f=t.module=new o(r.moduleObj);if(!r.setters)for(var i=0;i<t.importerSetters.length;i++)t.importerSetters[i](f);return f}function c(e,t){return p[e]={key:e,module:t,importerSetters:[],linkRecord:void 0}}var p={},v="undefined"!=typeof Symbol?Symbol():"@@baseObject";o.prototype=Object.create(null),"undefined"!=typeof Symbol&&Symbol.toStringTag&&(o.prototype[Symbol.toStringTag]="Module");var m="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&"undefined"!=typeof require.resolve&&"undefined"!=typeof process&&process.platform&&require,y={};return Object.freeze&&Object.freeze(y),function(e,t,n,i){return function(d){d(function(d){var s={_nodeRequire:m,register:l,registerDynamic:f,registry:{get:function(e){return p[e].module},set:c},newModule:function(e){return new o(e)}};c("@empty",new o({}));for(var a=0;a<t.length;a++)c(t[a],r(arguments[a],{}));i(s);var v=u(e[0]);if(e.length>1)for(var a=1;a<e.length;a++)u(e[a]);return n?v.__useDefault:(v instanceof o&&Object.defineProperty(v,"__esModule",{value:!0}),v)})}}}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this)

(["a"], [], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
$__System.registerDynamic('b', [], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var VALID_HOSTNAME_VALUE = 0;

  /**
   * Return min(a, b), handling possible `null` values.
   *
   * @param {number|null} a
   * @param {number|null} b
   * @return {number|null}
   */
  function minIndex(a, b) {
    if (a === null) {
      return b;
    } else if (b === null) {
      return a;
    }

    return a < b ? a : b;
  }

  /**
   * Insert a public suffix rule in the `trie`.
   *
   * @param {object} rule
   * @param {object} trie
   * @return {object} trie (updated)
   */
  function insertInTrie(rule, trie) {
    var parts = rule.parts;
    var node = trie;

    for (var i = 0; i < parts.length; i += 1) {
      var part = parts[i];
      var nextNode = node[part];
      if (nextNode === undefined) {
        nextNode = Object.create(null);
        node[part] = nextNode;
      }

      node = nextNode;
    }

    node.$ = VALID_HOSTNAME_VALUE;

    return trie;
  }

  /**
   * Recursive lookup of `parts` (starting at `index`) in the tree.
   *
   * @param {array} parts
   * @param {object} trie
   * @param {number} index - when to start in `parts` (initially: length - 1)
   * @return {number} size of the suffix found (in number of parts matched)
   */
  function lookupInTrie(parts, trie, index) {
    var part;
    var nextNode;
    var publicSuffixIndex = null;

    // We have a match!
    if (trie.$ !== undefined) {
      publicSuffixIndex = index + 1;
    }

    // No more `parts` to look for
    if (index === -1) {
      return publicSuffixIndex;
    }

    part = parts[index];

    // Check branch corresponding to next part of hostname
    nextNode = trie[part];
    if (nextNode !== undefined) {
      publicSuffixIndex = minIndex(publicSuffixIndex, lookupInTrie(parts, nextNode, index - 1));
    }

    // Check wildcard branch
    nextNode = trie['*'];
    if (nextNode !== undefined) {
      publicSuffixIndex = minIndex(publicSuffixIndex, lookupInTrie(parts, nextNode, index - 1));
    }

    return publicSuffixIndex;
  }

  /**
   * Contains the public suffix ruleset as a Trie for efficient look-up.
   *
   * @constructor
   */
  function SuffixTrie(rules) {
    this.exceptions = Object.create(null);
    this.rules = Object.create(null);

    if (rules) {
      for (var i = 0; i < rules.length; i += 1) {
        var rule = rules[i];
        if (rule.exception) {
          insertInTrie(rule, this.exceptions);
        } else {
          insertInTrie(rule, this.rules);
        }
      }
    }
  }

  /**
   * Load the trie from JSON (as serialized by JSON.stringify).
   */
  SuffixTrie.fromJson = function (json) {
    var trie = new SuffixTrie();

    trie.exceptions = json.exceptions;
    trie.rules = json.rules;

    return trie;
  };

  /**
   * Check if `value` is a valid TLD.
   */
  SuffixTrie.prototype.hasTld = function (value) {
    // All TLDs are at the root of the Trie.
    return this.rules[value] !== undefined;
  };

  /**
   * Check if `hostname` has a valid public suffix in `trie`.
   *
   * @param {string} hostname
   * @return {string|null} public suffix
   */
  SuffixTrie.prototype.suffixLookup = function (hostname) {
    var parts = hostname.split('.');

    // Look for a match in rules
    var publicSuffixIndex = lookupInTrie(parts, this.rules, parts.length - 1);

    if (publicSuffixIndex === null) {
      return null;
    }

    // Look for exceptions
    var exceptionIndex = lookupInTrie(parts, this.exceptions, parts.length - 1);

    if (exceptionIndex !== null) {
      return parts.slice(exceptionIndex + 1).join('.');
    }

    return parts.slice(publicSuffixIndex).join('.');
  };

  module.exports = SuffixTrie;
});
$__System.registerDynamic("c", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = { "exceptions": { "ck": { "www": { "$": 0 } }, "jp": { "kawasaki": { "city": { "$": 0 } }, "kitakyushu": { "city": { "$": 0 } }, "kobe": { "city": { "$": 0 } }, "nagoya": { "city": { "$": 0 } }, "sapporo": { "city": { "$": 0 } }, "sendai": { "city": { "$": 0 } }, "yokohama": { "city": { "$": 0 } } } }, "rules": { "ac": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "mil": { "$": 0 }, "org": { "$": 0 } }, "ad": { "$": 0, "nom": { "$": 0 } }, "ae": { "$": 0, "co": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "sch": { "$": 0 }, "ac": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "blogspot": { "$": 0 }, "nom": { "$": 0 } }, "aero": { "$": 0, "accident-investigation": { "$": 0 }, "accident-prevention": { "$": 0 }, "aerobatic": { "$": 0 }, "aeroclub": { "$": 0 }, "aerodrome": { "$": 0 }, "agents": { "$": 0 }, "aircraft": { "$": 0 }, "airline": { "$": 0 }, "airport": { "$": 0 }, "air-surveillance": { "$": 0 }, "airtraffic": { "$": 0 }, "air-traffic-control": { "$": 0 }, "ambulance": { "$": 0 }, "amusement": { "$": 0 }, "association": { "$": 0 }, "author": { "$": 0 }, "ballooning": { "$": 0 }, "broker": { "$": 0 }, "caa": { "$": 0 }, "cargo": { "$": 0 }, "catering": { "$": 0 }, "certification": { "$": 0 }, "championship": { "$": 0 }, "charter": { "$": 0 }, "civilaviation": { "$": 0 }, "club": { "$": 0 }, "conference": { "$": 0 }, "consultant": { "$": 0 }, "consulting": { "$": 0 }, "control": { "$": 0 }, "council": { "$": 0 }, "crew": { "$": 0 }, "design": { "$": 0 }, "dgca": { "$": 0 }, "educator": { "$": 0 }, "emergency": { "$": 0 }, "engine": { "$": 0 }, "engineer": { "$": 0 }, "entertainment": { "$": 0 }, "equipment": { "$": 0 }, "exchange": { "$": 0 }, "express": { "$": 0 }, "federation": { "$": 0 }, "flight": { "$": 0 }, "freight": { "$": 0 }, "fuel": { "$": 0 }, "gliding": { "$": 0 }, "government": { "$": 0 }, "groundhandling": { "$": 0 }, "group": { "$": 0 }, "hanggliding": { "$": 0 }, "homebuilt": { "$": 0 }, "insurance": { "$": 0 }, "journal": { "$": 0 }, "journalist": { "$": 0 }, "leasing": { "$": 0 }, "logistics": { "$": 0 }, "magazine": { "$": 0 }, "maintenance": { "$": 0 }, "media": { "$": 0 }, "microlight": { "$": 0 }, "modelling": { "$": 0 }, "navigation": { "$": 0 }, "parachuting": { "$": 0 }, "paragliding": { "$": 0 }, "passenger-association": { "$": 0 }, "pilot": { "$": 0 }, "press": { "$": 0 }, "production": { "$": 0 }, "recreation": { "$": 0 }, "repbody": { "$": 0 }, "res": { "$": 0 }, "research": { "$": 0 }, "rotorcraft": { "$": 0 }, "safety": { "$": 0 }, "scientist": { "$": 0 }, "services": { "$": 0 }, "show": { "$": 0 }, "skydiving": { "$": 0 }, "software": { "$": 0 }, "student": { "$": 0 }, "trader": { "$": 0 }, "trading": { "$": 0 }, "trainer": { "$": 0 }, "union": { "$": 0 }, "workinggroup": { "$": 0 }, "works": { "$": 0 } }, "af": { "$": 0, "gov": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "edu": { "$": 0 } }, "ag": { "$": 0, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "co": { "$": 0 }, "nom": { "$": 0 } }, "ai": { "$": 0, "off": { "$": 0 }, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "nom": { "$": 0 } }, "al": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "blogspot": { "$": 0 }, "nom": { "$": 0 } }, "am": { "$": 0, "blogspot": { "$": 0 } }, "ao": { "$": 0, "ed": { "$": 0 }, "gv": { "$": 0 }, "og": { "$": 0 }, "co": { "$": 0 }, "pb": { "$": 0 }, "it": { "$": 0 } }, "aq": { "$": 0 }, "ar": { "$": 0, "com": { "$": 0, "blogspot": { "$": 0 } }, "edu": { "$": 0 }, "gob": { "$": 0 }, "gov": { "$": 0 }, "int": { "$": 0 }, "mil": { "$": 0 }, "musica": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "tur": { "$": 0 } }, "arpa": { "$": 0, "e164": { "$": 0 }, "in-addr": { "$": 0 }, "ip6": { "$": 0 }, "iris": { "$": 0 }, "uri": { "$": 0 }, "urn": { "$": 0 } }, "as": { "$": 0, "gov": { "$": 0 } }, "asia": { "$": 0, "cloudns": { "$": 0 } }, "at": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0, "blogspot": { "$": 0 } }, "gv": { "$": 0 }, "or": { "$": 0 }, "futurecms": { "*": { "$": 0 } }, "futurehosting": { "$": 0 }, "futuremailing": { "$": 0 }, "ortsinfo": { "ex": { "*": { "$": 0 } }, "kunden": { "*": { "$": 0 } } }, "biz": { "$": 0 }, "info": { "$": 0 }, "priv": { "$": 0 }, "12hp": { "$": 0 }, "2ix": { "$": 0 }, "4lima": { "$": 0 }, "lima-city": { "$": 0 } }, "au": { "$": 0, "com": { "$": 0, "blogspot": { "$": 0 } }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0, "act": { "$": 0 }, "nsw": { "$": 0 }, "nt": { "$": 0 }, "qld": { "$": 0 }, "sa": { "$": 0 }, "tas": { "$": 0 }, "vic": { "$": 0 }, "wa": { "$": 0 } }, "gov": { "$": 0, "qld": { "$": 0 }, "sa": { "$": 0 }, "tas": { "$": 0 }, "vic": { "$": 0 }, "wa": { "$": 0 } }, "asn": { "$": 0 }, "id": { "$": 0 }, "info": { "$": 0 }, "conf": { "$": 0 }, "oz": { "$": 0 }, "act": { "$": 0 }, "nsw": { "$": 0 }, "nt": { "$": 0 }, "qld": { "$": 0 }, "sa": { "$": 0 }, "tas": { "$": 0 }, "vic": { "$": 0 }, "wa": { "$": 0 } }, "aw": { "$": 0, "com": { "$": 0 } }, "ax": { "$": 0 }, "az": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "int": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "info": { "$": 0 }, "pp": { "$": 0 }, "mil": { "$": 0 }, "name": { "$": 0 }, "pro": { "$": 0 }, "biz": { "$": 0 } }, "ba": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "blogspot": { "$": 0 } }, "bb": { "$": 0, "biz": { "$": 0 }, "co": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "info": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "store": { "$": 0 }, "tv": { "$": 0 } }, "bd": { "*": { "$": 0 } }, "be": { "$": 0, "ac": { "$": 0 }, "blogspot": { "$": 0 }, "transurl": { "*": { "$": 0 } } }, "bf": { "$": 0, "gov": { "$": 0 } }, "bg": { "0": { "$": 0 }, "1": { "$": 0 }, "2": { "$": 0 }, "3": { "$": 0 }, "4": { "$": 0 }, "5": { "$": 0 }, "6": { "$": 0 }, "7": { "$": 0 }, "8": { "$": 0 }, "9": { "$": 0 }, "$": 0, "a": { "$": 0 }, "b": { "$": 0 }, "c": { "$": 0 }, "d": { "$": 0 }, "e": { "$": 0 }, "f": { "$": 0 }, "g": { "$": 0 }, "h": { "$": 0 }, "i": { "$": 0 }, "j": { "$": 0 }, "k": { "$": 0 }, "l": { "$": 0 }, "m": { "$": 0 }, "n": { "$": 0 }, "o": { "$": 0 }, "p": { "$": 0 }, "q": { "$": 0 }, "r": { "$": 0 }, "s": { "$": 0 }, "t": { "$": 0 }, "u": { "$": 0 }, "v": { "$": 0 }, "w": { "$": 0 }, "x": { "$": 0 }, "y": { "$": 0 }, "z": { "$": 0 }, "blogspot": { "$": 0 }, "barsy": { "$": 0 } }, "bh": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 } }, "bi": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "or": { "$": 0 }, "org": { "$": 0 } }, "biz": { "$": 0, "cloudns": { "$": 0 }, "dyndns": { "$": 0 }, "for-better": { "$": 0 }, "for-more": { "$": 0 }, "for-some": { "$": 0 }, "for-the": { "$": 0 }, "selfip": { "$": 0 }, "webhop": { "$": 0 }, "mmafan": { "$": 0 }, "myftp": { "$": 0 }, "no-ip": { "$": 0 }, "dscloud": { "$": 0 } }, "bj": { "$": 0, "asso": { "$": 0 }, "barreau": { "$": 0 }, "gouv": { "$": 0 }, "blogspot": { "$": 0 } }, "bm": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "bn": { "*": { "$": 0 } }, "bo": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "gob": { "$": 0 }, "int": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "mil": { "$": 0 }, "tv": { "$": 0 } }, "br": { "$": 0, "adm": { "$": 0 }, "adv": { "$": 0 }, "agr": { "$": 0 }, "am": { "$": 0 }, "arq": { "$": 0 }, "art": { "$": 0 }, "ato": { "$": 0 }, "b": { "$": 0 }, "belem": { "$": 0 }, "bio": { "$": 0 }, "blog": { "$": 0 }, "bmd": { "$": 0 }, "cim": { "$": 0 }, "cng": { "$": 0 }, "cnt": { "$": 0 }, "com": { "$": 0, "blogspot": { "$": 0 } }, "coop": { "$": 0 }, "cri": { "$": 0 }, "def": { "$": 0 }, "ecn": { "$": 0 }, "eco": { "$": 0 }, "edu": { "$": 0 }, "emp": { "$": 0 }, "eng": { "$": 0 }, "esp": { "$": 0 }, "etc": { "$": 0 }, "eti": { "$": 0 }, "far": { "$": 0 }, "flog": { "$": 0 }, "floripa": { "$": 0 }, "fm": { "$": 0 }, "fnd": { "$": 0 }, "fot": { "$": 0 }, "fst": { "$": 0 }, "g12": { "$": 0 }, "ggf": { "$": 0 }, "gov": { "$": 0, "ac": { "$": 0 }, "al": { "$": 0 }, "am": { "$": 0 }, "ap": { "$": 0 }, "ba": { "$": 0 }, "ce": { "$": 0 }, "df": { "$": 0 }, "es": { "$": 0 }, "go": { "$": 0 }, "ma": { "$": 0 }, "mg": { "$": 0 }, "ms": { "$": 0 }, "mt": { "$": 0 }, "pa": { "$": 0 }, "pb": { "$": 0 }, "pe": { "$": 0 }, "pi": { "$": 0 }, "pr": { "$": 0 }, "rj": { "$": 0 }, "rn": { "$": 0 }, "ro": { "$": 0 }, "rr": { "$": 0 }, "rs": { "$": 0 }, "sc": { "$": 0 }, "se": { "$": 0 }, "sp": { "$": 0 }, "to": { "$": 0 } }, "imb": { "$": 0 }, "ind": { "$": 0 }, "inf": { "$": 0 }, "jampa": { "$": 0 }, "jor": { "$": 0 }, "jus": { "$": 0 }, "leg": { "$": 0, "ac": { "$": 0 }, "al": { "$": 0 }, "am": { "$": 0 }, "ap": { "$": 0 }, "ba": { "$": 0 }, "ce": { "$": 0 }, "df": { "$": 0 }, "es": { "$": 0 }, "go": { "$": 0 }, "ma": { "$": 0 }, "mg": { "$": 0 }, "ms": { "$": 0 }, "mt": { "$": 0 }, "pa": { "$": 0 }, "pb": { "$": 0 }, "pe": { "$": 0 }, "pi": { "$": 0 }, "pr": { "$": 0 }, "rj": { "$": 0 }, "rn": { "$": 0 }, "ro": { "$": 0 }, "rr": { "$": 0 }, "rs": { "$": 0 }, "sc": { "$": 0 }, "se": { "$": 0 }, "sp": { "$": 0 }, "to": { "$": 0 } }, "lel": { "$": 0 }, "mat": { "$": 0 }, "med": { "$": 0 }, "mil": { "$": 0 }, "mp": { "$": 0 }, "mus": { "$": 0 }, "net": { "$": 0 }, "nom": { "*": { "$": 0 } }, "not": { "$": 0 }, "ntr": { "$": 0 }, "odo": { "$": 0 }, "org": { "$": 0 }, "poa": { "$": 0 }, "ppg": { "$": 0 }, "pro": { "$": 0 }, "psc": { "$": 0 }, "psi": { "$": 0 }, "qsl": { "$": 0 }, "radio": { "$": 0 }, "rec": { "$": 0 }, "recife": { "$": 0 }, "slg": { "$": 0 }, "srv": { "$": 0 }, "taxi": { "$": 0 }, "teo": { "$": 0 }, "tmp": { "$": 0 }, "trd": { "$": 0 }, "tur": { "$": 0 }, "tv": { "$": 0 }, "vet": { "$": 0 }, "vix": { "$": 0 }, "vlog": { "$": 0 }, "wiki": { "$": 0 }, "zlg": { "$": 0 } }, "bs": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "we": { "$": 0 } }, "bt": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "bv": { "$": 0 }, "bw": { "$": 0, "co": { "$": 0 }, "org": { "$": 0 } }, "by": { "$": 0, "gov": { "$": 0 }, "mil": { "$": 0 }, "com": { "$": 0, "blogspot": { "$": 0 } }, "of": { "$": 0 }, "nym": { "$": 0 } }, "bz": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "za": { "$": 0 }, "nym": { "$": 0 } }, "ca": { "$": 0, "ab": { "$": 0 }, "bc": { "$": 0 }, "mb": { "$": 0 }, "nb": { "$": 0 }, "nf": { "$": 0 }, "nl": { "$": 0 }, "ns": { "$": 0 }, "nt": { "$": 0 }, "nu": { "$": 0 }, "on": { "$": 0 }, "pe": { "$": 0 }, "qc": { "$": 0 }, "sk": { "$": 0 }, "yk": { "$": 0 }, "gc": { "$": 0 }, "awdev": { "*": { "$": 0 } }, "co": { "$": 0 }, "blogspot": { "$": 0 }, "no-ip": { "$": 0 } }, "cat": { "$": 0 }, "cc": { "$": 0, "cloudns": { "$": 0 }, "ftpaccess": { "$": 0 }, "game-server": { "$": 0 }, "myphotos": { "$": 0 }, "scrapping": { "$": 0 }, "twmail": { "$": 0 }, "fantasyleague": { "$": 0 } }, "cd": { "$": 0, "gov": { "$": 0 } }, "cf": { "$": 0, "blogspot": { "$": 0 } }, "cg": { "$": 0 }, "ch": { "$": 0, "square7": { "$": 0 }, "blogspot": { "$": 0 }, "gotdns": { "$": 0 }, "12hp": { "$": 0 }, "2ix": { "$": 0 }, "4lima": { "$": 0 }, "lima-city": { "$": 0 } }, "ci": { "$": 0, "org": { "$": 0 }, "or": { "$": 0 }, "com": { "$": 0 }, "co": { "$": 0 }, "edu": { "$": 0 }, "ed": { "$": 0 }, "ac": { "$": 0 }, "net": { "$": 0 }, "go": { "$": 0 }, "asso": { "$": 0 }, "xn--aroport-bya": { "$": 0 }, "int": { "$": 0 }, "presse": { "$": 0 }, "md": { "$": 0 }, "gouv": { "$": 0 } }, "ck": { "*": { "$": 0 } }, "cl": { "$": 0, "gov": { "$": 0 }, "gob": { "$": 0 }, "co": { "$": 0 }, "mil": { "$": 0 }, "blogspot": { "$": 0 }, "nom": { "$": 0 } }, "cm": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 } }, "cn": { "$": 0, "ac": { "$": 0 }, "com": { "$": 0, "amazonaws": { "compute": { "*": { "$": 0 } }, "eb": { "cn-north-1": { "$": 0 } }, "elb": { "*": { "$": 0 } }, "cn-north-1": { "s3": { "$": 0 } } } }, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "mil": { "$": 0 }, "xn--55qx5d": { "$": 0 }, "xn--io0a7i": { "$": 0 }, "xn--od0alg": { "$": 0 }, "ah": { "$": 0 }, "bj": { "$": 0 }, "cq": { "$": 0 }, "fj": { "$": 0 }, "gd": { "$": 0 }, "gs": { "$": 0 }, "gz": { "$": 0 }, "gx": { "$": 0 }, "ha": { "$": 0 }, "hb": { "$": 0 }, "he": { "$": 0 }, "hi": { "$": 0 }, "hl": { "$": 0 }, "hn": { "$": 0 }, "jl": { "$": 0 }, "js": { "$": 0 }, "jx": { "$": 0 }, "ln": { "$": 0 }, "nm": { "$": 0 }, "nx": { "$": 0 }, "qh": { "$": 0 }, "sc": { "$": 0 }, "sd": { "$": 0 }, "sh": { "$": 0 }, "sn": { "$": 0 }, "sx": { "$": 0 }, "tj": { "$": 0 }, "xj": { "$": 0 }, "xz": { "$": 0 }, "yn": { "$": 0 }, "zj": { "$": 0 }, "hk": { "$": 0 }, "mo": { "$": 0 }, "tw": { "$": 0 } }, "co": { "$": 0, "arts": { "$": 0 }, "com": { "$": 0, "blogspot": { "$": 0 } }, "edu": { "$": 0 }, "firm": { "$": 0 }, "gov": { "$": 0 }, "info": { "$": 0 }, "int": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "nom": { "$": 0 }, "org": { "$": 0 }, "rec": { "$": 0 }, "web": { "$": 0 }, "nodum": { "$": 0 } }, "com": { "$": 0, "amazonaws": { "compute": { "*": { "$": 0 } }, "compute-1": { "*": { "$": 0 } }, "us-east-1": { "$": 0, "dualstack": { "s3": { "$": 0 } } }, "elb": { "*": { "$": 0 } }, "s3": { "$": 0 }, "s3-ap-northeast-1": { "$": 0 }, "s3-ap-northeast-2": { "$": 0 }, "s3-ap-south-1": { "$": 0 }, "s3-ap-southeast-1": { "$": 0 }, "s3-ap-southeast-2": { "$": 0 }, "s3-ca-central-1": { "$": 0 }, "s3-eu-central-1": { "$": 0 }, "s3-eu-west-1": { "$": 0 }, "s3-eu-west-2": { "$": 0 }, "s3-external-1": { "$": 0 }, "s3-fips-us-gov-west-1": { "$": 0 }, "s3-sa-east-1": { "$": 0 }, "s3-us-gov-west-1": { "$": 0 }, "s3-us-east-2": { "$": 0 }, "s3-us-west-1": { "$": 0 }, "s3-us-west-2": { "$": 0 }, "ap-northeast-2": { "s3": { "$": 0 }, "dualstack": { "s3": { "$": 0 } }, "s3-website": { "$": 0 } }, "ap-south-1": { "s3": { "$": 0 }, "dualstack": { "s3": { "$": 0 } }, "s3-website": { "$": 0 } }, "ca-central-1": { "s3": { "$": 0 }, "dualstack": { "s3": { "$": 0 } }, "s3-website": { "$": 0 } }, "eu-central-1": { "s3": { "$": 0 }, "dualstack": { "s3": { "$": 0 } }, "s3-website": { "$": 0 } }, "eu-west-2": { "s3": { "$": 0 }, "dualstack": { "s3": { "$": 0 } }, "s3-website": { "$": 0 } }, "us-east-2": { "s3": { "$": 0 }, "dualstack": { "s3": { "$": 0 } }, "s3-website": { "$": 0 } }, "ap-northeast-1": { "dualstack": { "s3": { "$": 0 } } }, "ap-southeast-1": { "dualstack": { "s3": { "$": 0 } } }, "ap-southeast-2": { "dualstack": { "s3": { "$": 0 } } }, "eu-west-1": { "dualstack": { "s3": { "$": 0 } } }, "sa-east-1": { "dualstack": { "s3": { "$": 0 } } }, "s3-website-us-east-1": { "$": 0 }, "s3-website-us-west-1": { "$": 0 }, "s3-website-us-west-2": { "$": 0 }, "s3-website-ap-northeast-1": { "$": 0 }, "s3-website-ap-southeast-1": { "$": 0 }, "s3-website-ap-southeast-2": { "$": 0 }, "s3-website-eu-west-1": { "$": 0 }, "s3-website-sa-east-1": { "$": 0 } }, "elasticbeanstalk": { "$": 0, "ap-northeast-1": { "$": 0 }, "ap-northeast-2": { "$": 0 }, "ap-south-1": { "$": 0 }, "ap-southeast-1": { "$": 0 }, "ap-southeast-2": { "$": 0 }, "ca-central-1": { "$": 0 }, "eu-central-1": { "$": 0 }, "eu-west-1": { "$": 0 }, "eu-west-2": { "$": 0 }, "sa-east-1": { "$": 0 }, "us-east-1": { "$": 0 }, "us-east-2": { "$": 0 }, "us-gov-west-1": { "$": 0 }, "us-west-1": { "$": 0 }, "us-west-2": { "$": 0 } }, "on-aptible": { "$": 0 }, "myasustor": { "$": 0 }, "betainabox": { "$": 0 }, "bplaced": { "$": 0 }, "ar": { "$": 0 }, "br": { "$": 0 }, "cn": { "$": 0 }, "de": { "$": 0 }, "eu": { "$": 0 }, "gb": { "$": 0 }, "hu": { "$": 0 }, "jpn": { "$": 0 }, "kr": { "$": 0 }, "mex": { "$": 0 }, "no": { "$": 0 }, "qc": { "$": 0 }, "ru": { "$": 0 }, "sa": { "$": 0 }, "se": { "$": 0 }, "uk": { "$": 0 }, "us": { "$": 0 }, "uy": { "$": 0 }, "za": { "$": 0 }, "africa": { "$": 0 }, "gr": { "$": 0 }, "co": { "$": 0 }, "xenapponazure": { "$": 0 }, "jdevcloud": { "$": 0 }, "wpdevcloud": { "$": 0 }, "cloudcontrolled": { "$": 0 }, "cloudcontrolapp": { "$": 0 }, "drayddns": { "$": 0 }, "dreamhosters": { "$": 0 }, "mydrobo": { "$": 0 }, "dyndns-at-home": { "$": 0 }, "dyndns-at-work": { "$": 0 }, "dyndns-blog": { "$": 0 }, "dyndns-free": { "$": 0 }, "dyndns-home": { "$": 0 }, "dyndns-ip": { "$": 0 }, "dyndns-mail": { "$": 0 }, "dyndns-office": { "$": 0 }, "dyndns-pics": { "$": 0 }, "dyndns-remote": { "$": 0 }, "dyndns-server": { "$": 0 }, "dyndns-web": { "$": 0 }, "dyndns-wiki": { "$": 0 }, "dyndns-work": { "$": 0 }, "blogdns": { "$": 0 }, "cechire": { "$": 0 }, "dnsalias": { "$": 0 }, "dnsdojo": { "$": 0 }, "doesntexist": { "$": 0 }, "dontexist": { "$": 0 }, "doomdns": { "$": 0 }, "dyn-o-saur": { "$": 0 }, "dynalias": { "$": 0 }, "est-a-la-maison": { "$": 0 }, "est-a-la-masion": { "$": 0 }, "est-le-patron": { "$": 0 }, "est-mon-blogueur": { "$": 0 }, "from-ak": { "$": 0 }, "from-al": { "$": 0 }, "from-ar": { "$": 0 }, "from-ca": { "$": 0 }, "from-ct": { "$": 0 }, "from-dc": { "$": 0 }, "from-de": { "$": 0 }, "from-fl": { "$": 0 }, "from-ga": { "$": 0 }, "from-hi": { "$": 0 }, "from-ia": { "$": 0 }, "from-id": { "$": 0 }, "from-il": { "$": 0 }, "from-in": { "$": 0 }, "from-ks": { "$": 0 }, "from-ky": { "$": 0 }, "from-ma": { "$": 0 }, "from-md": { "$": 0 }, "from-mi": { "$": 0 }, "from-mn": { "$": 0 }, "from-mo": { "$": 0 }, "from-ms": { "$": 0 }, "from-mt": { "$": 0 }, "from-nc": { "$": 0 }, "from-nd": { "$": 0 }, "from-ne": { "$": 0 }, "from-nh": { "$": 0 }, "from-nj": { "$": 0 }, "from-nm": { "$": 0 }, "from-nv": { "$": 0 }, "from-oh": { "$": 0 }, "from-ok": { "$": 0 }, "from-or": { "$": 0 }, "from-pa": { "$": 0 }, "from-pr": { "$": 0 }, "from-ri": { "$": 0 }, "from-sc": { "$": 0 }, "from-sd": { "$": 0 }, "from-tn": { "$": 0 }, "from-tx": { "$": 0 }, "from-ut": { "$": 0 }, "from-va": { "$": 0 }, "from-vt": { "$": 0 }, "from-wa": { "$": 0 }, "from-wi": { "$": 0 }, "from-wv": { "$": 0 }, "from-wy": { "$": 0 }, "getmyip": { "$": 0 }, "gotdns": { "$": 0 }, "hobby-site": { "$": 0 }, "homelinux": { "$": 0 }, "homeunix": { "$": 0 }, "iamallama": { "$": 0 }, "is-a-anarchist": { "$": 0 }, "is-a-blogger": { "$": 0 }, "is-a-bookkeeper": { "$": 0 }, "is-a-bulls-fan": { "$": 0 }, "is-a-caterer": { "$": 0 }, "is-a-chef": { "$": 0 }, "is-a-conservative": { "$": 0 }, "is-a-cpa": { "$": 0 }, "is-a-cubicle-slave": { "$": 0 }, "is-a-democrat": { "$": 0 }, "is-a-designer": { "$": 0 }, "is-a-doctor": { "$": 0 }, "is-a-financialadvisor": { "$": 0 }, "is-a-geek": { "$": 0 }, "is-a-green": { "$": 0 }, "is-a-guru": { "$": 0 }, "is-a-hard-worker": { "$": 0 }, "is-a-hunter": { "$": 0 }, "is-a-landscaper": { "$": 0 }, "is-a-lawyer": { "$": 0 }, "is-a-liberal": { "$": 0 }, "is-a-libertarian": { "$": 0 }, "is-a-llama": { "$": 0 }, "is-a-musician": { "$": 0 }, "is-a-nascarfan": { "$": 0 }, "is-a-nurse": { "$": 0 }, "is-a-painter": { "$": 0 }, "is-a-personaltrainer": { "$": 0 }, "is-a-photographer": { "$": 0 }, "is-a-player": { "$": 0 }, "is-a-republican": { "$": 0 }, "is-a-rockstar": { "$": 0 }, "is-a-socialist": { "$": 0 }, "is-a-student": { "$": 0 }, "is-a-teacher": { "$": 0 }, "is-a-techie": { "$": 0 }, "is-a-therapist": { "$": 0 }, "is-an-accountant": { "$": 0 }, "is-an-actor": { "$": 0 }, "is-an-actress": { "$": 0 }, "is-an-anarchist": { "$": 0 }, "is-an-artist": { "$": 0 }, "is-an-engineer": { "$": 0 }, "is-an-entertainer": { "$": 0 }, "is-certified": { "$": 0 }, "is-gone": { "$": 0 }, "is-into-anime": { "$": 0 }, "is-into-cars": { "$": 0 }, "is-into-cartoons": { "$": 0 }, "is-into-games": { "$": 0 }, "is-leet": { "$": 0 }, "is-not-certified": { "$": 0 }, "is-slick": { "$": 0 }, "is-uberleet": { "$": 0 }, "is-with-theband": { "$": 0 }, "isa-geek": { "$": 0 }, "isa-hockeynut": { "$": 0 }, "issmarterthanyou": { "$": 0 }, "likes-pie": { "$": 0 }, "likescandy": { "$": 0 }, "neat-url": { "$": 0 }, "saves-the-whales": { "$": 0 }, "selfip": { "$": 0 }, "sells-for-less": { "$": 0 }, "sells-for-u": { "$": 0 }, "servebbs": { "$": 0 }, "simple-url": { "$": 0 }, "space-to-rent": { "$": 0 }, "teaches-yoga": { "$": 0 }, "writesthisblog": { "$": 0 }, "ddnsfree": { "$": 0 }, "ddnsgeek": { "$": 0 }, "giize": { "$": 0 }, "gleeze": { "$": 0 }, "kozow": { "$": 0 }, "loseyourip": { "$": 0 }, "ooguy": { "$": 0 }, "theworkpc": { "$": 0 }, "mytuleap": { "$": 0 }, "evennode": { "eu-1": { "$": 0 }, "eu-2": { "$": 0 }, "eu-3": { "$": 0 }, "eu-4": { "$": 0 }, "us-1": { "$": 0 }, "us-2": { "$": 0 }, "us-3": { "$": 0 }, "us-4": { "$": 0 } }, "fbsbx": { "apps": { "$": 0 } }, "firebaseapp": { "$": 0 }, "flynnhub": { "$": 0 }, "freebox-os": { "$": 0 }, "freeboxos": { "$": 0 }, "githubusercontent": { "$": 0 }, "0emm": { "*": { "$": 0 } }, "appspot": { "$": 0 }, "blogspot": { "$": 0 }, "codespot": { "$": 0 }, "googleapis": { "$": 0 }, "googlecode": { "$": 0 }, "pagespeedmobilizer": { "$": 0 }, "publishproxy": { "$": 0 }, "withgoogle": { "$": 0 }, "withyoutube": { "$": 0 }, "herokuapp": { "$": 0 }, "herokussl": { "$": 0 }, "pixolino": { "$": 0 }, "joyent": { "cns": { "*": { "$": 0 } } }, "barsyonline": { "$": 0 }, "meteorapp": { "$": 0, "eu": { "$": 0 } }, "bitballoon": { "$": 0 }, "netlify": { "$": 0 }, "4u": { "$": 0 }, "nfshost": { "$": 0 }, "blogsyte": { "$": 0 }, "ciscofreak": { "$": 0 }, "damnserver": { "$": 0 }, "ditchyourip": { "$": 0 }, "dnsiskinky": { "$": 0 }, "dynns": { "$": 0 }, "geekgalaxy": { "$": 0 }, "health-carereform": { "$": 0 }, "homesecuritymac": { "$": 0 }, "homesecuritypc": { "$": 0 }, "myactivedirectory": { "$": 0 }, "mysecuritycamera": { "$": 0 }, "net-freaks": { "$": 0 }, "onthewifi": { "$": 0 }, "point2this": { "$": 0 }, "quicksytes": { "$": 0 }, "securitytactics": { "$": 0 }, "serveexchange": { "$": 0 }, "servehumour": { "$": 0 }, "servep2p": { "$": 0 }, "servesarcasm": { "$": 0 }, "stufftoread": { "$": 0 }, "unusualperson": { "$": 0 }, "workisboring": { "$": 0 }, "3utilities": { "$": 0 }, "ddnsking": { "$": 0 }, "myvnc": { "$": 0 }, "servebeer": { "$": 0 }, "servecounterstrike": { "$": 0 }, "serveftp": { "$": 0 }, "servegame": { "$": 0 }, "servehalflife": { "$": 0 }, "servehttp": { "$": 0 }, "serveirc": { "$": 0 }, "servemp3": { "$": 0 }, "servepics": { "$": 0 }, "servequake": { "$": 0 }, "operaunite": { "$": 0 }, "outsystemscloud": { "$": 0 }, "ownprovider": { "$": 0 }, "pgfog": { "$": 0 }, "pagefrontapp": { "$": 0 }, "gotpantheon": { "$": 0 }, "prgmr": { "xen": { "$": 0 } }, "qa2": { "$": 0 }, "dev-myqnapcloud": { "$": 0 }, "alpha-myqnapcloud": { "$": 0 }, "myqnapcloud": { "$": 0 }, "quipelements": { "*": { "$": 0 } }, "rackmaze": { "$": 0 }, "rhcloud": { "$": 0 }, "logoip": { "$": 0 }, "firewall-gateway": { "$": 0 }, "myshopblocks": { "$": 0 }, "1kapp": { "$": 0 }, "appchizi": { "$": 0 }, "applinzi": { "$": 0 }, "sinaapp": { "$": 0 }, "vipsinaapp": { "$": 0 }, "bounty-full": { "$": 0, "alpha": { "$": 0 }, "beta": { "$": 0 } }, "temp-dns": { "$": 0 }, "dsmynas": { "$": 0 }, "familyds": { "$": 0 }, "bloxcms": { "$": 0 }, "townnews-staging": { "$": 0 }, "hk": { "$": 0 }, "remotewd": { "$": 0 }, "yolasite": { "$": 0 } }, "coop": { "$": 0 }, "cr": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0 }, "ed": { "$": 0 }, "fi": { "$": 0 }, "go": { "$": 0 }, "or": { "$": 0 }, "sa": { "$": 0 } }, "cu": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "gov": { "$": 0 }, "inf": { "$": 0 } }, "cv": { "$": 0, "blogspot": { "$": 0 } }, "cw": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "cx": { "$": 0, "gov": { "$": 0 }, "ath": { "$": 0 }, "info": { "$": 0 } }, "cy": { "$": 0, "ac": { "$": 0 }, "biz": { "$": 0 }, "com": { "$": 0, "blogspot": { "$": 0 } }, "ekloges": { "$": 0 }, "gov": { "$": 0 }, "ltd": { "$": 0 }, "name": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "parliament": { "$": 0 }, "press": { "$": 0 }, "pro": { "$": 0 }, "tm": { "$": 0 } }, "cz": { "$": 0, "co": { "$": 0 }, "realm": { "$": 0 }, "e4": { "$": 0 }, "blogspot": { "$": 0 }, "metacentrum": { "cloud": { "$": 0 }, "custom": { "$": 0 } } }, "de": { "$": 0, "bplaced": { "$": 0 }, "square7": { "$": 0 }, "com": { "$": 0 }, "cosidns": { "dyn": { "$": 0 } }, "dynamisches-dns": { "$": 0 }, "dnsupdater": { "$": 0 }, "internet-dns": { "$": 0 }, "l-o-g-i-n": { "$": 0 }, "dnshome": { "$": 0 }, "fuettertdasnetz": { "$": 0 }, "isteingeek": { "$": 0 }, "istmein": { "$": 0 }, "lebtimnetz": { "$": 0 }, "leitungsen": { "$": 0 }, "traeumtgerade": { "$": 0 }, "ddnss": { "$": 0, "dyn": { "$": 0 }, "dyndns": { "$": 0 } }, "dyndns1": { "$": 0 }, "dyn-ip24": { "$": 0 }, "home-webserver": { "$": 0, "dyn": { "$": 0 } }, "myhome-server": { "$": 0 }, "goip": { "$": 0 }, "blogspot": { "$": 0 }, "keymachine": { "$": 0 }, "git-repos": { "$": 0 }, "lcube-server": { "$": 0 }, "svn-repos": { "$": 0 }, "barsy": { "$": 0 }, "logoip": { "$": 0 }, "firewall-gateway": { "$": 0 }, "my-gateway": { "$": 0 }, "my-router": { "$": 0 }, "spdns": { "$": 0 }, "taifun-dns": { "$": 0 }, "12hp": { "$": 0 }, "2ix": { "$": 0 }, "4lima": { "$": 0 }, "lima-city": { "$": 0 }, "dd-dns": { "$": 0 }, "dray-dns": { "$": 0 }, "draydns": { "$": 0 }, "dyn-vpn": { "$": 0 }, "dynvpn": { "$": 0 }, "mein-vigor": { "$": 0 }, "my-vigor": { "$": 0 }, "my-wan": { "$": 0 }, "syno-ds": { "$": 0 }, "synology-diskstation": { "$": 0 }, "synology-ds": { "$": 0 } }, "dj": { "$": 0 }, "dk": { "$": 0, "biz": { "$": 0 }, "co": { "$": 0 }, "firm": { "$": 0 }, "reg": { "$": 0 }, "store": { "$": 0 }, "blogspot": { "$": 0 } }, "dm": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 } }, "do": { "$": 0, "art": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gob": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "sld": { "$": 0 }, "web": { "$": 0 } }, "dz": { "$": 0, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "gov": { "$": 0 }, "edu": { "$": 0 }, "asso": { "$": 0 }, "pol": { "$": 0 }, "art": { "$": 0 } }, "ec": { "$": 0, "com": { "$": 0 }, "info": { "$": 0 }, "net": { "$": 0 }, "fin": { "$": 0 }, "k12": { "$": 0 }, "med": { "$": 0 }, "pro": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "gob": { "$": 0 }, "mil": { "$": 0 } }, "edu": { "$": 0 }, "ee": { "$": 0, "edu": { "$": 0 }, "gov": { "$": 0 }, "riik": { "$": 0 }, "lib": { "$": 0 }, "med": { "$": 0 }, "com": { "$": 0, "blogspot": { "$": 0 } }, "pri": { "$": 0 }, "aip": { "$": 0 }, "org": { "$": 0 }, "fie": { "$": 0 } }, "eg": { "$": 0, "com": { "$": 0, "blogspot": { "$": 0 } }, "edu": { "$": 0 }, "eun": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "name": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "sci": { "$": 0 } }, "er": { "*": { "$": 0 } }, "es": { "$": 0, "com": { "$": 0, "blogspot": { "$": 0 } }, "nom": { "$": 0 }, "org": { "$": 0 }, "gob": { "$": 0 }, "edu": { "$": 0 } }, "et": { "$": 0, "com": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "biz": { "$": 0 }, "name": { "$": 0 }, "info": { "$": 0 }, "net": { "$": 0 } }, "eu": { "$": 0, "mycd": { "$": 0 }, "cloudns": { "$": 0 }, "barsy": { "$": 0 }, "wellbeingzone": { "$": 0 }, "spdns": { "$": 0 }, "transurl": { "*": { "$": 0 } }, "diskstation": { "$": 0 } }, "fi": { "$": 0, "aland": { "$": 0 }, "dy": { "$": 0 }, "blogspot": { "$": 0 }, "iki": { "$": 0 } }, "fj": { "*": { "$": 0 } }, "fk": { "*": { "$": 0 } }, "fm": { "$": 0 }, "fo": { "$": 0 }, "fr": { "$": 0, "com": { "$": 0 }, "asso": { "$": 0 }, "nom": { "$": 0 }, "prd": { "$": 0 }, "presse": { "$": 0 }, "tm": { "$": 0 }, "aeroport": { "$": 0 }, "assedic": { "$": 0 }, "avocat": { "$": 0 }, "avoues": { "$": 0 }, "cci": { "$": 0 }, "chambagri": { "$": 0 }, "chirurgiens-dentistes": { "$": 0 }, "experts-comptables": { "$": 0 }, "geometre-expert": { "$": 0 }, "gouv": { "$": 0 }, "greta": { "$": 0 }, "huissier-justice": { "$": 0 }, "medecin": { "$": 0 }, "notaires": { "$": 0 }, "pharmacien": { "$": 0 }, "port": { "$": 0 }, "veterinaire": { "$": 0 }, "fbx-os": { "$": 0 }, "fbxos": { "$": 0 }, "freebox-os": { "$": 0 }, "freeboxos": { "$": 0 }, "blogspot": { "$": 0 }, "on-web": { "$": 0 }, "chirurgiens-dentistes-en-france": { "$": 0 } }, "ga": { "$": 0 }, "gb": { "$": 0 }, "gd": { "$": 0, "nom": { "$": 0 } }, "ge": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "pvt": { "$": 0 } }, "gf": { "$": 0 }, "gg": { "$": 0, "co": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "cya": { "$": 0 } }, "gh": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "mil": { "$": 0 } }, "gi": { "$": 0, "com": { "$": 0 }, "ltd": { "$": 0 }, "gov": { "$": 0 }, "mod": { "$": 0 }, "edu": { "$": 0 }, "org": { "$": 0 } }, "gl": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "nom": { "$": 0 } }, "gm": { "$": 0 }, "gn": { "$": 0, "ac": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 } }, "gov": { "$": 0 }, "gp": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "mobi": { "$": 0 }, "edu": { "$": 0 }, "org": { "$": 0 }, "asso": { "$": 0 } }, "gq": { "$": 0 }, "gr": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "blogspot": { "$": 0 }, "nym": { "$": 0 } }, "gs": { "$": 0 }, "gt": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gob": { "$": 0 }, "ind": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "nom": { "$": 0 } }, "gu": { "*": { "$": 0 } }, "gw": { "$": 0 }, "gy": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "hk": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "idv": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "xn--55qx5d": { "$": 0 }, "xn--wcvs22d": { "$": 0 }, "xn--lcvr32d": { "$": 0 }, "xn--mxtq1m": { "$": 0 }, "xn--gmqw5a": { "$": 0 }, "xn--ciqpn": { "$": 0 }, "xn--gmq050i": { "$": 0 }, "xn--zf0avx": { "$": 0 }, "xn--io0a7i": { "$": 0 }, "xn--mk0axi": { "$": 0 }, "xn--od0alg": { "$": 0 }, "xn--od0aq3b": { "$": 0 }, "xn--tn0ag": { "$": 0 }, "xn--uc0atv": { "$": 0 }, "xn--uc0ay4a": { "$": 0 }, "blogspot": { "$": 0 }, "ltd": { "$": 0 }, "inc": { "$": 0 } }, "hm": { "$": 0 }, "hn": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "mil": { "$": 0 }, "gob": { "$": 0 }, "nom": { "$": 0 } }, "hr": { "$": 0, "iz": { "$": 0 }, "from": { "$": 0 }, "name": { "$": 0 }, "com": { "$": 0 }, "blogspot": { "$": 0 } }, "ht": { "$": 0, "com": { "$": 0 }, "shop": { "$": 0 }, "firm": { "$": 0 }, "info": { "$": 0 }, "adult": { "$": 0 }, "net": { "$": 0 }, "pro": { "$": 0 }, "org": { "$": 0 }, "med": { "$": 0 }, "art": { "$": 0 }, "coop": { "$": 0 }, "pol": { "$": 0 }, "asso": { "$": 0 }, "edu": { "$": 0 }, "rel": { "$": 0 }, "gouv": { "$": 0 }, "perso": { "$": 0 } }, "hu": { "2000": { "$": 0 }, "$": 0, "co": { "$": 0 }, "info": { "$": 0 }, "org": { "$": 0 }, "priv": { "$": 0 }, "sport": { "$": 0 }, "tm": { "$": 0 }, "agrar": { "$": 0 }, "bolt": { "$": 0 }, "casino": { "$": 0 }, "city": { "$": 0 }, "erotica": { "$": 0 }, "erotika": { "$": 0 }, "film": { "$": 0 }, "forum": { "$": 0 }, "games": { "$": 0 }, "hotel": { "$": 0 }, "ingatlan": { "$": 0 }, "jogasz": { "$": 0 }, "konyvelo": { "$": 0 }, "lakas": { "$": 0 }, "media": { "$": 0 }, "news": { "$": 0 }, "reklam": { "$": 0 }, "sex": { "$": 0 }, "shop": { "$": 0 }, "suli": { "$": 0 }, "szex": { "$": 0 }, "tozsde": { "$": 0 }, "utazas": { "$": 0 }, "video": { "$": 0 }, "blogspot": { "$": 0 } }, "id": { "$": 0, "ac": { "$": 0 }, "biz": { "$": 0 }, "co": { "$": 0, "blogspot": { "$": 0 } }, "desa": { "$": 0 }, "go": { "$": 0 }, "mil": { "$": 0 }, "my": { "$": 0 }, "net": { "$": 0 }, "or": { "$": 0 }, "sch": { "$": 0 }, "web": { "$": 0 } }, "ie": { "$": 0, "gov": { "$": 0 }, "blogspot": { "$": 0 } }, "il": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0, "blogspot": { "$": 0 } }, "gov": { "$": 0 }, "idf": { "$": 0 }, "k12": { "$": 0 }, "muni": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "im": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0, "ltd": { "$": 0 }, "plc": { "$": 0 } }, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "tt": { "$": 0 }, "tv": { "$": 0 }, "ro": { "$": 0 }, "nom": { "$": 0 } }, "in": { "$": 0, "co": { "$": 0 }, "firm": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gen": { "$": 0 }, "ind": { "$": 0 }, "nic": { "$": 0 }, "ac": { "$": 0 }, "edu": { "$": 0 }, "res": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "cloudns": { "$": 0 }, "blogspot": { "$": 0 }, "barsy": { "$": 0 } }, "info": { "$": 0, "cloudns": { "$": 0 }, "dynamic-dns": { "$": 0 }, "dyndns": { "$": 0 }, "barrel-of-knowledge": { "$": 0 }, "barrell-of-knowledge": { "$": 0 }, "for-our": { "$": 0 }, "groks-the": { "$": 0 }, "groks-this": { "$": 0 }, "here-for-more": { "$": 0 }, "knowsitall": { "$": 0 }, "selfip": { "$": 0 }, "webhop": { "$": 0 }, "nsupdate": { "$": 0 }, "dvrcam": { "$": 0 }, "ilovecollege": { "$": 0 }, "no-ip": { "$": 0 }, "v-info": { "$": 0 } }, "int": { "$": 0, "eu": { "$": 0 } }, "io": { "$": 0, "com": { "$": 0 }, "backplaneapp": { "$": 0 }, "boxfuse": { "$": 0 }, "browsersafetymark": { "$": 0 }, "dedyn": { "$": 0 }, "drud": { "$": 0 }, "definima": { "$": 0 }, "enonic": { "$": 0, "customer": { "$": 0 } }, "github": { "$": 0 }, "gitlab": { "$": 0 }, "hasura-app": { "$": 0 }, "ngrok": { "$": 0 }, "nodeart": { "stage": { "$": 0 } }, "nodum": { "$": 0 }, "nid": { "$": 0 }, "pantheonsite": { "$": 0 }, "protonet": { "$": 0 }, "vaporcloud": { "$": 0 }, "hzc": { "$": 0 }, "sandcats": { "$": 0 }, "shiftedit": { "$": 0 }, "lair": { "apps": { "$": 0 } }, "stolos": { "*": { "$": 0 } }, "spacekit": { "$": 0 }, "thingdust": { "dev": { "cust": { "$": 0 } }, "disrec": { "cust": { "$": 0 } }, "prod": { "cust": { "$": 0 } }, "testing": { "cust": { "$": 0 } } }, "wedeploy": { "$": 0 } }, "iq": { "$": 0, "gov": { "$": 0 }, "edu": { "$": 0 }, "mil": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 } }, "ir": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0 }, "gov": { "$": 0 }, "id": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "sch": { "$": 0 }, "xn--mgba3a4f16a": { "$": 0 }, "xn--mgba3a4fra": { "$": 0 } }, "is": { "$": 0, "net": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "int": { "$": 0 }, "cupcake": { "$": 0 }, "blogspot": { "$": 0 } }, "it": { "$": 0, "gov": { "$": 0 }, "edu": { "$": 0 }, "abr": { "$": 0 }, "abruzzo": { "$": 0 }, "aosta-valley": { "$": 0 }, "aostavalley": { "$": 0 }, "bas": { "$": 0 }, "basilicata": { "$": 0 }, "cal": { "$": 0 }, "calabria": { "$": 0 }, "cam": { "$": 0 }, "campania": { "$": 0 }, "emilia-romagna": { "$": 0 }, "emiliaromagna": { "$": 0 }, "emr": { "$": 0 }, "friuli-v-giulia": { "$": 0 }, "friuli-ve-giulia": { "$": 0 }, "friuli-vegiulia": { "$": 0 }, "friuli-venezia-giulia": { "$": 0 }, "friuli-veneziagiulia": { "$": 0 }, "friuli-vgiulia": { "$": 0 }, "friuliv-giulia": { "$": 0 }, "friulive-giulia": { "$": 0 }, "friulivegiulia": { "$": 0 }, "friulivenezia-giulia": { "$": 0 }, "friuliveneziagiulia": { "$": 0 }, "friulivgiulia": { "$": 0 }, "fvg": { "$": 0 }, "laz": { "$": 0 }, "lazio": { "$": 0 }, "lig": { "$": 0 }, "liguria": { "$": 0 }, "lom": { "$": 0 }, "lombardia": { "$": 0 }, "lombardy": { "$": 0 }, "lucania": { "$": 0 }, "mar": { "$": 0 }, "marche": { "$": 0 }, "mol": { "$": 0 }, "molise": { "$": 0 }, "piedmont": { "$": 0 }, "piemonte": { "$": 0 }, "pmn": { "$": 0 }, "pug": { "$": 0 }, "puglia": { "$": 0 }, "sar": { "$": 0 }, "sardegna": { "$": 0 }, "sardinia": { "$": 0 }, "sic": { "$": 0 }, "sicilia": { "$": 0 }, "sicily": { "$": 0 }, "taa": { "$": 0 }, "tos": { "$": 0 }, "toscana": { "$": 0 }, "trentino-a-adige": { "$": 0 }, "trentino-aadige": { "$": 0 }, "trentino-alto-adige": { "$": 0 }, "trentino-altoadige": { "$": 0 }, "trentino-s-tirol": { "$": 0 }, "trentino-stirol": { "$": 0 }, "trentino-sud-tirol": { "$": 0 }, "trentino-sudtirol": { "$": 0 }, "trentino-sued-tirol": { "$": 0 }, "trentino-suedtirol": { "$": 0 }, "trentinoa-adige": { "$": 0 }, "trentinoaadige": { "$": 0 }, "trentinoalto-adige": { "$": 0 }, "trentinoaltoadige": { "$": 0 }, "trentinos-tirol": { "$": 0 }, "trentinostirol": { "$": 0 }, "trentinosud-tirol": { "$": 0 }, "trentinosudtirol": { "$": 0 }, "trentinosued-tirol": { "$": 0 }, "trentinosuedtirol": { "$": 0 }, "tuscany": { "$": 0 }, "umb": { "$": 0 }, "umbria": { "$": 0 }, "val-d-aosta": { "$": 0 }, "val-daosta": { "$": 0 }, "vald-aosta": { "$": 0 }, "valdaosta": { "$": 0 }, "valle-aosta": { "$": 0 }, "valle-d-aosta": { "$": 0 }, "valle-daosta": { "$": 0 }, "valleaosta": { "$": 0 }, "valled-aosta": { "$": 0 }, "valledaosta": { "$": 0 }, "vallee-aoste": { "$": 0 }, "valleeaoste": { "$": 0 }, "vao": { "$": 0 }, "vda": { "$": 0 }, "ven": { "$": 0 }, "veneto": { "$": 0 }, "ag": { "$": 0 }, "agrigento": { "$": 0 }, "al": { "$": 0 }, "alessandria": { "$": 0 }, "alto-adige": { "$": 0 }, "altoadige": { "$": 0 }, "an": { "$": 0 }, "ancona": { "$": 0 }, "andria-barletta-trani": { "$": 0 }, "andria-trani-barletta": { "$": 0 }, "andriabarlettatrani": { "$": 0 }, "andriatranibarletta": { "$": 0 }, "ao": { "$": 0 }, "aosta": { "$": 0 }, "aoste": { "$": 0 }, "ap": { "$": 0 }, "aq": { "$": 0 }, "aquila": { "$": 0 }, "ar": { "$": 0 }, "arezzo": { "$": 0 }, "ascoli-piceno": { "$": 0 }, "ascolipiceno": { "$": 0 }, "asti": { "$": 0 }, "at": { "$": 0 }, "av": { "$": 0 }, "avellino": { "$": 0 }, "ba": { "$": 0 }, "balsan": { "$": 0 }, "bari": { "$": 0 }, "barletta-trani-andria": { "$": 0 }, "barlettatraniandria": { "$": 0 }, "belluno": { "$": 0 }, "benevento": { "$": 0 }, "bergamo": { "$": 0 }, "bg": { "$": 0 }, "bi": { "$": 0 }, "biella": { "$": 0 }, "bl": { "$": 0 }, "bn": { "$": 0 }, "bo": { "$": 0 }, "bologna": { "$": 0 }, "bolzano": { "$": 0 }, "bozen": { "$": 0 }, "br": { "$": 0 }, "brescia": { "$": 0 }, "brindisi": { "$": 0 }, "bs": { "$": 0 }, "bt": { "$": 0 }, "bz": { "$": 0 }, "ca": { "$": 0 }, "cagliari": { "$": 0 }, "caltanissetta": { "$": 0 }, "campidano-medio": { "$": 0 }, "campidanomedio": { "$": 0 }, "campobasso": { "$": 0 }, "carbonia-iglesias": { "$": 0 }, "carboniaiglesias": { "$": 0 }, "carrara-massa": { "$": 0 }, "carraramassa": { "$": 0 }, "caserta": { "$": 0 }, "catania": { "$": 0 }, "catanzaro": { "$": 0 }, "cb": { "$": 0 }, "ce": { "$": 0 }, "cesena-forli": { "$": 0 }, "cesenaforli": { "$": 0 }, "ch": { "$": 0 }, "chieti": { "$": 0 }, "ci": { "$": 0 }, "cl": { "$": 0 }, "cn": { "$": 0 }, "co": { "$": 0 }, "como": { "$": 0 }, "cosenza": { "$": 0 }, "cr": { "$": 0 }, "cremona": { "$": 0 }, "crotone": { "$": 0 }, "cs": { "$": 0 }, "ct": { "$": 0 }, "cuneo": { "$": 0 }, "cz": { "$": 0 }, "dell-ogliastra": { "$": 0 }, "dellogliastra": { "$": 0 }, "en": { "$": 0 }, "enna": { "$": 0 }, "fc": { "$": 0 }, "fe": { "$": 0 }, "fermo": { "$": 0 }, "ferrara": { "$": 0 }, "fg": { "$": 0 }, "fi": { "$": 0 }, "firenze": { "$": 0 }, "florence": { "$": 0 }, "fm": { "$": 0 }, "foggia": { "$": 0 }, "forli-cesena": { "$": 0 }, "forlicesena": { "$": 0 }, "fr": { "$": 0 }, "frosinone": { "$": 0 }, "ge": { "$": 0 }, "genoa": { "$": 0 }, "genova": { "$": 0 }, "go": { "$": 0 }, "gorizia": { "$": 0 }, "gr": { "$": 0 }, "grosseto": { "$": 0 }, "iglesias-carbonia": { "$": 0 }, "iglesiascarbonia": { "$": 0 }, "im": { "$": 0 }, "imperia": { "$": 0 }, "is": { "$": 0 }, "isernia": { "$": 0 }, "kr": { "$": 0 }, "la-spezia": { "$": 0 }, "laquila": { "$": 0 }, "laspezia": { "$": 0 }, "latina": { "$": 0 }, "lc": { "$": 0 }, "le": { "$": 0 }, "lecce": { "$": 0 }, "lecco": { "$": 0 }, "li": { "$": 0 }, "livorno": { "$": 0 }, "lo": { "$": 0 }, "lodi": { "$": 0 }, "lt": { "$": 0 }, "lu": { "$": 0 }, "lucca": { "$": 0 }, "macerata": { "$": 0 }, "mantova": { "$": 0 }, "massa-carrara": { "$": 0 }, "massacarrara": { "$": 0 }, "matera": { "$": 0 }, "mb": { "$": 0 }, "mc": { "$": 0 }, "me": { "$": 0 }, "medio-campidano": { "$": 0 }, "mediocampidano": { "$": 0 }, "messina": { "$": 0 }, "mi": { "$": 0 }, "milan": { "$": 0 }, "milano": { "$": 0 }, "mn": { "$": 0 }, "mo": { "$": 0 }, "modena": { "$": 0 }, "monza-brianza": { "$": 0 }, "monza-e-della-brianza": { "$": 0 }, "monza": { "$": 0 }, "monzabrianza": { "$": 0 }, "monzaebrianza": { "$": 0 }, "monzaedellabrianza": { "$": 0 }, "ms": { "$": 0 }, "mt": { "$": 0 }, "na": { "$": 0 }, "naples": { "$": 0 }, "napoli": { "$": 0 }, "no": { "$": 0 }, "novara": { "$": 0 }, "nu": { "$": 0 }, "nuoro": { "$": 0 }, "og": { "$": 0 }, "ogliastra": { "$": 0 }, "olbia-tempio": { "$": 0 }, "olbiatempio": { "$": 0 }, "or": { "$": 0 }, "oristano": { "$": 0 }, "ot": { "$": 0 }, "pa": { "$": 0 }, "padova": { "$": 0 }, "padua": { "$": 0 }, "palermo": { "$": 0 }, "parma": { "$": 0 }, "pavia": { "$": 0 }, "pc": { "$": 0 }, "pd": { "$": 0 }, "pe": { "$": 0 }, "perugia": { "$": 0 }, "pesaro-urbino": { "$": 0 }, "pesarourbino": { "$": 0 }, "pescara": { "$": 0 }, "pg": { "$": 0 }, "pi": { "$": 0 }, "piacenza": { "$": 0 }, "pisa": { "$": 0 }, "pistoia": { "$": 0 }, "pn": { "$": 0 }, "po": { "$": 0 }, "pordenone": { "$": 0 }, "potenza": { "$": 0 }, "pr": { "$": 0 }, "prato": { "$": 0 }, "pt": { "$": 0 }, "pu": { "$": 0 }, "pv": { "$": 0 }, "pz": { "$": 0 }, "ra": { "$": 0 }, "ragusa": { "$": 0 }, "ravenna": { "$": 0 }, "rc": { "$": 0 }, "re": { "$": 0 }, "reggio-calabria": { "$": 0 }, "reggio-emilia": { "$": 0 }, "reggiocalabria": { "$": 0 }, "reggioemilia": { "$": 0 }, "rg": { "$": 0 }, "ri": { "$": 0 }, "rieti": { "$": 0 }, "rimini": { "$": 0 }, "rm": { "$": 0 }, "rn": { "$": 0 }, "ro": { "$": 0 }, "roma": { "$": 0 }, "rome": { "$": 0 }, "rovigo": { "$": 0 }, "sa": { "$": 0 }, "salerno": { "$": 0 }, "sassari": { "$": 0 }, "savona": { "$": 0 }, "si": { "$": 0 }, "siena": { "$": 0 }, "siracusa": { "$": 0 }, "so": { "$": 0 }, "sondrio": { "$": 0 }, "sp": { "$": 0 }, "sr": { "$": 0 }, "ss": { "$": 0 }, "suedtirol": { "$": 0 }, "sv": { "$": 0 }, "ta": { "$": 0 }, "taranto": { "$": 0 }, "te": { "$": 0 }, "tempio-olbia": { "$": 0 }, "tempioolbia": { "$": 0 }, "teramo": { "$": 0 }, "terni": { "$": 0 }, "tn": { "$": 0 }, "to": { "$": 0 }, "torino": { "$": 0 }, "tp": { "$": 0 }, "tr": { "$": 0 }, "trani-andria-barletta": { "$": 0 }, "trani-barletta-andria": { "$": 0 }, "traniandriabarletta": { "$": 0 }, "tranibarlettaandria": { "$": 0 }, "trapani": { "$": 0 }, "trentino": { "$": 0 }, "trento": { "$": 0 }, "treviso": { "$": 0 }, "trieste": { "$": 0 }, "ts": { "$": 0 }, "turin": { "$": 0 }, "tv": { "$": 0 }, "ud": { "$": 0 }, "udine": { "$": 0 }, "urbino-pesaro": { "$": 0 }, "urbinopesaro": { "$": 0 }, "va": { "$": 0 }, "varese": { "$": 0 }, "vb": { "$": 0 }, "vc": { "$": 0 }, "ve": { "$": 0 }, "venezia": { "$": 0 }, "venice": { "$": 0 }, "verbania": { "$": 0 }, "vercelli": { "$": 0 }, "verona": { "$": 0 }, "vi": { "$": 0 }, "vibo-valentia": { "$": 0 }, "vibovalentia": { "$": 0 }, "vicenza": { "$": 0 }, "viterbo": { "$": 0 }, "vr": { "$": 0 }, "vs": { "$": 0 }, "vt": { "$": 0 }, "vv": { "$": 0 }, "blogspot": { "$": 0 } }, "je": { "$": 0, "co": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "jm": { "*": { "$": 0 } }, "jo": { "$": 0, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "edu": { "$": 0 }, "sch": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "name": { "$": 0 } }, "jobs": { "$": 0 }, "jp": { "$": 0, "ac": { "$": 0 }, "ad": { "$": 0 }, "co": { "$": 0 }, "ed": { "$": 0 }, "go": { "$": 0 }, "gr": { "$": 0 }, "lg": { "$": 0 }, "ne": { "$": 0 }, "or": { "$": 0 }, "aichi": { "$": 0, "aisai": { "$": 0 }, "ama": { "$": 0 }, "anjo": { "$": 0 }, "asuke": { "$": 0 }, "chiryu": { "$": 0 }, "chita": { "$": 0 }, "fuso": { "$": 0 }, "gamagori": { "$": 0 }, "handa": { "$": 0 }, "hazu": { "$": 0 }, "hekinan": { "$": 0 }, "higashiura": { "$": 0 }, "ichinomiya": { "$": 0 }, "inazawa": { "$": 0 }, "inuyama": { "$": 0 }, "isshiki": { "$": 0 }, "iwakura": { "$": 0 }, "kanie": { "$": 0 }, "kariya": { "$": 0 }, "kasugai": { "$": 0 }, "kira": { "$": 0 }, "kiyosu": { "$": 0 }, "komaki": { "$": 0 }, "konan": { "$": 0 }, "kota": { "$": 0 }, "mihama": { "$": 0 }, "miyoshi": { "$": 0 }, "nishio": { "$": 0 }, "nisshin": { "$": 0 }, "obu": { "$": 0 }, "oguchi": { "$": 0 }, "oharu": { "$": 0 }, "okazaki": { "$": 0 }, "owariasahi": { "$": 0 }, "seto": { "$": 0 }, "shikatsu": { "$": 0 }, "shinshiro": { "$": 0 }, "shitara": { "$": 0 }, "tahara": { "$": 0 }, "takahama": { "$": 0 }, "tobishima": { "$": 0 }, "toei": { "$": 0 }, "togo": { "$": 0 }, "tokai": { "$": 0 }, "tokoname": { "$": 0 }, "toyoake": { "$": 0 }, "toyohashi": { "$": 0 }, "toyokawa": { "$": 0 }, "toyone": { "$": 0 }, "toyota": { "$": 0 }, "tsushima": { "$": 0 }, "yatomi": { "$": 0 } }, "akita": { "$": 0, "akita": { "$": 0 }, "daisen": { "$": 0 }, "fujisato": { "$": 0 }, "gojome": { "$": 0 }, "hachirogata": { "$": 0 }, "happou": { "$": 0 }, "higashinaruse": { "$": 0 }, "honjo": { "$": 0 }, "honjyo": { "$": 0 }, "ikawa": { "$": 0 }, "kamikoani": { "$": 0 }, "kamioka": { "$": 0 }, "katagami": { "$": 0 }, "kazuno": { "$": 0 }, "kitaakita": { "$": 0 }, "kosaka": { "$": 0 }, "kyowa": { "$": 0 }, "misato": { "$": 0 }, "mitane": { "$": 0 }, "moriyoshi": { "$": 0 }, "nikaho": { "$": 0 }, "noshiro": { "$": 0 }, "odate": { "$": 0 }, "oga": { "$": 0 }, "ogata": { "$": 0 }, "semboku": { "$": 0 }, "yokote": { "$": 0 }, "yurihonjo": { "$": 0 } }, "aomori": { "$": 0, "aomori": { "$": 0 }, "gonohe": { "$": 0 }, "hachinohe": { "$": 0 }, "hashikami": { "$": 0 }, "hiranai": { "$": 0 }, "hirosaki": { "$": 0 }, "itayanagi": { "$": 0 }, "kuroishi": { "$": 0 }, "misawa": { "$": 0 }, "mutsu": { "$": 0 }, "nakadomari": { "$": 0 }, "noheji": { "$": 0 }, "oirase": { "$": 0 }, "owani": { "$": 0 }, "rokunohe": { "$": 0 }, "sannohe": { "$": 0 }, "shichinohe": { "$": 0 }, "shingo": { "$": 0 }, "takko": { "$": 0 }, "towada": { "$": 0 }, "tsugaru": { "$": 0 }, "tsuruta": { "$": 0 } }, "chiba": { "$": 0, "abiko": { "$": 0 }, "asahi": { "$": 0 }, "chonan": { "$": 0 }, "chosei": { "$": 0 }, "choshi": { "$": 0 }, "chuo": { "$": 0 }, "funabashi": { "$": 0 }, "futtsu": { "$": 0 }, "hanamigawa": { "$": 0 }, "ichihara": { "$": 0 }, "ichikawa": { "$": 0 }, "ichinomiya": { "$": 0 }, "inzai": { "$": 0 }, "isumi": { "$": 0 }, "kamagaya": { "$": 0 }, "kamogawa": { "$": 0 }, "kashiwa": { "$": 0 }, "katori": { "$": 0 }, "katsuura": { "$": 0 }, "kimitsu": { "$": 0 }, "kisarazu": { "$": 0 }, "kozaki": { "$": 0 }, "kujukuri": { "$": 0 }, "kyonan": { "$": 0 }, "matsudo": { "$": 0 }, "midori": { "$": 0 }, "mihama": { "$": 0 }, "minamiboso": { "$": 0 }, "mobara": { "$": 0 }, "mutsuzawa": { "$": 0 }, "nagara": { "$": 0 }, "nagareyama": { "$": 0 }, "narashino": { "$": 0 }, "narita": { "$": 0 }, "noda": { "$": 0 }, "oamishirasato": { "$": 0 }, "omigawa": { "$": 0 }, "onjuku": { "$": 0 }, "otaki": { "$": 0 }, "sakae": { "$": 0 }, "sakura": { "$": 0 }, "shimofusa": { "$": 0 }, "shirako": { "$": 0 }, "shiroi": { "$": 0 }, "shisui": { "$": 0 }, "sodegaura": { "$": 0 }, "sosa": { "$": 0 }, "tako": { "$": 0 }, "tateyama": { "$": 0 }, "togane": { "$": 0 }, "tohnosho": { "$": 0 }, "tomisato": { "$": 0 }, "urayasu": { "$": 0 }, "yachimata": { "$": 0 }, "yachiyo": { "$": 0 }, "yokaichiba": { "$": 0 }, "yokoshibahikari": { "$": 0 }, "yotsukaido": { "$": 0 } }, "ehime": { "$": 0, "ainan": { "$": 0 }, "honai": { "$": 0 }, "ikata": { "$": 0 }, "imabari": { "$": 0 }, "iyo": { "$": 0 }, "kamijima": { "$": 0 }, "kihoku": { "$": 0 }, "kumakogen": { "$": 0 }, "masaki": { "$": 0 }, "matsuno": { "$": 0 }, "matsuyama": { "$": 0 }, "namikata": { "$": 0 }, "niihama": { "$": 0 }, "ozu": { "$": 0 }, "saijo": { "$": 0 }, "seiyo": { "$": 0 }, "shikokuchuo": { "$": 0 }, "tobe": { "$": 0 }, "toon": { "$": 0 }, "uchiko": { "$": 0 }, "uwajima": { "$": 0 }, "yawatahama": { "$": 0 } }, "fukui": { "$": 0, "echizen": { "$": 0 }, "eiheiji": { "$": 0 }, "fukui": { "$": 0 }, "ikeda": { "$": 0 }, "katsuyama": { "$": 0 }, "mihama": { "$": 0 }, "minamiechizen": { "$": 0 }, "obama": { "$": 0 }, "ohi": { "$": 0 }, "ono": { "$": 0 }, "sabae": { "$": 0 }, "sakai": { "$": 0 }, "takahama": { "$": 0 }, "tsuruga": { "$": 0 }, "wakasa": { "$": 0 } }, "fukuoka": { "$": 0, "ashiya": { "$": 0 }, "buzen": { "$": 0 }, "chikugo": { "$": 0 }, "chikuho": { "$": 0 }, "chikujo": { "$": 0 }, "chikushino": { "$": 0 }, "chikuzen": { "$": 0 }, "chuo": { "$": 0 }, "dazaifu": { "$": 0 }, "fukuchi": { "$": 0 }, "hakata": { "$": 0 }, "higashi": { "$": 0 }, "hirokawa": { "$": 0 }, "hisayama": { "$": 0 }, "iizuka": { "$": 0 }, "inatsuki": { "$": 0 }, "kaho": { "$": 0 }, "kasuga": { "$": 0 }, "kasuya": { "$": 0 }, "kawara": { "$": 0 }, "keisen": { "$": 0 }, "koga": { "$": 0 }, "kurate": { "$": 0 }, "kurogi": { "$": 0 }, "kurume": { "$": 0 }, "minami": { "$": 0 }, "miyako": { "$": 0 }, "miyama": { "$": 0 }, "miyawaka": { "$": 0 }, "mizumaki": { "$": 0 }, "munakata": { "$": 0 }, "nakagawa": { "$": 0 }, "nakama": { "$": 0 }, "nishi": { "$": 0 }, "nogata": { "$": 0 }, "ogori": { "$": 0 }, "okagaki": { "$": 0 }, "okawa": { "$": 0 }, "oki": { "$": 0 }, "omuta": { "$": 0 }, "onga": { "$": 0 }, "onojo": { "$": 0 }, "oto": { "$": 0 }, "saigawa": { "$": 0 }, "sasaguri": { "$": 0 }, "shingu": { "$": 0 }, "shinyoshitomi": { "$": 0 }, "shonai": { "$": 0 }, "soeda": { "$": 0 }, "sue": { "$": 0 }, "tachiarai": { "$": 0 }, "tagawa": { "$": 0 }, "takata": { "$": 0 }, "toho": { "$": 0 }, "toyotsu": { "$": 0 }, "tsuiki": { "$": 0 }, "ukiha": { "$": 0 }, "umi": { "$": 0 }, "usui": { "$": 0 }, "yamada": { "$": 0 }, "yame": { "$": 0 }, "yanagawa": { "$": 0 }, "yukuhashi": { "$": 0 } }, "fukushima": { "$": 0, "aizubange": { "$": 0 }, "aizumisato": { "$": 0 }, "aizuwakamatsu": { "$": 0 }, "asakawa": { "$": 0 }, "bandai": { "$": 0 }, "date": { "$": 0 }, "fukushima": { "$": 0 }, "furudono": { "$": 0 }, "futaba": { "$": 0 }, "hanawa": { "$": 0 }, "higashi": { "$": 0 }, "hirata": { "$": 0 }, "hirono": { "$": 0 }, "iitate": { "$": 0 }, "inawashiro": { "$": 0 }, "ishikawa": { "$": 0 }, "iwaki": { "$": 0 }, "izumizaki": { "$": 0 }, "kagamiishi": { "$": 0 }, "kaneyama": { "$": 0 }, "kawamata": { "$": 0 }, "kitakata": { "$": 0 }, "kitashiobara": { "$": 0 }, "koori": { "$": 0 }, "koriyama": { "$": 0 }, "kunimi": { "$": 0 }, "miharu": { "$": 0 }, "mishima": { "$": 0 }, "namie": { "$": 0 }, "nango": { "$": 0 }, "nishiaizu": { "$": 0 }, "nishigo": { "$": 0 }, "okuma": { "$": 0 }, "omotego": { "$": 0 }, "ono": { "$": 0 }, "otama": { "$": 0 }, "samegawa": { "$": 0 }, "shimogo": { "$": 0 }, "shirakawa": { "$": 0 }, "showa": { "$": 0 }, "soma": { "$": 0 }, "sukagawa": { "$": 0 }, "taishin": { "$": 0 }, "tamakawa": { "$": 0 }, "tanagura": { "$": 0 }, "tenei": { "$": 0 }, "yabuki": { "$": 0 }, "yamato": { "$": 0 }, "yamatsuri": { "$": 0 }, "yanaizu": { "$": 0 }, "yugawa": { "$": 0 } }, "gifu": { "$": 0, "anpachi": { "$": 0 }, "ena": { "$": 0 }, "gifu": { "$": 0 }, "ginan": { "$": 0 }, "godo": { "$": 0 }, "gujo": { "$": 0 }, "hashima": { "$": 0 }, "hichiso": { "$": 0 }, "hida": { "$": 0 }, "higashishirakawa": { "$": 0 }, "ibigawa": { "$": 0 }, "ikeda": { "$": 0 }, "kakamigahara": { "$": 0 }, "kani": { "$": 0 }, "kasahara": { "$": 0 }, "kasamatsu": { "$": 0 }, "kawaue": { "$": 0 }, "kitagata": { "$": 0 }, "mino": { "$": 0 }, "minokamo": { "$": 0 }, "mitake": { "$": 0 }, "mizunami": { "$": 0 }, "motosu": { "$": 0 }, "nakatsugawa": { "$": 0 }, "ogaki": { "$": 0 }, "sakahogi": { "$": 0 }, "seki": { "$": 0 }, "sekigahara": { "$": 0 }, "shirakawa": { "$": 0 }, "tajimi": { "$": 0 }, "takayama": { "$": 0 }, "tarui": { "$": 0 }, "toki": { "$": 0 }, "tomika": { "$": 0 }, "wanouchi": { "$": 0 }, "yamagata": { "$": 0 }, "yaotsu": { "$": 0 }, "yoro": { "$": 0 } }, "gunma": { "$": 0, "annaka": { "$": 0 }, "chiyoda": { "$": 0 }, "fujioka": { "$": 0 }, "higashiagatsuma": { "$": 0 }, "isesaki": { "$": 0 }, "itakura": { "$": 0 }, "kanna": { "$": 0 }, "kanra": { "$": 0 }, "katashina": { "$": 0 }, "kawaba": { "$": 0 }, "kiryu": { "$": 0 }, "kusatsu": { "$": 0 }, "maebashi": { "$": 0 }, "meiwa": { "$": 0 }, "midori": { "$": 0 }, "minakami": { "$": 0 }, "naganohara": { "$": 0 }, "nakanojo": { "$": 0 }, "nanmoku": { "$": 0 }, "numata": { "$": 0 }, "oizumi": { "$": 0 }, "ora": { "$": 0 }, "ota": { "$": 0 }, "shibukawa": { "$": 0 }, "shimonita": { "$": 0 }, "shinto": { "$": 0 }, "showa": { "$": 0 }, "takasaki": { "$": 0 }, "takayama": { "$": 0 }, "tamamura": { "$": 0 }, "tatebayashi": { "$": 0 }, "tomioka": { "$": 0 }, "tsukiyono": { "$": 0 }, "tsumagoi": { "$": 0 }, "ueno": { "$": 0 }, "yoshioka": { "$": 0 } }, "hiroshima": { "$": 0, "asaminami": { "$": 0 }, "daiwa": { "$": 0 }, "etajima": { "$": 0 }, "fuchu": { "$": 0 }, "fukuyama": { "$": 0 }, "hatsukaichi": { "$": 0 }, "higashihiroshima": { "$": 0 }, "hongo": { "$": 0 }, "jinsekikogen": { "$": 0 }, "kaita": { "$": 0 }, "kui": { "$": 0 }, "kumano": { "$": 0 }, "kure": { "$": 0 }, "mihara": { "$": 0 }, "miyoshi": { "$": 0 }, "naka": { "$": 0 }, "onomichi": { "$": 0 }, "osakikamijima": { "$": 0 }, "otake": { "$": 0 }, "saka": { "$": 0 }, "sera": { "$": 0 }, "seranishi": { "$": 0 }, "shinichi": { "$": 0 }, "shobara": { "$": 0 }, "takehara": { "$": 0 } }, "hokkaido": { "$": 0, "abashiri": { "$": 0 }, "abira": { "$": 0 }, "aibetsu": { "$": 0 }, "akabira": { "$": 0 }, "akkeshi": { "$": 0 }, "asahikawa": { "$": 0 }, "ashibetsu": { "$": 0 }, "ashoro": { "$": 0 }, "assabu": { "$": 0 }, "atsuma": { "$": 0 }, "bibai": { "$": 0 }, "biei": { "$": 0 }, "bifuka": { "$": 0 }, "bihoro": { "$": 0 }, "biratori": { "$": 0 }, "chippubetsu": { "$": 0 }, "chitose": { "$": 0 }, "date": { "$": 0 }, "ebetsu": { "$": 0 }, "embetsu": { "$": 0 }, "eniwa": { "$": 0 }, "erimo": { "$": 0 }, "esan": { "$": 0 }, "esashi": { "$": 0 }, "fukagawa": { "$": 0 }, "fukushima": { "$": 0 }, "furano": { "$": 0 }, "furubira": { "$": 0 }, "haboro": { "$": 0 }, "hakodate": { "$": 0 }, "hamatonbetsu": { "$": 0 }, "hidaka": { "$": 0 }, "higashikagura": { "$": 0 }, "higashikawa": { "$": 0 }, "hiroo": { "$": 0 }, "hokuryu": { "$": 0 }, "hokuto": { "$": 0 }, "honbetsu": { "$": 0 }, "horokanai": { "$": 0 }, "horonobe": { "$": 0 }, "ikeda": { "$": 0 }, "imakane": { "$": 0 }, "ishikari": { "$": 0 }, "iwamizawa": { "$": 0 }, "iwanai": { "$": 0 }, "kamifurano": { "$": 0 }, "kamikawa": { "$": 0 }, "kamishihoro": { "$": 0 }, "kamisunagawa": { "$": 0 }, "kamoenai": { "$": 0 }, "kayabe": { "$": 0 }, "kembuchi": { "$": 0 }, "kikonai": { "$": 0 }, "kimobetsu": { "$": 0 }, "kitahiroshima": { "$": 0 }, "kitami": { "$": 0 }, "kiyosato": { "$": 0 }, "koshimizu": { "$": 0 }, "kunneppu": { "$": 0 }, "kuriyama": { "$": 0 }, "kuromatsunai": { "$": 0 }, "kushiro": { "$": 0 }, "kutchan": { "$": 0 }, "kyowa": { "$": 0 }, "mashike": { "$": 0 }, "matsumae": { "$": 0 }, "mikasa": { "$": 0 }, "minamifurano": { "$": 0 }, "mombetsu": { "$": 0 }, "moseushi": { "$": 0 }, "mukawa": { "$": 0 }, "muroran": { "$": 0 }, "naie": { "$": 0 }, "nakagawa": { "$": 0 }, "nakasatsunai": { "$": 0 }, "nakatombetsu": { "$": 0 }, "nanae": { "$": 0 }, "nanporo": { "$": 0 }, "nayoro": { "$": 0 }, "nemuro": { "$": 0 }, "niikappu": { "$": 0 }, "niki": { "$": 0 }, "nishiokoppe": { "$": 0 }, "noboribetsu": { "$": 0 }, "numata": { "$": 0 }, "obihiro": { "$": 0 }, "obira": { "$": 0 }, "oketo": { "$": 0 }, "okoppe": { "$": 0 }, "otaru": { "$": 0 }, "otobe": { "$": 0 }, "otofuke": { "$": 0 }, "otoineppu": { "$": 0 }, "oumu": { "$": 0 }, "ozora": { "$": 0 }, "pippu": { "$": 0 }, "rankoshi": { "$": 0 }, "rebun": { "$": 0 }, "rikubetsu": { "$": 0 }, "rishiri": { "$": 0 }, "rishirifuji": { "$": 0 }, "saroma": { "$": 0 }, "sarufutsu": { "$": 0 }, "shakotan": { "$": 0 }, "shari": { "$": 0 }, "shibecha": { "$": 0 }, "shibetsu": { "$": 0 }, "shikabe": { "$": 0 }, "shikaoi": { "$": 0 }, "shimamaki": { "$": 0 }, "shimizu": { "$": 0 }, "shimokawa": { "$": 0 }, "shinshinotsu": { "$": 0 }, "shintoku": { "$": 0 }, "shiranuka": { "$": 0 }, "shiraoi": { "$": 0 }, "shiriuchi": { "$": 0 }, "sobetsu": { "$": 0 }, "sunagawa": { "$": 0 }, "taiki": { "$": 0 }, "takasu": { "$": 0 }, "takikawa": { "$": 0 }, "takinoue": { "$": 0 }, "teshikaga": { "$": 0 }, "tobetsu": { "$": 0 }, "tohma": { "$": 0 }, "tomakomai": { "$": 0 }, "tomari": { "$": 0 }, "toya": { "$": 0 }, "toyako": { "$": 0 }, "toyotomi": { "$": 0 }, "toyoura": { "$": 0 }, "tsubetsu": { "$": 0 }, "tsukigata": { "$": 0 }, "urakawa": { "$": 0 }, "urausu": { "$": 0 }, "uryu": { "$": 0 }, "utashinai": { "$": 0 }, "wakkanai": { "$": 0 }, "wassamu": { "$": 0 }, "yakumo": { "$": 0 }, "yoichi": { "$": 0 } }, "hyogo": { "$": 0, "aioi": { "$": 0 }, "akashi": { "$": 0 }, "ako": { "$": 0 }, "amagasaki": { "$": 0 }, "aogaki": { "$": 0 }, "asago": { "$": 0 }, "ashiya": { "$": 0 }, "awaji": { "$": 0 }, "fukusaki": { "$": 0 }, "goshiki": { "$": 0 }, "harima": { "$": 0 }, "himeji": { "$": 0 }, "ichikawa": { "$": 0 }, "inagawa": { "$": 0 }, "itami": { "$": 0 }, "kakogawa": { "$": 0 }, "kamigori": { "$": 0 }, "kamikawa": { "$": 0 }, "kasai": { "$": 0 }, "kasuga": { "$": 0 }, "kawanishi": { "$": 0 }, "miki": { "$": 0 }, "minamiawaji": { "$": 0 }, "nishinomiya": { "$": 0 }, "nishiwaki": { "$": 0 }, "ono": { "$": 0 }, "sanda": { "$": 0 }, "sannan": { "$": 0 }, "sasayama": { "$": 0 }, "sayo": { "$": 0 }, "shingu": { "$": 0 }, "shinonsen": { "$": 0 }, "shiso": { "$": 0 }, "sumoto": { "$": 0 }, "taishi": { "$": 0 }, "taka": { "$": 0 }, "takarazuka": { "$": 0 }, "takasago": { "$": 0 }, "takino": { "$": 0 }, "tamba": { "$": 0 }, "tatsuno": { "$": 0 }, "toyooka": { "$": 0 }, "yabu": { "$": 0 }, "yashiro": { "$": 0 }, "yoka": { "$": 0 }, "yokawa": { "$": 0 } }, "ibaraki": { "$": 0, "ami": { "$": 0 }, "asahi": { "$": 0 }, "bando": { "$": 0 }, "chikusei": { "$": 0 }, "daigo": { "$": 0 }, "fujishiro": { "$": 0 }, "hitachi": { "$": 0 }, "hitachinaka": { "$": 0 }, "hitachiomiya": { "$": 0 }, "hitachiota": { "$": 0 }, "ibaraki": { "$": 0 }, "ina": { "$": 0 }, "inashiki": { "$": 0 }, "itako": { "$": 0 }, "iwama": { "$": 0 }, "joso": { "$": 0 }, "kamisu": { "$": 0 }, "kasama": { "$": 0 }, "kashima": { "$": 0 }, "kasumigaura": { "$": 0 }, "koga": { "$": 0 }, "miho": { "$": 0 }, "mito": { "$": 0 }, "moriya": { "$": 0 }, "naka": { "$": 0 }, "namegata": { "$": 0 }, "oarai": { "$": 0 }, "ogawa": { "$": 0 }, "omitama": { "$": 0 }, "ryugasaki": { "$": 0 }, "sakai": { "$": 0 }, "sakuragawa": { "$": 0 }, "shimodate": { "$": 0 }, "shimotsuma": { "$": 0 }, "shirosato": { "$": 0 }, "sowa": { "$": 0 }, "suifu": { "$": 0 }, "takahagi": { "$": 0 }, "tamatsukuri": { "$": 0 }, "tokai": { "$": 0 }, "tomobe": { "$": 0 }, "tone": { "$": 0 }, "toride": { "$": 0 }, "tsuchiura": { "$": 0 }, "tsukuba": { "$": 0 }, "uchihara": { "$": 0 }, "ushiku": { "$": 0 }, "yachiyo": { "$": 0 }, "yamagata": { "$": 0 }, "yawara": { "$": 0 }, "yuki": { "$": 0 } }, "ishikawa": { "$": 0, "anamizu": { "$": 0 }, "hakui": { "$": 0 }, "hakusan": { "$": 0 }, "kaga": { "$": 0 }, "kahoku": { "$": 0 }, "kanazawa": { "$": 0 }, "kawakita": { "$": 0 }, "komatsu": { "$": 0 }, "nakanoto": { "$": 0 }, "nanao": { "$": 0 }, "nomi": { "$": 0 }, "nonoichi": { "$": 0 }, "noto": { "$": 0 }, "shika": { "$": 0 }, "suzu": { "$": 0 }, "tsubata": { "$": 0 }, "tsurugi": { "$": 0 }, "uchinada": { "$": 0 }, "wajima": { "$": 0 } }, "iwate": { "$": 0, "fudai": { "$": 0 }, "fujisawa": { "$": 0 }, "hanamaki": { "$": 0 }, "hiraizumi": { "$": 0 }, "hirono": { "$": 0 }, "ichinohe": { "$": 0 }, "ichinoseki": { "$": 0 }, "iwaizumi": { "$": 0 }, "iwate": { "$": 0 }, "joboji": { "$": 0 }, "kamaishi": { "$": 0 }, "kanegasaki": { "$": 0 }, "karumai": { "$": 0 }, "kawai": { "$": 0 }, "kitakami": { "$": 0 }, "kuji": { "$": 0 }, "kunohe": { "$": 0 }, "kuzumaki": { "$": 0 }, "miyako": { "$": 0 }, "mizusawa": { "$": 0 }, "morioka": { "$": 0 }, "ninohe": { "$": 0 }, "noda": { "$": 0 }, "ofunato": { "$": 0 }, "oshu": { "$": 0 }, "otsuchi": { "$": 0 }, "rikuzentakata": { "$": 0 }, "shiwa": { "$": 0 }, "shizukuishi": { "$": 0 }, "sumita": { "$": 0 }, "tanohata": { "$": 0 }, "tono": { "$": 0 }, "yahaba": { "$": 0 }, "yamada": { "$": 0 } }, "kagawa": { "$": 0, "ayagawa": { "$": 0 }, "higashikagawa": { "$": 0 }, "kanonji": { "$": 0 }, "kotohira": { "$": 0 }, "manno": { "$": 0 }, "marugame": { "$": 0 }, "mitoyo": { "$": 0 }, "naoshima": { "$": 0 }, "sanuki": { "$": 0 }, "tadotsu": { "$": 0 }, "takamatsu": { "$": 0 }, "tonosho": { "$": 0 }, "uchinomi": { "$": 0 }, "utazu": { "$": 0 }, "zentsuji": { "$": 0 } }, "kagoshima": { "$": 0, "akune": { "$": 0 }, "amami": { "$": 0 }, "hioki": { "$": 0 }, "isa": { "$": 0 }, "isen": { "$": 0 }, "izumi": { "$": 0 }, "kagoshima": { "$": 0 }, "kanoya": { "$": 0 }, "kawanabe": { "$": 0 }, "kinko": { "$": 0 }, "kouyama": { "$": 0 }, "makurazaki": { "$": 0 }, "matsumoto": { "$": 0 }, "minamitane": { "$": 0 }, "nakatane": { "$": 0 }, "nishinoomote": { "$": 0 }, "satsumasendai": { "$": 0 }, "soo": { "$": 0 }, "tarumizu": { "$": 0 }, "yusui": { "$": 0 } }, "kanagawa": { "$": 0, "aikawa": { "$": 0 }, "atsugi": { "$": 0 }, "ayase": { "$": 0 }, "chigasaki": { "$": 0 }, "ebina": { "$": 0 }, "fujisawa": { "$": 0 }, "hadano": { "$": 0 }, "hakone": { "$": 0 }, "hiratsuka": { "$": 0 }, "isehara": { "$": 0 }, "kaisei": { "$": 0 }, "kamakura": { "$": 0 }, "kiyokawa": { "$": 0 }, "matsuda": { "$": 0 }, "minamiashigara": { "$": 0 }, "miura": { "$": 0 }, "nakai": { "$": 0 }, "ninomiya": { "$": 0 }, "odawara": { "$": 0 }, "oi": { "$": 0 }, "oiso": { "$": 0 }, "sagamihara": { "$": 0 }, "samukawa": { "$": 0 }, "tsukui": { "$": 0 }, "yamakita": { "$": 0 }, "yamato": { "$": 0 }, "yokosuka": { "$": 0 }, "yugawara": { "$": 0 }, "zama": { "$": 0 }, "zushi": { "$": 0 } }, "kochi": { "$": 0, "aki": { "$": 0 }, "geisei": { "$": 0 }, "hidaka": { "$": 0 }, "higashitsuno": { "$": 0 }, "ino": { "$": 0 }, "kagami": { "$": 0 }, "kami": { "$": 0 }, "kitagawa": { "$": 0 }, "kochi": { "$": 0 }, "mihara": { "$": 0 }, "motoyama": { "$": 0 }, "muroto": { "$": 0 }, "nahari": { "$": 0 }, "nakamura": { "$": 0 }, "nankoku": { "$": 0 }, "nishitosa": { "$": 0 }, "niyodogawa": { "$": 0 }, "ochi": { "$": 0 }, "okawa": { "$": 0 }, "otoyo": { "$": 0 }, "otsuki": { "$": 0 }, "sakawa": { "$": 0 }, "sukumo": { "$": 0 }, "susaki": { "$": 0 }, "tosa": { "$": 0 }, "tosashimizu": { "$": 0 }, "toyo": { "$": 0 }, "tsuno": { "$": 0 }, "umaji": { "$": 0 }, "yasuda": { "$": 0 }, "yusuhara": { "$": 0 } }, "kumamoto": { "$": 0, "amakusa": { "$": 0 }, "arao": { "$": 0 }, "aso": { "$": 0 }, "choyo": { "$": 0 }, "gyokuto": { "$": 0 }, "kamiamakusa": { "$": 0 }, "kikuchi": { "$": 0 }, "kumamoto": { "$": 0 }, "mashiki": { "$": 0 }, "mifune": { "$": 0 }, "minamata": { "$": 0 }, "minamioguni": { "$": 0 }, "nagasu": { "$": 0 }, "nishihara": { "$": 0 }, "oguni": { "$": 0 }, "ozu": { "$": 0 }, "sumoto": { "$": 0 }, "takamori": { "$": 0 }, "uki": { "$": 0 }, "uto": { "$": 0 }, "yamaga": { "$": 0 }, "yamato": { "$": 0 }, "yatsushiro": { "$": 0 } }, "kyoto": { "$": 0, "ayabe": { "$": 0 }, "fukuchiyama": { "$": 0 }, "higashiyama": { "$": 0 }, "ide": { "$": 0 }, "ine": { "$": 0 }, "joyo": { "$": 0 }, "kameoka": { "$": 0 }, "kamo": { "$": 0 }, "kita": { "$": 0 }, "kizu": { "$": 0 }, "kumiyama": { "$": 0 }, "kyotamba": { "$": 0 }, "kyotanabe": { "$": 0 }, "kyotango": { "$": 0 }, "maizuru": { "$": 0 }, "minami": { "$": 0 }, "minamiyamashiro": { "$": 0 }, "miyazu": { "$": 0 }, "muko": { "$": 0 }, "nagaokakyo": { "$": 0 }, "nakagyo": { "$": 0 }, "nantan": { "$": 0 }, "oyamazaki": { "$": 0 }, "sakyo": { "$": 0 }, "seika": { "$": 0 }, "tanabe": { "$": 0 }, "uji": { "$": 0 }, "ujitawara": { "$": 0 }, "wazuka": { "$": 0 }, "yamashina": { "$": 0 }, "yawata": { "$": 0 } }, "mie": { "$": 0, "asahi": { "$": 0 }, "inabe": { "$": 0 }, "ise": { "$": 0 }, "kameyama": { "$": 0 }, "kawagoe": { "$": 0 }, "kiho": { "$": 0 }, "kisosaki": { "$": 0 }, "kiwa": { "$": 0 }, "komono": { "$": 0 }, "kumano": { "$": 0 }, "kuwana": { "$": 0 }, "matsusaka": { "$": 0 }, "meiwa": { "$": 0 }, "mihama": { "$": 0 }, "minamiise": { "$": 0 }, "misugi": { "$": 0 }, "miyama": { "$": 0 }, "nabari": { "$": 0 }, "shima": { "$": 0 }, "suzuka": { "$": 0 }, "tado": { "$": 0 }, "taiki": { "$": 0 }, "taki": { "$": 0 }, "tamaki": { "$": 0 }, "toba": { "$": 0 }, "tsu": { "$": 0 }, "udono": { "$": 0 }, "ureshino": { "$": 0 }, "watarai": { "$": 0 }, "yokkaichi": { "$": 0 } }, "miyagi": { "$": 0, "furukawa": { "$": 0 }, "higashimatsushima": { "$": 0 }, "ishinomaki": { "$": 0 }, "iwanuma": { "$": 0 }, "kakuda": { "$": 0 }, "kami": { "$": 0 }, "kawasaki": { "$": 0 }, "marumori": { "$": 0 }, "matsushima": { "$": 0 }, "minamisanriku": { "$": 0 }, "misato": { "$": 0 }, "murata": { "$": 0 }, "natori": { "$": 0 }, "ogawara": { "$": 0 }, "ohira": { "$": 0 }, "onagawa": { "$": 0 }, "osaki": { "$": 0 }, "rifu": { "$": 0 }, "semine": { "$": 0 }, "shibata": { "$": 0 }, "shichikashuku": { "$": 0 }, "shikama": { "$": 0 }, "shiogama": { "$": 0 }, "shiroishi": { "$": 0 }, "tagajo": { "$": 0 }, "taiwa": { "$": 0 }, "tome": { "$": 0 }, "tomiya": { "$": 0 }, "wakuya": { "$": 0 }, "watari": { "$": 0 }, "yamamoto": { "$": 0 }, "zao": { "$": 0 } }, "miyazaki": { "$": 0, "aya": { "$": 0 }, "ebino": { "$": 0 }, "gokase": { "$": 0 }, "hyuga": { "$": 0 }, "kadogawa": { "$": 0 }, "kawaminami": { "$": 0 }, "kijo": { "$": 0 }, "kitagawa": { "$": 0 }, "kitakata": { "$": 0 }, "kitaura": { "$": 0 }, "kobayashi": { "$": 0 }, "kunitomi": { "$": 0 }, "kushima": { "$": 0 }, "mimata": { "$": 0 }, "miyakonojo": { "$": 0 }, "miyazaki": { "$": 0 }, "morotsuka": { "$": 0 }, "nichinan": { "$": 0 }, "nishimera": { "$": 0 }, "nobeoka": { "$": 0 }, "saito": { "$": 0 }, "shiiba": { "$": 0 }, "shintomi": { "$": 0 }, "takaharu": { "$": 0 }, "takanabe": { "$": 0 }, "takazaki": { "$": 0 }, "tsuno": { "$": 0 } }, "nagano": { "$": 0, "achi": { "$": 0 }, "agematsu": { "$": 0 }, "anan": { "$": 0 }, "aoki": { "$": 0 }, "asahi": { "$": 0 }, "azumino": { "$": 0 }, "chikuhoku": { "$": 0 }, "chikuma": { "$": 0 }, "chino": { "$": 0 }, "fujimi": { "$": 0 }, "hakuba": { "$": 0 }, "hara": { "$": 0 }, "hiraya": { "$": 0 }, "iida": { "$": 0 }, "iijima": { "$": 0 }, "iiyama": { "$": 0 }, "iizuna": { "$": 0 }, "ikeda": { "$": 0 }, "ikusaka": { "$": 0 }, "ina": { "$": 0 }, "karuizawa": { "$": 0 }, "kawakami": { "$": 0 }, "kiso": { "$": 0 }, "kisofukushima": { "$": 0 }, "kitaaiki": { "$": 0 }, "komagane": { "$": 0 }, "komoro": { "$": 0 }, "matsukawa": { "$": 0 }, "matsumoto": { "$": 0 }, "miasa": { "$": 0 }, "minamiaiki": { "$": 0 }, "minamimaki": { "$": 0 }, "minamiminowa": { "$": 0 }, "minowa": { "$": 0 }, "miyada": { "$": 0 }, "miyota": { "$": 0 }, "mochizuki": { "$": 0 }, "nagano": { "$": 0 }, "nagawa": { "$": 0 }, "nagiso": { "$": 0 }, "nakagawa": { "$": 0 }, "nakano": { "$": 0 }, "nozawaonsen": { "$": 0 }, "obuse": { "$": 0 }, "ogawa": { "$": 0 }, "okaya": { "$": 0 }, "omachi": { "$": 0 }, "omi": { "$": 0 }, "ookuwa": { "$": 0 }, "ooshika": { "$": 0 }, "otaki": { "$": 0 }, "otari": { "$": 0 }, "sakae": { "$": 0 }, "sakaki": { "$": 0 }, "saku": { "$": 0 }, "sakuho": { "$": 0 }, "shimosuwa": { "$": 0 }, "shinanomachi": { "$": 0 }, "shiojiri": { "$": 0 }, "suwa": { "$": 0 }, "suzaka": { "$": 0 }, "takagi": { "$": 0 }, "takamori": { "$": 0 }, "takayama": { "$": 0 }, "tateshina": { "$": 0 }, "tatsuno": { "$": 0 }, "togakushi": { "$": 0 }, "togura": { "$": 0 }, "tomi": { "$": 0 }, "ueda": { "$": 0 }, "wada": { "$": 0 }, "yamagata": { "$": 0 }, "yamanouchi": { "$": 0 }, "yasaka": { "$": 0 }, "yasuoka": { "$": 0 } }, "nagasaki": { "$": 0, "chijiwa": { "$": 0 }, "futsu": { "$": 0 }, "goto": { "$": 0 }, "hasami": { "$": 0 }, "hirado": { "$": 0 }, "iki": { "$": 0 }, "isahaya": { "$": 0 }, "kawatana": { "$": 0 }, "kuchinotsu": { "$": 0 }, "matsuura": { "$": 0 }, "nagasaki": { "$": 0 }, "obama": { "$": 0 }, "omura": { "$": 0 }, "oseto": { "$": 0 }, "saikai": { "$": 0 }, "sasebo": { "$": 0 }, "seihi": { "$": 0 }, "shimabara": { "$": 0 }, "shinkamigoto": { "$": 0 }, "togitsu": { "$": 0 }, "tsushima": { "$": 0 }, "unzen": { "$": 0 } }, "nara": { "$": 0, "ando": { "$": 0 }, "gose": { "$": 0 }, "heguri": { "$": 0 }, "higashiyoshino": { "$": 0 }, "ikaruga": { "$": 0 }, "ikoma": { "$": 0 }, "kamikitayama": { "$": 0 }, "kanmaki": { "$": 0 }, "kashiba": { "$": 0 }, "kashihara": { "$": 0 }, "katsuragi": { "$": 0 }, "kawai": { "$": 0 }, "kawakami": { "$": 0 }, "kawanishi": { "$": 0 }, "koryo": { "$": 0 }, "kurotaki": { "$": 0 }, "mitsue": { "$": 0 }, "miyake": { "$": 0 }, "nara": { "$": 0 }, "nosegawa": { "$": 0 }, "oji": { "$": 0 }, "ouda": { "$": 0 }, "oyodo": { "$": 0 }, "sakurai": { "$": 0 }, "sango": { "$": 0 }, "shimoichi": { "$": 0 }, "shimokitayama": { "$": 0 }, "shinjo": { "$": 0 }, "soni": { "$": 0 }, "takatori": { "$": 0 }, "tawaramoto": { "$": 0 }, "tenkawa": { "$": 0 }, "tenri": { "$": 0 }, "uda": { "$": 0 }, "yamatokoriyama": { "$": 0 }, "yamatotakada": { "$": 0 }, "yamazoe": { "$": 0 }, "yoshino": { "$": 0 } }, "niigata": { "$": 0, "aga": { "$": 0 }, "agano": { "$": 0 }, "gosen": { "$": 0 }, "itoigawa": { "$": 0 }, "izumozaki": { "$": 0 }, "joetsu": { "$": 0 }, "kamo": { "$": 0 }, "kariwa": { "$": 0 }, "kashiwazaki": { "$": 0 }, "minamiuonuma": { "$": 0 }, "mitsuke": { "$": 0 }, "muika": { "$": 0 }, "murakami": { "$": 0 }, "myoko": { "$": 0 }, "nagaoka": { "$": 0 }, "niigata": { "$": 0 }, "ojiya": { "$": 0 }, "omi": { "$": 0 }, "sado": { "$": 0 }, "sanjo": { "$": 0 }, "seiro": { "$": 0 }, "seirou": { "$": 0 }, "sekikawa": { "$": 0 }, "shibata": { "$": 0 }, "tagami": { "$": 0 }, "tainai": { "$": 0 }, "tochio": { "$": 0 }, "tokamachi": { "$": 0 }, "tsubame": { "$": 0 }, "tsunan": { "$": 0 }, "uonuma": { "$": 0 }, "yahiko": { "$": 0 }, "yoita": { "$": 0 }, "yuzawa": { "$": 0 } }, "oita": { "$": 0, "beppu": { "$": 0 }, "bungoono": { "$": 0 }, "bungotakada": { "$": 0 }, "hasama": { "$": 0 }, "hiji": { "$": 0 }, "himeshima": { "$": 0 }, "hita": { "$": 0 }, "kamitsue": { "$": 0 }, "kokonoe": { "$": 0 }, "kuju": { "$": 0 }, "kunisaki": { "$": 0 }, "kusu": { "$": 0 }, "oita": { "$": 0 }, "saiki": { "$": 0 }, "taketa": { "$": 0 }, "tsukumi": { "$": 0 }, "usa": { "$": 0 }, "usuki": { "$": 0 }, "yufu": { "$": 0 } }, "okayama": { "$": 0, "akaiwa": { "$": 0 }, "asakuchi": { "$": 0 }, "bizen": { "$": 0 }, "hayashima": { "$": 0 }, "ibara": { "$": 0 }, "kagamino": { "$": 0 }, "kasaoka": { "$": 0 }, "kibichuo": { "$": 0 }, "kumenan": { "$": 0 }, "kurashiki": { "$": 0 }, "maniwa": { "$": 0 }, "misaki": { "$": 0 }, "nagi": { "$": 0 }, "niimi": { "$": 0 }, "nishiawakura": { "$": 0 }, "okayama": { "$": 0 }, "satosho": { "$": 0 }, "setouchi": { "$": 0 }, "shinjo": { "$": 0 }, "shoo": { "$": 0 }, "soja": { "$": 0 }, "takahashi": { "$": 0 }, "tamano": { "$": 0 }, "tsuyama": { "$": 0 }, "wake": { "$": 0 }, "yakage": { "$": 0 } }, "okinawa": { "$": 0, "aguni": { "$": 0 }, "ginowan": { "$": 0 }, "ginoza": { "$": 0 }, "gushikami": { "$": 0 }, "haebaru": { "$": 0 }, "higashi": { "$": 0 }, "hirara": { "$": 0 }, "iheya": { "$": 0 }, "ishigaki": { "$": 0 }, "ishikawa": { "$": 0 }, "itoman": { "$": 0 }, "izena": { "$": 0 }, "kadena": { "$": 0 }, "kin": { "$": 0 }, "kitadaito": { "$": 0 }, "kitanakagusuku": { "$": 0 }, "kumejima": { "$": 0 }, "kunigami": { "$": 0 }, "minamidaito": { "$": 0 }, "motobu": { "$": 0 }, "nago": { "$": 0 }, "naha": { "$": 0 }, "nakagusuku": { "$": 0 }, "nakijin": { "$": 0 }, "nanjo": { "$": 0 }, "nishihara": { "$": 0 }, "ogimi": { "$": 0 }, "okinawa": { "$": 0 }, "onna": { "$": 0 }, "shimoji": { "$": 0 }, "taketomi": { "$": 0 }, "tarama": { "$": 0 }, "tokashiki": { "$": 0 }, "tomigusuku": { "$": 0 }, "tonaki": { "$": 0 }, "urasoe": { "$": 0 }, "uruma": { "$": 0 }, "yaese": { "$": 0 }, "yomitan": { "$": 0 }, "yonabaru": { "$": 0 }, "yonaguni": { "$": 0 }, "zamami": { "$": 0 } }, "osaka": { "$": 0, "abeno": { "$": 0 }, "chihayaakasaka": { "$": 0 }, "chuo": { "$": 0 }, "daito": { "$": 0 }, "fujiidera": { "$": 0 }, "habikino": { "$": 0 }, "hannan": { "$": 0 }, "higashiosaka": { "$": 0 }, "higashisumiyoshi": { "$": 0 }, "higashiyodogawa": { "$": 0 }, "hirakata": { "$": 0 }, "ibaraki": { "$": 0 }, "ikeda": { "$": 0 }, "izumi": { "$": 0 }, "izumiotsu": { "$": 0 }, "izumisano": { "$": 0 }, "kadoma": { "$": 0 }, "kaizuka": { "$": 0 }, "kanan": { "$": 0 }, "kashiwara": { "$": 0 }, "katano": { "$": 0 }, "kawachinagano": { "$": 0 }, "kishiwada": { "$": 0 }, "kita": { "$": 0 }, "kumatori": { "$": 0 }, "matsubara": { "$": 0 }, "minato": { "$": 0 }, "minoh": { "$": 0 }, "misaki": { "$": 0 }, "moriguchi": { "$": 0 }, "neyagawa": { "$": 0 }, "nishi": { "$": 0 }, "nose": { "$": 0 }, "osakasayama": { "$": 0 }, "sakai": { "$": 0 }, "sayama": { "$": 0 }, "sennan": { "$": 0 }, "settsu": { "$": 0 }, "shijonawate": { "$": 0 }, "shimamoto": { "$": 0 }, "suita": { "$": 0 }, "tadaoka": { "$": 0 }, "taishi": { "$": 0 }, "tajiri": { "$": 0 }, "takaishi": { "$": 0 }, "takatsuki": { "$": 0 }, "tondabayashi": { "$": 0 }, "toyonaka": { "$": 0 }, "toyono": { "$": 0 }, "yao": { "$": 0 } }, "saga": { "$": 0, "ariake": { "$": 0 }, "arita": { "$": 0 }, "fukudomi": { "$": 0 }, "genkai": { "$": 0 }, "hamatama": { "$": 0 }, "hizen": { "$": 0 }, "imari": { "$": 0 }, "kamimine": { "$": 0 }, "kanzaki": { "$": 0 }, "karatsu": { "$": 0 }, "kashima": { "$": 0 }, "kitagata": { "$": 0 }, "kitahata": { "$": 0 }, "kiyama": { "$": 0 }, "kouhoku": { "$": 0 }, "kyuragi": { "$": 0 }, "nishiarita": { "$": 0 }, "ogi": { "$": 0 }, "omachi": { "$": 0 }, "ouchi": { "$": 0 }, "saga": { "$": 0 }, "shiroishi": { "$": 0 }, "taku": { "$": 0 }, "tara": { "$": 0 }, "tosu": { "$": 0 }, "yoshinogari": { "$": 0 } }, "saitama": { "$": 0, "arakawa": { "$": 0 }, "asaka": { "$": 0 }, "chichibu": { "$": 0 }, "fujimi": { "$": 0 }, "fujimino": { "$": 0 }, "fukaya": { "$": 0 }, "hanno": { "$": 0 }, "hanyu": { "$": 0 }, "hasuda": { "$": 0 }, "hatogaya": { "$": 0 }, "hatoyama": { "$": 0 }, "hidaka": { "$": 0 }, "higashichichibu": { "$": 0 }, "higashimatsuyama": { "$": 0 }, "honjo": { "$": 0 }, "ina": { "$": 0 }, "iruma": { "$": 0 }, "iwatsuki": { "$": 0 }, "kamiizumi": { "$": 0 }, "kamikawa": { "$": 0 }, "kamisato": { "$": 0 }, "kasukabe": { "$": 0 }, "kawagoe": { "$": 0 }, "kawaguchi": { "$": 0 }, "kawajima": { "$": 0 }, "kazo": { "$": 0 }, "kitamoto": { "$": 0 }, "koshigaya": { "$": 0 }, "kounosu": { "$": 0 }, "kuki": { "$": 0 }, "kumagaya": { "$": 0 }, "matsubushi": { "$": 0 }, "minano": { "$": 0 }, "misato": { "$": 0 }, "miyashiro": { "$": 0 }, "miyoshi": { "$": 0 }, "moroyama": { "$": 0 }, "nagatoro": { "$": 0 }, "namegawa": { "$": 0 }, "niiza": { "$": 0 }, "ogano": { "$": 0 }, "ogawa": { "$": 0 }, "ogose": { "$": 0 }, "okegawa": { "$": 0 }, "omiya": { "$": 0 }, "otaki": { "$": 0 }, "ranzan": { "$": 0 }, "ryokami": { "$": 0 }, "saitama": { "$": 0 }, "sakado": { "$": 0 }, "satte": { "$": 0 }, "sayama": { "$": 0 }, "shiki": { "$": 0 }, "shiraoka": { "$": 0 }, "soka": { "$": 0 }, "sugito": { "$": 0 }, "toda": { "$": 0 }, "tokigawa": { "$": 0 }, "tokorozawa": { "$": 0 }, "tsurugashima": { "$": 0 }, "urawa": { "$": 0 }, "warabi": { "$": 0 }, "yashio": { "$": 0 }, "yokoze": { "$": 0 }, "yono": { "$": 0 }, "yorii": { "$": 0 }, "yoshida": { "$": 0 }, "yoshikawa": { "$": 0 }, "yoshimi": { "$": 0 } }, "shiga": { "$": 0, "aisho": { "$": 0 }, "gamo": { "$": 0 }, "higashiomi": { "$": 0 }, "hikone": { "$": 0 }, "koka": { "$": 0 }, "konan": { "$": 0 }, "kosei": { "$": 0 }, "koto": { "$": 0 }, "kusatsu": { "$": 0 }, "maibara": { "$": 0 }, "moriyama": { "$": 0 }, "nagahama": { "$": 0 }, "nishiazai": { "$": 0 }, "notogawa": { "$": 0 }, "omihachiman": { "$": 0 }, "otsu": { "$": 0 }, "ritto": { "$": 0 }, "ryuoh": { "$": 0 }, "takashima": { "$": 0 }, "takatsuki": { "$": 0 }, "torahime": { "$": 0 }, "toyosato": { "$": 0 }, "yasu": { "$": 0 } }, "shimane": { "$": 0, "akagi": { "$": 0 }, "ama": { "$": 0 }, "gotsu": { "$": 0 }, "hamada": { "$": 0 }, "higashiizumo": { "$": 0 }, "hikawa": { "$": 0 }, "hikimi": { "$": 0 }, "izumo": { "$": 0 }, "kakinoki": { "$": 0 }, "masuda": { "$": 0 }, "matsue": { "$": 0 }, "misato": { "$": 0 }, "nishinoshima": { "$": 0 }, "ohda": { "$": 0 }, "okinoshima": { "$": 0 }, "okuizumo": { "$": 0 }, "shimane": { "$": 0 }, "tamayu": { "$": 0 }, "tsuwano": { "$": 0 }, "unnan": { "$": 0 }, "yakumo": { "$": 0 }, "yasugi": { "$": 0 }, "yatsuka": { "$": 0 } }, "shizuoka": { "$": 0, "arai": { "$": 0 }, "atami": { "$": 0 }, "fuji": { "$": 0 }, "fujieda": { "$": 0 }, "fujikawa": { "$": 0 }, "fujinomiya": { "$": 0 }, "fukuroi": { "$": 0 }, "gotemba": { "$": 0 }, "haibara": { "$": 0 }, "hamamatsu": { "$": 0 }, "higashiizu": { "$": 0 }, "ito": { "$": 0 }, "iwata": { "$": 0 }, "izu": { "$": 0 }, "izunokuni": { "$": 0 }, "kakegawa": { "$": 0 }, "kannami": { "$": 0 }, "kawanehon": { "$": 0 }, "kawazu": { "$": 0 }, "kikugawa": { "$": 0 }, "kosai": { "$": 0 }, "makinohara": { "$": 0 }, "matsuzaki": { "$": 0 }, "minamiizu": { "$": 0 }, "mishima": { "$": 0 }, "morimachi": { "$": 0 }, "nishiizu": { "$": 0 }, "numazu": { "$": 0 }, "omaezaki": { "$": 0 }, "shimada": { "$": 0 }, "shimizu": { "$": 0 }, "shimoda": { "$": 0 }, "shizuoka": { "$": 0 }, "susono": { "$": 0 }, "yaizu": { "$": 0 }, "yoshida": { "$": 0 } }, "tochigi": { "$": 0, "ashikaga": { "$": 0 }, "bato": { "$": 0 }, "haga": { "$": 0 }, "ichikai": { "$": 0 }, "iwafune": { "$": 0 }, "kaminokawa": { "$": 0 }, "kanuma": { "$": 0 }, "karasuyama": { "$": 0 }, "kuroiso": { "$": 0 }, "mashiko": { "$": 0 }, "mibu": { "$": 0 }, "moka": { "$": 0 }, "motegi": { "$": 0 }, "nasu": { "$": 0 }, "nasushiobara": { "$": 0 }, "nikko": { "$": 0 }, "nishikata": { "$": 0 }, "nogi": { "$": 0 }, "ohira": { "$": 0 }, "ohtawara": { "$": 0 }, "oyama": { "$": 0 }, "sakura": { "$": 0 }, "sano": { "$": 0 }, "shimotsuke": { "$": 0 }, "shioya": { "$": 0 }, "takanezawa": { "$": 0 }, "tochigi": { "$": 0 }, "tsuga": { "$": 0 }, "ujiie": { "$": 0 }, "utsunomiya": { "$": 0 }, "yaita": { "$": 0 } }, "tokushima": { "$": 0, "aizumi": { "$": 0 }, "anan": { "$": 0 }, "ichiba": { "$": 0 }, "itano": { "$": 0 }, "kainan": { "$": 0 }, "komatsushima": { "$": 0 }, "matsushige": { "$": 0 }, "mima": { "$": 0 }, "minami": { "$": 0 }, "miyoshi": { "$": 0 }, "mugi": { "$": 0 }, "nakagawa": { "$": 0 }, "naruto": { "$": 0 }, "sanagochi": { "$": 0 }, "shishikui": { "$": 0 }, "tokushima": { "$": 0 }, "wajiki": { "$": 0 } }, "tokyo": { "$": 0, "adachi": { "$": 0 }, "akiruno": { "$": 0 }, "akishima": { "$": 0 }, "aogashima": { "$": 0 }, "arakawa": { "$": 0 }, "bunkyo": { "$": 0 }, "chiyoda": { "$": 0 }, "chofu": { "$": 0 }, "chuo": { "$": 0 }, "edogawa": { "$": 0 }, "fuchu": { "$": 0 }, "fussa": { "$": 0 }, "hachijo": { "$": 0 }, "hachioji": { "$": 0 }, "hamura": { "$": 0 }, "higashikurume": { "$": 0 }, "higashimurayama": { "$": 0 }, "higashiyamato": { "$": 0 }, "hino": { "$": 0 }, "hinode": { "$": 0 }, "hinohara": { "$": 0 }, "inagi": { "$": 0 }, "itabashi": { "$": 0 }, "katsushika": { "$": 0 }, "kita": { "$": 0 }, "kiyose": { "$": 0 }, "kodaira": { "$": 0 }, "koganei": { "$": 0 }, "kokubunji": { "$": 0 }, "komae": { "$": 0 }, "koto": { "$": 0 }, "kouzushima": { "$": 0 }, "kunitachi": { "$": 0 }, "machida": { "$": 0 }, "meguro": { "$": 0 }, "minato": { "$": 0 }, "mitaka": { "$": 0 }, "mizuho": { "$": 0 }, "musashimurayama": { "$": 0 }, "musashino": { "$": 0 }, "nakano": { "$": 0 }, "nerima": { "$": 0 }, "ogasawara": { "$": 0 }, "okutama": { "$": 0 }, "ome": { "$": 0 }, "oshima": { "$": 0 }, "ota": { "$": 0 }, "setagaya": { "$": 0 }, "shibuya": { "$": 0 }, "shinagawa": { "$": 0 }, "shinjuku": { "$": 0 }, "suginami": { "$": 0 }, "sumida": { "$": 0 }, "tachikawa": { "$": 0 }, "taito": { "$": 0 }, "tama": { "$": 0 }, "toshima": { "$": 0 } }, "tottori": { "$": 0, "chizu": { "$": 0 }, "hino": { "$": 0 }, "kawahara": { "$": 0 }, "koge": { "$": 0 }, "kotoura": { "$": 0 }, "misasa": { "$": 0 }, "nanbu": { "$": 0 }, "nichinan": { "$": 0 }, "sakaiminato": { "$": 0 }, "tottori": { "$": 0 }, "wakasa": { "$": 0 }, "yazu": { "$": 0 }, "yonago": { "$": 0 } }, "toyama": { "$": 0, "asahi": { "$": 0 }, "fuchu": { "$": 0 }, "fukumitsu": { "$": 0 }, "funahashi": { "$": 0 }, "himi": { "$": 0 }, "imizu": { "$": 0 }, "inami": { "$": 0 }, "johana": { "$": 0 }, "kamiichi": { "$": 0 }, "kurobe": { "$": 0 }, "nakaniikawa": { "$": 0 }, "namerikawa": { "$": 0 }, "nanto": { "$": 0 }, "nyuzen": { "$": 0 }, "oyabe": { "$": 0 }, "taira": { "$": 0 }, "takaoka": { "$": 0 }, "tateyama": { "$": 0 }, "toga": { "$": 0 }, "tonami": { "$": 0 }, "toyama": { "$": 0 }, "unazuki": { "$": 0 }, "uozu": { "$": 0 }, "yamada": { "$": 0 } }, "wakayama": { "$": 0, "arida": { "$": 0 }, "aridagawa": { "$": 0 }, "gobo": { "$": 0 }, "hashimoto": { "$": 0 }, "hidaka": { "$": 0 }, "hirogawa": { "$": 0 }, "inami": { "$": 0 }, "iwade": { "$": 0 }, "kainan": { "$": 0 }, "kamitonda": { "$": 0 }, "katsuragi": { "$": 0 }, "kimino": { "$": 0 }, "kinokawa": { "$": 0 }, "kitayama": { "$": 0 }, "koya": { "$": 0 }, "koza": { "$": 0 }, "kozagawa": { "$": 0 }, "kudoyama": { "$": 0 }, "kushimoto": { "$": 0 }, "mihama": { "$": 0 }, "misato": { "$": 0 }, "nachikatsuura": { "$": 0 }, "shingu": { "$": 0 }, "shirahama": { "$": 0 }, "taiji": { "$": 0 }, "tanabe": { "$": 0 }, "wakayama": { "$": 0 }, "yuasa": { "$": 0 }, "yura": { "$": 0 } }, "yamagata": { "$": 0, "asahi": { "$": 0 }, "funagata": { "$": 0 }, "higashine": { "$": 0 }, "iide": { "$": 0 }, "kahoku": { "$": 0 }, "kaminoyama": { "$": 0 }, "kaneyama": { "$": 0 }, "kawanishi": { "$": 0 }, "mamurogawa": { "$": 0 }, "mikawa": { "$": 0 }, "murayama": { "$": 0 }, "nagai": { "$": 0 }, "nakayama": { "$": 0 }, "nanyo": { "$": 0 }, "nishikawa": { "$": 0 }, "obanazawa": { "$": 0 }, "oe": { "$": 0 }, "oguni": { "$": 0 }, "ohkura": { "$": 0 }, "oishida": { "$": 0 }, "sagae": { "$": 0 }, "sakata": { "$": 0 }, "sakegawa": { "$": 0 }, "shinjo": { "$": 0 }, "shirataka": { "$": 0 }, "shonai": { "$": 0 }, "takahata": { "$": 0 }, "tendo": { "$": 0 }, "tozawa": { "$": 0 }, "tsuruoka": { "$": 0 }, "yamagata": { "$": 0 }, "yamanobe": { "$": 0 }, "yonezawa": { "$": 0 }, "yuza": { "$": 0 } }, "yamaguchi": { "$": 0, "abu": { "$": 0 }, "hagi": { "$": 0 }, "hikari": { "$": 0 }, "hofu": { "$": 0 }, "iwakuni": { "$": 0 }, "kudamatsu": { "$": 0 }, "mitou": { "$": 0 }, "nagato": { "$": 0 }, "oshima": { "$": 0 }, "shimonoseki": { "$": 0 }, "shunan": { "$": 0 }, "tabuse": { "$": 0 }, "tokuyama": { "$": 0 }, "toyota": { "$": 0 }, "ube": { "$": 0 }, "yuu": { "$": 0 } }, "yamanashi": { "$": 0, "chuo": { "$": 0 }, "doshi": { "$": 0 }, "fuefuki": { "$": 0 }, "fujikawa": { "$": 0 }, "fujikawaguchiko": { "$": 0 }, "fujiyoshida": { "$": 0 }, "hayakawa": { "$": 0 }, "hokuto": { "$": 0 }, "ichikawamisato": { "$": 0 }, "kai": { "$": 0 }, "kofu": { "$": 0 }, "koshu": { "$": 0 }, "kosuge": { "$": 0 }, "minami-alps": { "$": 0 }, "minobu": { "$": 0 }, "nakamichi": { "$": 0 }, "nanbu": { "$": 0 }, "narusawa": { "$": 0 }, "nirasaki": { "$": 0 }, "nishikatsura": { "$": 0 }, "oshino": { "$": 0 }, "otsuki": { "$": 0 }, "showa": { "$": 0 }, "tabayama": { "$": 0 }, "tsuru": { "$": 0 }, "uenohara": { "$": 0 }, "yamanakako": { "$": 0 }, "yamanashi": { "$": 0 } }, "xn--4pvxs": { "$": 0 }, "xn--vgu402c": { "$": 0 }, "xn--c3s14m": { "$": 0 }, "xn--f6qx53a": { "$": 0 }, "xn--8pvr4u": { "$": 0 }, "xn--uist22h": { "$": 0 }, "xn--djrs72d6uy": { "$": 0 }, "xn--mkru45i": { "$": 0 }, "xn--0trq7p7nn": { "$": 0 }, "xn--8ltr62k": { "$": 0 }, "xn--2m4a15e": { "$": 0 }, "xn--efvn9s": { "$": 0 }, "xn--32vp30h": { "$": 0 }, "xn--4it797k": { "$": 0 }, "xn--1lqs71d": { "$": 0 }, "xn--5rtp49c": { "$": 0 }, "xn--5js045d": { "$": 0 }, "xn--ehqz56n": { "$": 0 }, "xn--1lqs03n": { "$": 0 }, "xn--qqqt11m": { "$": 0 }, "xn--kbrq7o": { "$": 0 }, "xn--pssu33l": { "$": 0 }, "xn--ntsq17g": { "$": 0 }, "xn--uisz3g": { "$": 0 }, "xn--6btw5a": { "$": 0 }, "xn--1ctwo": { "$": 0 }, "xn--6orx2r": { "$": 0 }, "xn--rht61e": { "$": 0 }, "xn--rht27z": { "$": 0 }, "xn--djty4k": { "$": 0 }, "xn--nit225k": { "$": 0 }, "xn--rht3d": { "$": 0 }, "xn--klty5x": { "$": 0 }, "xn--kltx9a": { "$": 0 }, "xn--kltp7d": { "$": 0 }, "xn--uuwu58a": { "$": 0 }, "xn--zbx025d": { "$": 0 }, "xn--ntso0iqx3a": { "$": 0 }, "xn--elqq16h": { "$": 0 }, "xn--4it168d": { "$": 0 }, "xn--klt787d": { "$": 0 }, "xn--rny31h": { "$": 0 }, "xn--7t0a264c": { "$": 0 }, "xn--5rtq34k": { "$": 0 }, "xn--k7yn95e": { "$": 0 }, "xn--tor131o": { "$": 0 }, "xn--d5qv7z876c": { "$": 0 }, "kawasaki": { "*": { "$": 0 } }, "kitakyushu": { "*": { "$": 0 } }, "kobe": { "*": { "$": 0 } }, "nagoya": { "*": { "$": 0 } }, "sapporo": { "*": { "$": 0 } }, "sendai": { "*": { "$": 0 } }, "yokohama": { "*": { "$": 0 } }, "blogspot": { "$": 0 } }, "ke": { "*": { "$": 0 }, "co": { "blogspot": { "$": 0 } } }, "kg": { "$": 0, "org": { "$": 0 }, "net": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 } }, "kh": { "*": { "$": 0 } }, "ki": { "$": 0, "edu": { "$": 0 }, "biz": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "info": { "$": 0 }, "com": { "$": 0 } }, "km": { "$": 0, "org": { "$": 0 }, "nom": { "$": 0 }, "gov": { "$": 0 }, "prd": { "$": 0 }, "tm": { "$": 0 }, "edu": { "$": 0 }, "mil": { "$": 0 }, "ass": { "$": 0 }, "com": { "$": 0 }, "coop": { "$": 0 }, "asso": { "$": 0 }, "presse": { "$": 0 }, "medecin": { "$": 0 }, "notaires": { "$": 0 }, "pharmaciens": { "$": 0 }, "veterinaire": { "$": 0 }, "gouv": { "$": 0 } }, "kn": { "$": 0, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 } }, "kp": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "rep": { "$": 0 }, "tra": { "$": 0 } }, "kr": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0 }, "es": { "$": 0 }, "go": { "$": 0 }, "hs": { "$": 0 }, "kg": { "$": 0 }, "mil": { "$": 0 }, "ms": { "$": 0 }, "ne": { "$": 0 }, "or": { "$": 0 }, "pe": { "$": 0 }, "re": { "$": 0 }, "sc": { "$": 0 }, "busan": { "$": 0 }, "chungbuk": { "$": 0 }, "chungnam": { "$": 0 }, "daegu": { "$": 0 }, "daejeon": { "$": 0 }, "gangwon": { "$": 0 }, "gwangju": { "$": 0 }, "gyeongbuk": { "$": 0 }, "gyeonggi": { "$": 0 }, "gyeongnam": { "$": 0 }, "incheon": { "$": 0 }, "jeju": { "$": 0 }, "jeonbuk": { "$": 0 }, "jeonnam": { "$": 0 }, "seoul": { "$": 0 }, "ulsan": { "$": 0 }, "blogspot": { "$": 0 } }, "kw": { "*": { "$": 0 } }, "ky": { "$": 0, "edu": { "$": 0 }, "gov": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 } }, "kz": { "$": 0, "org": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "com": { "$": 0 }, "nym": { "$": 0 } }, "la": { "$": 0, "int": { "$": 0 }, "net": { "$": 0 }, "info": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "per": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "bnr": { "$": 0 }, "c": { "$": 0 }, "nym": { "$": 0 } }, "lb": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "lc": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "co": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "oy": { "$": 0 } }, "li": { "$": 0, "blogspot": { "$": 0 }, "nom": { "$": 0 }, "nym": { "$": 0 } }, "lk": { "$": 0, "gov": { "$": 0 }, "sch": { "$": 0 }, "net": { "$": 0 }, "int": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "ngo": { "$": 0 }, "soc": { "$": 0 }, "web": { "$": 0 }, "ltd": { "$": 0 }, "assn": { "$": 0 }, "grp": { "$": 0 }, "hotel": { "$": 0 }, "ac": { "$": 0 } }, "lr": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 } }, "ls": { "$": 0, "co": { "$": 0 }, "org": { "$": 0 } }, "lt": { "$": 0, "gov": { "$": 0 }, "blogspot": { "$": 0 }, "nym": { "$": 0 } }, "lu": { "$": 0, "blogspot": { "$": 0 }, "nym": { "$": 0 } }, "lv": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "mil": { "$": 0 }, "id": { "$": 0 }, "net": { "$": 0 }, "asn": { "$": 0 }, "conf": { "$": 0 } }, "ly": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "gov": { "$": 0 }, "plc": { "$": 0 }, "edu": { "$": 0 }, "sch": { "$": 0 }, "med": { "$": 0 }, "org": { "$": 0 }, "id": { "$": 0 } }, "ma": { "$": 0, "co": { "$": 0 }, "net": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "ac": { "$": 0 }, "press": { "$": 0 } }, "mc": { "$": 0, "tm": { "$": 0 }, "asso": { "$": 0 } }, "md": { "$": 0, "blogspot": { "$": 0 } }, "me": { "$": 0, "co": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "ac": { "$": 0 }, "gov": { "$": 0 }, "its": { "$": 0 }, "priv": { "$": 0 }, "c66": { "$": 0 }, "daplie": { "$": 0, "localhost": { "$": 0 } }, "filegear": { "$": 0 }, "brasilia": { "$": 0 }, "ddns": { "$": 0 }, "dnsfor": { "$": 0 }, "hopto": { "$": 0 }, "loginto": { "$": 0 }, "noip": { "$": 0 }, "webhop": { "$": 0 }, "nym": { "$": 0 }, "diskstation": { "$": 0 }, "dscloud": { "$": 0 }, "i234": { "$": 0 }, "myds": { "$": 0 }, "synology": { "$": 0 }, "wedeploy": { "$": 0 }, "yombo": { "$": 0 } }, "mg": { "$": 0, "org": { "$": 0 }, "nom": { "$": 0 }, "gov": { "$": 0 }, "prd": { "$": 0 }, "tm": { "$": 0 }, "edu": { "$": 0 }, "mil": { "$": 0 }, "com": { "$": 0 }, "co": { "$": 0 } }, "mh": { "$": 0 }, "mil": { "$": 0 }, "mk": { "$": 0, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "inf": { "$": 0 }, "name": { "$": 0 }, "blogspot": { "$": 0 }, "nom": { "$": 0 } }, "ml": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gouv": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "presse": { "$": 0 } }, "mm": { "*": { "$": 0 } }, "mn": { "$": 0, "gov": { "$": 0 }, "edu": { "$": 0 }, "org": { "$": 0 }, "nyc": { "$": 0 } }, "mo": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 } }, "mobi": { "$": 0, "dscloud": { "$": 0 } }, "mp": { "$": 0 }, "mq": { "$": 0 }, "mr": { "$": 0, "gov": { "$": 0 }, "blogspot": { "$": 0 } }, "ms": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "mt": { "$": 0, "com": { "$": 0, "blogspot": { "$": 0 } }, "edu": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "mu": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "ac": { "$": 0 }, "co": { "$": 0 }, "or": { "$": 0 } }, "museum": { "$": 0, "academy": { "$": 0 }, "agriculture": { "$": 0 }, "air": { "$": 0 }, "airguard": { "$": 0 }, "alabama": { "$": 0 }, "alaska": { "$": 0 }, "amber": { "$": 0 }, "ambulance": { "$": 0 }, "american": { "$": 0 }, "americana": { "$": 0 }, "americanantiques": { "$": 0 }, "americanart": { "$": 0 }, "amsterdam": { "$": 0 }, "and": { "$": 0 }, "annefrank": { "$": 0 }, "anthro": { "$": 0 }, "anthropology": { "$": 0 }, "antiques": { "$": 0 }, "aquarium": { "$": 0 }, "arboretum": { "$": 0 }, "archaeological": { "$": 0 }, "archaeology": { "$": 0 }, "architecture": { "$": 0 }, "art": { "$": 0 }, "artanddesign": { "$": 0 }, "artcenter": { "$": 0 }, "artdeco": { "$": 0 }, "arteducation": { "$": 0 }, "artgallery": { "$": 0 }, "arts": { "$": 0 }, "artsandcrafts": { "$": 0 }, "asmatart": { "$": 0 }, "assassination": { "$": 0 }, "assisi": { "$": 0 }, "association": { "$": 0 }, "astronomy": { "$": 0 }, "atlanta": { "$": 0 }, "austin": { "$": 0 }, "australia": { "$": 0 }, "automotive": { "$": 0 }, "aviation": { "$": 0 }, "axis": { "$": 0 }, "badajoz": { "$": 0 }, "baghdad": { "$": 0 }, "bahn": { "$": 0 }, "bale": { "$": 0 }, "baltimore": { "$": 0 }, "barcelona": { "$": 0 }, "baseball": { "$": 0 }, "basel": { "$": 0 }, "baths": { "$": 0 }, "bauern": { "$": 0 }, "beauxarts": { "$": 0 }, "beeldengeluid": { "$": 0 }, "bellevue": { "$": 0 }, "bergbau": { "$": 0 }, "berkeley": { "$": 0 }, "berlin": { "$": 0 }, "bern": { "$": 0 }, "bible": { "$": 0 }, "bilbao": { "$": 0 }, "bill": { "$": 0 }, "birdart": { "$": 0 }, "birthplace": { "$": 0 }, "bonn": { "$": 0 }, "boston": { "$": 0 }, "botanical": { "$": 0 }, "botanicalgarden": { "$": 0 }, "botanicgarden": { "$": 0 }, "botany": { "$": 0 }, "brandywinevalley": { "$": 0 }, "brasil": { "$": 0 }, "bristol": { "$": 0 }, "british": { "$": 0 }, "britishcolumbia": { "$": 0 }, "broadcast": { "$": 0 }, "brunel": { "$": 0 }, "brussel": { "$": 0 }, "brussels": { "$": 0 }, "bruxelles": { "$": 0 }, "building": { "$": 0 }, "burghof": { "$": 0 }, "bus": { "$": 0 }, "bushey": { "$": 0 }, "cadaques": { "$": 0 }, "california": { "$": 0 }, "cambridge": { "$": 0 }, "can": { "$": 0 }, "canada": { "$": 0 }, "capebreton": { "$": 0 }, "carrier": { "$": 0 }, "cartoonart": { "$": 0 }, "casadelamoneda": { "$": 0 }, "castle": { "$": 0 }, "castres": { "$": 0 }, "celtic": { "$": 0 }, "center": { "$": 0 }, "chattanooga": { "$": 0 }, "cheltenham": { "$": 0 }, "chesapeakebay": { "$": 0 }, "chicago": { "$": 0 }, "children": { "$": 0 }, "childrens": { "$": 0 }, "childrensgarden": { "$": 0 }, "chiropractic": { "$": 0 }, "chocolate": { "$": 0 }, "christiansburg": { "$": 0 }, "cincinnati": { "$": 0 }, "cinema": { "$": 0 }, "circus": { "$": 0 }, "civilisation": { "$": 0 }, "civilization": { "$": 0 }, "civilwar": { "$": 0 }, "clinton": { "$": 0 }, "clock": { "$": 0 }, "coal": { "$": 0 }, "coastaldefence": { "$": 0 }, "cody": { "$": 0 }, "coldwar": { "$": 0 }, "collection": { "$": 0 }, "colonialwilliamsburg": { "$": 0 }, "coloradoplateau": { "$": 0 }, "columbia": { "$": 0 }, "columbus": { "$": 0 }, "communication": { "$": 0 }, "communications": { "$": 0 }, "community": { "$": 0 }, "computer": { "$": 0 }, "computerhistory": { "$": 0 }, "xn--comunicaes-v6a2o": { "$": 0 }, "contemporary": { "$": 0 }, "contemporaryart": { "$": 0 }, "convent": { "$": 0 }, "copenhagen": { "$": 0 }, "corporation": { "$": 0 }, "xn--correios-e-telecomunicaes-ghc29a": { "$": 0 }, "corvette": { "$": 0 }, "costume": { "$": 0 }, "countryestate": { "$": 0 }, "county": { "$": 0 }, "crafts": { "$": 0 }, "cranbrook": { "$": 0 }, "creation": { "$": 0 }, "cultural": { "$": 0 }, "culturalcenter": { "$": 0 }, "culture": { "$": 0 }, "cyber": { "$": 0 }, "cymru": { "$": 0 }, "dali": { "$": 0 }, "dallas": { "$": 0 }, "database": { "$": 0 }, "ddr": { "$": 0 }, "decorativearts": { "$": 0 }, "delaware": { "$": 0 }, "delmenhorst": { "$": 0 }, "denmark": { "$": 0 }, "depot": { "$": 0 }, "design": { "$": 0 }, "detroit": { "$": 0 }, "dinosaur": { "$": 0 }, "discovery": { "$": 0 }, "dolls": { "$": 0 }, "donostia": { "$": 0 }, "durham": { "$": 0 }, "eastafrica": { "$": 0 }, "eastcoast": { "$": 0 }, "education": { "$": 0 }, "educational": { "$": 0 }, "egyptian": { "$": 0 }, "eisenbahn": { "$": 0 }, "elburg": { "$": 0 }, "elvendrell": { "$": 0 }, "embroidery": { "$": 0 }, "encyclopedic": { "$": 0 }, "england": { "$": 0 }, "entomology": { "$": 0 }, "environment": { "$": 0 }, "environmentalconservation": { "$": 0 }, "epilepsy": { "$": 0 }, "essex": { "$": 0 }, "estate": { "$": 0 }, "ethnology": { "$": 0 }, "exeter": { "$": 0 }, "exhibition": { "$": 0 }, "family": { "$": 0 }, "farm": { "$": 0 }, "farmequipment": { "$": 0 }, "farmers": { "$": 0 }, "farmstead": { "$": 0 }, "field": { "$": 0 }, "figueres": { "$": 0 }, "filatelia": { "$": 0 }, "film": { "$": 0 }, "fineart": { "$": 0 }, "finearts": { "$": 0 }, "finland": { "$": 0 }, "flanders": { "$": 0 }, "florida": { "$": 0 }, "force": { "$": 0 }, "fortmissoula": { "$": 0 }, "fortworth": { "$": 0 }, "foundation": { "$": 0 }, "francaise": { "$": 0 }, "frankfurt": { "$": 0 }, "franziskaner": { "$": 0 }, "freemasonry": { "$": 0 }, "freiburg": { "$": 0 }, "fribourg": { "$": 0 }, "frog": { "$": 0 }, "fundacio": { "$": 0 }, "furniture": { "$": 0 }, "gallery": { "$": 0 }, "garden": { "$": 0 }, "gateway": { "$": 0 }, "geelvinck": { "$": 0 }, "gemological": { "$": 0 }, "geology": { "$": 0 }, "georgia": { "$": 0 }, "giessen": { "$": 0 }, "glas": { "$": 0 }, "glass": { "$": 0 }, "gorge": { "$": 0 }, "grandrapids": { "$": 0 }, "graz": { "$": 0 }, "guernsey": { "$": 0 }, "halloffame": { "$": 0 }, "hamburg": { "$": 0 }, "handson": { "$": 0 }, "harvestcelebration": { "$": 0 }, "hawaii": { "$": 0 }, "health": { "$": 0 }, "heimatunduhren": { "$": 0 }, "hellas": { "$": 0 }, "helsinki": { "$": 0 }, "hembygdsforbund": { "$": 0 }, "heritage": { "$": 0 }, "histoire": { "$": 0 }, "historical": { "$": 0 }, "historicalsociety": { "$": 0 }, "historichouses": { "$": 0 }, "historisch": { "$": 0 }, "historisches": { "$": 0 }, "history": { "$": 0 }, "historyofscience": { "$": 0 }, "horology": { "$": 0 }, "house": { "$": 0 }, "humanities": { "$": 0 }, "illustration": { "$": 0 }, "imageandsound": { "$": 0 }, "indian": { "$": 0 }, "indiana": { "$": 0 }, "indianapolis": { "$": 0 }, "indianmarket": { "$": 0 }, "intelligence": { "$": 0 }, "interactive": { "$": 0 }, "iraq": { "$": 0 }, "iron": { "$": 0 }, "isleofman": { "$": 0 }, "jamison": { "$": 0 }, "jefferson": { "$": 0 }, "jerusalem": { "$": 0 }, "jewelry": { "$": 0 }, "jewish": { "$": 0 }, "jewishart": { "$": 0 }, "jfk": { "$": 0 }, "journalism": { "$": 0 }, "judaica": { "$": 0 }, "judygarland": { "$": 0 }, "juedisches": { "$": 0 }, "juif": { "$": 0 }, "karate": { "$": 0 }, "karikatur": { "$": 0 }, "kids": { "$": 0 }, "koebenhavn": { "$": 0 }, "koeln": { "$": 0 }, "kunst": { "$": 0 }, "kunstsammlung": { "$": 0 }, "kunstunddesign": { "$": 0 }, "labor": { "$": 0 }, "labour": { "$": 0 }, "lajolla": { "$": 0 }, "lancashire": { "$": 0 }, "landes": { "$": 0 }, "lans": { "$": 0 }, "xn--lns-qla": { "$": 0 }, "larsson": { "$": 0 }, "lewismiller": { "$": 0 }, "lincoln": { "$": 0 }, "linz": { "$": 0 }, "living": { "$": 0 }, "livinghistory": { "$": 0 }, "localhistory": { "$": 0 }, "london": { "$": 0 }, "losangeles": { "$": 0 }, "louvre": { "$": 0 }, "loyalist": { "$": 0 }, "lucerne": { "$": 0 }, "luxembourg": { "$": 0 }, "luzern": { "$": 0 }, "mad": { "$": 0 }, "madrid": { "$": 0 }, "mallorca": { "$": 0 }, "manchester": { "$": 0 }, "mansion": { "$": 0 }, "mansions": { "$": 0 }, "manx": { "$": 0 }, "marburg": { "$": 0 }, "maritime": { "$": 0 }, "maritimo": { "$": 0 }, "maryland": { "$": 0 }, "marylhurst": { "$": 0 }, "media": { "$": 0 }, "medical": { "$": 0 }, "medizinhistorisches": { "$": 0 }, "meeres": { "$": 0 }, "memorial": { "$": 0 }, "mesaverde": { "$": 0 }, "michigan": { "$": 0 }, "midatlantic": { "$": 0 }, "military": { "$": 0 }, "mill": { "$": 0 }, "miners": { "$": 0 }, "mining": { "$": 0 }, "minnesota": { "$": 0 }, "missile": { "$": 0 }, "missoula": { "$": 0 }, "modern": { "$": 0 }, "moma": { "$": 0 }, "money": { "$": 0 }, "monmouth": { "$": 0 }, "monticello": { "$": 0 }, "montreal": { "$": 0 }, "moscow": { "$": 0 }, "motorcycle": { "$": 0 }, "muenchen": { "$": 0 }, "muenster": { "$": 0 }, "mulhouse": { "$": 0 }, "muncie": { "$": 0 }, "museet": { "$": 0 }, "museumcenter": { "$": 0 }, "museumvereniging": { "$": 0 }, "music": { "$": 0 }, "national": { "$": 0 }, "nationalfirearms": { "$": 0 }, "nationalheritage": { "$": 0 }, "nativeamerican": { "$": 0 }, "naturalhistory": { "$": 0 }, "naturalhistorymuseum": { "$": 0 }, "naturalsciences": { "$": 0 }, "nature": { "$": 0 }, "naturhistorisches": { "$": 0 }, "natuurwetenschappen": { "$": 0 }, "naumburg": { "$": 0 }, "naval": { "$": 0 }, "nebraska": { "$": 0 }, "neues": { "$": 0 }, "newhampshire": { "$": 0 }, "newjersey": { "$": 0 }, "newmexico": { "$": 0 }, "newport": { "$": 0 }, "newspaper": { "$": 0 }, "newyork": { "$": 0 }, "niepce": { "$": 0 }, "norfolk": { "$": 0 }, "north": { "$": 0 }, "nrw": { "$": 0 }, "nuernberg": { "$": 0 }, "nuremberg": { "$": 0 }, "nyc": { "$": 0 }, "nyny": { "$": 0 }, "oceanographic": { "$": 0 }, "oceanographique": { "$": 0 }, "omaha": { "$": 0 }, "online": { "$": 0 }, "ontario": { "$": 0 }, "openair": { "$": 0 }, "oregon": { "$": 0 }, "oregontrail": { "$": 0 }, "otago": { "$": 0 }, "oxford": { "$": 0 }, "pacific": { "$": 0 }, "paderborn": { "$": 0 }, "palace": { "$": 0 }, "paleo": { "$": 0 }, "palmsprings": { "$": 0 }, "panama": { "$": 0 }, "paris": { "$": 0 }, "pasadena": { "$": 0 }, "pharmacy": { "$": 0 }, "philadelphia": { "$": 0 }, "philadelphiaarea": { "$": 0 }, "philately": { "$": 0 }, "phoenix": { "$": 0 }, "photography": { "$": 0 }, "pilots": { "$": 0 }, "pittsburgh": { "$": 0 }, "planetarium": { "$": 0 }, "plantation": { "$": 0 }, "plants": { "$": 0 }, "plaza": { "$": 0 }, "portal": { "$": 0 }, "portland": { "$": 0 }, "portlligat": { "$": 0 }, "posts-and-telecommunications": { "$": 0 }, "preservation": { "$": 0 }, "presidio": { "$": 0 }, "press": { "$": 0 }, "project": { "$": 0 }, "public": { "$": 0 }, "pubol": { "$": 0 }, "quebec": { "$": 0 }, "railroad": { "$": 0 }, "railway": { "$": 0 }, "research": { "$": 0 }, "resistance": { "$": 0 }, "riodejaneiro": { "$": 0 }, "rochester": { "$": 0 }, "rockart": { "$": 0 }, "roma": { "$": 0 }, "russia": { "$": 0 }, "saintlouis": { "$": 0 }, "salem": { "$": 0 }, "salvadordali": { "$": 0 }, "salzburg": { "$": 0 }, "sandiego": { "$": 0 }, "sanfrancisco": { "$": 0 }, "santabarbara": { "$": 0 }, "santacruz": { "$": 0 }, "santafe": { "$": 0 }, "saskatchewan": { "$": 0 }, "satx": { "$": 0 }, "savannahga": { "$": 0 }, "schlesisches": { "$": 0 }, "schoenbrunn": { "$": 0 }, "schokoladen": { "$": 0 }, "school": { "$": 0 }, "schweiz": { "$": 0 }, "science": { "$": 0 }, "scienceandhistory": { "$": 0 }, "scienceandindustry": { "$": 0 }, "sciencecenter": { "$": 0 }, "sciencecenters": { "$": 0 }, "science-fiction": { "$": 0 }, "sciencehistory": { "$": 0 }, "sciences": { "$": 0 }, "sciencesnaturelles": { "$": 0 }, "scotland": { "$": 0 }, "seaport": { "$": 0 }, "settlement": { "$": 0 }, "settlers": { "$": 0 }, "shell": { "$": 0 }, "sherbrooke": { "$": 0 }, "sibenik": { "$": 0 }, "silk": { "$": 0 }, "ski": { "$": 0 }, "skole": { "$": 0 }, "society": { "$": 0 }, "sologne": { "$": 0 }, "soundandvision": { "$": 0 }, "southcarolina": { "$": 0 }, "southwest": { "$": 0 }, "space": { "$": 0 }, "spy": { "$": 0 }, "square": { "$": 0 }, "stadt": { "$": 0 }, "stalbans": { "$": 0 }, "starnberg": { "$": 0 }, "state": { "$": 0 }, "stateofdelaware": { "$": 0 }, "station": { "$": 0 }, "steam": { "$": 0 }, "steiermark": { "$": 0 }, "stjohn": { "$": 0 }, "stockholm": { "$": 0 }, "stpetersburg": { "$": 0 }, "stuttgart": { "$": 0 }, "suisse": { "$": 0 }, "surgeonshall": { "$": 0 }, "surrey": { "$": 0 }, "svizzera": { "$": 0 }, "sweden": { "$": 0 }, "sydney": { "$": 0 }, "tank": { "$": 0 }, "tcm": { "$": 0 }, "technology": { "$": 0 }, "telekommunikation": { "$": 0 }, "television": { "$": 0 }, "texas": { "$": 0 }, "textile": { "$": 0 }, "theater": { "$": 0 }, "time": { "$": 0 }, "timekeeping": { "$": 0 }, "topology": { "$": 0 }, "torino": { "$": 0 }, "touch": { "$": 0 }, "town": { "$": 0 }, "transport": { "$": 0 }, "tree": { "$": 0 }, "trolley": { "$": 0 }, "trust": { "$": 0 }, "trustee": { "$": 0 }, "uhren": { "$": 0 }, "ulm": { "$": 0 }, "undersea": { "$": 0 }, "university": { "$": 0 }, "usa": { "$": 0 }, "usantiques": { "$": 0 }, "usarts": { "$": 0 }, "uscountryestate": { "$": 0 }, "usculture": { "$": 0 }, "usdecorativearts": { "$": 0 }, "usgarden": { "$": 0 }, "ushistory": { "$": 0 }, "ushuaia": { "$": 0 }, "uslivinghistory": { "$": 0 }, "utah": { "$": 0 }, "uvic": { "$": 0 }, "valley": { "$": 0 }, "vantaa": { "$": 0 }, "versailles": { "$": 0 }, "viking": { "$": 0 }, "village": { "$": 0 }, "virginia": { "$": 0 }, "virtual": { "$": 0 }, "virtuel": { "$": 0 }, "vlaanderen": { "$": 0 }, "volkenkunde": { "$": 0 }, "wales": { "$": 0 }, "wallonie": { "$": 0 }, "war": { "$": 0 }, "washingtondc": { "$": 0 }, "watchandclock": { "$": 0 }, "watch-and-clock": { "$": 0 }, "western": { "$": 0 }, "westfalen": { "$": 0 }, "whaling": { "$": 0 }, "wildlife": { "$": 0 }, "williamsburg": { "$": 0 }, "windmill": { "$": 0 }, "workshop": { "$": 0 }, "york": { "$": 0 }, "yorkshire": { "$": 0 }, "yosemite": { "$": 0 }, "youth": { "$": 0 }, "zoological": { "$": 0 }, "zoology": { "$": 0 }, "xn--9dbhblg6di": { "$": 0 }, "xn--h1aegh": { "$": 0 } }, "mv": { "$": 0, "aero": { "$": 0 }, "biz": { "$": 0 }, "com": { "$": 0 }, "coop": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "info": { "$": 0 }, "int": { "$": 0 }, "mil": { "$": 0 }, "museum": { "$": 0 }, "name": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "pro": { "$": 0 } }, "mw": { "$": 0, "ac": { "$": 0 }, "biz": { "$": 0 }, "co": { "$": 0 }, "com": { "$": 0 }, "coop": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "int": { "$": 0 }, "museum": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "mx": { "$": 0, "com": { "$": 0 }, "org": { "$": 0 }, "gob": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 }, "blogspot": { "$": 0 }, "nym": { "$": 0 } }, "my": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "edu": { "$": 0 }, "mil": { "$": 0 }, "name": { "$": 0 }, "blogspot": { "$": 0 } }, "mz": { "$": 0, "ac": { "$": 0 }, "adv": { "$": 0 }, "co": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "na": { "$": 0, "info": { "$": 0 }, "pro": { "$": 0 }, "name": { "$": 0 }, "school": { "$": 0 }, "or": { "$": 0 }, "dr": { "$": 0 }, "us": { "$": 0 }, "mx": { "$": 0 }, "ca": { "$": 0 }, "in": { "$": 0 }, "cc": { "$": 0 }, "tv": { "$": 0 }, "ws": { "$": 0 }, "mobi": { "$": 0 }, "co": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 } }, "name": { "$": 0, "her": { "forgot": { "$": 0 } }, "his": { "forgot": { "$": 0 } } }, "nc": { "$": 0, "asso": { "$": 0 }, "nom": { "$": 0 } }, "ne": { "$": 0 }, "net": { "$": 0, "alwaysdata": { "*": { "$": 0 } }, "cloudfront": { "$": 0 }, "t3l3p0rt": { "$": 0 }, "myfritz": { "$": 0 }, "boomla": { "$": 0 }, "bplaced": { "$": 0 }, "square7": { "$": 0 }, "gb": { "$": 0 }, "hu": { "$": 0 }, "jp": { "$": 0 }, "se": { "$": 0 }, "uk": { "$": 0 }, "in": { "$": 0 }, "cloudaccess": { "$": 0 }, "cdn77-ssl": { "$": 0 }, "cdn77": { "r": { "$": 0 } }, "feste-ip": { "$": 0 }, "knx-server": { "$": 0 }, "static-access": { "$": 0 }, "cryptonomic": { "*": { "$": 0 } }, "debian": { "$": 0 }, "at-band-camp": { "$": 0 }, "blogdns": { "$": 0 }, "broke-it": { "$": 0 }, "buyshouses": { "$": 0 }, "dnsalias": { "$": 0 }, "dnsdojo": { "$": 0 }, "does-it": { "$": 0 }, "dontexist": { "$": 0 }, "dynalias": { "$": 0 }, "dynathome": { "$": 0 }, "endofinternet": { "$": 0 }, "from-az": { "$": 0 }, "from-co": { "$": 0 }, "from-la": { "$": 0 }, "from-ny": { "$": 0 }, "gets-it": { "$": 0 }, "ham-radio-op": { "$": 0 }, "homeftp": { "$": 0 }, "homeip": { "$": 0 }, "homelinux": { "$": 0 }, "homeunix": { "$": 0 }, "in-the-band": { "$": 0 }, "is-a-chef": { "$": 0 }, "is-a-geek": { "$": 0 }, "isa-geek": { "$": 0 }, "kicks-ass": { "$": 0 }, "office-on-the": { "$": 0 }, "podzone": { "$": 0 }, "scrapper-site": { "$": 0 }, "selfip": { "$": 0 }, "sells-it": { "$": 0 }, "servebbs": { "$": 0 }, "serveftp": { "$": 0 }, "thruhere": { "$": 0 }, "webhop": { "$": 0 }, "definima": { "$": 0 }, "casacam": { "$": 0 }, "dynu": { "$": 0 }, "dynv6": { "$": 0 }, "twmail": { "$": 0 }, "ru": { "$": 0 }, "channelsdvr": { "$": 0 }, "fastlylb": { "$": 0, "map": { "$": 0 } }, "fastly": { "freetls": { "$": 0 }, "map": { "$": 0 }, "prod": { "a": { "$": 0 }, "global": { "$": 0 } }, "ssl": { "a": { "$": 0 }, "b": { "$": 0 }, "global": { "$": 0 } } }, "flynnhosting": { "$": 0 }, "cloudfunctions": { "$": 0 }, "moonscale": { "$": 0 }, "ipifony": { "$": 0 }, "barsy": { "$": 0 }, "azurewebsites": { "$": 0 }, "azure-mobile": { "$": 0 }, "cloudapp": { "$": 0 }, "eating-organic": { "$": 0 }, "mydissent": { "$": 0 }, "myeffect": { "$": 0 }, "mymediapc": { "$": 0 }, "mypsx": { "$": 0 }, "mysecuritycamera": { "$": 0 }, "nhlfan": { "$": 0 }, "no-ip": { "$": 0 }, "pgafan": { "$": 0 }, "privatizehealthinsurance": { "$": 0 }, "bounceme": { "$": 0 }, "ddns": { "$": 0 }, "redirectme": { "$": 0 }, "serveblog": { "$": 0 }, "serveminecraft": { "$": 0 }, "sytes": { "$": 0 }, "rackmaze": { "$": 0 }, "firewall-gateway": { "$": 0 }, "dsmynas": { "$": 0 }, "familyds": { "$": 0 }, "za": { "$": 0 } }, "nf": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "per": { "$": 0 }, "rec": { "$": 0 }, "web": { "$": 0 }, "arts": { "$": 0 }, "firm": { "$": 0 }, "info": { "$": 0 }, "other": { "$": 0 }, "store": { "$": 0 } }, "ng": { "$": 0, "com": { "$": 0, "blogspot": { "$": 0 } }, "edu": { "$": 0 }, "gov": { "$": 0 }, "i": { "$": 0 }, "mil": { "$": 0 }, "mobi": { "$": 0 }, "name": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "sch": { "$": 0 } }, "ni": { "$": 0, "ac": { "$": 0 }, "biz": { "$": 0 }, "co": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gob": { "$": 0 }, "in": { "$": 0 }, "info": { "$": 0 }, "int": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "nom": { "$": 0 }, "org": { "$": 0 }, "web": { "$": 0 } }, "nl": { "$": 0, "bv": { "$": 0 }, "virtueeldomein": { "$": 0 }, "co": { "$": 0 }, "blogspot": { "$": 0 }, "transurl": { "*": { "$": 0 } }, "cistron": { "$": 0 }, "demon": { "$": 0 } }, "no": { "$": 0, "fhs": { "$": 0 }, "vgs": { "$": 0 }, "fylkesbibl": { "$": 0 }, "folkebibl": { "$": 0 }, "museum": { "$": 0 }, "idrett": { "$": 0 }, "priv": { "$": 0 }, "mil": { "$": 0 }, "stat": { "$": 0 }, "dep": { "$": 0 }, "kommune": { "$": 0 }, "herad": { "$": 0 }, "aa": { "$": 0, "gs": { "$": 0 } }, "ah": { "$": 0, "gs": { "$": 0 } }, "bu": { "$": 0, "gs": { "$": 0 } }, "fm": { "$": 0, "gs": { "$": 0 } }, "hl": { "$": 0, "gs": { "$": 0 } }, "hm": { "$": 0, "gs": { "$": 0 } }, "jan-mayen": { "$": 0, "gs": { "$": 0 } }, "mr": { "$": 0, "gs": { "$": 0 } }, "nl": { "$": 0, "gs": { "$": 0 } }, "nt": { "$": 0, "gs": { "$": 0 } }, "of": { "$": 0, "gs": { "$": 0 } }, "ol": { "$": 0, "gs": { "$": 0 } }, "oslo": { "$": 0, "gs": { "$": 0 } }, "rl": { "$": 0, "gs": { "$": 0 } }, "sf": { "$": 0, "gs": { "$": 0 } }, "st": { "$": 0, "gs": { "$": 0 } }, "svalbard": { "$": 0, "gs": { "$": 0 } }, "tm": { "$": 0, "gs": { "$": 0 } }, "tr": { "$": 0, "gs": { "$": 0 } }, "va": { "$": 0, "gs": { "$": 0 } }, "vf": { "$": 0, "gs": { "$": 0 } }, "akrehamn": { "$": 0 }, "xn--krehamn-dxa": { "$": 0 }, "algard": { "$": 0 }, "xn--lgrd-poac": { "$": 0 }, "arna": { "$": 0 }, "brumunddal": { "$": 0 }, "bryne": { "$": 0 }, "bronnoysund": { "$": 0 }, "xn--brnnysund-m8ac": { "$": 0 }, "drobak": { "$": 0 }, "xn--drbak-wua": { "$": 0 }, "egersund": { "$": 0 }, "fetsund": { "$": 0 }, "floro": { "$": 0 }, "xn--flor-jra": { "$": 0 }, "fredrikstad": { "$": 0 }, "hokksund": { "$": 0 }, "honefoss": { "$": 0 }, "xn--hnefoss-q1a": { "$": 0 }, "jessheim": { "$": 0 }, "jorpeland": { "$": 0 }, "xn--jrpeland-54a": { "$": 0 }, "kirkenes": { "$": 0 }, "kopervik": { "$": 0 }, "krokstadelva": { "$": 0 }, "langevag": { "$": 0 }, "xn--langevg-jxa": { "$": 0 }, "leirvik": { "$": 0 }, "mjondalen": { "$": 0 }, "xn--mjndalen-64a": { "$": 0 }, "mo-i-rana": { "$": 0 }, "mosjoen": { "$": 0 }, "xn--mosjen-eya": { "$": 0 }, "nesoddtangen": { "$": 0 }, "orkanger": { "$": 0 }, "osoyro": { "$": 0 }, "xn--osyro-wua": { "$": 0 }, "raholt": { "$": 0 }, "xn--rholt-mra": { "$": 0 }, "sandnessjoen": { "$": 0 }, "xn--sandnessjen-ogb": { "$": 0 }, "skedsmokorset": { "$": 0 }, "slattum": { "$": 0 }, "spjelkavik": { "$": 0 }, "stathelle": { "$": 0 }, "stavern": { "$": 0 }, "stjordalshalsen": { "$": 0 }, "xn--stjrdalshalsen-sqb": { "$": 0 }, "tananger": { "$": 0 }, "tranby": { "$": 0 }, "vossevangen": { "$": 0 }, "afjord": { "$": 0 }, "xn--fjord-lra": { "$": 0 }, "agdenes": { "$": 0 }, "al": { "$": 0 }, "xn--l-1fa": { "$": 0 }, "alesund": { "$": 0 }, "xn--lesund-hua": { "$": 0 }, "alstahaug": { "$": 0 }, "alta": { "$": 0 }, "xn--lt-liac": { "$": 0 }, "alaheadju": { "$": 0 }, "xn--laheadju-7ya": { "$": 0 }, "alvdal": { "$": 0 }, "amli": { "$": 0 }, "xn--mli-tla": { "$": 0 }, "amot": { "$": 0 }, "xn--mot-tla": { "$": 0 }, "andebu": { "$": 0 }, "andoy": { "$": 0 }, "xn--andy-ira": { "$": 0 }, "andasuolo": { "$": 0 }, "ardal": { "$": 0 }, "xn--rdal-poa": { "$": 0 }, "aremark": { "$": 0 }, "arendal": { "$": 0 }, "xn--s-1fa": { "$": 0 }, "aseral": { "$": 0 }, "xn--seral-lra": { "$": 0 }, "asker": { "$": 0 }, "askim": { "$": 0 }, "askvoll": { "$": 0 }, "askoy": { "$": 0 }, "xn--asky-ira": { "$": 0 }, "asnes": { "$": 0 }, "xn--snes-poa": { "$": 0 }, "audnedaln": { "$": 0 }, "aukra": { "$": 0 }, "aure": { "$": 0 }, "aurland": { "$": 0 }, "aurskog-holand": { "$": 0 }, "xn--aurskog-hland-jnb": { "$": 0 }, "austevoll": { "$": 0 }, "austrheim": { "$": 0 }, "averoy": { "$": 0 }, "xn--avery-yua": { "$": 0 }, "balestrand": { "$": 0 }, "ballangen": { "$": 0 }, "balat": { "$": 0 }, "xn--blt-elab": { "$": 0 }, "balsfjord": { "$": 0 }, "bahccavuotna": { "$": 0 }, "xn--bhccavuotna-k7a": { "$": 0 }, "bamble": { "$": 0 }, "bardu": { "$": 0 }, "beardu": { "$": 0 }, "beiarn": { "$": 0 }, "bajddar": { "$": 0 }, "xn--bjddar-pta": { "$": 0 }, "baidar": { "$": 0 }, "xn--bidr-5nac": { "$": 0 }, "berg": { "$": 0 }, "bergen": { "$": 0 }, "berlevag": { "$": 0 }, "xn--berlevg-jxa": { "$": 0 }, "bearalvahki": { "$": 0 }, "xn--bearalvhki-y4a": { "$": 0 }, "bindal": { "$": 0 }, "birkenes": { "$": 0 }, "bjarkoy": { "$": 0 }, "xn--bjarky-fya": { "$": 0 }, "bjerkreim": { "$": 0 }, "bjugn": { "$": 0 }, "bodo": { "$": 0 }, "xn--bod-2na": { "$": 0 }, "badaddja": { "$": 0 }, "xn--bdddj-mrabd": { "$": 0 }, "budejju": { "$": 0 }, "bokn": { "$": 0 }, "bremanger": { "$": 0 }, "bronnoy": { "$": 0 }, "xn--brnny-wuac": { "$": 0 }, "bygland": { "$": 0 }, "bykle": { "$": 0 }, "barum": { "$": 0 }, "xn--brum-voa": { "$": 0 }, "telemark": { "bo": { "$": 0 }, "xn--b-5ga": { "$": 0 } }, "nordland": { "bo": { "$": 0 }, "xn--b-5ga": { "$": 0 }, "heroy": { "$": 0 }, "xn--hery-ira": { "$": 0 } }, "bievat": { "$": 0 }, "xn--bievt-0qa": { "$": 0 }, "bomlo": { "$": 0 }, "xn--bmlo-gra": { "$": 0 }, "batsfjord": { "$": 0 }, "xn--btsfjord-9za": { "$": 0 }, "bahcavuotna": { "$": 0 }, "xn--bhcavuotna-s4a": { "$": 0 }, "dovre": { "$": 0 }, "drammen": { "$": 0 }, "drangedal": { "$": 0 }, "dyroy": { "$": 0 }, "xn--dyry-ira": { "$": 0 }, "donna": { "$": 0 }, "xn--dnna-gra": { "$": 0 }, "eid": { "$": 0 }, "eidfjord": { "$": 0 }, "eidsberg": { "$": 0 }, "eidskog": { "$": 0 }, "eidsvoll": { "$": 0 }, "eigersund": { "$": 0 }, "elverum": { "$": 0 }, "enebakk": { "$": 0 }, "engerdal": { "$": 0 }, "etne": { "$": 0 }, "etnedal": { "$": 0 }, "evenes": { "$": 0 }, "evenassi": { "$": 0 }, "xn--eveni-0qa01ga": { "$": 0 }, "evje-og-hornnes": { "$": 0 }, "farsund": { "$": 0 }, "fauske": { "$": 0 }, "fuossko": { "$": 0 }, "fuoisku": { "$": 0 }, "fedje": { "$": 0 }, "fet": { "$": 0 }, "finnoy": { "$": 0 }, "xn--finny-yua": { "$": 0 }, "fitjar": { "$": 0 }, "fjaler": { "$": 0 }, "fjell": { "$": 0 }, "flakstad": { "$": 0 }, "flatanger": { "$": 0 }, "flekkefjord": { "$": 0 }, "flesberg": { "$": 0 }, "flora": { "$": 0 }, "fla": { "$": 0 }, "xn--fl-zia": { "$": 0 }, "folldal": { "$": 0 }, "forsand": { "$": 0 }, "fosnes": { "$": 0 }, "frei": { "$": 0 }, "frogn": { "$": 0 }, "froland": { "$": 0 }, "frosta": { "$": 0 }, "frana": { "$": 0 }, "xn--frna-woa": { "$": 0 }, "froya": { "$": 0 }, "xn--frya-hra": { "$": 0 }, "fusa": { "$": 0 }, "fyresdal": { "$": 0 }, "forde": { "$": 0 }, "xn--frde-gra": { "$": 0 }, "gamvik": { "$": 0 }, "gangaviika": { "$": 0 }, "xn--ggaviika-8ya47h": { "$": 0 }, "gaular": { "$": 0 }, "gausdal": { "$": 0 }, "gildeskal": { "$": 0 }, "xn--gildeskl-g0a": { "$": 0 }, "giske": { "$": 0 }, "gjemnes": { "$": 0 }, "gjerdrum": { "$": 0 }, "gjerstad": { "$": 0 }, "gjesdal": { "$": 0 }, "gjovik": { "$": 0 }, "xn--gjvik-wua": { "$": 0 }, "gloppen": { "$": 0 }, "gol": { "$": 0 }, "gran": { "$": 0 }, "grane": { "$": 0 }, "granvin": { "$": 0 }, "gratangen": { "$": 0 }, "grimstad": { "$": 0 }, "grong": { "$": 0 }, "kraanghke": { "$": 0 }, "xn--kranghke-b0a": { "$": 0 }, "grue": { "$": 0 }, "gulen": { "$": 0 }, "hadsel": { "$": 0 }, "halden": { "$": 0 }, "halsa": { "$": 0 }, "hamar": { "$": 0 }, "hamaroy": { "$": 0 }, "habmer": { "$": 0 }, "xn--hbmer-xqa": { "$": 0 }, "hapmir": { "$": 0 }, "xn--hpmir-xqa": { "$": 0 }, "hammerfest": { "$": 0 }, "hammarfeasta": { "$": 0 }, "xn--hmmrfeasta-s4ac": { "$": 0 }, "haram": { "$": 0 }, "hareid": { "$": 0 }, "harstad": { "$": 0 }, "hasvik": { "$": 0 }, "aknoluokta": { "$": 0 }, "xn--koluokta-7ya57h": { "$": 0 }, "hattfjelldal": { "$": 0 }, "aarborte": { "$": 0 }, "haugesund": { "$": 0 }, "hemne": { "$": 0 }, "hemnes": { "$": 0 }, "hemsedal": { "$": 0 }, "more-og-romsdal": { "heroy": { "$": 0 }, "sande": { "$": 0 } }, "xn--mre-og-romsdal-qqb": { "xn--hery-ira": { "$": 0 }, "sande": { "$": 0 } }, "hitra": { "$": 0 }, "hjartdal": { "$": 0 }, "hjelmeland": { "$": 0 }, "hobol": { "$": 0 }, "xn--hobl-ira": { "$": 0 }, "hof": { "$": 0 }, "hol": { "$": 0 }, "hole": { "$": 0 }, "holmestrand": { "$": 0 }, "holtalen": { "$": 0 }, "xn--holtlen-hxa": { "$": 0 }, "hornindal": { "$": 0 }, "horten": { "$": 0 }, "hurdal": { "$": 0 }, "hurum": { "$": 0 }, "hvaler": { "$": 0 }, "hyllestad": { "$": 0 }, "hagebostad": { "$": 0 }, "xn--hgebostad-g3a": { "$": 0 }, "hoyanger": { "$": 0 }, "xn--hyanger-q1a": { "$": 0 }, "hoylandet": { "$": 0 }, "xn--hylandet-54a": { "$": 0 }, "ha": { "$": 0 }, "xn--h-2fa": { "$": 0 }, "ibestad": { "$": 0 }, "inderoy": { "$": 0 }, "xn--indery-fya": { "$": 0 }, "iveland": { "$": 0 }, "jevnaker": { "$": 0 }, "jondal": { "$": 0 }, "jolster": { "$": 0 }, "xn--jlster-bya": { "$": 0 }, "karasjok": { "$": 0 }, "karasjohka": { "$": 0 }, "xn--krjohka-hwab49j": { "$": 0 }, "karlsoy": { "$": 0 }, "galsa": { "$": 0 }, "xn--gls-elac": { "$": 0 }, "karmoy": { "$": 0 }, "xn--karmy-yua": { "$": 0 }, "kautokeino": { "$": 0 }, "guovdageaidnu": { "$": 0 }, "klepp": { "$": 0 }, "klabu": { "$": 0 }, "xn--klbu-woa": { "$": 0 }, "kongsberg": { "$": 0 }, "kongsvinger": { "$": 0 }, "kragero": { "$": 0 }, "xn--krager-gya": { "$": 0 }, "kristiansand": { "$": 0 }, "kristiansund": { "$": 0 }, "krodsherad": { "$": 0 }, "xn--krdsherad-m8a": { "$": 0 }, "kvalsund": { "$": 0 }, "rahkkeravju": { "$": 0 }, "xn--rhkkervju-01af": { "$": 0 }, "kvam": { "$": 0 }, "kvinesdal": { "$": 0 }, "kvinnherad": { "$": 0 }, "kviteseid": { "$": 0 }, "kvitsoy": { "$": 0 }, "xn--kvitsy-fya": { "$": 0 }, "kvafjord": { "$": 0 }, "xn--kvfjord-nxa": { "$": 0 }, "giehtavuoatna": { "$": 0 }, "kvanangen": { "$": 0 }, "xn--kvnangen-k0a": { "$": 0 }, "navuotna": { "$": 0 }, "xn--nvuotna-hwa": { "$": 0 }, "kafjord": { "$": 0 }, "xn--kfjord-iua": { "$": 0 }, "gaivuotna": { "$": 0 }, "xn--givuotna-8ya": { "$": 0 }, "larvik": { "$": 0 }, "lavangen": { "$": 0 }, "lavagis": { "$": 0 }, "loabat": { "$": 0 }, "xn--loabt-0qa": { "$": 0 }, "lebesby": { "$": 0 }, "davvesiida": { "$": 0 }, "leikanger": { "$": 0 }, "leirfjord": { "$": 0 }, "leka": { "$": 0 }, "leksvik": { "$": 0 }, "lenvik": { "$": 0 }, "leangaviika": { "$": 0 }, "xn--leagaviika-52b": { "$": 0 }, "lesja": { "$": 0 }, "levanger": { "$": 0 }, "lier": { "$": 0 }, "lierne": { "$": 0 }, "lillehammer": { "$": 0 }, "lillesand": { "$": 0 }, "lindesnes": { "$": 0 }, "lindas": { "$": 0 }, "xn--linds-pra": { "$": 0 }, "lom": { "$": 0 }, "loppa": { "$": 0 }, "lahppi": { "$": 0 }, "xn--lhppi-xqa": { "$": 0 }, "lund": { "$": 0 }, "lunner": { "$": 0 }, "luroy": { "$": 0 }, "xn--lury-ira": { "$": 0 }, "luster": { "$": 0 }, "lyngdal": { "$": 0 }, "lyngen": { "$": 0 }, "ivgu": { "$": 0 }, "lardal": { "$": 0 }, "lerdal": { "$": 0 }, "xn--lrdal-sra": { "$": 0 }, "lodingen": { "$": 0 }, "xn--ldingen-q1a": { "$": 0 }, "lorenskog": { "$": 0 }, "xn--lrenskog-54a": { "$": 0 }, "loten": { "$": 0 }, "xn--lten-gra": { "$": 0 }, "malvik": { "$": 0 }, "masoy": { "$": 0 }, "xn--msy-ula0h": { "$": 0 }, "muosat": { "$": 0 }, "xn--muost-0qa": { "$": 0 }, "mandal": { "$": 0 }, "marker": { "$": 0 }, "marnardal": { "$": 0 }, "masfjorden": { "$": 0 }, "meland": { "$": 0 }, "meldal": { "$": 0 }, "melhus": { "$": 0 }, "meloy": { "$": 0 }, "xn--mely-ira": { "$": 0 }, "meraker": { "$": 0 }, "xn--merker-kua": { "$": 0 }, "moareke": { "$": 0 }, "xn--moreke-jua": { "$": 0 }, "midsund": { "$": 0 }, "midtre-gauldal": { "$": 0 }, "modalen": { "$": 0 }, "modum": { "$": 0 }, "molde": { "$": 0 }, "moskenes": { "$": 0 }, "moss": { "$": 0 }, "mosvik": { "$": 0 }, "malselv": { "$": 0 }, "xn--mlselv-iua": { "$": 0 }, "malatvuopmi": { "$": 0 }, "xn--mlatvuopmi-s4a": { "$": 0 }, "namdalseid": { "$": 0 }, "aejrie": { "$": 0 }, "namsos": { "$": 0 }, "namsskogan": { "$": 0 }, "naamesjevuemie": { "$": 0 }, "xn--nmesjevuemie-tcba": { "$": 0 }, "laakesvuemie": { "$": 0 }, "nannestad": { "$": 0 }, "narvik": { "$": 0 }, "narviika": { "$": 0 }, "naustdal": { "$": 0 }, "nedre-eiker": { "$": 0 }, "akershus": { "nes": { "$": 0 } }, "buskerud": { "nes": { "$": 0 } }, "nesna": { "$": 0 }, "nesodden": { "$": 0 }, "nesseby": { "$": 0 }, "unjarga": { "$": 0 }, "xn--unjrga-rta": { "$": 0 }, "nesset": { "$": 0 }, "nissedal": { "$": 0 }, "nittedal": { "$": 0 }, "nord-aurdal": { "$": 0 }, "nord-fron": { "$": 0 }, "nord-odal": { "$": 0 }, "norddal": { "$": 0 }, "nordkapp": { "$": 0 }, "davvenjarga": { "$": 0 }, "xn--davvenjrga-y4a": { "$": 0 }, "nordre-land": { "$": 0 }, "nordreisa": { "$": 0 }, "raisa": { "$": 0 }, "xn--risa-5na": { "$": 0 }, "nore-og-uvdal": { "$": 0 }, "notodden": { "$": 0 }, "naroy": { "$": 0 }, "xn--nry-yla5g": { "$": 0 }, "notteroy": { "$": 0 }, "xn--nttery-byae": { "$": 0 }, "odda": { "$": 0 }, "oksnes": { "$": 0 }, "xn--ksnes-uua": { "$": 0 }, "oppdal": { "$": 0 }, "oppegard": { "$": 0 }, "xn--oppegrd-ixa": { "$": 0 }, "orkdal": { "$": 0 }, "orland": { "$": 0 }, "xn--rland-uua": { "$": 0 }, "orskog": { "$": 0 }, "xn--rskog-uua": { "$": 0 }, "orsta": { "$": 0 }, "xn--rsta-fra": { "$": 0 }, "hedmark": { "os": { "$": 0 }, "valer": { "$": 0 }, "xn--vler-qoa": { "$": 0 } }, "hordaland": { "os": { "$": 0 } }, "osen": { "$": 0 }, "osteroy": { "$": 0 }, "xn--ostery-fya": { "$": 0 }, "ostre-toten": { "$": 0 }, "xn--stre-toten-zcb": { "$": 0 }, "overhalla": { "$": 0 }, "ovre-eiker": { "$": 0 }, "xn--vre-eiker-k8a": { "$": 0 }, "oyer": { "$": 0 }, "xn--yer-zna": { "$": 0 }, "oygarden": { "$": 0 }, "xn--ygarden-p1a": { "$": 0 }, "oystre-slidre": { "$": 0 }, "xn--ystre-slidre-ujb": { "$": 0 }, "porsanger": { "$": 0 }, "porsangu": { "$": 0 }, "xn--porsgu-sta26f": { "$": 0 }, "porsgrunn": { "$": 0 }, "radoy": { "$": 0 }, "xn--rady-ira": { "$": 0 }, "rakkestad": { "$": 0 }, "rana": { "$": 0 }, "ruovat": { "$": 0 }, "randaberg": { "$": 0 }, "rauma": { "$": 0 }, "rendalen": { "$": 0 }, "rennebu": { "$": 0 }, "rennesoy": { "$": 0 }, "xn--rennesy-v1a": { "$": 0 }, "rindal": { "$": 0 }, "ringebu": { "$": 0 }, "ringerike": { "$": 0 }, "ringsaker": { "$": 0 }, "rissa": { "$": 0 }, "risor": { "$": 0 }, "xn--risr-ira": { "$": 0 }, "roan": { "$": 0 }, "rollag": { "$": 0 }, "rygge": { "$": 0 }, "ralingen": { "$": 0 }, "xn--rlingen-mxa": { "$": 0 }, "rodoy": { "$": 0 }, "xn--rdy-0nab": { "$": 0 }, "romskog": { "$": 0 }, "xn--rmskog-bya": { "$": 0 }, "roros": { "$": 0 }, "xn--rros-gra": { "$": 0 }, "rost": { "$": 0 }, "xn--rst-0na": { "$": 0 }, "royken": { "$": 0 }, "xn--ryken-vua": { "$": 0 }, "royrvik": { "$": 0 }, "xn--ryrvik-bya": { "$": 0 }, "rade": { "$": 0 }, "xn--rde-ula": { "$": 0 }, "salangen": { "$": 0 }, "siellak": { "$": 0 }, "saltdal": { "$": 0 }, "salat": { "$": 0 }, "xn--slt-elab": { "$": 0 }, "xn--slat-5na": { "$": 0 }, "samnanger": { "$": 0 }, "vestfold": { "sande": { "$": 0 } }, "sandefjord": { "$": 0 }, "sandnes": { "$": 0 }, "sandoy": { "$": 0 }, "xn--sandy-yua": { "$": 0 }, "sarpsborg": { "$": 0 }, "sauda": { "$": 0 }, "sauherad": { "$": 0 }, "sel": { "$": 0 }, "selbu": { "$": 0 }, "selje": { "$": 0 }, "seljord": { "$": 0 }, "sigdal": { "$": 0 }, "siljan": { "$": 0 }, "sirdal": { "$": 0 }, "skaun": { "$": 0 }, "skedsmo": { "$": 0 }, "ski": { "$": 0 }, "skien": { "$": 0 }, "skiptvet": { "$": 0 }, "skjervoy": { "$": 0 }, "xn--skjervy-v1a": { "$": 0 }, "skierva": { "$": 0 }, "xn--skierv-uta": { "$": 0 }, "skjak": { "$": 0 }, "xn--skjk-soa": { "$": 0 }, "skodje": { "$": 0 }, "skanland": { "$": 0 }, "xn--sknland-fxa": { "$": 0 }, "skanit": { "$": 0 }, "xn--sknit-yqa": { "$": 0 }, "smola": { "$": 0 }, "xn--smla-hra": { "$": 0 }, "snillfjord": { "$": 0 }, "snasa": { "$": 0 }, "xn--snsa-roa": { "$": 0 }, "snoasa": { "$": 0 }, "snaase": { "$": 0 }, "xn--snase-nra": { "$": 0 }, "sogndal": { "$": 0 }, "sokndal": { "$": 0 }, "sola": { "$": 0 }, "solund": { "$": 0 }, "songdalen": { "$": 0 }, "sortland": { "$": 0 }, "spydeberg": { "$": 0 }, "stange": { "$": 0 }, "stavanger": { "$": 0 }, "steigen": { "$": 0 }, "steinkjer": { "$": 0 }, "stjordal": { "$": 0 }, "xn--stjrdal-s1a": { "$": 0 }, "stokke": { "$": 0 }, "stor-elvdal": { "$": 0 }, "stord": { "$": 0 }, "stordal": { "$": 0 }, "storfjord": { "$": 0 }, "omasvuotna": { "$": 0 }, "strand": { "$": 0 }, "stranda": { "$": 0 }, "stryn": { "$": 0 }, "sula": { "$": 0 }, "suldal": { "$": 0 }, "sund": { "$": 0 }, "sunndal": { "$": 0 }, "surnadal": { "$": 0 }, "sveio": { "$": 0 }, "svelvik": { "$": 0 }, "sykkylven": { "$": 0 }, "sogne": { "$": 0 }, "xn--sgne-gra": { "$": 0 }, "somna": { "$": 0 }, "xn--smna-gra": { "$": 0 }, "sondre-land": { "$": 0 }, "xn--sndre-land-0cb": { "$": 0 }, "sor-aurdal": { "$": 0 }, "xn--sr-aurdal-l8a": { "$": 0 }, "sor-fron": { "$": 0 }, "xn--sr-fron-q1a": { "$": 0 }, "sor-odal": { "$": 0 }, "xn--sr-odal-q1a": { "$": 0 }, "sor-varanger": { "$": 0 }, "xn--sr-varanger-ggb": { "$": 0 }, "matta-varjjat": { "$": 0 }, "xn--mtta-vrjjat-k7af": { "$": 0 }, "sorfold": { "$": 0 }, "xn--srfold-bya": { "$": 0 }, "sorreisa": { "$": 0 }, "xn--srreisa-q1a": { "$": 0 }, "sorum": { "$": 0 }, "xn--srum-gra": { "$": 0 }, "tana": { "$": 0 }, "deatnu": { "$": 0 }, "time": { "$": 0 }, "tingvoll": { "$": 0 }, "tinn": { "$": 0 }, "tjeldsund": { "$": 0 }, "dielddanuorri": { "$": 0 }, "tjome": { "$": 0 }, "xn--tjme-hra": { "$": 0 }, "tokke": { "$": 0 }, "tolga": { "$": 0 }, "torsken": { "$": 0 }, "tranoy": { "$": 0 }, "xn--trany-yua": { "$": 0 }, "tromso": { "$": 0 }, "xn--troms-zua": { "$": 0 }, "tromsa": { "$": 0 }, "romsa": { "$": 0 }, "trondheim": { "$": 0 }, "troandin": { "$": 0 }, "trysil": { "$": 0 }, "trana": { "$": 0 }, "xn--trna-woa": { "$": 0 }, "trogstad": { "$": 0 }, "xn--trgstad-r1a": { "$": 0 }, "tvedestrand": { "$": 0 }, "tydal": { "$": 0 }, "tynset": { "$": 0 }, "tysfjord": { "$": 0 }, "divtasvuodna": { "$": 0 }, "divttasvuotna": { "$": 0 }, "tysnes": { "$": 0 }, "tysvar": { "$": 0 }, "xn--tysvr-vra": { "$": 0 }, "tonsberg": { "$": 0 }, "xn--tnsberg-q1a": { "$": 0 }, "ullensaker": { "$": 0 }, "ullensvang": { "$": 0 }, "ulvik": { "$": 0 }, "utsira": { "$": 0 }, "vadso": { "$": 0 }, "xn--vads-jra": { "$": 0 }, "cahcesuolo": { "$": 0 }, "xn--hcesuolo-7ya35b": { "$": 0 }, "vaksdal": { "$": 0 }, "valle": { "$": 0 }, "vang": { "$": 0 }, "vanylven": { "$": 0 }, "vardo": { "$": 0 }, "xn--vard-jra": { "$": 0 }, "varggat": { "$": 0 }, "xn--vrggt-xqad": { "$": 0 }, "vefsn": { "$": 0 }, "vaapste": { "$": 0 }, "vega": { "$": 0 }, "vegarshei": { "$": 0 }, "xn--vegrshei-c0a": { "$": 0 }, "vennesla": { "$": 0 }, "verdal": { "$": 0 }, "verran": { "$": 0 }, "vestby": { "$": 0 }, "vestnes": { "$": 0 }, "vestre-slidre": { "$": 0 }, "vestre-toten": { "$": 0 }, "vestvagoy": { "$": 0 }, "xn--vestvgy-ixa6o": { "$": 0 }, "vevelstad": { "$": 0 }, "vik": { "$": 0 }, "vikna": { "$": 0 }, "vindafjord": { "$": 0 }, "volda": { "$": 0 }, "voss": { "$": 0 }, "varoy": { "$": 0 }, "xn--vry-yla5g": { "$": 0 }, "vagan": { "$": 0 }, "xn--vgan-qoa": { "$": 0 }, "voagat": { "$": 0 }, "vagsoy": { "$": 0 }, "xn--vgsy-qoa0j": { "$": 0 }, "vaga": { "$": 0 }, "xn--vg-yiab": { "$": 0 }, "ostfold": { "valer": { "$": 0 } }, "xn--stfold-9xa": { "xn--vler-qoa": { "$": 0 } }, "co": { "$": 0 }, "blogspot": { "$": 0 } }, "np": { "*": { "$": 0 } }, "nr": { "$": 0, "biz": { "$": 0 }, "info": { "$": 0 }, "gov": { "$": 0 }, "edu": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "com": { "$": 0 } }, "nu": { "$": 0, "merseine": { "$": 0 }, "mine": { "$": 0 }, "shacknet": { "$": 0 }, "nom": { "$": 0 } }, "nz": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0, "blogspot": { "$": 0 } }, "cri": { "$": 0 }, "geek": { "$": 0 }, "gen": { "$": 0 }, "govt": { "$": 0 }, "health": { "$": 0 }, "iwi": { "$": 0 }, "kiwi": { "$": 0 }, "maori": { "$": 0 }, "mil": { "$": 0 }, "xn--mori-qsa": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "parliament": { "$": 0 }, "school": { "$": 0 }, "nym": { "$": 0 } }, "om": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "med": { "$": 0 }, "museum": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "pro": { "$": 0 } }, "onion": { "$": 0 }, "org": { "$": 0, "amune": { "tele": { "$": 0 } }, "pimienta": { "$": 0 }, "poivron": { "$": 0 }, "potager": { "$": 0 }, "sweetpepper": { "$": 0 }, "ae": { "$": 0 }, "us": { "$": 0 }, "certmgr": { "$": 0 }, "cdn77": { "c": { "$": 0 }, "rsc": { "$": 0 } }, "cdn77-secure": { "origin": { "ssl": { "$": 0 } } }, "cloudns": { "$": 0 }, "duckdns": { "$": 0 }, "tunk": { "$": 0 }, "dyndns": { "$": 0, "go": { "$": 0 }, "home": { "$": 0 } }, "blogdns": { "$": 0 }, "blogsite": { "$": 0 }, "boldlygoingnowhere": { "$": 0 }, "dnsalias": { "$": 0 }, "dnsdojo": { "$": 0 }, "doesntexist": { "$": 0 }, "dontexist": { "$": 0 }, "doomdns": { "$": 0 }, "dvrdns": { "$": 0 }, "dynalias": { "$": 0 }, "endofinternet": { "$": 0 }, "endoftheinternet": { "$": 0 }, "from-me": { "$": 0 }, "game-host": { "$": 0 }, "gotdns": { "$": 0 }, "hobby-site": { "$": 0 }, "homedns": { "$": 0 }, "homeftp": { "$": 0 }, "homelinux": { "$": 0 }, "homeunix": { "$": 0 }, "is-a-bruinsfan": { "$": 0 }, "is-a-candidate": { "$": 0 }, "is-a-celticsfan": { "$": 0 }, "is-a-chef": { "$": 0 }, "is-a-geek": { "$": 0 }, "is-a-knight": { "$": 0 }, "is-a-linux-user": { "$": 0 }, "is-a-patsfan": { "$": 0 }, "is-a-soxfan": { "$": 0 }, "is-found": { "$": 0 }, "is-lost": { "$": 0 }, "is-saved": { "$": 0 }, "is-very-bad": { "$": 0 }, "is-very-evil": { "$": 0 }, "is-very-good": { "$": 0 }, "is-very-nice": { "$": 0 }, "is-very-sweet": { "$": 0 }, "isa-geek": { "$": 0 }, "kicks-ass": { "$": 0 }, "misconfused": { "$": 0 }, "podzone": { "$": 0 }, "readmyblog": { "$": 0 }, "selfip": { "$": 0 }, "sellsyourhome": { "$": 0 }, "servebbs": { "$": 0 }, "serveftp": { "$": 0 }, "servegame": { "$": 0 }, "stuff-4-sale": { "$": 0 }, "webhop": { "$": 0 }, "ddnss": { "$": 0 }, "accesscam": { "$": 0 }, "camdvr": { "$": 0 }, "freeddns": { "$": 0 }, "mywire": { "$": 0 }, "webredirect": { "$": 0 }, "eu": { "$": 0, "al": { "$": 0 }, "asso": { "$": 0 }, "at": { "$": 0 }, "au": { "$": 0 }, "be": { "$": 0 }, "bg": { "$": 0 }, "ca": { "$": 0 }, "cd": { "$": 0 }, "ch": { "$": 0 }, "cn": { "$": 0 }, "cy": { "$": 0 }, "cz": { "$": 0 }, "de": { "$": 0 }, "dk": { "$": 0 }, "edu": { "$": 0 }, "ee": { "$": 0 }, "es": { "$": 0 }, "fi": { "$": 0 }, "fr": { "$": 0 }, "gr": { "$": 0 }, "hr": { "$": 0 }, "hu": { "$": 0 }, "ie": { "$": 0 }, "il": { "$": 0 }, "in": { "$": 0 }, "int": { "$": 0 }, "is": { "$": 0 }, "it": { "$": 0 }, "jp": { "$": 0 }, "kr": { "$": 0 }, "lt": { "$": 0 }, "lu": { "$": 0 }, "lv": { "$": 0 }, "mc": { "$": 0 }, "me": { "$": 0 }, "mk": { "$": 0 }, "mt": { "$": 0 }, "my": { "$": 0 }, "net": { "$": 0 }, "ng": { "$": 0 }, "nl": { "$": 0 }, "no": { "$": 0 }, "nz": { "$": 0 }, "paris": { "$": 0 }, "pl": { "$": 0 }, "pt": { "$": 0 }, "q-a": { "$": 0 }, "ro": { "$": 0 }, "ru": { "$": 0 }, "se": { "$": 0 }, "si": { "$": 0 }, "sk": { "$": 0 }, "tr": { "$": 0 }, "uk": { "$": 0 }, "us": { "$": 0 } }, "twmail": { "$": 0 }, "fedorainfracloud": { "$": 0 }, "fedorapeople": { "$": 0 }, "fedoraproject": { "cloud": { "$": 0 } }, "hepforge": { "$": 0 }, "js": { "$": 0 }, "bmoattachments": { "$": 0 }, "cable-modem": { "$": 0 }, "collegefan": { "$": 0 }, "couchpotatofries": { "$": 0 }, "mlbfan": { "$": 0 }, "mysecuritycamera": { "$": 0 }, "nflfan": { "$": 0 }, "read-books": { "$": 0 }, "ufcfan": { "$": 0 }, "hopto": { "$": 0 }, "myftp": { "$": 0 }, "no-ip": { "$": 0 }, "zapto": { "$": 0 }, "my-firewall": { "$": 0 }, "myfirewall": { "$": 0 }, "spdns": { "$": 0 }, "dsmynas": { "$": 0 }, "familyds": { "$": 0 }, "tuxfamily": { "$": 0 }, "diskstation": { "$": 0 }, "hk": { "$": 0 }, "wmflabs": { "$": 0 }, "za": { "$": 0 } }, "pa": { "$": 0, "ac": { "$": 0 }, "gob": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "sld": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 }, "ing": { "$": 0 }, "abo": { "$": 0 }, "med": { "$": 0 }, "nom": { "$": 0 } }, "pe": { "$": 0, "edu": { "$": 0 }, "gob": { "$": 0 }, "nom": { "$": 0 }, "mil": { "$": 0 }, "org": { "$": 0 }, "com": { "$": 0 }, "net": { "$": 0 }, "blogspot": { "$": 0 }, "nym": { "$": 0 } }, "pf": { "$": 0, "com": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 } }, "pg": { "*": { "$": 0 } }, "ph": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "edu": { "$": 0 }, "ngo": { "$": 0 }, "mil": { "$": 0 }, "i": { "$": 0 } }, "pk": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "edu": { "$": 0 }, "org": { "$": 0 }, "fam": { "$": 0 }, "biz": { "$": 0 }, "web": { "$": 0 }, "gov": { "$": 0 }, "gob": { "$": 0 }, "gok": { "$": 0 }, "gon": { "$": 0 }, "gop": { "$": 0 }, "gos": { "$": 0 }, "info": { "$": 0 } }, "pl": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "aid": { "$": 0 }, "agro": { "$": 0 }, "atm": { "$": 0 }, "auto": { "$": 0 }, "biz": { "$": 0 }, "edu": { "$": 0 }, "gmina": { "$": 0 }, "gsm": { "$": 0 }, "info": { "$": 0 }, "mail": { "$": 0 }, "miasta": { "$": 0 }, "media": { "$": 0 }, "mil": { "$": 0 }, "nieruchomosci": { "$": 0 }, "nom": { "$": 0 }, "pc": { "$": 0 }, "powiat": { "$": 0 }, "priv": { "$": 0 }, "realestate": { "$": 0 }, "rel": { "$": 0 }, "sex": { "$": 0 }, "shop": { "$": 0 }, "sklep": { "$": 0 }, "sos": { "$": 0 }, "szkola": { "$": 0 }, "targi": { "$": 0 }, "tm": { "$": 0 }, "tourism": { "$": 0 }, "travel": { "$": 0 }, "turystyka": { "$": 0 }, "gov": { "$": 0, "ap": { "$": 0 }, "ic": { "$": 0 }, "is": { "$": 0 }, "us": { "$": 0 }, "kmpsp": { "$": 0 }, "kppsp": { "$": 0 }, "kwpsp": { "$": 0 }, "psp": { "$": 0 }, "wskr": { "$": 0 }, "kwp": { "$": 0 }, "mw": { "$": 0 }, "ug": { "$": 0 }, "um": { "$": 0 }, "umig": { "$": 0 }, "ugim": { "$": 0 }, "upow": { "$": 0 }, "uw": { "$": 0 }, "starostwo": { "$": 0 }, "pa": { "$": 0 }, "po": { "$": 0 }, "psse": { "$": 0 }, "pup": { "$": 0 }, "rzgw": { "$": 0 }, "sa": { "$": 0 }, "so": { "$": 0 }, "sr": { "$": 0 }, "wsa": { "$": 0 }, "sko": { "$": 0 }, "uzs": { "$": 0 }, "wiih": { "$": 0 }, "winb": { "$": 0 }, "pinb": { "$": 0 }, "wios": { "$": 0 }, "witd": { "$": 0 }, "wzmiuw": { "$": 0 }, "piw": { "$": 0 }, "wiw": { "$": 0 }, "griw": { "$": 0 }, "wif": { "$": 0 }, "oum": { "$": 0 }, "sdn": { "$": 0 }, "zp": { "$": 0 }, "uppo": { "$": 0 }, "mup": { "$": 0 }, "wuoz": { "$": 0 }, "konsulat": { "$": 0 }, "oirm": { "$": 0 } }, "augustow": { "$": 0 }, "babia-gora": { "$": 0 }, "bedzin": { "$": 0 }, "beskidy": { "$": 0 }, "bialowieza": { "$": 0 }, "bialystok": { "$": 0 }, "bielawa": { "$": 0 }, "bieszczady": { "$": 0 }, "boleslawiec": { "$": 0 }, "bydgoszcz": { "$": 0 }, "bytom": { "$": 0 }, "cieszyn": { "$": 0 }, "czeladz": { "$": 0 }, "czest": { "$": 0 }, "dlugoleka": { "$": 0 }, "elblag": { "$": 0 }, "elk": { "$": 0 }, "glogow": { "$": 0 }, "gniezno": { "$": 0 }, "gorlice": { "$": 0 }, "grajewo": { "$": 0 }, "ilawa": { "$": 0 }, "jaworzno": { "$": 0 }, "jelenia-gora": { "$": 0 }, "jgora": { "$": 0 }, "kalisz": { "$": 0 }, "kazimierz-dolny": { "$": 0 }, "karpacz": { "$": 0 }, "kartuzy": { "$": 0 }, "kaszuby": { "$": 0 }, "katowice": { "$": 0 }, "kepno": { "$": 0 }, "ketrzyn": { "$": 0 }, "klodzko": { "$": 0 }, "kobierzyce": { "$": 0 }, "kolobrzeg": { "$": 0 }, "konin": { "$": 0 }, "konskowola": { "$": 0 }, "kutno": { "$": 0 }, "lapy": { "$": 0 }, "lebork": { "$": 0 }, "legnica": { "$": 0 }, "lezajsk": { "$": 0 }, "limanowa": { "$": 0 }, "lomza": { "$": 0 }, "lowicz": { "$": 0 }, "lubin": { "$": 0 }, "lukow": { "$": 0 }, "malbork": { "$": 0 }, "malopolska": { "$": 0 }, "mazowsze": { "$": 0 }, "mazury": { "$": 0 }, "mielec": { "$": 0 }, "mielno": { "$": 0 }, "mragowo": { "$": 0 }, "naklo": { "$": 0 }, "nowaruda": { "$": 0 }, "nysa": { "$": 0 }, "olawa": { "$": 0 }, "olecko": { "$": 0 }, "olkusz": { "$": 0 }, "olsztyn": { "$": 0 }, "opoczno": { "$": 0 }, "opole": { "$": 0 }, "ostroda": { "$": 0 }, "ostroleka": { "$": 0 }, "ostrowiec": { "$": 0 }, "ostrowwlkp": { "$": 0 }, "pila": { "$": 0 }, "pisz": { "$": 0 }, "podhale": { "$": 0 }, "podlasie": { "$": 0 }, "polkowice": { "$": 0 }, "pomorze": { "$": 0 }, "pomorskie": { "$": 0 }, "prochowice": { "$": 0 }, "pruszkow": { "$": 0 }, "przeworsk": { "$": 0 }, "pulawy": { "$": 0 }, "radom": { "$": 0 }, "rawa-maz": { "$": 0 }, "rybnik": { "$": 0 }, "rzeszow": { "$": 0 }, "sanok": { "$": 0 }, "sejny": { "$": 0 }, "slask": { "$": 0 }, "slupsk": { "$": 0 }, "sosnowiec": { "$": 0 }, "stalowa-wola": { "$": 0 }, "skoczow": { "$": 0 }, "starachowice": { "$": 0 }, "stargard": { "$": 0 }, "suwalki": { "$": 0 }, "swidnica": { "$": 0 }, "swiebodzin": { "$": 0 }, "swinoujscie": { "$": 0 }, "szczecin": { "$": 0 }, "szczytno": { "$": 0 }, "tarnobrzeg": { "$": 0 }, "tgory": { "$": 0 }, "turek": { "$": 0 }, "tychy": { "$": 0 }, "ustka": { "$": 0 }, "walbrzych": { "$": 0 }, "warmia": { "$": 0 }, "warszawa": { "$": 0 }, "waw": { "$": 0 }, "wegrow": { "$": 0 }, "wielun": { "$": 0 }, "wlocl": { "$": 0 }, "wloclawek": { "$": 0 }, "wodzislaw": { "$": 0 }, "wolomin": { "$": 0 }, "wroclaw": { "$": 0 }, "zachpomor": { "$": 0 }, "zagan": { "$": 0 }, "zarow": { "$": 0 }, "zgora": { "$": 0 }, "zgorzelec": { "$": 0 }, "beep": { "$": 0 }, "co": { "$": 0 }, "art": { "$": 0 }, "gliwice": { "$": 0 }, "krakow": { "$": 0 }, "poznan": { "$": 0 }, "wroc": { "$": 0 }, "zakopane": { "$": 0 }, "gda": { "$": 0 }, "gdansk": { "$": 0 }, "gdynia": { "$": 0 }, "med": { "$": 0 }, "sopot": { "$": 0 } }, "pm": { "$": 0 }, "pn": { "$": 0, "gov": { "$": 0 }, "co": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 } }, "post": { "$": 0 }, "pr": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "edu": { "$": 0 }, "isla": { "$": 0 }, "pro": { "$": 0 }, "biz": { "$": 0 }, "info": { "$": 0 }, "name": { "$": 0 }, "est": { "$": 0 }, "prof": { "$": 0 }, "ac": { "$": 0 } }, "pro": { "$": 0, "aaa": { "$": 0 }, "aca": { "$": 0 }, "acct": { "$": 0 }, "avocat": { "$": 0 }, "bar": { "$": 0 }, "cpa": { "$": 0 }, "eng": { "$": 0 }, "jur": { "$": 0 }, "law": { "$": 0 }, "med": { "$": 0 }, "recht": { "$": 0 }, "cloudns": { "$": 0 } }, "ps": { "$": 0, "edu": { "$": 0 }, "gov": { "$": 0 }, "sec": { "$": 0 }, "plo": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 } }, "pt": { "$": 0, "net": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "int": { "$": 0 }, "publ": { "$": 0 }, "com": { "$": 0 }, "nome": { "$": 0 }, "blogspot": { "$": 0 }, "nym": { "$": 0 } }, "pw": { "$": 0, "co": { "$": 0 }, "ne": { "$": 0 }, "or": { "$": 0 }, "ed": { "$": 0 }, "go": { "$": 0 }, "belau": { "$": 0 }, "cloudns": { "$": 0 }, "nom": { "$": 0 } }, "py": { "$": 0, "com": { "$": 0 }, "coop": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "qa": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "name": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "sch": { "$": 0 }, "blogspot": { "$": 0 }, "nom": { "$": 0 } }, "re": { "$": 0, "asso": { "$": 0 }, "com": { "$": 0 }, "nom": { "$": 0 }, "blogspot": { "$": 0 } }, "ro": { "$": 0, "arts": { "$": 0 }, "com": { "$": 0 }, "firm": { "$": 0 }, "info": { "$": 0 }, "nom": { "$": 0 }, "nt": { "$": 0 }, "org": { "$": 0 }, "rec": { "$": 0 }, "store": { "$": 0 }, "tm": { "$": 0 }, "www": { "$": 0 }, "shop": { "$": 0 }, "blogspot": { "$": 0 } }, "rs": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "in": { "$": 0 }, "org": { "$": 0 }, "blogspot": { "$": 0 }, "nom": { "$": 0 } }, "ru": { "$": 0, "ac": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "int": { "$": 0 }, "mil": { "$": 0 }, "test": { "$": 0 }, "adygeya": { "$": 0 }, "bashkiria": { "$": 0 }, "bir": { "$": 0 }, "cbg": { "$": 0 }, "com": { "$": 0 }, "dagestan": { "$": 0 }, "grozny": { "$": 0 }, "kalmykia": { "$": 0 }, "kustanai": { "$": 0 }, "marine": { "$": 0 }, "mordovia": { "$": 0 }, "msk": { "$": 0 }, "mytis": { "$": 0 }, "nalchik": { "$": 0 }, "nov": { "$": 0 }, "pyatigorsk": { "$": 0 }, "spb": { "$": 0 }, "vladikavkaz": { "$": 0 }, "vladimir": { "$": 0 }, "blogspot": { "$": 0 }, "cldmail": { "hb": { "$": 0 } }, "net": { "$": 0 }, "org": { "$": 0 }, "pp": { "$": 0 } }, "rw": { "$": 0, "gov": { "$": 0 }, "net": { "$": 0 }, "edu": { "$": 0 }, "ac": { "$": 0 }, "com": { "$": 0 }, "co": { "$": 0 }, "int": { "$": 0 }, "mil": { "$": 0 }, "gouv": { "$": 0 } }, "sa": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "med": { "$": 0 }, "pub": { "$": 0 }, "edu": { "$": 0 }, "sch": { "$": 0 } }, "sb": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "sc": { "$": 0, "com": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 } }, "sd": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "med": { "$": 0 }, "tv": { "$": 0 }, "gov": { "$": 0 }, "info": { "$": 0 } }, "se": { "$": 0, "a": { "$": 0 }, "ac": { "$": 0 }, "b": { "$": 0 }, "bd": { "$": 0 }, "brand": { "$": 0 }, "c": { "$": 0 }, "d": { "$": 0 }, "e": { "$": 0 }, "f": { "$": 0 }, "fh": { "$": 0 }, "fhsk": { "$": 0 }, "fhv": { "$": 0 }, "g": { "$": 0 }, "h": { "$": 0 }, "i": { "$": 0 }, "k": { "$": 0 }, "komforb": { "$": 0 }, "kommunalforbund": { "$": 0 }, "komvux": { "$": 0 }, "l": { "$": 0 }, "lanbib": { "$": 0 }, "m": { "$": 0 }, "n": { "$": 0 }, "naturbruksgymn": { "$": 0 }, "o": { "$": 0 }, "org": { "$": 0 }, "p": { "$": 0 }, "parti": { "$": 0 }, "pp": { "$": 0 }, "press": { "$": 0 }, "r": { "$": 0 }, "s": { "$": 0 }, "t": { "$": 0 }, "tm": { "$": 0 }, "u": { "$": 0 }, "w": { "$": 0 }, "x": { "$": 0 }, "y": { "$": 0 }, "z": { "$": 0 }, "com": { "$": 0 }, "blogspot": { "$": 0 } }, "sg": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "edu": { "$": 0 }, "per": { "$": 0 }, "blogspot": { "$": 0 } }, "sh": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 }, "mil": { "$": 0 }, "hashbang": { "$": 0 }, "platform": { "*": { "$": 0 } }, "wedeploy": { "$": 0 }, "now": { "$": 0 } }, "si": { "$": 0, "blogspot": { "$": 0 }, "nom": { "$": 0 } }, "sj": { "$": 0 }, "sk": { "$": 0, "blogspot": { "$": 0 }, "nym": { "$": 0 } }, "sl": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "org": { "$": 0 } }, "sm": { "$": 0 }, "sn": { "$": 0, "art": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gouv": { "$": 0 }, "org": { "$": 0 }, "perso": { "$": 0 }, "univ": { "$": 0 }, "blogspot": { "$": 0 } }, "so": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "sr": { "$": 0 }, "st": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "consulado": { "$": 0 }, "edu": { "$": 0 }, "embaixada": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "principe": { "$": 0 }, "saotome": { "$": 0 }, "store": { "$": 0 } }, "su": { "$": 0, "abkhazia": { "$": 0 }, "adygeya": { "$": 0 }, "aktyubinsk": { "$": 0 }, "arkhangelsk": { "$": 0 }, "armenia": { "$": 0 }, "ashgabad": { "$": 0 }, "azerbaijan": { "$": 0 }, "balashov": { "$": 0 }, "bashkiria": { "$": 0 }, "bryansk": { "$": 0 }, "bukhara": { "$": 0 }, "chimkent": { "$": 0 }, "dagestan": { "$": 0 }, "east-kazakhstan": { "$": 0 }, "exnet": { "$": 0 }, "georgia": { "$": 0 }, "grozny": { "$": 0 }, "ivanovo": { "$": 0 }, "jambyl": { "$": 0 }, "kalmykia": { "$": 0 }, "kaluga": { "$": 0 }, "karacol": { "$": 0 }, "karaganda": { "$": 0 }, "karelia": { "$": 0 }, "khakassia": { "$": 0 }, "krasnodar": { "$": 0 }, "kurgan": { "$": 0 }, "kustanai": { "$": 0 }, "lenug": { "$": 0 }, "mangyshlak": { "$": 0 }, "mordovia": { "$": 0 }, "msk": { "$": 0 }, "murmansk": { "$": 0 }, "nalchik": { "$": 0 }, "navoi": { "$": 0 }, "north-kazakhstan": { "$": 0 }, "nov": { "$": 0 }, "obninsk": { "$": 0 }, "penza": { "$": 0 }, "pokrovsk": { "$": 0 }, "sochi": { "$": 0 }, "spb": { "$": 0 }, "tashkent": { "$": 0 }, "termez": { "$": 0 }, "togliatti": { "$": 0 }, "troitsk": { "$": 0 }, "tselinograd": { "$": 0 }, "tula": { "$": 0 }, "tuva": { "$": 0 }, "vladikavkaz": { "$": 0 }, "vladimir": { "$": 0 }, "vologda": { "$": 0 }, "nym": { "$": 0 } }, "sv": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gob": { "$": 0 }, "org": { "$": 0 }, "red": { "$": 0 } }, "sx": { "$": 0, "gov": { "$": 0 }, "nym": { "$": 0 } }, "sy": { "$": 0, "edu": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "mil": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 } }, "sz": { "$": 0, "co": { "$": 0 }, "ac": { "$": 0 }, "org": { "$": 0 } }, "tc": { "$": 0 }, "td": { "$": 0, "blogspot": { "$": 0 } }, "tel": { "$": 0 }, "tf": { "$": 0 }, "tg": { "$": 0 }, "th": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0 }, "go": { "$": 0 }, "in": { "$": 0 }, "mi": { "$": 0 }, "net": { "$": 0 }, "or": { "$": 0 } }, "tj": { "$": 0, "ac": { "$": 0 }, "biz": { "$": 0 }, "co": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "go": { "$": 0 }, "gov": { "$": 0 }, "int": { "$": 0 }, "mil": { "$": 0 }, "name": { "$": 0 }, "net": { "$": 0 }, "nic": { "$": 0 }, "org": { "$": 0 }, "test": { "$": 0 }, "web": { "$": 0 } }, "tk": { "$": 0 }, "tl": { "$": 0, "gov": { "$": 0 } }, "tm": { "$": 0, "com": { "$": 0 }, "co": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "nom": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "edu": { "$": 0 } }, "tn": { "$": 0, "com": { "$": 0 }, "ens": { "$": 0 }, "fin": { "$": 0 }, "gov": { "$": 0 }, "ind": { "$": 0 }, "intl": { "$": 0 }, "nat": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "info": { "$": 0 }, "perso": { "$": 0 }, "tourism": { "$": 0 }, "edunet": { "$": 0 }, "rnrt": { "$": 0 }, "rns": { "$": 0 }, "rnu": { "$": 0 }, "mincom": { "$": 0 }, "agrinet": { "$": 0 }, "defense": { "$": 0 }, "turen": { "$": 0 } }, "to": { "$": 0, "com": { "$": 0 }, "gov": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "mil": { "$": 0 }, "vpnplus": { "$": 0 } }, "tr": { "$": 0, "com": { "$": 0, "blogspot": { "$": 0 } }, "info": { "$": 0 }, "biz": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "web": { "$": 0 }, "gen": { "$": 0 }, "tv": { "$": 0 }, "av": { "$": 0 }, "dr": { "$": 0 }, "bbs": { "$": 0 }, "name": { "$": 0 }, "tel": { "$": 0 }, "gov": { "$": 0 }, "bel": { "$": 0 }, "pol": { "$": 0 }, "mil": { "$": 0 }, "k12": { "$": 0 }, "edu": { "$": 0 }, "kep": { "$": 0 }, "nc": { "$": 0, "gov": { "$": 0 } } }, "travel": { "$": 0 }, "tt": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "net": { "$": 0 }, "biz": { "$": 0 }, "info": { "$": 0 }, "pro": { "$": 0 }, "int": { "$": 0 }, "coop": { "$": 0 }, "jobs": { "$": 0 }, "mobi": { "$": 0 }, "travel": { "$": 0 }, "museum": { "$": 0 }, "aero": { "$": 0 }, "name": { "$": 0 }, "gov": { "$": 0 }, "edu": { "$": 0 } }, "tv": { "$": 0, "dyndns": { "$": 0 }, "better-than": { "$": 0 }, "on-the-web": { "$": 0 }, "worse-than": { "$": 0 } }, "tw": { "$": 0, "edu": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "com": { "$": 0, "mymailer": { "$": 0 } }, "net": { "$": 0 }, "org": { "$": 0 }, "idv": { "$": 0 }, "game": { "$": 0 }, "ebiz": { "$": 0 }, "club": { "$": 0 }, "xn--zf0ao64a": { "$": 0 }, "xn--uc0atv": { "$": 0 }, "xn--czrw28b": { "$": 0 }, "url": { "$": 0 }, "blogspot": { "$": 0 }, "nym": { "$": 0 } }, "tz": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0 }, "go": { "$": 0 }, "hotel": { "$": 0 }, "info": { "$": 0 }, "me": { "$": 0 }, "mil": { "$": 0 }, "mobi": { "$": 0 }, "ne": { "$": 0 }, "or": { "$": 0 }, "sc": { "$": 0 }, "tv": { "$": 0 } }, "ua": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "in": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "cherkassy": { "$": 0 }, "cherkasy": { "$": 0 }, "chernigov": { "$": 0 }, "chernihiv": { "$": 0 }, "chernivtsi": { "$": 0 }, "chernovtsy": { "$": 0 }, "ck": { "$": 0 }, "cn": { "$": 0 }, "cr": { "$": 0 }, "crimea": { "$": 0 }, "cv": { "$": 0 }, "dn": { "$": 0 }, "dnepropetrovsk": { "$": 0 }, "dnipropetrovsk": { "$": 0 }, "dominic": { "$": 0 }, "donetsk": { "$": 0 }, "dp": { "$": 0 }, "if": { "$": 0 }, "ivano-frankivsk": { "$": 0 }, "kh": { "$": 0 }, "kharkiv": { "$": 0 }, "kharkov": { "$": 0 }, "kherson": { "$": 0 }, "khmelnitskiy": { "$": 0 }, "khmelnytskyi": { "$": 0 }, "kiev": { "$": 0 }, "kirovograd": { "$": 0 }, "km": { "$": 0 }, "kr": { "$": 0 }, "krym": { "$": 0 }, "ks": { "$": 0 }, "kv": { "$": 0 }, "kyiv": { "$": 0 }, "lg": { "$": 0 }, "lt": { "$": 0 }, "lugansk": { "$": 0 }, "lutsk": { "$": 0 }, "lv": { "$": 0 }, "lviv": { "$": 0 }, "mk": { "$": 0 }, "mykolaiv": { "$": 0 }, "nikolaev": { "$": 0 }, "od": { "$": 0 }, "odesa": { "$": 0 }, "odessa": { "$": 0 }, "pl": { "$": 0 }, "poltava": { "$": 0 }, "rivne": { "$": 0 }, "rovno": { "$": 0 }, "rv": { "$": 0 }, "sb": { "$": 0 }, "sebastopol": { "$": 0 }, "sevastopol": { "$": 0 }, "sm": { "$": 0 }, "sumy": { "$": 0 }, "te": { "$": 0 }, "ternopil": { "$": 0 }, "uz": { "$": 0 }, "uzhgorod": { "$": 0 }, "vinnica": { "$": 0 }, "vinnytsia": { "$": 0 }, "vn": { "$": 0 }, "volyn": { "$": 0 }, "yalta": { "$": 0 }, "zaporizhzhe": { "$": 0 }, "zaporizhzhia": { "$": 0 }, "zhitomir": { "$": 0 }, "zhytomyr": { "$": 0 }, "zp": { "$": 0 }, "zt": { "$": 0 }, "cc": { "$": 0 }, "inf": { "$": 0 }, "ltd": { "$": 0 }, "biz": { "$": 0 }, "co": { "$": 0 }, "pp": { "$": 0 } }, "ug": { "$": 0, "co": { "$": 0 }, "or": { "$": 0 }, "ac": { "$": 0 }, "sc": { "$": 0 }, "go": { "$": 0 }, "ne": { "$": 0 }, "com": { "$": 0 }, "org": { "$": 0 }, "blogspot": { "$": 0 }, "nom": { "$": 0 } }, "uk": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0, "blogspot": { "$": 0 }, "no-ip": { "$": 0 }, "wellbeingzone": { "$": 0 } }, "gov": { "$": 0, "service": { "$": 0 }, "homeoffice": { "$": 0 } }, "ltd": { "$": 0 }, "me": { "$": 0 }, "net": { "$": 0 }, "nhs": { "$": 0 }, "org": { "$": 0 }, "plc": { "$": 0 }, "police": { "$": 0 }, "sch": { "*": { "$": 0 } } }, "us": { "$": 0, "dni": { "$": 0 }, "fed": { "$": 0 }, "isa": { "$": 0 }, "kids": { "$": 0 }, "nsn": { "$": 0 }, "ak": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "al": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ar": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "as": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "az": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ca": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "co": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ct": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "dc": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "de": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "fl": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ga": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "gu": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "hi": { "$": 0, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ia": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "id": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "il": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "in": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ks": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ky": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "la": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ma": { "$": 0, "k12": { "$": 0, "pvt": { "$": 0 }, "chtr": { "$": 0 }, "paroch": { "$": 0 } }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "md": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "me": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "mi": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 }, "ann-arbor": { "$": 0 }, "cog": { "$": 0 }, "dst": { "$": 0 }, "eaton": { "$": 0 }, "gen": { "$": 0 }, "mus": { "$": 0 }, "tec": { "$": 0 }, "washtenaw": { "$": 0 } }, "mn": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "mo": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ms": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "mt": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "nc": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "nd": { "$": 0, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ne": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "nh": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "nj": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "nm": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "nv": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ny": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "oh": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ok": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "or": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "pa": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "pr": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ri": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "sc": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "sd": { "$": 0, "cc": { "$": 0 }, "lib": { "$": 0 } }, "tn": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "tx": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "ut": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "vi": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "vt": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "va": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "wa": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "wi": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "wv": { "$": 0, "cc": { "$": 0 } }, "wy": { "$": 0, "k12": { "$": 0 }, "cc": { "$": 0 }, "lib": { "$": 0 } }, "cloudns": { "$": 0 }, "drud": { "$": 0 }, "is-by": { "$": 0 }, "land-4-sale": { "$": 0 }, "stuff-4-sale": { "$": 0 }, "golffan": { "$": 0 }, "noip": { "$": 0 }, "pointto": { "$": 0 } }, "uy": { "$": 0, "com": { "$": 0, "blogspot": { "$": 0 } }, "edu": { "$": 0 }, "gub": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "nom": { "$": 0 } }, "uz": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "va": { "$": 0 }, "vc": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "edu": { "$": 0 }, "nom": { "$": 0 } }, "ve": { "$": 0, "arts": { "$": 0 }, "co": { "$": 0 }, "com": { "$": 0 }, "e12": { "$": 0 }, "edu": { "$": 0 }, "firm": { "$": 0 }, "gob": { "$": 0 }, "gov": { "$": 0 }, "info": { "$": 0 }, "int": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "rec": { "$": 0 }, "store": { "$": 0 }, "tec": { "$": 0 }, "web": { "$": 0 } }, "vg": { "$": 0, "nom": { "$": 0 } }, "vi": { "$": 0, "co": { "$": 0 }, "com": { "$": 0 }, "k12": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "vn": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "int": { "$": 0 }, "ac": { "$": 0 }, "biz": { "$": 0 }, "info": { "$": 0 }, "name": { "$": 0 }, "pro": { "$": 0 }, "health": { "$": 0 }, "blogspot": { "$": 0 } }, "vu": { "$": 0, "com": { "$": 0 }, "edu": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 } }, "wf": { "$": 0 }, "ws": { "$": 0, "com": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "gov": { "$": 0 }, "edu": { "$": 0 }, "advisor": { "*": { "$": 0 } }, "dyndns": { "$": 0 }, "mypets": { "$": 0 } }, "yt": { "$": 0 }, "xn--mgbaam7a8h": { "$": 0 }, "xn--y9a3aq": { "$": 0 }, "xn--54b7fta0cc": { "$": 0 }, "xn--90ae": { "$": 0 }, "xn--90ais": { "$": 0 }, "xn--fiqs8s": { "$": 0 }, "xn--fiqz9s": { "$": 0 }, "xn--lgbbat1ad8j": { "$": 0 }, "xn--wgbh1c": { "$": 0 }, "xn--e1a4c": { "$": 0 }, "xn--node": { "$": 0 }, "xn--qxam": { "$": 0 }, "xn--j6w193g": { "$": 0 }, "xn--2scrj9c": { "$": 0 }, "xn--3hcrj9c": { "$": 0 }, "xn--45br5cyl": { "$": 0 }, "xn--h2breg3eve": { "$": 0 }, "xn--h2brj9c8c": { "$": 0 }, "xn--mgbgu82a": { "$": 0 }, "xn--rvc1e0am3e": { "$": 0 }, "xn--h2brj9c": { "$": 0 }, "xn--mgbbh1a71e": { "$": 0 }, "xn--fpcrj9c3d": { "$": 0 }, "xn--gecrj9c": { "$": 0 }, "xn--s9brj9c": { "$": 0 }, "xn--45brj9c": { "$": 0 }, "xn--xkc2dl3a5ee0h": { "$": 0 }, "xn--mgba3a4f16a": { "$": 0 }, "xn--mgba3a4fra": { "$": 0 }, "xn--mgbtx2b": { "$": 0 }, "xn--mgbayh7gpa": { "$": 0 }, "xn--3e0b707e": { "$": 0 }, "xn--80ao21a": { "$": 0 }, "xn--fzc2c9e2c": { "$": 0 }, "xn--xkc2al3hye2a": { "$": 0 }, "xn--mgbc0a9azcg": { "$": 0 }, "xn--d1alf": { "$": 0 }, "xn--l1acc": { "$": 0 }, "xn--mix891f": { "$": 0 }, "xn--mix082f": { "$": 0 }, "xn--mgbx4cd0ab": { "$": 0 }, "xn--mgb9awbf": { "$": 0 }, "xn--mgbai9azgqp6j": { "$": 0 }, "xn--mgbai9a5eva00b": { "$": 0 }, "xn--ygbi2ammx": { "$": 0 }, "xn--90a3ac": { "$": 0, "xn--o1ac": { "$": 0 }, "xn--c1avg": { "$": 0 }, "xn--90azh": { "$": 0 }, "xn--d1at": { "$": 0 }, "xn--o1ach": { "$": 0 }, "xn--80au": { "$": 0 } }, "xn--p1ai": { "$": 0 }, "xn--wgbl6a": { "$": 0 }, "xn--mgberp4a5d4ar": { "$": 0 }, "xn--mgberp4a5d4a87g": { "$": 0 }, "xn--mgbqly7c0a67fbc": { "$": 0 }, "xn--mgbqly7cvafr": { "$": 0 }, "xn--mgbpl2fh": { "$": 0 }, "xn--yfro4i67o": { "$": 0 }, "xn--clchc0ea0b2g2a9gcd": { "$": 0 }, "xn--ogbpf8fl": { "$": 0 }, "xn--mgbtf8fl": { "$": 0 }, "xn--o3cw4h": { "$": 0, "xn--12c1fe0br": { "$": 0 }, "xn--12co0c3b4eva": { "$": 0 }, "xn--h3cuzk1di": { "$": 0 }, "xn--o3cyx2a": { "$": 0 }, "xn--m3ch0j3a": { "$": 0 }, "xn--12cfi8ixb8l": { "$": 0 } }, "xn--pgbs0dh": { "$": 0 }, "xn--kpry57d": { "$": 0 }, "xn--kprw13d": { "$": 0 }, "xn--nnx388a": { "$": 0 }, "xn--j1amh": { "$": 0 }, "xn--mgb2ddes": { "$": 0 }, "xxx": { "$": 0 }, "ye": { "*": { "$": 0 } }, "za": { "ac": { "$": 0 }, "agric": { "$": 0 }, "alt": { "$": 0 }, "co": { "$": 0, "blogspot": { "$": 0 } }, "edu": { "$": 0 }, "gov": { "$": 0 }, "grondar": { "$": 0 }, "law": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "ngo": { "$": 0 }, "nis": { "$": 0 }, "nom": { "$": 0 }, "org": { "$": 0 }, "school": { "$": 0 }, "tm": { "$": 0 }, "web": { "$": 0 } }, "zm": { "$": 0, "ac": { "$": 0 }, "biz": { "$": 0 }, "co": { "$": 0 }, "com": { "$": 0 }, "edu": { "$": 0 }, "gov": { "$": 0 }, "info": { "$": 0 }, "mil": { "$": 0 }, "net": { "$": 0 }, "org": { "$": 0 }, "sch": { "$": 0 } }, "zw": { "$": 0, "ac": { "$": 0 }, "co": { "$": 0 }, "gov": { "$": 0 }, "mil": { "$": 0 }, "org": { "$": 0 } }, "aaa": { "$": 0 }, "aarp": { "$": 0 }, "abarth": { "$": 0 }, "abb": { "$": 0 }, "abbott": { "$": 0 }, "abbvie": { "$": 0 }, "abc": { "$": 0 }, "able": { "$": 0 }, "abogado": { "$": 0 }, "abudhabi": { "$": 0 }, "academy": { "$": 0 }, "accenture": { "$": 0 }, "accountant": { "$": 0 }, "accountants": { "$": 0 }, "aco": { "$": 0 }, "active": { "$": 0 }, "actor": { "$": 0 }, "adac": { "$": 0 }, "ads": { "$": 0 }, "adult": { "$": 0 }, "aeg": { "$": 0 }, "aetna": { "$": 0 }, "afamilycompany": { "$": 0 }, "afl": { "$": 0 }, "africa": { "$": 0 }, "agakhan": { "$": 0 }, "agency": { "$": 0 }, "aig": { "$": 0 }, "aigo": { "$": 0 }, "airbus": { "$": 0 }, "airforce": { "$": 0 }, "airtel": { "$": 0 }, "akdn": { "$": 0 }, "alfaromeo": { "$": 0 }, "alibaba": { "$": 0 }, "alipay": { "$": 0 }, "allfinanz": { "$": 0 }, "allstate": { "$": 0 }, "ally": { "$": 0 }, "alsace": { "$": 0 }, "alstom": { "$": 0 }, "americanexpress": { "$": 0 }, "americanfamily": { "$": 0 }, "amex": { "$": 0 }, "amfam": { "$": 0 }, "amica": { "$": 0 }, "amsterdam": { "$": 0 }, "analytics": { "$": 0 }, "android": { "$": 0 }, "anquan": { "$": 0 }, "anz": { "$": 0 }, "aol": { "$": 0 }, "apartments": { "$": 0 }, "app": { "$": 0 }, "apple": { "$": 0 }, "aquarelle": { "$": 0 }, "arab": { "$": 0 }, "aramco": { "$": 0 }, "archi": { "$": 0 }, "army": { "$": 0 }, "art": { "$": 0 }, "arte": { "$": 0 }, "asda": { "$": 0 }, "associates": { "$": 0 }, "athleta": { "$": 0 }, "attorney": { "$": 0 }, "auction": { "$": 0 }, "audi": { "$": 0 }, "audible": { "$": 0 }, "audio": { "$": 0 }, "auspost": { "$": 0 }, "author": { "$": 0 }, "auto": { "$": 0 }, "autos": { "$": 0 }, "avianca": { "$": 0 }, "aws": { "$": 0 }, "axa": { "$": 0 }, "azure": { "$": 0 }, "baby": { "$": 0 }, "baidu": { "$": 0 }, "banamex": { "$": 0 }, "bananarepublic": { "$": 0 }, "band": { "$": 0 }, "bank": { "$": 0 }, "bar": { "$": 0 }, "barcelona": { "$": 0 }, "barclaycard": { "$": 0 }, "barclays": { "$": 0 }, "barefoot": { "$": 0 }, "bargains": { "$": 0 }, "baseball": { "$": 0 }, "basketball": { "$": 0 }, "bauhaus": { "$": 0 }, "bayern": { "$": 0 }, "bbc": { "$": 0 }, "bbt": { "$": 0 }, "bbva": { "$": 0 }, "bcg": { "$": 0 }, "bcn": { "$": 0 }, "beats": { "$": 0 }, "beauty": { "$": 0 }, "beer": { "$": 0 }, "bentley": { "$": 0 }, "berlin": { "$": 0 }, "best": { "$": 0 }, "bestbuy": { "$": 0 }, "bet": { "$": 0 }, "bharti": { "$": 0 }, "bible": { "$": 0 }, "bid": { "$": 0 }, "bike": { "$": 0 }, "bing": { "$": 0 }, "bingo": { "$": 0 }, "bio": { "$": 0 }, "black": { "$": 0 }, "blackfriday": { "$": 0 }, "blanco": { "$": 0 }, "blockbuster": { "$": 0 }, "blog": { "$": 0 }, "bloomberg": { "$": 0 }, "blue": { "$": 0 }, "bms": { "$": 0 }, "bmw": { "$": 0 }, "bnl": { "$": 0 }, "bnpparibas": { "$": 0 }, "boats": { "$": 0 }, "boehringer": { "$": 0 }, "bofa": { "$": 0 }, "bom": { "$": 0 }, "bond": { "$": 0 }, "boo": { "$": 0 }, "book": { "$": 0 }, "booking": { "$": 0 }, "boots": { "$": 0 }, "bosch": { "$": 0 }, "bostik": { "$": 0 }, "boston": { "$": 0 }, "bot": { "$": 0 }, "boutique": { "$": 0 }, "box": { "$": 0 }, "bradesco": { "$": 0 }, "bridgestone": { "$": 0 }, "broadway": { "$": 0 }, "broker": { "$": 0 }, "brother": { "$": 0 }, "brussels": { "$": 0 }, "budapest": { "$": 0 }, "bugatti": { "$": 0 }, "build": { "$": 0 }, "builders": { "$": 0 }, "business": { "$": 0 }, "buy": { "$": 0 }, "buzz": { "$": 0 }, "bzh": { "$": 0 }, "cab": { "$": 0 }, "cafe": { "$": 0 }, "cal": { "$": 0 }, "call": { "$": 0 }, "calvinklein": { "$": 0 }, "cam": { "$": 0 }, "camera": { "$": 0 }, "camp": { "$": 0 }, "cancerresearch": { "$": 0 }, "canon": { "$": 0 }, "capetown": { "$": 0 }, "capital": { "$": 0 }, "capitalone": { "$": 0 }, "car": { "$": 0 }, "caravan": { "$": 0 }, "cards": { "$": 0 }, "care": { "$": 0 }, "career": { "$": 0 }, "careers": { "$": 0 }, "cars": { "$": 0 }, "cartier": { "$": 0 }, "casa": { "$": 0 }, "case": { "$": 0 }, "caseih": { "$": 0 }, "cash": { "$": 0 }, "casino": { "$": 0 }, "catering": { "$": 0 }, "catholic": { "$": 0 }, "cba": { "$": 0 }, "cbn": { "$": 0 }, "cbre": { "$": 0 }, "cbs": { "$": 0 }, "ceb": { "$": 0 }, "center": { "$": 0 }, "ceo": { "$": 0 }, "cern": { "$": 0 }, "cfa": { "$": 0 }, "cfd": { "$": 0 }, "chanel": { "$": 0 }, "channel": { "$": 0 }, "chase": { "$": 0 }, "chat": { "$": 0 }, "cheap": { "$": 0 }, "chintai": { "$": 0 }, "chloe": { "$": 0 }, "christmas": { "$": 0 }, "chrome": { "$": 0 }, "chrysler": { "$": 0 }, "church": { "$": 0 }, "cipriani": { "$": 0 }, "circle": { "$": 0 }, "cisco": { "$": 0 }, "citadel": { "$": 0 }, "citi": { "$": 0 }, "citic": { "$": 0 }, "city": { "$": 0 }, "cityeats": { "$": 0 }, "claims": { "$": 0 }, "cleaning": { "$": 0 }, "click": { "$": 0 }, "clinic": { "$": 0 }, "clinique": { "$": 0 }, "clothing": { "$": 0 }, "cloud": { "$": 0, "myfusion": { "$": 0 }, "statics": { "*": { "$": 0 } }, "magentosite": { "*": { "$": 0 } }, "vapor": { "$": 0 }, "sensiosite": { "*": { "$": 0 } }, "trafficplex": { "$": 0 } }, "club": { "$": 0, "cloudns": { "$": 0 } }, "clubmed": { "$": 0 }, "coach": { "$": 0 }, "codes": { "$": 0 }, "coffee": { "$": 0 }, "college": { "$": 0 }, "cologne": { "$": 0 }, "comcast": { "$": 0 }, "commbank": { "$": 0 }, "community": { "$": 0 }, "company": { "$": 0 }, "compare": { "$": 0 }, "computer": { "$": 0 }, "comsec": { "$": 0 }, "condos": { "$": 0 }, "construction": { "$": 0 }, "consulting": { "$": 0 }, "contact": { "$": 0 }, "contractors": { "$": 0 }, "cooking": { "$": 0 }, "cookingchannel": { "$": 0 }, "cool": { "$": 0, "de": { "$": 0 } }, "corsica": { "$": 0 }, "country": { "$": 0 }, "coupon": { "$": 0 }, "coupons": { "$": 0 }, "courses": { "$": 0 }, "credit": { "$": 0 }, "creditcard": { "$": 0 }, "creditunion": { "$": 0 }, "cricket": { "$": 0 }, "crown": { "$": 0 }, "crs": { "$": 0 }, "cruise": { "$": 0 }, "cruises": { "$": 0 }, "csc": { "$": 0 }, "cuisinella": { "$": 0 }, "cymru": { "$": 0 }, "cyou": { "$": 0 }, "dabur": { "$": 0 }, "dad": { "$": 0 }, "dance": { "$": 0 }, "data": { "$": 0 }, "date": { "$": 0 }, "dating": { "$": 0 }, "datsun": { "$": 0 }, "day": { "$": 0 }, "dclk": { "$": 0 }, "dds": { "$": 0 }, "deal": { "$": 0 }, "dealer": { "$": 0 }, "deals": { "$": 0 }, "degree": { "$": 0 }, "delivery": { "$": 0 }, "dell": { "$": 0 }, "deloitte": { "$": 0 }, "delta": { "$": 0 }, "democrat": { "$": 0 }, "dental": { "$": 0 }, "dentist": { "$": 0 }, "desi": { "$": 0 }, "design": { "$": 0 }, "dev": { "$": 0 }, "dhl": { "$": 0 }, "diamonds": { "$": 0 }, "diet": { "$": 0 }, "digital": { "$": 0 }, "direct": { "$": 0 }, "directory": { "$": 0 }, "discount": { "$": 0 }, "discover": { "$": 0 }, "dish": { "$": 0 }, "diy": { "$": 0 }, "dnp": { "$": 0 }, "docs": { "$": 0 }, "doctor": { "$": 0 }, "dodge": { "$": 0 }, "dog": { "$": 0 }, "doha": { "$": 0 }, "domains": { "$": 0 }, "dot": { "$": 0 }, "download": { "$": 0 }, "drive": { "$": 0 }, "dtv": { "$": 0 }, "dubai": { "$": 0 }, "duck": { "$": 0 }, "dunlop": { "$": 0 }, "duns": { "$": 0 }, "dupont": { "$": 0 }, "durban": { "$": 0 }, "dvag": { "$": 0 }, "dvr": { "$": 0 }, "earth": { "$": 0 }, "eat": { "$": 0 }, "eco": { "$": 0 }, "edeka": { "$": 0 }, "education": { "$": 0 }, "email": { "$": 0 }, "emerck": { "$": 0 }, "energy": { "$": 0 }, "engineer": { "$": 0 }, "engineering": { "$": 0 }, "enterprises": { "$": 0 }, "epost": { "$": 0 }, "epson": { "$": 0 }, "equipment": { "$": 0 }, "ericsson": { "$": 0 }, "erni": { "$": 0 }, "esq": { "$": 0 }, "estate": { "$": 0, "compute": { "*": { "$": 0 } } }, "esurance": { "$": 0 }, "etisalat": { "$": 0 }, "eurovision": { "$": 0 }, "eus": { "$": 0, "party": { "user": { "$": 0 } } }, "events": { "$": 0 }, "everbank": { "$": 0 }, "exchange": { "$": 0 }, "expert": { "$": 0 }, "exposed": { "$": 0 }, "express": { "$": 0 }, "extraspace": { "$": 0 }, "fage": { "$": 0 }, "fail": { "$": 0 }, "fairwinds": { "$": 0 }, "faith": { "$": 0, "ybo": { "$": 0 } }, "family": { "$": 0 }, "fan": { "$": 0 }, "fans": { "$": 0 }, "farm": { "$": 0, "storj": { "$": 0 } }, "farmers": { "$": 0 }, "fashion": { "$": 0 }, "fast": { "$": 0 }, "fedex": { "$": 0 }, "feedback": { "$": 0 }, "ferrari": { "$": 0 }, "ferrero": { "$": 0 }, "fiat": { "$": 0 }, "fidelity": { "$": 0 }, "fido": { "$": 0 }, "film": { "$": 0 }, "final": { "$": 0 }, "finance": { "$": 0 }, "financial": { "$": 0 }, "fire": { "$": 0 }, "firestone": { "$": 0 }, "firmdale": { "$": 0 }, "fish": { "$": 0 }, "fishing": { "$": 0 }, "fit": { "$": 0, "ptplus": { "$": 0 } }, "fitness": { "$": 0 }, "flickr": { "$": 0 }, "flights": { "$": 0 }, "flir": { "$": 0 }, "florist": { "$": 0 }, "flowers": { "$": 0 }, "fly": { "$": 0 }, "foo": { "$": 0 }, "food": { "$": 0 }, "foodnetwork": { "$": 0 }, "football": { "$": 0 }, "ford": { "$": 0 }, "forex": { "$": 0 }, "forsale": { "$": 0 }, "forum": { "$": 0 }, "foundation": { "$": 0 }, "fox": { "$": 0 }, "free": { "$": 0 }, "fresenius": { "$": 0 }, "frl": { "$": 0 }, "frogans": { "$": 0 }, "frontdoor": { "$": 0 }, "frontier": { "$": 0 }, "ftr": { "$": 0 }, "fujitsu": { "$": 0 }, "fujixerox": { "$": 0 }, "fun": { "$": 0 }, "fund": { "$": 0 }, "furniture": { "$": 0 }, "futbol": { "$": 0 }, "fyi": { "$": 0 }, "gal": { "$": 0 }, "gallery": { "$": 0 }, "gallo": { "$": 0 }, "gallup": { "$": 0 }, "game": { "$": 0 }, "games": { "$": 0 }, "gap": { "$": 0 }, "garden": { "$": 0 }, "gbiz": { "$": 0 }, "gdn": { "$": 0 }, "gea": { "$": 0 }, "gent": { "$": 0 }, "genting": { "$": 0 }, "george": { "$": 0 }, "ggee": { "$": 0 }, "gift": { "$": 0 }, "gifts": { "$": 0 }, "gives": { "$": 0 }, "giving": { "$": 0 }, "glade": { "$": 0 }, "glass": { "$": 0 }, "gle": { "$": 0 }, "global": { "$": 0 }, "globo": { "$": 0 }, "gmail": { "$": 0 }, "gmbh": { "$": 0 }, "gmo": { "$": 0 }, "gmx": { "$": 0 }, "godaddy": { "$": 0 }, "gold": { "$": 0 }, "goldpoint": { "$": 0 }, "golf": { "$": 0 }, "goo": { "$": 0 }, "goodhands": { "$": 0 }, "goodyear": { "$": 0 }, "goog": { "$": 0, "cloud": { "$": 0 } }, "google": { "$": 0 }, "gop": { "$": 0 }, "got": { "$": 0 }, "grainger": { "$": 0 }, "graphics": { "$": 0 }, "gratis": { "$": 0 }, "green": { "$": 0 }, "gripe": { "$": 0 }, "grocery": { "$": 0 }, "group": { "$": 0 }, "guardian": { "$": 0 }, "gucci": { "$": 0 }, "guge": { "$": 0 }, "guide": { "$": 0 }, "guitars": { "$": 0 }, "guru": { "$": 0 }, "hair": { "$": 0 }, "hamburg": { "$": 0 }, "hangout": { "$": 0 }, "haus": { "$": 0 }, "hbo": { "$": 0 }, "hdfc": { "$": 0 }, "hdfcbank": { "$": 0 }, "health": { "$": 0 }, "healthcare": { "$": 0 }, "help": { "$": 0 }, "helsinki": { "$": 0 }, "here": { "$": 0 }, "hermes": { "$": 0 }, "hgtv": { "$": 0 }, "hiphop": { "$": 0 }, "hisamitsu": { "$": 0 }, "hitachi": { "$": 0 }, "hiv": { "$": 0 }, "hkt": { "$": 0 }, "hockey": { "$": 0 }, "holdings": { "$": 0 }, "holiday": { "$": 0 }, "homedepot": { "$": 0 }, "homegoods": { "$": 0 }, "homes": { "$": 0 }, "homesense": { "$": 0 }, "honda": { "$": 0 }, "honeywell": { "$": 0 }, "horse": { "$": 0 }, "hospital": { "$": 0 }, "host": { "$": 0, "cloudaccess": { "$": 0 }, "freesite": { "$": 0 } }, "hosting": { "$": 0, "opencraft": { "$": 0 } }, "hot": { "$": 0 }, "hoteles": { "$": 0 }, "hotels": { "$": 0 }, "hotmail": { "$": 0 }, "house": { "$": 0 }, "how": { "$": 0 }, "hsbc": { "$": 0 }, "htc": { "$": 0 }, "hughes": { "$": 0 }, "hyatt": { "$": 0 }, "hyundai": { "$": 0 }, "ibm": { "$": 0 }, "icbc": { "$": 0 }, "ice": { "$": 0 }, "icu": { "$": 0 }, "ieee": { "$": 0 }, "ifm": { "$": 0 }, "ikano": { "$": 0 }, "imamat": { "$": 0 }, "imdb": { "$": 0 }, "immo": { "$": 0 }, "immobilien": { "$": 0 }, "industries": { "$": 0 }, "infiniti": { "$": 0 }, "ing": { "$": 0 }, "ink": { "$": 0 }, "institute": { "$": 0 }, "insurance": { "$": 0 }, "insure": { "$": 0 }, "intel": { "$": 0 }, "international": { "$": 0 }, "intuit": { "$": 0 }, "investments": { "$": 0 }, "ipiranga": { "$": 0 }, "irish": { "$": 0 }, "iselect": { "$": 0 }, "ismaili": { "$": 0 }, "ist": { "$": 0 }, "istanbul": { "$": 0 }, "itau": { "$": 0 }, "itv": { "$": 0 }, "iveco": { "$": 0 }, "iwc": { "$": 0 }, "jaguar": { "$": 0 }, "java": { "$": 0 }, "jcb": { "$": 0 }, "jcp": { "$": 0 }, "jeep": { "$": 0 }, "jetzt": { "$": 0 }, "jewelry": { "$": 0 }, "jio": { "$": 0 }, "jlc": { "$": 0 }, "jll": { "$": 0 }, "jmp": { "$": 0 }, "jnj": { "$": 0 }, "joburg": { "$": 0 }, "jot": { "$": 0 }, "joy": { "$": 0 }, "jpmorgan": { "$": 0 }, "jprs": { "$": 0 }, "juegos": { "$": 0 }, "juniper": { "$": 0 }, "kaufen": { "$": 0 }, "kddi": { "$": 0 }, "kerryhotels": { "$": 0 }, "kerrylogistics": { "$": 0 }, "kerryproperties": { "$": 0 }, "kfh": { "$": 0 }, "kia": { "$": 0 }, "kim": { "$": 0 }, "kinder": { "$": 0 }, "kindle": { "$": 0 }, "kitchen": { "$": 0 }, "kiwi": { "$": 0 }, "koeln": { "$": 0 }, "komatsu": { "$": 0 }, "kosher": { "$": 0 }, "kpmg": { "$": 0 }, "kpn": { "$": 0 }, "krd": { "$": 0, "co": { "$": 0 }, "edu": { "$": 0 } }, "kred": { "$": 0 }, "kuokgroup": { "$": 0 }, "kyoto": { "$": 0 }, "lacaixa": { "$": 0 }, "ladbrokes": { "$": 0 }, "lamborghini": { "$": 0 }, "lamer": { "$": 0 }, "lancaster": { "$": 0 }, "lancia": { "$": 0 }, "lancome": { "$": 0 }, "land": { "$": 0, "static": { "$": 0, "dev": { "$": 0 }, "sites": { "$": 0 } } }, "landrover": { "$": 0 }, "lanxess": { "$": 0 }, "lasalle": { "$": 0 }, "lat": { "$": 0 }, "latino": { "$": 0 }, "latrobe": { "$": 0 }, "law": { "$": 0 }, "lawyer": { "$": 0 }, "lds": { "$": 0 }, "lease": { "$": 0 }, "leclerc": { "$": 0 }, "lefrak": { "$": 0 }, "legal": { "$": 0 }, "lego": { "$": 0 }, "lexus": { "$": 0 }, "lgbt": { "$": 0 }, "liaison": { "$": 0 }, "lidl": { "$": 0 }, "life": { "$": 0 }, "lifeinsurance": { "$": 0 }, "lifestyle": { "$": 0 }, "lighting": { "$": 0 }, "like": { "$": 0 }, "lilly": { "$": 0 }, "limited": { "$": 0 }, "limo": { "$": 0 }, "lincoln": { "$": 0 }, "linde": { "$": 0 }, "link": { "$": 0, "cyon": { "$": 0 }, "mypep": { "$": 0 } }, "lipsy": { "$": 0 }, "live": { "$": 0 }, "living": { "$": 0 }, "lixil": { "$": 0 }, "loan": { "$": 0 }, "loans": { "$": 0 }, "locker": { "$": 0 }, "locus": { "$": 0 }, "loft": { "$": 0 }, "lol": { "$": 0 }, "london": { "$": 0 }, "lotte": { "$": 0 }, "lotto": { "$": 0 }, "love": { "$": 0 }, "lpl": { "$": 0 }, "lplfinancial": { "$": 0 }, "ltd": { "$": 0 }, "ltda": { "$": 0 }, "lundbeck": { "$": 0 }, "lupin": { "$": 0 }, "luxe": { "$": 0 }, "luxury": { "$": 0 }, "macys": { "$": 0 }, "madrid": { "$": 0 }, "maif": { "$": 0 }, "maison": { "$": 0 }, "makeup": { "$": 0 }, "man": { "$": 0 }, "management": { "$": 0, "router": { "$": 0 } }, "mango": { "$": 0 }, "map": { "$": 0 }, "market": { "$": 0 }, "marketing": { "$": 0 }, "markets": { "$": 0 }, "marriott": { "$": 0 }, "marshalls": { "$": 0 }, "maserati": { "$": 0 }, "mattel": { "$": 0 }, "mba": { "$": 0 }, "mcd": { "$": 0 }, "mcdonalds": { "$": 0 }, "mckinsey": { "$": 0 }, "med": { "$": 0 }, "media": { "$": 0 }, "meet": { "$": 0 }, "melbourne": { "$": 0 }, "meme": { "$": 0 }, "memorial": { "$": 0 }, "men": { "$": 0 }, "menu": { "$": 0 }, "meo": { "$": 0 }, "merckmsd": { "$": 0 }, "metlife": { "$": 0 }, "miami": { "$": 0 }, "microsoft": { "$": 0 }, "mini": { "$": 0 }, "mint": { "$": 0 }, "mit": { "$": 0 }, "mitsubishi": { "$": 0 }, "mlb": { "$": 0 }, "mls": { "$": 0 }, "mma": { "$": 0 }, "mobile": { "$": 0 }, "mobily": { "$": 0 }, "moda": { "$": 0 }, "moe": { "$": 0 }, "moi": { "$": 0 }, "mom": { "$": 0 }, "monash": { "$": 0 }, "money": { "$": 0 }, "monster": { "$": 0 }, "montblanc": { "$": 0 }, "mopar": { "$": 0 }, "mormon": { "$": 0 }, "mortgage": { "$": 0 }, "moscow": { "$": 0 }, "moto": { "$": 0 }, "motorcycles": { "$": 0 }, "mov": { "$": 0 }, "movie": { "$": 0 }, "movistar": { "$": 0 }, "msd": { "$": 0 }, "mtn": { "$": 0 }, "mtpc": { "$": 0 }, "mtr": { "$": 0 }, "mutual": { "$": 0 }, "nab": { "$": 0 }, "nadex": { "$": 0 }, "nagoya": { "$": 0 }, "nationwide": { "$": 0 }, "natura": { "$": 0 }, "navy": { "$": 0 }, "nba": { "$": 0 }, "nec": { "$": 0 }, "netbank": { "$": 0 }, "netflix": { "$": 0 }, "network": { "$": 0, "alces": { "*": { "$": 0 } } }, "neustar": { "$": 0 }, "new": { "$": 0 }, "newholland": { "$": 0 }, "news": { "$": 0 }, "next": { "$": 0 }, "nextdirect": { "$": 0 }, "nexus": { "$": 0 }, "nfl": { "$": 0 }, "ngo": { "$": 0 }, "nhk": { "$": 0 }, "nico": { "$": 0 }, "nike": { "$": 0 }, "nikon": { "$": 0 }, "ninja": { "$": 0 }, "nissan": { "$": 0 }, "nissay": { "$": 0 }, "nokia": { "$": 0 }, "northwesternmutual": { "$": 0 }, "norton": { "$": 0 }, "now": { "$": 0 }, "nowruz": { "$": 0 }, "nowtv": { "$": 0 }, "nra": { "$": 0 }, "nrw": { "$": 0 }, "ntt": { "$": 0 }, "nyc": { "$": 0 }, "obi": { "$": 0 }, "observer": { "$": 0 }, "off": { "$": 0 }, "office": { "$": 0 }, "okinawa": { "$": 0 }, "olayan": { "$": 0 }, "olayangroup": { "$": 0 }, "oldnavy": { "$": 0 }, "ollo": { "$": 0 }, "omega": { "$": 0 }, "one": { "$": 0, "homelink": { "$": 0 } }, "ong": { "$": 0 }, "onl": { "$": 0 }, "online": { "$": 0, "barsy": { "$": 0 } }, "onyourside": { "$": 0 }, "ooo": { "$": 0 }, "open": { "$": 0 }, "oracle": { "$": 0 }, "orange": { "$": 0 }, "organic": { "$": 0 }, "origins": { "$": 0 }, "osaka": { "$": 0 }, "otsuka": { "$": 0 }, "ott": { "$": 0 }, "ovh": { "$": 0, "nerdpol": { "$": 0 } }, "page": { "$": 0 }, "pamperedchef": { "$": 0 }, "panasonic": { "$": 0 }, "panerai": { "$": 0 }, "paris": { "$": 0 }, "pars": { "$": 0 }, "partners": { "$": 0 }, "parts": { "$": 0 }, "party": { "$": 0, "ybo": { "$": 0 } }, "passagens": { "$": 0 }, "pay": { "$": 0 }, "pccw": { "$": 0 }, "pet": { "$": 0 }, "pfizer": { "$": 0 }, "pharmacy": { "$": 0 }, "phd": { "$": 0 }, "philips": { "$": 0 }, "phone": { "$": 0 }, "photo": { "$": 0 }, "photography": { "$": 0 }, "photos": { "$": 0 }, "physio": { "$": 0 }, "piaget": { "$": 0 }, "pics": { "$": 0 }, "pictet": { "$": 0 }, "pictures": { "1337": { "$": 0 }, "$": 0 }, "pid": { "$": 0 }, "pin": { "$": 0 }, "ping": { "$": 0 }, "pink": { "$": 0 }, "pioneer": { "$": 0 }, "pizza": { "$": 0 }, "place": { "$": 0 }, "play": { "$": 0 }, "playstation": { "$": 0 }, "plumbing": { "$": 0 }, "plus": { "$": 0 }, "pnc": { "$": 0 }, "pohl": { "$": 0 }, "poker": { "$": 0 }, "politie": { "$": 0 }, "porn": { "$": 0 }, "pramerica": { "$": 0 }, "praxi": { "$": 0 }, "press": { "$": 0 }, "prime": { "$": 0 }, "prod": { "$": 0 }, "productions": { "$": 0 }, "prof": { "$": 0 }, "progressive": { "$": 0 }, "promo": { "$": 0 }, "properties": { "$": 0 }, "property": { "$": 0 }, "protection": { "$": 0 }, "pru": { "$": 0 }, "prudential": { "$": 0 }, "pub": { "$": 0 }, "pwc": { "$": 0 }, "qpon": { "$": 0 }, "quebec": { "$": 0 }, "quest": { "$": 0 }, "qvc": { "$": 0 }, "racing": { "$": 0 }, "radio": { "$": 0 }, "raid": { "$": 0 }, "read": { "$": 0 }, "realestate": { "$": 0 }, "realtor": { "$": 0 }, "realty": { "$": 0 }, "recipes": { "$": 0 }, "red": { "$": 0 }, "redstone": { "$": 0 }, "redumbrella": { "$": 0 }, "rehab": { "$": 0 }, "reise": { "$": 0 }, "reisen": { "$": 0 }, "reit": { "$": 0 }, "reliance": { "$": 0 }, "ren": { "$": 0 }, "rent": { "$": 0 }, "rentals": { "$": 0 }, "repair": { "$": 0 }, "report": { "$": 0 }, "republican": { "$": 0 }, "rest": { "$": 0 }, "restaurant": { "$": 0 }, "review": { "$": 0, "ybo": { "$": 0 } }, "reviews": { "$": 0 }, "rexroth": { "$": 0 }, "rich": { "$": 0 }, "richardli": { "$": 0 }, "ricoh": { "$": 0 }, "rightathome": { "$": 0 }, "ril": { "$": 0 }, "rio": { "$": 0 }, "rip": { "$": 0, "clan": { "$": 0 } }, "rmit": { "$": 0 }, "rocher": { "$": 0 }, "rocks": { "$": 0, "myddns": { "$": 0 }, "lima-city": { "$": 0 }, "webspace": { "$": 0 } }, "rodeo": { "$": 0 }, "rogers": { "$": 0 }, "room": { "$": 0 }, "rsvp": { "$": 0 }, "rugby": { "$": 0 }, "ruhr": { "$": 0 }, "run": { "$": 0 }, "rwe": { "$": 0 }, "ryukyu": { "$": 0 }, "saarland": { "$": 0 }, "safe": { "$": 0 }, "safety": { "$": 0 }, "sakura": { "$": 0 }, "sale": { "$": 0 }, "salon": { "$": 0 }, "samsclub": { "$": 0 }, "samsung": { "$": 0 }, "sandvik": { "$": 0 }, "sandvikcoromant": { "$": 0 }, "sanofi": { "$": 0 }, "sap": { "$": 0 }, "sapo": { "$": 0 }, "sarl": { "$": 0 }, "sas": { "$": 0 }, "save": { "$": 0 }, "saxo": { "$": 0 }, "sbi": { "$": 0 }, "sbs": { "$": 0 }, "sca": { "$": 0 }, "scb": { "$": 0 }, "schaeffler": { "$": 0 }, "schmidt": { "$": 0 }, "scholarships": { "$": 0 }, "school": { "$": 0 }, "schule": { "$": 0 }, "schwarz": { "$": 0 }, "science": { "$": 0, "ybo": { "$": 0 } }, "scjohnson": { "$": 0 }, "scor": { "$": 0 }, "scot": { "$": 0 }, "search": { "$": 0 }, "seat": { "$": 0 }, "secure": { "$": 0 }, "security": { "$": 0 }, "seek": { "$": 0 }, "select": { "$": 0 }, "sener": { "$": 0 }, "services": { "$": 0 }, "ses": { "$": 0 }, "seven": { "$": 0 }, "sew": { "$": 0 }, "sex": { "$": 0 }, "sexy": { "$": 0 }, "sfr": { "$": 0 }, "shangrila": { "$": 0 }, "sharp": { "$": 0 }, "shaw": { "$": 0 }, "shell": { "$": 0 }, "shia": { "$": 0 }, "shiksha": { "$": 0 }, "shoes": { "$": 0 }, "shop": { "$": 0 }, "shopping": { "$": 0 }, "shouji": { "$": 0 }, "show": { "$": 0 }, "showtime": { "$": 0 }, "shriram": { "$": 0 }, "silk": { "$": 0 }, "sina": { "$": 0 }, "singles": { "$": 0 }, "site": { "$": 0, "cyon": { "$": 0 }, "platformsh": { "*": { "$": 0 } }, "byen": { "$": 0 } }, "ski": { "$": 0 }, "skin": { "$": 0 }, "sky": { "$": 0 }, "skype": { "$": 0 }, "sling": { "$": 0 }, "smart": { "$": 0 }, "smile": { "$": 0 }, "sncf": { "$": 0 }, "soccer": { "$": 0 }, "social": { "$": 0 }, "softbank": { "$": 0 }, "software": { "$": 0 }, "sohu": { "$": 0 }, "solar": { "$": 0 }, "solutions": { "$": 0 }, "song": { "$": 0 }, "sony": { "$": 0 }, "soy": { "$": 0 }, "space": { "$": 0, "stackspace": { "$": 0 }, "uber": { "$": 0 }, "xs4all": { "$": 0 } }, "spiegel": { "$": 0 }, "spot": { "$": 0 }, "spreadbetting": { "$": 0 }, "srl": { "$": 0 }, "srt": { "$": 0 }, "stada": { "$": 0 }, "staples": { "$": 0 }, "star": { "$": 0 }, "starhub": { "$": 0 }, "statebank": { "$": 0 }, "statefarm": { "$": 0 }, "statoil": { "$": 0 }, "stc": { "$": 0 }, "stcgroup": { "$": 0 }, "stockholm": { "$": 0 }, "storage": { "$": 0 }, "store": { "$": 0 }, "stream": { "$": 0 }, "studio": { "$": 0 }, "study": { "$": 0 }, "style": { "$": 0 }, "sucks": { "$": 0 }, "supplies": { "$": 0 }, "supply": { "$": 0 }, "support": { "$": 0, "barsy": { "$": 0 } }, "surf": { "$": 0 }, "surgery": { "$": 0 }, "suzuki": { "$": 0 }, "swatch": { "$": 0 }, "swiftcover": { "$": 0 }, "swiss": { "$": 0 }, "sydney": { "$": 0 }, "symantec": { "$": 0 }, "systems": { "$": 0, "knightpoint": { "$": 0 } }, "tab": { "$": 0 }, "taipei": { "$": 0 }, "talk": { "$": 0 }, "taobao": { "$": 0 }, "target": { "$": 0 }, "tatamotors": { "$": 0 }, "tatar": { "$": 0 }, "tattoo": { "$": 0 }, "tax": { "$": 0 }, "taxi": { "$": 0 }, "tci": { "$": 0 }, "tdk": { "$": 0 }, "team": { "$": 0 }, "tech": { "$": 0 }, "technology": { "$": 0 }, "telecity": { "$": 0 }, "telefonica": { "$": 0 }, "temasek": { "$": 0 }, "tennis": { "$": 0 }, "teva": { "$": 0 }, "thd": { "$": 0 }, "theater": { "$": 0 }, "theatre": { "$": 0 }, "tiaa": { "$": 0 }, "tickets": { "$": 0 }, "tienda": { "$": 0 }, "tiffany": { "$": 0 }, "tips": { "$": 0 }, "tires": { "$": 0 }, "tirol": { "$": 0 }, "tjmaxx": { "$": 0 }, "tjx": { "$": 0 }, "tkmaxx": { "$": 0 }, "tmall": { "$": 0 }, "today": { "$": 0 }, "tokyo": { "$": 0 }, "tools": { "$": 0 }, "top": { "$": 0 }, "toray": { "$": 0 }, "toshiba": { "$": 0 }, "total": { "$": 0 }, "tours": { "$": 0 }, "town": { "$": 0 }, "toyota": { "$": 0 }, "toys": { "$": 0 }, "trade": { "$": 0, "ybo": { "$": 0 } }, "trading": { "$": 0 }, "training": { "$": 0 }, "travelchannel": { "$": 0 }, "travelers": { "$": 0 }, "travelersinsurance": { "$": 0 }, "trust": { "$": 0 }, "trv": { "$": 0 }, "tube": { "$": 0 }, "tui": { "$": 0 }, "tunes": { "$": 0 }, "tushu": { "$": 0 }, "tvs": { "$": 0 }, "ubank": { "$": 0 }, "ubs": { "$": 0 }, "uconnect": { "$": 0 }, "unicom": { "$": 0 }, "university": { "$": 0 }, "uno": { "$": 0 }, "uol": { "$": 0 }, "ups": { "$": 0 }, "vacations": { "$": 0 }, "vana": { "$": 0 }, "vanguard": { "$": 0 }, "vegas": { "$": 0 }, "ventures": { "$": 0 }, "verisign": { "$": 0 }, "versicherung": { "$": 0 }, "vet": { "$": 0 }, "viajes": { "$": 0 }, "video": { "$": 0 }, "vig": { "$": 0 }, "viking": { "$": 0 }, "villas": { "$": 0 }, "vin": { "$": 0 }, "vip": { "$": 0 }, "virgin": { "$": 0 }, "visa": { "$": 0 }, "vision": { "$": 0 }, "vista": { "$": 0 }, "vistaprint": { "$": 0 }, "viva": { "$": 0 }, "vivo": { "$": 0 }, "vlaanderen": { "$": 0 }, "vodka": { "$": 0 }, "volkswagen": { "$": 0 }, "volvo": { "$": 0 }, "vote": { "$": 0 }, "voting": { "$": 0 }, "voto": { "$": 0 }, "voyage": { "$": 0 }, "vuelos": { "$": 0 }, "wales": { "$": 0 }, "walmart": { "$": 0 }, "walter": { "$": 0 }, "wang": { "$": 0 }, "wanggou": { "$": 0 }, "warman": { "$": 0 }, "watch": { "$": 0 }, "watches": { "$": 0 }, "weather": { "$": 0 }, "weatherchannel": { "$": 0 }, "webcam": { "$": 0 }, "weber": { "$": 0 }, "website": { "$": 0 }, "wed": { "$": 0 }, "wedding": { "$": 0 }, "weibo": { "$": 0 }, "weir": { "$": 0 }, "whoswho": { "$": 0 }, "wien": { "$": 0 }, "wiki": { "$": 0 }, "williamhill": { "$": 0 }, "win": { "$": 0 }, "windows": { "$": 0 }, "wine": { "$": 0 }, "winners": { "$": 0 }, "wme": { "$": 0 }, "wolterskluwer": { "$": 0 }, "woodside": { "$": 0 }, "work": { "$": 0 }, "works": { "$": 0 }, "world": { "$": 0 }, "wow": { "$": 0 }, "wtc": { "$": 0 }, "wtf": { "$": 0 }, "xbox": { "$": 0 }, "xerox": { "$": 0 }, "xfinity": { "$": 0 }, "xihuan": { "$": 0 }, "xin": { "$": 0 }, "xn--11b4c3d": { "$": 0 }, "xn--1ck2e1b": { "$": 0 }, "xn--1qqw23a": { "$": 0 }, "xn--30rr7y": { "$": 0 }, "xn--3bst00m": { "$": 0 }, "xn--3ds443g": { "$": 0 }, "xn--3oq18vl8pn36a": { "$": 0 }, "xn--3pxu8k": { "$": 0 }, "xn--42c2d9a": { "$": 0 }, "xn--45q11c": { "$": 0 }, "xn--4gbrim": { "$": 0 }, "xn--55qw42g": { "$": 0 }, "xn--55qx5d": { "$": 0 }, "xn--5su34j936bgsg": { "$": 0 }, "xn--5tzm5g": { "$": 0 }, "xn--6frz82g": { "$": 0 }, "xn--6qq986b3xl": { "$": 0 }, "xn--80adxhks": { "$": 0 }, "xn--80aqecdr1a": { "$": 0 }, "xn--80asehdb": { "$": 0 }, "xn--80aswg": { "$": 0 }, "xn--8y0a063a": { "$": 0 }, "xn--9dbq2a": { "$": 0 }, "xn--9et52u": { "$": 0 }, "xn--9krt00a": { "$": 0 }, "xn--b4w605ferd": { "$": 0 }, "xn--bck1b9a5dre4c": { "$": 0 }, "xn--c1avg": { "$": 0 }, "xn--c2br7g": { "$": 0 }, "xn--cck2b3b": { "$": 0 }, "xn--cg4bki": { "$": 0 }, "xn--czr694b": { "$": 0 }, "xn--czrs0t": { "$": 0 }, "xn--czru2d": { "$": 0 }, "xn--d1acj3b": { "$": 0 }, "xn--eckvdtc9d": { "$": 0 }, "xn--efvy88h": { "$": 0 }, "xn--estv75g": { "$": 0 }, "xn--fct429k": { "$": 0 }, "xn--fhbei": { "$": 0 }, "xn--fiq228c5hs": { "$": 0 }, "xn--fiq64b": { "$": 0 }, "xn--fjq720a": { "$": 0 }, "xn--flw351e": { "$": 0 }, "xn--fzys8d69uvgm": { "$": 0 }, "xn--g2xx48c": { "$": 0 }, "xn--gckr3f0f": { "$": 0 }, "xn--gk3at1e": { "$": 0 }, "xn--hxt814e": { "$": 0 }, "xn--i1b6b1a6a2e": { "$": 0 }, "xn--imr513n": { "$": 0 }, "xn--io0a7i": { "$": 0 }, "xn--j1aef": { "$": 0 }, "xn--jlq61u9w7b": { "$": 0 }, "xn--jvr189m": { "$": 0 }, "xn--kcrx77d1x4a": { "$": 0 }, "xn--kpu716f": { "$": 0 }, "xn--kput3i": { "$": 0 }, "xn--mgba3a3ejt": { "$": 0 }, "xn--mgba7c0bbn0a": { "$": 0 }, "xn--mgbaakc7dvf": { "$": 0 }, "xn--mgbab2bd": { "$": 0 }, "xn--mgbb9fbpob": { "$": 0 }, "xn--mgbca7dzdo": { "$": 0 }, "xn--mgbi4ecexp": { "$": 0 }, "xn--mgbt3dhd": { "$": 0 }, "xn--mk1bu44c": { "$": 0 }, "xn--mxtq1m": { "$": 0 }, "xn--ngbc5azd": { "$": 0 }, "xn--ngbe9e0a": { "$": 0 }, "xn--ngbrx": { "$": 0 }, "xn--nqv7f": { "$": 0 }, "xn--nqv7fs00ema": { "$": 0 }, "xn--nyqy26a": { "$": 0 }, "xn--p1acf": { "$": 0 }, "xn--pbt977c": { "$": 0 }, "xn--pssy2u": { "$": 0 }, "xn--q9jyb4c": { "$": 0 }, "xn--qcka1pmc": { "$": 0 }, "xn--rhqv96g": { "$": 0 }, "xn--rovu88b": { "$": 0 }, "xn--ses554g": { "$": 0 }, "xn--t60b56a": { "$": 0 }, "xn--tckwe": { "$": 0 }, "xn--tiq49xqyj": { "$": 0 }, "xn--unup4y": { "$": 0 }, "xn--vermgensberater-ctb": { "$": 0 }, "xn--vermgensberatung-pwb": { "$": 0 }, "xn--vhquv": { "$": 0 }, "xn--vuq861b": { "$": 0 }, "xn--w4r85el8fhu5dnra": { "$": 0 }, "xn--w4rs40l": { "$": 0 }, "xn--xhq521b": { "$": 0 }, "xn--zfr164b": { "$": 0 }, "xperia": { "$": 0 }, "xyz": { "$": 0, "blogsite": { "$": 0 }, "fhapp": { "$": 0 } }, "yachts": { "$": 0 }, "yahoo": { "$": 0 }, "yamaxun": { "$": 0 }, "yandex": { "$": 0 }, "yodobashi": { "$": 0 }, "yoga": { "$": 0 }, "yokohama": { "$": 0 }, "you": { "$": 0 }, "youtube": { "$": 0 }, "yun": { "$": 0 }, "zappos": { "$": 0 }, "zara": { "$": 0 }, "zero": { "$": 0 }, "zip": { "$": 0 }, "zippo": { "$": 0 }, "zone": { "$": 0, "triton": { "*": { "$": 0 } }, "lima": { "$": 0 } }, "zuerich": { "$": 0 } } };
});
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module && !module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ('function' == 'function' && 'object' == 'object' && true) {
		$__System.registerDynamic('d', [], false, function ($__require, $__exports, $__module) {
			return (function () {
				return punycode;
			}).call(this);
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(this);
$__System.registerDynamic('e', [], true, function ($__require, exports, module) {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  'use strict';

  // If obj.hasOwnProperty has been overridden, then calling
  // obj.hasOwnProperty(prop) will break.
  // See: https://github.com/joyent/node/issues/1707

  var global = this || self,
      GLOBAL = global;
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  module.exports = function (qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr,
          vstr,
          k,
          v;

      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }

      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);

      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }

    return obj;
  };
});
$__System.registerDynamic('f', [], true, function ($__require, exports, module) {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var stringifyPrimitive = function (v) {
    switch (typeof v) {
      case 'string':
        return v;

      case 'boolean':
        return v ? 'true' : 'false';

      case 'number':
        return isFinite(v) ? v : '';

      default:
        return '';
    }
  };

  module.exports = function (obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }

    if (typeof obj === 'object') {
      return Object.keys(obj).map(function (k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function (v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);
    }

    if (!name) return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  };
});
$__System.registerDynamic('10', ['e', 'f'], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  exports.decode = exports.parse = $__require('e');
  exports.encode = exports.stringify = $__require('f');
});
$__System.registerDynamic('11', ['d', '10'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  var punycode = $__require('d');

  exports.parse = urlParse;
  exports.resolve = urlResolve;
  exports.resolveObject = urlResolveObject;
  exports.format = urlFormat;

  exports.Url = Url;

  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }

  // Reference: RFC 3986, RFC 1808, RFC 2396

  // define these here so at least they only have to be
  // compiled once on the first module load.
  var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,


  // RFC 2396: characters reserved for delimiting URLs.
  // We actually just auto-escape these.
  delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


  // RFC 2396: characters not allowed for various reasons.
  unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),

  // Characters that are never ever allowed in a hostname.
  // Note that any invalid chars are also handled, but these
  // are the ones that are *expected* to be seen, so we fast-path
  // them.
  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,

  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    'javascript': true,
    'javascript:': true
  },

  // protocols that never have a hostname.
  hostlessProtocol = {
    'javascript': true,
    'javascript:': true
  },

  // protocols that always contain a // bit.
  slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
      querystring = $__require('10');

  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && isObject(url) && url instanceof Url) return url;

    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }

  Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
    if (!isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === '//';
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }

    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

      // there's a hostname.
      // the first instance of /, ?, ;, or # ends the host.
      //
      // If there is an @ in the hostname, then non-host chars *are* allowed
      // to the left of the last @ sign, unless some host-ending character
      // comes *before* the @-sign.
      // URLs are obnoxious.
      //
      // ex:
      // http://a@b@c/ => user:a@b host:c
      // http://a@b?@c => user:a host:c path:/?@c

      // v0.12 TODO(isaacs): This is not quite how Chrome does things.
      // Review our test case against browsers more comprehensively.

      // find the first instance of any hostEndingChars
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
      }

      // at this point, either we have an explicit point where the
      // auth portion cannot go past, or the last @ char is the decider.
      var auth, atSign;
      if (hostEnd === -1) {
        // atSign can be anywhere.
        atSign = rest.lastIndexOf('@');
      } else {
        // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf('@', hostEnd);
      }

      // Now we have a portion which is definitely the auth.
      // Pull that off.
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }

      // the host is the remaining to the left of the first non-host char
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
      }
      // if we still have not hit it, then the entire thing is a host.
      if (hostEnd === -1) hostEnd = rest.length;

      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);

      // pull out port.
      this.parseHost();

      // we've indicated that there is a hostname,
      // so even if it's empty, it has to be present.
      this.hostname = this.hostname || '';

      // if hostname begins with [ and ends with ]
      // assume that it's an IPv6 address.
      var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

      // validate a little.
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = '';
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                // we replace non-ASCII char with a temporary placeholder
                // we need this to make sure size of hostname is not
                // broken by replacing non-ASCII by nothing
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            }
            // we test again with ASCII char only
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = '/' + notHost.join('.') + rest;
              }
              this.hostname = validParts.join('.');
              break;
            }
          }
        }
      }

      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = '';
      } else {
        // hostnames are always lower case.
        this.hostname = this.hostname.toLowerCase();
      }

      if (!ipv6Hostname) {
        // IDNA Support: Returns a puny coded representation of "domain".
        // It only converts the part of the domain name that
        // has non ASCII characters. I.e. it dosent matter if
        // you call it with a domain that already is in ASCII.
        var domainArray = this.hostname.split('.');
        var newOut = [];
        for (var i = 0; i < domainArray.length; ++i) {
          var s = domainArray[i];
          newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
        }
        this.hostname = newOut.join('.');
      }

      var p = this.port ? ':' + this.port : '';
      var h = this.hostname || '';
      this.host = h + p;
      this.href += this.host;

      // strip [ and ] from the hostname
      // the host field still retains them, though
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== '/') {
          rest = '/' + rest;
        }
      }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

      // First, make 100% sure that any "autoEscape" chars get
      // escaped, even if encodeURIComponent doesn't think they
      // need to be.
      for (var i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }

    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
      // got a fragment string.
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      // no query string, but parseQueryString still requested
      this.search = '';
      this.query = {};
    }
    if (rest) this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = '/';
    }

    //to support http.request
    if (this.pathname || this.search) {
      var p = this.pathname || '';
      var s = this.search || '';
      this.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
  };

  // format a parsed object into a url string
  function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (isString(obj)) obj = urlParse(obj);
    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
    return obj.format();
  }

  Url.prototype.format = function () {
    var auth = this.auth || '';
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ':');
      auth += '@';
    }

    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
      if (this.port) {
        host += ':' + this.port;
      }
    }

    if (this.query && isObject(this.query) && Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }

    var search = this.search || query && '?' + query || '';

    if (protocol && protocol.substr(-1) !== ':') protocol += ':';

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = '//' + (host || '');
      if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
    } else if (!host) {
      host = '';
    }

    if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
    if (search && search.charAt(0) !== '?') search = '?' + search;

    pathname = pathname.replace(/[?#]/g, function (match) {
      return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
  };

  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }

  Url.prototype.resolve = function (relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };

  function urlResolveObject(source, relative) {
    if (!source) return relative;
    return urlParse(source, false, true).resolveObject(relative);
  }

  Url.prototype.resolveObject = function (relative) {
    if (isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }

    var result = new Url();
    Object.keys(this).forEach(function (k) {
      result[k] = this[k];
    }, this);

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
      result.href = result.format();
      return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
      // take everything except the protocol from relative
      Object.keys(relative).forEach(function (k) {
        if (k !== 'protocol') result[k] = relative[k];
      });

      //urlParse appends trailing / to urls like http://www.example.com
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
        result.path = result.pathname = '/';
      }

      result.href = result.format();
      return result;
    }

    if (relative.protocol && relative.protocol !== result.protocol) {
      // if it's a known url protocol, then changing
      // the protocol does weird things
      // first, if it's not file:, then we MUST have a host,
      // and if there was a path
      // to begin with, then we MUST have a path.
      // if it is file:, then the host is dropped,
      // because that's known to be hostless.
      // anything else is assumed to be absolute.
      if (!slashedProtocol[relative.protocol]) {
        Object.keys(relative).forEach(function (k) {
          result[k] = relative[k];
        });
        result.href = result.format();
        return result;
      }

      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || '').split('/');
        while (relPath.length && !(relative.host = relPath.shift()));
        if (!relative.host) relative.host = '';
        if (!relative.hostname) relative.hostname = '';
        if (relPath[0] !== '') relPath.unshift('');
        if (relPath.length < 2) relPath.unshift('');
        result.pathname = relPath.join('/');
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || '';
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      // to support http.request
      if (result.pathname || result.search) {
        var p = result.pathname || '';
        var s = result.search || '';
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }

    var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
        isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
        mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
      result.hostname = '';
      result.port = null;
      if (result.host) {
        if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
      }
      result.host = '';
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }

    if (isRelAbs) {
      // it's absolute.
      result.host = relative.host || relative.host === '' ? relative.host : result.host;
      result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
      // fall through to the dot-handling below.
    } else if (relPath.length) {
      // it's relative
      // throw away the existing file, and take the new path instead.
      if (!srcPath) srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!isNullOrUndefined(relative.search)) {
      // just pull out the search.
      // like href='?foo'.
      // Put this after the other two cases because it simplifies the booleans
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      //to support http.request
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
      }
      result.href = result.format();
      return result;
    }

    if (!srcPath.length) {
      // no path at all.  easy.
      // we've already handled the other stuff above.
      result.pathname = null;
      //to support http.request
      if (result.search) {
        result.path = '/' + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host) && (last === '.' || last === '..') || last === '';

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last == '.') {
        srcPath.splice(i, 1);
      } else if (last === '..') {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift('..');
      }
    }

    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
      srcPath.unshift('');
    }

    if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
      srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

    // put the host back
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    mustEndAbs = mustEndAbs || result.host && srcPath.length;

    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift('');
    }

    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };

  Url.prototype.parseHost = function () {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ':') {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) this.hostname = host;
  };

  function isString(arg) {
    return typeof arg === "string";
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
});
$__System.registerDynamic('12', ['11', '13'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;

  var URL = $__require('11');
  var isValid = $__require('13');

  /**
   * Utility to cleanup the base host value. Also removes url fragments.
   *
   * Works for:
   * - hostname
   * - //hostname
   * - scheme://hostname
   * - scheme+scheme://hostname
   *
   * @param {string} value
   * @return {String}
   */

  // scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
  var hasPrefixRE = /^(([a-z][a-z0-9+.-]*)?:)?\/\//;
  var invalidHostnameChars = /[^A-Za-z0-9.-]/;

  // @see https://github.com/oncletom/tld.js/issues/95
  function rtrim(value) {
    if (value[value.length - 1] === '.') {
      return value.substr(0, value.length - 1);
    }
    return value;
  }

  module.exports = function extractHostname(validHosts, value) {
    if (isValid(validHosts, value)) {
      return rtrim(value);
    }

    var url = ('' + value).toLowerCase().trim();

    if (isValid(validHosts, url)) {
      return rtrim(url);
    }

    // Proceed with heavier url parsing to extract the hostname.
    var parts = URL.parse(hasPrefixRE.test(url) ? url : '//' + url, null, true);

    if (parts.hostname && !invalidHostnameChars.test(parts.hostname)) {
      return rtrim(parts.hostname);
    } else if (!invalidHostnameChars.test(url)) {
      return rtrim(url);
    }

    return null;
  };
});
$__System.registerDynamic('14', [], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Polyfill for `endsWith`
   *
   * @param {string} str
   * @param {string} pattern
   * @return {boolean}
   */

  var global = this || self,
      GLOBAL = global;
  function endsWith(str, pattern) {
    return str.lastIndexOf(pattern) === str.length - pattern.length;
  }

  /**
   * Check if `vhost` is a valid suffix of `hostname` (top-domain)
   *
   * It means that `vhost` needs to be a suffix of `hostname` and we then need to
   * make sure that: either they are equal, or the character preceding `vhost` in
   * `hostname` is a '.' (it should not be a partial label).
   *
   * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok
   * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok
   * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok
   *
   * @param {string} hostname
   * @param {string} vhost
   * @return {boolean}
   */
  function shareSameDomainSuffix(hostname, vhost) {
    if (endsWith(hostname, vhost)) {
      return hostname.length === vhost.length || hostname[hostname.length - vhost.length - 1] === '.';
    }

    return false;
  }

  /**
   * Given a hostname and its public suffix, extract the general domain.
   *
   *  @param {string} hostname
   *  @param {string} publicSuffix
   *  @return {string}
   */
  function extractDomainWithSuffix(hostname, publicSuffix) {
    // Locate the index of the last '.' in the part of the `hostname` preceding
    // the public suffix.
    //
    // examples:
    //   1. not.evil.co.uk  => evil.co.uk
    //         ^    ^
    //         |    | start of public suffix
    //         | index of the last dot
    //
    //   2. example.co.uk   => example.co.uk
    //     ^       ^
    //     |       | start of public suffix
    //     |
    //     | (-1) no dot found before the public suffix
    var publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    var lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);

    // No '.' found, then `hostname` is the general domain (no sub-domain)
    if (lastDotBeforeSuffixIndex === -1) {
      return hostname;
    }

    // Extract the part between the last '.'
    return hostname.substr(lastDotBeforeSuffixIndex + 1);
  }

  /**
   * Detects the domain based on rules and upon and a host string
   *
   * @api
   * @param {string} host
   * @return {String}
   */
  module.exports = function getDomain(validHosts, suffix, hostname) {
    // Check if `hostname` ends with a member of `validHosts`.
    for (var i = 0; i < validHosts.length; i += 1) {
      var vhost = validHosts[i];
      if (shareSameDomainSuffix(hostname, vhost)) {
        return vhost;
      }
    }

    // If there is no suffix, there is no hostname
    if (suffix === null) {
      return null;
    }

    // If `hostname` is a valid public suffix, then there is no domain to return.
    // Since we already know that `getPublicSuffix` returns a suffix of `hostname`
    // there is no need to perform a string comparison and we only compare the
    // size.
    if (suffix.length === hostname.length) {
      return null;
    }

    // To extract the general domain, we start by identifying the public suffix
    // (if any), then consider the domain to be the public suffix with one added
    // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:
    // `co.uk`, then we take one more level: `evil`, giving the final result:
    // `evil.co.uk`).
    return extractDomainWithSuffix(hostname, suffix);
  };
});
$__System.registerDynamic('15', ['16'], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var extractTldFromHost = $__require('16');

  /**
   * Returns the public suffix (including exact matches)
   *
   * @api
   * @since 1.5
   * @param {string} hostname
   * @return {string}
   */
  module.exports = function getPublicSuffix(rules, hostname) {
    // First check if `hostname` is already a valid top-level Domain.
    if (rules.hasTld(hostname)) {
      return hostname;
    }

    var candidate = rules.suffixLookup(hostname);
    if (candidate === null) {
      // Prevailing rule is '*' so we consider the top-level domain to be the
      // public suffix of `hostname` (e.g.: 'example.org' => 'org').
      return extractTldFromHost(hostname);
    }

    return candidate;
  };
});
$__System.registerDynamic('17', [], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Returns the subdomain of a hostname string
   *
   * @api
   * @param {string} hostname
   * @param {string} domain - the root domain of the hostname
   * @return {string|null} a subdomain string if any, blank string if subdomain
   *  is empty, otherwise null.
   */

  var global = this || self,
      GLOBAL = global;
  module.exports = function getSubdomain(hostname, domain) {
    // No domain found? Just abort, abort!
    if (domain === null) {
      return null;
    }

    return hostname.substr(0, hostname.length - domain.length - 1);
  };
});
$__System.registerDynamic("13", [], true, function ($__require, exports, module) {
  "use strict";

  /**
   * Check if the code point is a digit [0-9]
   *
   * @param {number} code
   * @return boolean
   */

  var global = this || self,
      GLOBAL = global;
  function isDigit(code) {
    // 48 == '0'
    // 57 == '9'
    return code >= 48 && code <= 57;
  }

  /**
   * Check if the code point is a letter [a-zA-Z]
   *
   * @param {number} code
   * @return boolean
   */
  function isAlpha(code) {
    // Force to lower-case
    // code |= 32;
    // 97 === 'a'
    // 122 == 'z'
    return code >= 97 && code <= 122;
  }

  /**
   * Check if a hostname string is valid (according to RFC
   * It's usually a preliminary check before trying to use getDomain or anything else
   *
   * Beware: it does not check if the TLD exists.
   *
   * @api
   * @param {string} hostname
   * @return {boolean}
   */
  module.exports = function isValid(validHosts, hostname) {
    if (typeof hostname !== 'string') {
      return false;
    }

    if (hostname.length > 255) {
      return false;
    }

    if (validHosts.length !== 0) {
      for (var j = 0; j < validHosts.length; j += 1) {
        if (hostname.endsWith(validHosts[j])) {
          return true;
        }
      }
    }

    if (hostname.length === 0) {
      return false;
    }

    // Check first character: [a-zA-Z0-9]
    var firstCharCode = hostname.charCodeAt(0);
    if (!(isAlpha(firstCharCode) || isDigit(firstCharCode))) {
      return false;
    }

    // Validate hostname according to RFC
    var lastDotIndex = -1;
    var lastCharCode;
    var code;
    var len = hostname.length;

    for (var i = 0; i < len; i += 1) {
      code = hostname.charCodeAt(i);

      if (code === 46) {
        // '.'
        if (
        // Check that previous label is < 63 bytes long (64 = 63 + '.')
        i - lastDotIndex > 64 ||
        // Check that previous character was not already a '.'
        lastCharCode === 46 ||
        // Check that the previous label does not end with a '-'
        lastCharCode === 45) {
          return false;
        }

        lastDotIndex = i;
      } else if (!(isAlpha(code) || isDigit(code) || code === 45)) {
        // Check if there is a forbidden character in the label: [^a-zA-Z0-9-]
        return false;
      }

      lastCharCode = code;
    }

    return (
      // Check that last label is shorter than 63 chars
      len - lastDotIndex - 1 <= 63 &&
      // Check that the last character is an allowed trailing label character.
      // Since we already checked that the char is a valid hostname character,
      // we only need to check that it's different from '-'.
      lastCharCode !== 45
    );
  };
});
$__System.registerDynamic("16", [], true, function ($__require, exports, module) {
  "use strict";

  /**
   * Utility to extract the TLD from a hostname string
   *
   * @param {string} host
   * @return {String}
   */

  var global = this || self,
      GLOBAL = global;
  module.exports = function extractTldFromHost(hostname) {
    var lastDotIndex = hostname.lastIndexOf('.');
    if (lastDotIndex === -1) {
      return null;
    }

    return hostname.substr(lastDotIndex + 1);
  };
});
$__System.registerDynamic('18', ['16'], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var extractTldFromHost = $__require('16');

  /**
   * Checks if the TLD exists for a given hostname
   *
   * @api
   * @param {string} rules
   * @param {string} hostname
   * @return {boolean}
   */
  module.exports = function tldExists(rules, hostname) {
    // Easy case, it's a TLD
    if (rules.hasTld(hostname)) {
      return true;
    }

    // Popping only the TLD of the hostname
    var hostTld = extractTldFromHost(hostname);
    if (hostTld === null) {
      return false;
    }

    return rules.hasTld(hostTld);
  };
});
$__System.registerDynamic('19', ['b', 'c', '12', '14', '15', '17', '13', '18'], true, function ($__require, exports, module) {
  'use strict';

  // Load rules

  var global = this || self,
      GLOBAL = global;
  var Trie = $__require('b');
  var allRules = Trie.fromJson($__require('c'));

  // Internals
  var extractHostname = $__require('12');
  var getDomain = $__require('14');
  var getPublicSuffix = $__require('15');
  var getSubdomain = $__require('17');
  var isValid = $__require('13');
  var tldExists = $__require('18');

  function parse(url, validHosts, rules, _extractHostname) {
    var hostname = _extractHostname(validHosts, url);
    var valid = isValid(validHosts, hostname);
    var suffix = null;
    var domain = null;
    var subdomain = null;

    if (valid) {
      suffix = getPublicSuffix(rules, hostname);
      domain = getDomain(validHosts, suffix, hostname);
      subdomain = getSubdomain(hostname, domain);
    }

    return {
      valid,
      hostname,
      suffix,
      domain,
      subdomain
    };
  }

  /**
   * Creates a new instance of tldjs
   * @param  {Object.<rules,validHosts>} options [description]
   * @return {tldjs|Object}                      [description]
   */
  function factory(options) {
    var rules = options.rules || allRules || {};
    var validHosts = options.validHosts || [];
    var _extractHostname = options.extractHostname || extractHostname;

    return {
      extractHostname: function (url) {
        return _extractHostname(validHosts, url);
      },
      isValid: function (hostname) {
        return isValid(validHosts, hostname);
      },
      tldExists: function (url) {
        var hostname = _extractHostname(validHosts, url);
        return tldExists(rules, hostname);
      },
      getPublicSuffix: function (url) {
        return parse(url, validHosts, rules, _extractHostname).suffix;
      },
      getDomain: function (url) {
        return parse(url, validHosts, rules, _extractHostname).domain;
      },
      getSubdomain: function (url) {
        return parse(url, validHosts, rules, _extractHostname).subdomain;
      },
      parse: function (url) {
        return parse(url, validHosts, rules, _extractHostname);
      },
      fromUserSettings: factory
    };
  }

  module.exports = factory({});
});
/**!

 @license
 handlebars v4.0.11

Copyright (C) 2011-2017 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
!function (a, b) {
  "object" == typeof exports && "object" == typeof module ? module.exports = b() : "function" == "function" && true ? $__System.registerDynamic("1a", [], false, function ($__require, $__exports, $__module) {
    if (typeof b === "function") {
      return b.call(this);
    } else {
      return b;
    }
  }) : "object" == typeof exports ? exports.Handlebars = b() : a.Handlebars = b();
}(this, function () {
  return function (a) {
    function b(d) {
      if (c[d]) return c[d].exports;var e = c[d] = { exports: {}, id: d, loaded: !1 };return a[d].call(e.exports, e, e.exports, b), e.loaded = !0, e.exports;
    }var c = {};return b.m = a, b.c = c, b.p = "", b(0);
  }([function (a, b, c) {
    "use strict";
    function d() {
      var a = r();return a.compile = function (b, c) {
        return k.compile(b, c, a);
      }, a.precompile = function (b, c) {
        return k.precompile(b, c, a);
      }, a.AST = i["default"], a.Compiler = k.Compiler, a.JavaScriptCompiler = m["default"], a.Parser = j.parser, a.parse = j.parse, a;
    }var e = c(1)["default"];b.__esModule = !0;var f = c(2),
        g = e(f),
        h = c(35),
        i = e(h),
        j = c(36),
        k = c(41),
        l = c(42),
        m = e(l),
        n = c(39),
        o = e(n),
        p = c(34),
        q = e(p),
        r = g["default"].create,
        s = d();s.create = d, q["default"](s), s.Visitor = o["default"], s["default"] = s, b["default"] = s, a.exports = b["default"];
  }, function (a, b) {
    "use strict";
    b["default"] = function (a) {
      return a && a.__esModule ? a : { "default": a };
    }, b.__esModule = !0;
  }, function (a, b, c) {
    "use strict";
    function d() {
      var a = new h.HandlebarsEnvironment();return n.extend(a, h), a.SafeString = j["default"], a.Exception = l["default"], a.Utils = n, a.escapeExpression = n.escapeExpression, a.VM = p, a.template = function (b) {
        return p.template(b, a);
      }, a;
    }var e = c(3)["default"],
        f = c(1)["default"];b.__esModule = !0;var g = c(4),
        h = e(g),
        i = c(21),
        j = f(i),
        k = c(6),
        l = f(k),
        m = c(5),
        n = e(m),
        o = c(22),
        p = e(o),
        q = c(34),
        r = f(q),
        s = d();s.create = d, r["default"](s), s["default"] = s, b["default"] = s, a.exports = b["default"];
  }, function (a, b) {
    "use strict";
    b["default"] = function (a) {
      if (a && a.__esModule) return a;var b = {};if (null != a) for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]);return b["default"] = a, b;
    }, b.__esModule = !0;
  }, function (a, b, c) {
    "use strict";
    function d(a, b, c) {
      this.helpers = a || {}, this.partials = b || {}, this.decorators = c || {}, i.registerDefaultHelpers(this), j.registerDefaultDecorators(this);
    }var e = c(1)["default"];b.__esModule = !0, b.HandlebarsEnvironment = d;var f = c(5),
        g = c(6),
        h = e(g),
        i = c(10),
        j = c(18),
        k = c(20),
        l = e(k),
        m = "4.0.11";b.VERSION = m;var n = 7;b.COMPILER_REVISION = n;var o = { 1: "<= 1.0.rc.2", 2: "== 1.0.0-rc.3", 3: "== 1.0.0-rc.4", 4: "== 1.x.x", 5: "== 2.0.0-alpha.x", 6: ">= 2.0.0-beta.1", 7: ">= 4.0.0" };b.REVISION_CHANGES = o;var p = "[object Object]";d.prototype = { constructor: d, logger: l["default"], log: l["default"].log, registerHelper: function (a, b) {
        if (f.toString.call(a) === p) {
          if (b) throw new h["default"]("Arg not supported with multiple helpers");f.extend(this.helpers, a);
        } else this.helpers[a] = b;
      }, unregisterHelper: function (a) {
        delete this.helpers[a];
      }, registerPartial: function (a, b) {
        if (f.toString.call(a) === p) f.extend(this.partials, a);else {
          if ("undefined" == typeof b) throw new h["default"]('Attempting to register a partial called "' + a + '" as undefined');this.partials[a] = b;
        }
      }, unregisterPartial: function (a) {
        delete this.partials[a];
      }, registerDecorator: function (a, b) {
        if (f.toString.call(a) === p) {
          if (b) throw new h["default"]("Arg not supported with multiple decorators");f.extend(this.decorators, a);
        } else this.decorators[a] = b;
      }, unregisterDecorator: function (a) {
        delete this.decorators[a];
      } };var q = l["default"].log;b.log = q, b.createFrame = f.createFrame, b.logger = l["default"];
  }, function (a, b) {
    "use strict";
    function c(a) {
      return k[a];
    }function d(a) {
      for (var b = 1; b < arguments.length; b++) for (var c in arguments[b]) Object.prototype.hasOwnProperty.call(arguments[b], c) && (a[c] = arguments[b][c]);return a;
    }function e(a, b) {
      for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return c;return -1;
    }function f(a) {
      if ("string" != typeof a) {
        if (a && a.toHTML) return a.toHTML();if (null == a) return "";if (!a) return a + "";a = "" + a;
      }return m.test(a) ? a.replace(l, c) : a;
    }function g(a) {
      return !a && 0 !== a || !(!p(a) || 0 !== a.length);
    }function h(a) {
      var b = d({}, a);return b._parent = a, b;
    }function i(a, b) {
      return a.path = b, a;
    }function j(a, b) {
      return (a ? a + "." : "") + b;
    }b.__esModule = !0, b.extend = d, b.indexOf = e, b.escapeExpression = f, b.isEmpty = g, b.createFrame = h, b.blockParams = i, b.appendContextPath = j;var k = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;", "=": "&#x3D;" },
        l = /[&<>"'`=]/g,
        m = /[&<>"'`=]/,
        n = Object.prototype.toString;b.toString = n;var o = function (a) {
      return "function" == typeof a;
    };o(/x/) && (b.isFunction = o = function (a) {
      return "function" == typeof a && "[object Function]" === n.call(a);
    }), b.isFunction = o;var p = Array.isArray || function (a) {
      return !(!a || "object" != typeof a) && "[object Array]" === n.call(a);
    };b.isArray = p;
  }, function (a, b, c) {
    "use strict";
    function d(a, b) {
      var c = b && b.loc,
          g = void 0,
          h = void 0;c && (g = c.start.line, h = c.start.column, a += " - " + g + ":" + h);for (var i = Error.prototype.constructor.call(this, a), j = 0; j < f.length; j++) this[f[j]] = i[f[j]];Error.captureStackTrace && Error.captureStackTrace(this, d);try {
        c && (this.lineNumber = g, e ? Object.defineProperty(this, "column", { value: h, enumerable: !0 }) : this.column = h);
      } catch (k) {}
    }var e = c(7)["default"];b.__esModule = !0;var f = ["description", "fileName", "lineNumber", "message", "name", "number", "stack"];d.prototype = new Error(), b["default"] = d, a.exports = b["default"];
  }, function (a, b, c) {
    a.exports = { "default": c(8), __esModule: !0 };
  }, function (a, b, c) {
    var d = c(9);a.exports = function (a, b, c) {
      return d.setDesc(a, b, c);
    };
  }, function (a, b) {
    var c = Object;a.exports = { create: c.create, getProto: c.getPrototypeOf, isEnum: {}.propertyIsEnumerable, getDesc: c.getOwnPropertyDescriptor, setDesc: c.defineProperty, setDescs: c.defineProperties, getKeys: c.keys, getNames: c.getOwnPropertyNames, getSymbols: c.getOwnPropertySymbols, each: [].forEach };
  }, function (a, b, c) {
    "use strict";
    function d(a) {
      g["default"](a), i["default"](a), k["default"](a), m["default"](a), o["default"](a), q["default"](a), s["default"](a);
    }var e = c(1)["default"];b.__esModule = !0, b.registerDefaultHelpers = d;var f = c(11),
        g = e(f),
        h = c(12),
        i = e(h),
        j = c(13),
        k = e(j),
        l = c(14),
        m = e(l),
        n = c(15),
        o = e(n),
        p = c(16),
        q = e(p),
        r = c(17),
        s = e(r);
  }, function (a, b, c) {
    "use strict";
    b.__esModule = !0;var d = c(5);b["default"] = function (a) {
      a.registerHelper("blockHelperMissing", function (b, c) {
        var e = c.inverse,
            f = c.fn;if (b === !0) return f(this);if (b === !1 || null == b) return e(this);if (d.isArray(b)) return b.length > 0 ? (c.ids && (c.ids = [c.name]), a.helpers.each(b, c)) : e(this);if (c.data && c.ids) {
          var g = d.createFrame(c.data);g.contextPath = d.appendContextPath(c.data.contextPath, c.name), c = { data: g };
        }return f(b, c);
      });
    }, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    var d = c(1)["default"];b.__esModule = !0;var e = c(5),
        f = c(6),
        g = d(f);b["default"] = function (a) {
      a.registerHelper("each", function (a, b) {
        function c(b, c, f) {
          j && (j.key = b, j.index = c, j.first = 0 === c, j.last = !!f, k && (j.contextPath = k + b)), i += d(a[b], { data: j, blockParams: e.blockParams([a[b], b], [k + b, null]) });
        }if (!b) throw new g["default"]("Must pass iterator to #each");var d = b.fn,
            f = b.inverse,
            h = 0,
            i = "",
            j = void 0,
            k = void 0;if (b.data && b.ids && (k = e.appendContextPath(b.data.contextPath, b.ids[0]) + "."), e.isFunction(a) && (a = a.call(this)), b.data && (j = e.createFrame(b.data)), a && "object" == typeof a) if (e.isArray(a)) for (var l = a.length; h < l; h++) h in a && c(h, h, h === a.length - 1);else {
          var m = void 0;for (var n in a) a.hasOwnProperty(n) && (void 0 !== m && c(m, h - 1), m = n, h++);void 0 !== m && c(m, h - 1, !0);
        }return 0 === h && (i = f(this)), i;
      });
    }, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    var d = c(1)["default"];b.__esModule = !0;var e = c(6),
        f = d(e);b["default"] = function (a) {
      a.registerHelper("helperMissing", function () {
        if (1 !== arguments.length) throw new f["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      });
    }, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    b.__esModule = !0;var d = c(5);b["default"] = function (a) {
      a.registerHelper("if", function (a, b) {
        return d.isFunction(a) && (a = a.call(this)), !b.hash.includeZero && !a || d.isEmpty(a) ? b.inverse(this) : b.fn(this);
      }), a.registerHelper("unless", function (b, c) {
        return a.helpers["if"].call(this, b, { fn: c.inverse, inverse: c.fn, hash: c.hash });
      });
    }, a.exports = b["default"];
  }, function (a, b) {
    "use strict";
    b.__esModule = !0, b["default"] = function (a) {
      a.registerHelper("log", function () {
        for (var b = [void 0], c = arguments[arguments.length - 1], d = 0; d < arguments.length - 1; d++) b.push(arguments[d]);var e = 1;null != c.hash.level ? e = c.hash.level : c.data && null != c.data.level && (e = c.data.level), b[0] = e, a.log.apply(a, b);
      });
    }, a.exports = b["default"];
  }, function (a, b) {
    "use strict";
    b.__esModule = !0, b["default"] = function (a) {
      a.registerHelper("lookup", function (a, b) {
        return a && a[b];
      });
    }, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    b.__esModule = !0;var d = c(5);b["default"] = function (a) {
      a.registerHelper("with", function (a, b) {
        d.isFunction(a) && (a = a.call(this));var c = b.fn;if (d.isEmpty(a)) return b.inverse(this);var e = b.data;return b.data && b.ids && (e = d.createFrame(b.data), e.contextPath = d.appendContextPath(b.data.contextPath, b.ids[0])), c(a, { data: e, blockParams: d.blockParams([a], [e && e.contextPath]) });
      });
    }, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    function d(a) {
      g["default"](a);
    }var e = c(1)["default"];b.__esModule = !0, b.registerDefaultDecorators = d;var f = c(19),
        g = e(f);
  }, function (a, b, c) {
    "use strict";
    b.__esModule = !0;var d = c(5);b["default"] = function (a) {
      a.registerDecorator("inline", function (a, b, c, e) {
        var f = a;return b.partials || (b.partials = {}, f = function (e, f) {
          var g = c.partials;c.partials = d.extend({}, g, b.partials);var h = a(e, f);return c.partials = g, h;
        }), b.partials[e.args[0]] = e.fn, f;
      });
    }, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    b.__esModule = !0;var d = c(5),
        e = { methodMap: ["debug", "info", "warn", "error"], level: "info", lookupLevel: function (a) {
        if ("string" == typeof a) {
          var b = d.indexOf(e.methodMap, a.toLowerCase());a = b >= 0 ? b : parseInt(a, 10);
        }return a;
      }, log: function (a) {
        if (a = e.lookupLevel(a), "undefined" != typeof console && e.lookupLevel(e.level) <= a) {
          var b = e.methodMap[a];console[b] || (b = "log");for (var c = arguments.length, d = Array(c > 1 ? c - 1 : 0), f = 1; f < c; f++) d[f - 1] = arguments[f];console[b].apply(console, d);
        }
      } };b["default"] = e, a.exports = b["default"];
  }, function (a, b) {
    "use strict";
    function c(a) {
      this.string = a;
    }b.__esModule = !0, c.prototype.toString = c.prototype.toHTML = function () {
      return "" + this.string;
    }, b["default"] = c, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    function d(a) {
      var b = a && a[0] || 1,
          c = s.COMPILER_REVISION;if (b !== c) {
        if (b < c) {
          var d = s.REVISION_CHANGES[c],
              e = s.REVISION_CHANGES[b];throw new r["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + d + ") or downgrade your runtime to an older version (" + e + ").");
        }throw new r["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + a[1] + ").");
      }
    }function e(a, b) {
      function c(c, d, e) {
        e.hash && (d = p.extend({}, d, e.hash), e.ids && (e.ids[0] = !0)), c = b.VM.resolvePartial.call(this, c, d, e);var f = b.VM.invokePartial.call(this, c, d, e);if (null == f && b.compile && (e.partials[e.name] = b.compile(c, a.compilerOptions, b), f = e.partials[e.name](d, e)), null != f) {
          if (e.indent) {
            for (var g = f.split("\n"), h = 0, i = g.length; h < i && (g[h] || h + 1 !== i); h++) g[h] = e.indent + g[h];f = g.join("\n");
          }return f;
        }throw new r["default"]("The partial " + e.name + " could not be compiled when running in runtime-only mode");
      }function d(b) {
        function c(b) {
          return "" + a.main(e, b, e.helpers, e.partials, g, i, h);
        }var f = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
            g = f.data;d._setup(f), !f.partial && a.useData && (g = j(b, g));var h = void 0,
            i = a.useBlockParams ? [] : void 0;return a.useDepths && (h = f.depths ? b != f.depths[0] ? [b].concat(f.depths) : f.depths : [b]), (c = k(a.main, c, e, f.depths || [], g, i))(b, f);
      }if (!b) throw new r["default"]("No environment passed to template");if (!a || !a.main) throw new r["default"]("Unknown template object: " + typeof a);a.main.decorator = a.main_d, b.VM.checkRevision(a.compiler);var e = { strict: function (a, b) {
          if (!(b in a)) throw new r["default"]('"' + b + '" not defined in ' + a);return a[b];
        }, lookup: function (a, b) {
          for (var c = a.length, d = 0; d < c; d++) if (a[d] && null != a[d][b]) return a[d][b];
        }, lambda: function (a, b) {
          return "function" == typeof a ? a.call(b) : a;
        }, escapeExpression: p.escapeExpression, invokePartial: c, fn: function (b) {
          var c = a[b];return c.decorator = a[b + "_d"], c;
        }, programs: [], program: function (a, b, c, d, e) {
          var g = this.programs[a],
              h = this.fn(a);return b || e || d || c ? g = f(this, a, h, b, c, d, e) : g || (g = this.programs[a] = f(this, a, h)), g;
        }, data: function (a, b) {
          for (; a && b--;) a = a._parent;return a;
        }, merge: function (a, b) {
          var c = a || b;return a && b && a !== b && (c = p.extend({}, b, a)), c;
        }, nullContext: l({}), noop: b.VM.noop, compilerInfo: a.compiler };return d.isTop = !0, d._setup = function (c) {
        c.partial ? (e.helpers = c.helpers, e.partials = c.partials, e.decorators = c.decorators) : (e.helpers = e.merge(c.helpers, b.helpers), a.usePartial && (e.partials = e.merge(c.partials, b.partials)), (a.usePartial || a.useDecorators) && (e.decorators = e.merge(c.decorators, b.decorators)));
      }, d._child = function (b, c, d, g) {
        if (a.useBlockParams && !d) throw new r["default"]("must pass block params");if (a.useDepths && !g) throw new r["default"]("must pass parent depths");return f(e, b, a[b], c, 0, d, g);
      }, d;
    }function f(a, b, c, d, e, f, g) {
      function h(b) {
        var e = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
            h = g;return !g || b == g[0] || b === a.nullContext && null === g[0] || (h = [b].concat(g)), c(a, b, a.helpers, a.partials, e.data || d, f && [e.blockParams].concat(f), h);
      }return h = k(c, h, a, g, d, f), h.program = b, h.depth = g ? g.length : 0, h.blockParams = e || 0, h;
    }function g(a, b, c) {
      return a ? a.call || c.name || (c.name = a, a = c.partials[a]) : a = "@partial-block" === c.name ? c.data["partial-block"] : c.partials[c.name], a;
    }function h(a, b, c) {
      var d = c.data && c.data["partial-block"];c.partial = !0, c.ids && (c.data.contextPath = c.ids[0] || c.data.contextPath);var e = void 0;if (c.fn && c.fn !== i && !function () {
        c.data = s.createFrame(c.data);var a = c.fn;e = c.data["partial-block"] = function (b) {
          var c = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1];return c.data = s.createFrame(c.data), c.data["partial-block"] = d, a(b, c);
        }, a.partials && (c.partials = p.extend({}, c.partials, a.partials));
      }(), void 0 === a && e && (a = e), void 0 === a) throw new r["default"]("The partial " + c.name + " could not be found");if (a instanceof Function) return a(b, c);
    }function i() {
      return "";
    }function j(a, b) {
      return b && "root" in b || (b = b ? s.createFrame(b) : {}, b.root = a), b;
    }function k(a, b, c, d, e, f) {
      if (a.decorator) {
        var g = {};b = a.decorator(b, g, c, d && d[0], e, f, d), p.extend(b, g);
      }return b;
    }var l = c(23)["default"],
        m = c(3)["default"],
        n = c(1)["default"];b.__esModule = !0, b.checkRevision = d, b.template = e, b.wrapProgram = f, b.resolvePartial = g, b.invokePartial = h, b.noop = i;var o = c(5),
        p = m(o),
        q = c(6),
        r = n(q),
        s = c(4);
  }, function (a, b, c) {
    a.exports = { "default": c(24), __esModule: !0 };
  }, function (a, b, c) {
    c(25), a.exports = c(30).Object.seal;
  }, function (a, b, c) {
    var d = c(26);c(27)("seal", function (a) {
      return function (b) {
        return a && d(b) ? a(b) : b;
      };
    });
  }, function (a, b) {
    a.exports = function (a) {
      return "object" == typeof a ? null !== a : "function" == typeof a;
    };
  }, function (a, b, c) {
    var d = c(28),
        e = c(30),
        f = c(33);a.exports = function (a, b) {
      var c = (e.Object || {})[a] || Object[a],
          g = {};g[a] = b(c), d(d.S + d.F * f(function () {
        c(1);
      }), "Object", g);
    };
  }, function (a, b, c) {
    var d = c(29),
        e = c(30),
        f = c(31),
        g = "prototype",
        h = function (a, b, c) {
      var i,
          j,
          k,
          l = a & h.F,
          m = a & h.G,
          n = a & h.S,
          o = a & h.P,
          p = a & h.B,
          q = a & h.W,
          r = m ? e : e[b] || (e[b] = {}),
          s = m ? d : n ? d[b] : (d[b] || {})[g];m && (c = b);for (i in c) j = !l && s && i in s, j && i in r || (k = j ? s[i] : c[i], r[i] = m && "function" != typeof s[i] ? c[i] : p && j ? f(k, d) : q && s[i] == k ? function (a) {
        var b = function (b) {
          return this instanceof a ? new a(b) : a(b);
        };return b[g] = a[g], b;
      }(k) : o && "function" == typeof k ? f(Function.call, k) : k, o && ((r[g] || (r[g] = {}))[i] = k));
    };h.F = 1, h.G = 2, h.S = 4, h.P = 8, h.B = 16, h.W = 32, a.exports = h;
  }, function (a, b) {
    var c = a.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();"number" == typeof __g && (__g = c);
  }, function (a, b) {
    var c = a.exports = { version: "1.2.6" };"number" == typeof __e && (__e = c);
  }, function (a, b, c) {
    var d = c(32);a.exports = function (a, b, c) {
      if (d(a), void 0 === b) return a;switch (c) {case 1:
          return function (c) {
            return a.call(b, c);
          };case 2:
          return function (c, d) {
            return a.call(b, c, d);
          };case 3:
          return function (c, d, e) {
            return a.call(b, c, d, e);
          };}return function () {
        return a.apply(b, arguments);
      };
    };
  }, function (a, b) {
    a.exports = function (a) {
      if ("function" != typeof a) throw TypeError(a + " is not a function!");return a;
    };
  }, function (a, b) {
    a.exports = function (a) {
      try {
        return !!a();
      } catch (b) {
        return !0;
      }
    };
  }, function (a, b) {
    (function (c) {
      "use strict";
      b.__esModule = !0, b["default"] = function (a) {
        var b = "undefined" != typeof c ? c : window,
            d = b.Handlebars;a.noConflict = function () {
          return b.Handlebars === a && (b.Handlebars = d), a;
        };
      }, a.exports = b["default"];
    }).call(b, function () {
      return this;
    }());
  }, function (a, b) {
    "use strict";
    b.__esModule = !0;var c = { helpers: { helperExpression: function (a) {
          return "SubExpression" === a.type || ("MustacheStatement" === a.type || "BlockStatement" === a.type) && !!(a.params && a.params.length || a.hash);
        }, scopedId: function (a) {
          return (/^\.|this\b/.test(a.original)
          );
        }, simpleId: function (a) {
          return 1 === a.parts.length && !c.helpers.scopedId(a) && !a.depth;
        } } };b["default"] = c, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    function d(a, b) {
      if ("Program" === a.type) return a;h["default"].yy = n, n.locInfo = function (a) {
        return new n.SourceLocation(b && b.srcName, a);
      };var c = new j["default"](b);return c.accept(h["default"].parse(a));
    }var e = c(1)["default"],
        f = c(3)["default"];b.__esModule = !0, b.parse = d;var g = c(37),
        h = e(g),
        i = c(38),
        j = e(i),
        k = c(40),
        l = f(k),
        m = c(5);b.parser = h["default"];var n = {};m.extend(n, l);
  }, function (a, b) {
    "use strict";
    b.__esModule = !0;var c = function () {
      function a() {
        this.yy = {};
      }var b = { trace: function () {}, yy: {}, symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition_plus0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1 }, terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" }, productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]], performAction: function (a, b, c, d, e, f, g) {
          var h = f.length - 1;switch (e) {case 1:
              return f[h - 1];case 2:
              this.$ = d.prepareProgram(f[h]);break;case 3:
              this.$ = f[h];break;case 4:
              this.$ = f[h];break;case 5:
              this.$ = f[h];break;case 6:
              this.$ = f[h];break;case 7:
              this.$ = f[h];break;case 8:
              this.$ = f[h];break;case 9:
              this.$ = { type: "CommentStatement", value: d.stripComment(f[h]), strip: d.stripFlags(f[h], f[h]), loc: d.locInfo(this._$) };break;case 10:
              this.$ = { type: "ContentStatement", original: f[h], value: f[h], loc: d.locInfo(this._$) };break;case 11:
              this.$ = d.prepareRawBlock(f[h - 2], f[h - 1], f[h], this._$);break;case 12:
              this.$ = { path: f[h - 3], params: f[h - 2], hash: f[h - 1] };break;case 13:
              this.$ = d.prepareBlock(f[h - 3], f[h - 2], f[h - 1], f[h], !1, this._$);break;case 14:
              this.$ = d.prepareBlock(f[h - 3], f[h - 2], f[h - 1], f[h], !0, this._$);break;case 15:
              this.$ = { open: f[h - 5], path: f[h - 4], params: f[h - 3], hash: f[h - 2], blockParams: f[h - 1], strip: d.stripFlags(f[h - 5], f[h]) };break;case 16:
              this.$ = { path: f[h - 4], params: f[h - 3], hash: f[h - 2], blockParams: f[h - 1], strip: d.stripFlags(f[h - 5], f[h]) };break;case 17:
              this.$ = { path: f[h - 4], params: f[h - 3], hash: f[h - 2], blockParams: f[h - 1], strip: d.stripFlags(f[h - 5], f[h]) };break;case 18:
              this.$ = { strip: d.stripFlags(f[h - 1], f[h - 1]), program: f[h] };break;case 19:
              var i = d.prepareBlock(f[h - 2], f[h - 1], f[h], f[h], !1, this._$),
                  j = d.prepareProgram([i], f[h - 1].loc);j.chained = !0, this.$ = { strip: f[h - 2].strip, program: j, chain: !0 };break;case 20:
              this.$ = f[h];break;case 21:
              this.$ = { path: f[h - 1], strip: d.stripFlags(f[h - 2], f[h]) };break;case 22:
              this.$ = d.prepareMustache(f[h - 3], f[h - 2], f[h - 1], f[h - 4], d.stripFlags(f[h - 4], f[h]), this._$);break;case 23:
              this.$ = d.prepareMustache(f[h - 3], f[h - 2], f[h - 1], f[h - 4], d.stripFlags(f[h - 4], f[h]), this._$);break;case 24:
              this.$ = { type: "PartialStatement", name: f[h - 3], params: f[h - 2], hash: f[h - 1], indent: "", strip: d.stripFlags(f[h - 4], f[h]), loc: d.locInfo(this._$) };break;case 25:
              this.$ = d.preparePartialBlock(f[h - 2], f[h - 1], f[h], this._$);break;case 26:
              this.$ = { path: f[h - 3], params: f[h - 2], hash: f[h - 1], strip: d.stripFlags(f[h - 4], f[h]) };break;case 27:
              this.$ = f[h];break;case 28:
              this.$ = f[h];break;case 29:
              this.$ = { type: "SubExpression", path: f[h - 3], params: f[h - 2], hash: f[h - 1], loc: d.locInfo(this._$) };break;case 30:
              this.$ = { type: "Hash", pairs: f[h], loc: d.locInfo(this._$) };break;case 31:
              this.$ = { type: "HashPair", key: d.id(f[h - 2]), value: f[h], loc: d.locInfo(this._$) };break;case 32:
              this.$ = d.id(f[h - 1]);break;case 33:
              this.$ = f[h];break;case 34:
              this.$ = f[h];break;case 35:
              this.$ = { type: "StringLiteral", value: f[h], original: f[h], loc: d.locInfo(this._$) };break;case 36:
              this.$ = { type: "NumberLiteral", value: Number(f[h]), original: Number(f[h]), loc: d.locInfo(this._$) };break;case 37:
              this.$ = { type: "BooleanLiteral", value: "true" === f[h], original: "true" === f[h], loc: d.locInfo(this._$) };break;case 38:
              this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: d.locInfo(this._$) };break;case 39:
              this.$ = { type: "NullLiteral", original: null, value: null, loc: d.locInfo(this._$) };break;case 40:
              this.$ = f[h];break;case 41:
              this.$ = f[h];break;case 42:
              this.$ = d.preparePath(!0, f[h], this._$);break;case 43:
              this.$ = d.preparePath(!1, f[h], this._$);break;case 44:
              f[h - 2].push({ part: d.id(f[h]), original: f[h], separator: f[h - 1] }), this.$ = f[h - 2];break;case 45:
              this.$ = [{ part: d.id(f[h]), original: f[h] }];break;case 46:
              this.$ = [];break;case 47:
              f[h - 1].push(f[h]);break;case 48:
              this.$ = [f[h]];break;case 49:
              f[h - 1].push(f[h]);break;case 50:
              this.$ = [];break;case 51:
              f[h - 1].push(f[h]);break;case 58:
              this.$ = [];break;case 59:
              f[h - 1].push(f[h]);break;case 64:
              this.$ = [];break;case 65:
              f[h - 1].push(f[h]);break;case 70:
              this.$ = [];break;case 71:
              f[h - 1].push(f[h]);break;case 78:
              this.$ = [];break;case 79:
              f[h - 1].push(f[h]);break;case 82:
              this.$ = [];break;case 83:
              f[h - 1].push(f[h]);break;case 86:
              this.$ = [];break;case 87:
              f[h - 1].push(f[h]);break;case 90:
              this.$ = [];break;case 91:
              f[h - 1].push(f[h]);break;case 94:
              this.$ = [];break;case 95:
              f[h - 1].push(f[h]);break;case 98:
              this.$ = [f[h]];break;case 99:
              f[h - 1].push(f[h]);break;case 100:
              this.$ = [f[h]];break;case 101:
              f[h - 1].push(f[h]);}
        }, table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87],
          85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }], defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] }, parseError: function (a, b) {
          throw new Error(a);
        }, parse: function (a) {
          function b() {
            var a;return a = c.lexer.lex() || 1, "number" != typeof a && (a = c.symbols_[a] || a), a;
          }var c = this,
              d = [0],
              e = [null],
              f = [],
              g = this.table,
              h = "",
              i = 0,
              j = 0,
              k = 0;this.lexer.setInput(a), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, "undefined" == typeof this.lexer.yylloc && (this.lexer.yylloc = {});var l = this.lexer.yylloc;f.push(l);var m = this.lexer.options && this.lexer.options.ranges;"function" == typeof this.yy.parseError && (this.parseError = this.yy.parseError);for (var n, o, p, q, r, s, t, u, v, w = {};;) {
            if (p = d[d.length - 1], this.defaultActions[p] ? q = this.defaultActions[p] : (null !== n && "undefined" != typeof n || (n = b()), q = g[p] && g[p][n]), "undefined" == typeof q || !q.length || !q[0]) {
              var x = "";if (!k) {
                v = [];for (s in g[p]) this.terminals_[s] && s > 2 && v.push("'" + this.terminals_[s] + "'");x = this.lexer.showPosition ? "Parse error on line " + (i + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + v.join(", ") + ", got '" + (this.terminals_[n] || n) + "'" : "Parse error on line " + (i + 1) + ": Unexpected " + (1 == n ? "end of input" : "'" + (this.terminals_[n] || n) + "'"), this.parseError(x, { text: this.lexer.match, token: this.terminals_[n] || n, line: this.lexer.yylineno, loc: l, expected: v });
              }
            }if (q[0] instanceof Array && q.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + p + ", token: " + n);switch (q[0]) {case 1:
                d.push(n), e.push(this.lexer.yytext), f.push(this.lexer.yylloc), d.push(q[1]), n = null, o ? (n = o, o = null) : (j = this.lexer.yyleng, h = this.lexer.yytext, i = this.lexer.yylineno, l = this.lexer.yylloc, k > 0 && k--);break;case 2:
                if (t = this.productions_[q[1]][1], w.$ = e[e.length - t], w._$ = { first_line: f[f.length - (t || 1)].first_line, last_line: f[f.length - 1].last_line, first_column: f[f.length - (t || 1)].first_column, last_column: f[f.length - 1].last_column }, m && (w._$.range = [f[f.length - (t || 1)].range[0], f[f.length - 1].range[1]]), r = this.performAction.call(w, h, j, i, this.yy, q[1], e, f), "undefined" != typeof r) return r;t && (d = d.slice(0, -1 * t * 2), e = e.slice(0, -1 * t), f = f.slice(0, -1 * t)), d.push(this.productions_[q[1]][0]), e.push(w.$), f.push(w._$), u = g[d[d.length - 2]][d[d.length - 1]], d.push(u);break;case 3:
                return !0;}
          }return !0;
        } },
          c = function () {
        var a = { EOF: 1, parseError: function (a, b) {
            if (!this.yy.parser) throw new Error(a);this.yy.parser.parseError(a, b);
          }, setInput: function (a) {
            return this._input = a, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
          }, input: function () {
            var a = this._input[0];this.yytext += a, this.yyleng++, this.offset++, this.match += a, this.matched += a;var b = a.match(/(?:\r\n?|\n).*/g);return b ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), a;
          }, unput: function (a) {
            var b = a.length,
                c = a.split(/(?:\r\n?|\n)/g);this._input = a + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - b - 1), this.offset -= b;var d = this.match.split(/(?:\r\n?|\n)/g);this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), c.length - 1 && (this.yylineno -= c.length - 1);var e = this.yylloc.range;return this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: c ? (c.length === d.length ? this.yylloc.first_column : 0) + d[d.length - c.length].length - c[0].length : this.yylloc.first_column - b }, this.options.ranges && (this.yylloc.range = [e[0], e[0] + this.yyleng - b]), this;
          }, more: function () {
            return this._more = !0, this;
          }, less: function (a) {
            this.unput(this.match.slice(a));
          }, pastInput: function () {
            var a = this.matched.substr(0, this.matched.length - this.match.length);return (a.length > 20 ? "..." : "") + a.substr(-20).replace(/\n/g, "");
          }, upcomingInput: function () {
            var a = this.match;return a.length < 20 && (a += this._input.substr(0, 20 - a.length)), (a.substr(0, 20) + (a.length > 20 ? "..." : "")).replace(/\n/g, "");
          }, showPosition: function () {
            var a = this.pastInput(),
                b = new Array(a.length + 1).join("-");return a + this.upcomingInput() + "\n" + b + "^";
          }, next: function () {
            if (this.done) return this.EOF;this._input || (this.done = !0);var a, b, c, d, e;this._more || (this.yytext = "", this.match = "");for (var f = this._currentRules(), g = 0; g < f.length && (c = this._input.match(this.rules[f[g]]), !c || b && !(c[0].length > b[0].length) || (b = c, d = g, this.options.flex)); g++);return b ? (e = b[0].match(/(?:\r\n?|\n).*/g), e && (this.yylineno += e.length), this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: e ? e[e.length - 1].length - e[e.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + b[0].length }, this.yytext += b[0], this.match += b[0], this.matches = b, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._input = this._input.slice(b[0].length), this.matched += b[0], a = this.performAction.call(this, this.yy, this, f[d], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), a ? a : void 0) : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
          }, lex: function () {
            var a = this.next();return "undefined" != typeof a ? a : this.lex();
          }, begin: function (a) {
            this.conditionStack.push(a);
          }, popState: function () {
            return this.conditionStack.pop();
          }, _currentRules: function () {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          }, topState: function () {
            return this.conditionStack[this.conditionStack.length - 2];
          }, pushState: function (a) {
            this.begin(a);
          } };return a.options = {}, a.performAction = function (a, b, c, d) {
          function e(a, c) {
            return b.yytext = b.yytext.substr(a, b.yyleng - c);
          }switch (c) {case 0:
              if ("\\\\" === b.yytext.slice(-2) ? (e(0, 1), this.begin("mu")) : "\\" === b.yytext.slice(-1) ? (e(0, 1), this.begin("emu")) : this.begin("mu"), b.yytext) return 15;break;case 1:
              return 15;case 2:
              return this.popState(), 15;case 3:
              return this.begin("raw"), 15;case 4:
              return this.popState(), "raw" === this.conditionStack[this.conditionStack.length - 1] ? 15 : (b.yytext = b.yytext.substr(5, b.yyleng - 9), "END_RAW_BLOCK");case 5:
              return 15;case 6:
              return this.popState(), 14;case 7:
              return 65;case 8:
              return 68;case 9:
              return 19;case 10:
              return this.popState(), this.begin("raw"), 23;case 11:
              return 55;case 12:
              return 60;case 13:
              return 29;case 14:
              return 47;case 15:
              return this.popState(), 44;case 16:
              return this.popState(), 44;case 17:
              return 34;case 18:
              return 39;case 19:
              return 51;case 20:
              return 48;case 21:
              this.unput(b.yytext), this.popState(), this.begin("com");break;case 22:
              return this.popState(), 14;case 23:
              return 48;case 24:
              return 73;case 25:
              return 72;case 26:
              return 72;case 27:
              return 87;case 28:
              break;case 29:
              return this.popState(), 54;case 30:
              return this.popState(), 33;case 31:
              return b.yytext = e(1, 2).replace(/\\"/g, '"'), 80;case 32:
              return b.yytext = e(1, 2).replace(/\\'/g, "'"), 80;case 33:
              return 85;case 34:
              return 82;case 35:
              return 82;case 36:
              return 83;case 37:
              return 84;case 38:
              return 81;case 39:
              return 75;case 40:
              return 77;case 41:
              return 72;case 42:
              return b.yytext = b.yytext.replace(/\\([\\\]])/g, "$1"), 72;case 43:
              return "INVALID";case 44:
              return 5;}
        }, a.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/], a.conditions = { mu: { rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: !1 }, emu: { rules: [2], inclusive: !1 }, com: { rules: [6], inclusive: !1 }, raw: { rules: [3, 4, 5], inclusive: !1 }, INITIAL: { rules: [0, 1, 44], inclusive: !0 } }, a;
      }();return b.lexer = c, a.prototype = b, b.Parser = a, new a();
    }();b["default"] = c, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    function d() {
      var a = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];this.options = a;
    }function e(a, b, c) {
      void 0 === b && (b = a.length);var d = a[b - 1],
          e = a[b - 2];return d ? "ContentStatement" === d.type ? (e || !c ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(d.original) : void 0 : c;
    }function f(a, b, c) {
      void 0 === b && (b = -1);var d = a[b + 1],
          e = a[b + 2];return d ? "ContentStatement" === d.type ? (e || !c ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(d.original) : void 0 : c;
    }function g(a, b, c) {
      var d = a[null == b ? 0 : b + 1];if (d && "ContentStatement" === d.type && (c || !d.rightStripped)) {
        var e = d.value;d.value = d.value.replace(c ? /^\s+/ : /^[ \t]*\r?\n?/, ""), d.rightStripped = d.value !== e;
      }
    }function h(a, b, c) {
      var d = a[null == b ? a.length - 1 : b - 1];if (d && "ContentStatement" === d.type && (c || !d.leftStripped)) {
        var e = d.value;return d.value = d.value.replace(c ? /\s+$/ : /[ \t]+$/, ""), d.leftStripped = d.value !== e, d.leftStripped;
      }
    }var i = c(1)["default"];b.__esModule = !0;var j = c(39),
        k = i(j);d.prototype = new k["default"](), d.prototype.Program = function (a) {
      var b = !this.options.ignoreStandalone,
          c = !this.isRootSeen;this.isRootSeen = !0;for (var d = a.body, i = 0, j = d.length; i < j; i++) {
        var k = d[i],
            l = this.accept(k);if (l) {
          var m = e(d, i, c),
              n = f(d, i, c),
              o = l.openStandalone && m,
              p = l.closeStandalone && n,
              q = l.inlineStandalone && m && n;l.close && g(d, i, !0), l.open && h(d, i, !0), b && q && (g(d, i), h(d, i) && "PartialStatement" === k.type && (k.indent = /([ \t]+$)/.exec(d[i - 1].original)[1])), b && o && (g((k.program || k.inverse).body), h(d, i)), b && p && (g(d, i), h((k.inverse || k.program).body));
        }
      }return a;
    }, d.prototype.BlockStatement = d.prototype.DecoratorBlock = d.prototype.PartialBlockStatement = function (a) {
      this.accept(a.program), this.accept(a.inverse);var b = a.program || a.inverse,
          c = a.program && a.inverse,
          d = c,
          i = c;if (c && c.chained) for (d = c.body[0].program; i.chained;) i = i.body[i.body.length - 1].program;var j = { open: a.openStrip.open, close: a.closeStrip.close, openStandalone: f(b.body), closeStandalone: e((d || b).body) };if (a.openStrip.close && g(b.body, null, !0), c) {
        var k = a.inverseStrip;k.open && h(b.body, null, !0), k.close && g(d.body, null, !0), a.closeStrip.open && h(i.body, null, !0), !this.options.ignoreStandalone && e(b.body) && f(d.body) && (h(b.body), g(d.body));
      } else a.closeStrip.open && h(b.body, null, !0);return j;
    }, d.prototype.Decorator = d.prototype.MustacheStatement = function (a) {
      return a.strip;
    }, d.prototype.PartialStatement = d.prototype.CommentStatement = function (a) {
      var b = a.strip || {};return { inlineStandalone: !0, open: b.open, close: b.close };
    }, b["default"] = d, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    function d() {
      this.parents = [];
    }function e(a) {
      this.acceptRequired(a, "path"), this.acceptArray(a.params), this.acceptKey(a, "hash");
    }function f(a) {
      e.call(this, a), this.acceptKey(a, "program"), this.acceptKey(a, "inverse");
    }function g(a) {
      this.acceptRequired(a, "name"), this.acceptArray(a.params), this.acceptKey(a, "hash");
    }var h = c(1)["default"];b.__esModule = !0;var i = c(6),
        j = h(i);d.prototype = { constructor: d, mutating: !1, acceptKey: function (a, b) {
        var c = this.accept(a[b]);if (this.mutating) {
          if (c && !d.prototype[c.type]) throw new j["default"]('Unexpected node type "' + c.type + '" found when accepting ' + b + " on " + a.type);a[b] = c;
        }
      }, acceptRequired: function (a, b) {
        if (this.acceptKey(a, b), !a[b]) throw new j["default"](a.type + " requires " + b);
      }, acceptArray: function (a) {
        for (var b = 0, c = a.length; b < c; b++) this.acceptKey(a, b), a[b] || (a.splice(b, 1), b--, c--);
      }, accept: function (a) {
        if (a) {
          if (!this[a.type]) throw new j["default"]("Unknown type: " + a.type, a);this.current && this.parents.unshift(this.current), this.current = a;var b = this[a.type](a);return this.current = this.parents.shift(), !this.mutating || b ? b : b !== !1 ? a : void 0;
        }
      }, Program: function (a) {
        this.acceptArray(a.body);
      }, MustacheStatement: e, Decorator: e, BlockStatement: f, DecoratorBlock: f, PartialStatement: g, PartialBlockStatement: function (a) {
        g.call(this, a), this.acceptKey(a, "program");
      }, ContentStatement: function () {}, CommentStatement: function () {}, SubExpression: e, PathExpression: function () {}, StringLiteral: function () {}, NumberLiteral: function () {}, BooleanLiteral: function () {}, UndefinedLiteral: function () {}, NullLiteral: function () {}, Hash: function (a) {
        this.acceptArray(a.pairs);
      }, HashPair: function (a) {
        this.acceptRequired(a, "value");
      } }, b["default"] = d, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    function d(a, b) {
      if (b = b.path ? b.path.original : b, a.path.original !== b) {
        var c = { loc: a.path.loc };throw new q["default"](a.path.original + " doesn't match " + b, c);
      }
    }function e(a, b) {
      this.source = a, this.start = { line: b.first_line, column: b.first_column }, this.end = { line: b.last_line, column: b.last_column };
    }function f(a) {
      return (/^\[.*\]$/.test(a) ? a.substr(1, a.length - 2) : a
      );
    }function g(a, b) {
      return { open: "~" === a.charAt(2), close: "~" === b.charAt(b.length - 3) };
    }function h(a) {
      return a.replace(/^\{\{~?\!-?-?/, "").replace(/-?-?~?\}\}$/, "");
    }function i(a, b, c) {
      c = this.locInfo(c);for (var d = a ? "@" : "", e = [], f = 0, g = "", h = 0, i = b.length; h < i; h++) {
        var j = b[h].part,
            k = b[h].original !== j;if (d += (b[h].separator || "") + j, k || ".." !== j && "." !== j && "this" !== j) e.push(j);else {
          if (e.length > 0) throw new q["default"]("Invalid path: " + d, { loc: c });".." === j && (f++, g += "../");
        }
      }return { type: "PathExpression", data: a, depth: f, parts: e, original: d, loc: c };
    }function j(a, b, c, d, e, f) {
      var g = d.charAt(3) || d.charAt(2),
          h = "{" !== g && "&" !== g,
          i = /\*/.test(d);return { type: i ? "Decorator" : "MustacheStatement", path: a, params: b, hash: c, escaped: h, strip: e, loc: this.locInfo(f) };
    }function k(a, b, c, e) {
      d(a, c), e = this.locInfo(e);var f = { type: "Program", body: b, strip: {}, loc: e };return { type: "BlockStatement", path: a.path, params: a.params, hash: a.hash, program: f, openStrip: {}, inverseStrip: {}, closeStrip: {}, loc: e };
    }function l(a, b, c, e, f, g) {
      e && e.path && d(a, e);var h = /\*/.test(a.open);b.blockParams = a.blockParams;var i = void 0,
          j = void 0;if (c) {
        if (h) throw new q["default"]("Unexpected inverse block on decorator", c);c.chain && (c.program.body[0].closeStrip = e.strip), j = c.strip, i = c.program;
      }return f && (f = i, i = b, b = f), { type: h ? "DecoratorBlock" : "BlockStatement", path: a.path, params: a.params, hash: a.hash, program: b, inverse: i, openStrip: a.strip, inverseStrip: j, closeStrip: e && e.strip, loc: this.locInfo(g) };
    }function m(a, b) {
      if (!b && a.length) {
        var c = a[0].loc,
            d = a[a.length - 1].loc;c && d && (b = { source: c.source, start: { line: c.start.line, column: c.start.column }, end: { line: d.end.line, column: d.end.column } });
      }return { type: "Program", body: a, strip: {}, loc: b };
    }function n(a, b, c, e) {
      return d(a, c), { type: "PartialBlockStatement", name: a.path, params: a.params, hash: a.hash, program: b, openStrip: a.strip, closeStrip: c && c.strip, loc: this.locInfo(e) };
    }var o = c(1)["default"];b.__esModule = !0, b.SourceLocation = e, b.id = f, b.stripFlags = g, b.stripComment = h, b.preparePath = i, b.prepareMustache = j, b.prepareRawBlock = k, b.prepareBlock = l, b.prepareProgram = m, b.preparePartialBlock = n;var p = c(6),
        q = o(p);
  }, function (a, b, c) {
    "use strict";
    function d() {}function e(a, b, c) {
      if (null == a || "string" != typeof a && "Program" !== a.type) throw new k["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + a);b = b || {}, "data" in b || (b.data = !0), b.compat && (b.useDepths = !0);var d = c.parse(a, b),
          e = new c.Compiler().compile(d, b);return new c.JavaScriptCompiler().compile(e, b);
    }function f(a, b, c) {
      function d() {
        var d = c.parse(a, b),
            e = new c.Compiler().compile(d, b),
            f = new c.JavaScriptCompiler().compile(e, b, void 0, !0);return c.template(f);
      }function e(a, b) {
        return f || (f = d()), f.call(this, a, b);
      }if (void 0 === b && (b = {}), null == a || "string" != typeof a && "Program" !== a.type) throw new k["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + a);b = l.extend({}, b), "data" in b || (b.data = !0), b.compat && (b.useDepths = !0);var f = void 0;return e._setup = function (a) {
        return f || (f = d()), f._setup(a);
      }, e._child = function (a, b, c, e) {
        return f || (f = d()), f._child(a, b, c, e);
      }, e;
    }function g(a, b) {
      if (a === b) return !0;if (l.isArray(a) && l.isArray(b) && a.length === b.length) {
        for (var c = 0; c < a.length; c++) if (!g(a[c], b[c])) return !1;return !0;
      }
    }function h(a) {
      if (!a.path.parts) {
        var b = a.path;a.path = { type: "PathExpression", data: !1, depth: 0, parts: [b.original + ""], original: b.original + "", loc: b.loc };
      }
    }var i = c(1)["default"];b.__esModule = !0, b.Compiler = d, b.precompile = e, b.compile = f;var j = c(6),
        k = i(j),
        l = c(5),
        m = c(35),
        n = i(m),
        o = [].slice;d.prototype = { compiler: d, equals: function (a) {
        var b = this.opcodes.length;if (a.opcodes.length !== b) return !1;for (var c = 0; c < b; c++) {
          var d = this.opcodes[c],
              e = a.opcodes[c];if (d.opcode !== e.opcode || !g(d.args, e.args)) return !1;
        }b = this.children.length;for (var c = 0; c < b; c++) if (!this.children[c].equals(a.children[c])) return !1;return !0;
      }, guid: 0, compile: function (a, b) {
        this.sourceNode = [], this.opcodes = [], this.children = [], this.options = b, this.stringParams = b.stringParams, this.trackIds = b.trackIds, b.blockParams = b.blockParams || [];var c = b.knownHelpers;if (b.knownHelpers = { helperMissing: !0, blockHelperMissing: !0, each: !0, "if": !0, unless: !0, "with": !0, log: !0, lookup: !0 }, c) for (var d in c) d in c && (this.options.knownHelpers[d] = c[d]);return this.accept(a);
      }, compileProgram: function (a) {
        var b = new this.compiler(),
            c = b.compile(a, this.options),
            d = this.guid++;return this.usePartial = this.usePartial || c.usePartial, this.children[d] = c, this.useDepths = this.useDepths || c.useDepths, d;
      }, accept: function (a) {
        if (!this[a.type]) throw new k["default"]("Unknown type: " + a.type, a);this.sourceNode.unshift(a);var b = this[a.type](a);return this.sourceNode.shift(), b;
      }, Program: function (a) {
        this.options.blockParams.unshift(a.blockParams);for (var b = a.body, c = b.length, d = 0; d < c; d++) this.accept(b[d]);return this.options.blockParams.shift(), this.isSimple = 1 === c, this.blockParams = a.blockParams ? a.blockParams.length : 0, this;
      }, BlockStatement: function (a) {
        h(a);var b = a.program,
            c = a.inverse;b = b && this.compileProgram(b), c = c && this.compileProgram(c);var d = this.classifySexpr(a);"helper" === d ? this.helperSexpr(a, b, c) : "simple" === d ? (this.simpleSexpr(a), this.opcode("pushProgram", b), this.opcode("pushProgram", c), this.opcode("emptyHash"), this.opcode("blockValue", a.path.original)) : (this.ambiguousSexpr(a, b, c), this.opcode("pushProgram", b), this.opcode("pushProgram", c), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue")), this.opcode("append");
      }, DecoratorBlock: function (a) {
        var b = a.program && this.compileProgram(a.program),
            c = this.setupFullMustacheParams(a, b, void 0),
            d = a.path;this.useDecorators = !0, this.opcode("registerDecorator", c.length, d.original);
      }, PartialStatement: function (a) {
        this.usePartial = !0;var b = a.program;b && (b = this.compileProgram(a.program));var c = a.params;if (c.length > 1) throw new k["default"]("Unsupported number of partial arguments: " + c.length, a);c.length || (this.options.explicitPartialContext ? this.opcode("pushLiteral", "undefined") : c.push({ type: "PathExpression", parts: [], depth: 0 }));var d = a.name.original,
            e = "SubExpression" === a.name.type;e && this.accept(a.name), this.setupFullMustacheParams(a, b, void 0, !0);var f = a.indent || "";this.options.preventIndent && f && (this.opcode("appendContent", f), f = ""), this.opcode("invokePartial", e, d, f), this.opcode("append");
      }, PartialBlockStatement: function (a) {
        this.PartialStatement(a);
      }, MustacheStatement: function (a) {
        this.SubExpression(a), a.escaped && !this.options.noEscape ? this.opcode("appendEscaped") : this.opcode("append");
      }, Decorator: function (a) {
        this.DecoratorBlock(a);
      }, ContentStatement: function (a) {
        a.value && this.opcode("appendContent", a.value);
      }, CommentStatement: function () {}, SubExpression: function (a) {
        h(a);var b = this.classifySexpr(a);"simple" === b ? this.simpleSexpr(a) : "helper" === b ? this.helperSexpr(a) : this.ambiguousSexpr(a);
      }, ambiguousSexpr: function (a, b, c) {
        var d = a.path,
            e = d.parts[0],
            f = null != b || null != c;this.opcode("getContext", d.depth), this.opcode("pushProgram", b), this.opcode("pushProgram", c), d.strict = !0, this.accept(d), this.opcode("invokeAmbiguous", e, f);
      }, simpleSexpr: function (a) {
        var b = a.path;b.strict = !0, this.accept(b), this.opcode("resolvePossibleLambda");
      }, helperSexpr: function (a, b, c) {
        var d = this.setupFullMustacheParams(a, b, c),
            e = a.path,
            f = e.parts[0];if (this.options.knownHelpers[f]) this.opcode("invokeKnownHelper", d.length, f);else {
          if (this.options.knownHelpersOnly) throw new k["default"]("You specified knownHelpersOnly, but used the unknown helper " + f, a);e.strict = !0, e.falsy = !0, this.accept(e), this.opcode("invokeHelper", d.length, e.original, n["default"].helpers.simpleId(e));
        }
      }, PathExpression: function (a) {
        this.addDepth(a.depth), this.opcode("getContext", a.depth);var b = a.parts[0],
            c = n["default"].helpers.scopedId(a),
            d = !a.depth && !c && this.blockParamIndex(b);d ? this.opcode("lookupBlockParam", d, a.parts) : b ? a.data ? (this.options.data = !0, this.opcode("lookupData", a.depth, a.parts, a.strict)) : this.opcode("lookupOnContext", a.parts, a.falsy, a.strict, c) : this.opcode("pushContext");
      }, StringLiteral: function (a) {
        this.opcode("pushString", a.value);
      }, NumberLiteral: function (a) {
        this.opcode("pushLiteral", a.value);
      }, BooleanLiteral: function (a) {
        this.opcode("pushLiteral", a.value);
      }, UndefinedLiteral: function () {
        this.opcode("pushLiteral", "undefined");
      }, NullLiteral: function () {
        this.opcode("pushLiteral", "null");
      }, Hash: function (a) {
        var b = a.pairs,
            c = 0,
            d = b.length;for (this.opcode("pushHash"); c < d; c++) this.pushParam(b[c].value);for (; c--;) this.opcode("assignToHash", b[c].key);this.opcode("popHash");
      }, opcode: function (a) {
        this.opcodes.push({ opcode: a, args: o.call(arguments, 1), loc: this.sourceNode[0].loc });
      }, addDepth: function (a) {
        a && (this.useDepths = !0);
      }, classifySexpr: function (a) {
        var b = n["default"].helpers.simpleId(a.path),
            c = b && !!this.blockParamIndex(a.path.parts[0]),
            d = !c && n["default"].helpers.helperExpression(a),
            e = !c && (d || b);if (e && !d) {
          var f = a.path.parts[0],
              g = this.options;g.knownHelpers[f] ? d = !0 : g.knownHelpersOnly && (e = !1);
        }return d ? "helper" : e ? "ambiguous" : "simple";
      }, pushParams: function (a) {
        for (var b = 0, c = a.length; b < c; b++) this.pushParam(a[b]);
      }, pushParam: function (a) {
        var b = null != a.value ? a.value : a.original || "";if (this.stringParams) b.replace && (b = b.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".")), a.depth && this.addDepth(a.depth), this.opcode("getContext", a.depth || 0), this.opcode("pushStringParam", b, a.type), "SubExpression" === a.type && this.accept(a);else {
          if (this.trackIds) {
            var c = void 0;if (!a.parts || n["default"].helpers.scopedId(a) || a.depth || (c = this.blockParamIndex(a.parts[0])), c) {
              var d = a.parts.slice(1).join(".");this.opcode("pushId", "BlockParam", c, d);
            } else b = a.original || b, b.replace && (b = b.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "")), this.opcode("pushId", a.type, b);
          }this.accept(a);
        }
      }, setupFullMustacheParams: function (a, b, c, d) {
        var e = a.params;return this.pushParams(e), this.opcode("pushProgram", b), this.opcode("pushProgram", c), a.hash ? this.accept(a.hash) : this.opcode("emptyHash", d), e;
      }, blockParamIndex: function (a) {
        for (var b = 0, c = this.options.blockParams.length; b < c; b++) {
          var d = this.options.blockParams[b],
              e = d && l.indexOf(d, a);if (d && e >= 0) return [b, e];
        }
      } };
  }, function (a, b, c) {
    "use strict";
    function d(a) {
      this.value = a;
    }function e() {}function f(a, b, c, d) {
      var e = b.popStack(),
          f = 0,
          g = c.length;for (a && g--; f < g; f++) e = b.nameLookup(e, c[f], d);return a ? [b.aliasable("container.strict"), "(", e, ", ", b.quotedString(c[f]), ")"] : e;
    }var g = c(1)["default"];b.__esModule = !0;var h = c(4),
        i = c(6),
        j = g(i),
        k = c(5),
        l = c(43),
        m = g(l);e.prototype = { nameLookup: function (a, b) {
        return e.isValidJavaScriptVariableName(b) ? [a, ".", b] : [a, "[", JSON.stringify(b), "]"];
      }, depthedLookup: function (a) {
        return [this.aliasable("container.lookup"), '(depths, "', a, '")'];
      }, compilerInfo: function () {
        var a = h.COMPILER_REVISION,
            b = h.REVISION_CHANGES[a];return [a, b];
      }, appendToBuffer: function (a, b, c) {
        return k.isArray(a) || (a = [a]), a = this.source.wrap(a, b), this.environment.isSimple ? ["return ", a, ";"] : c ? ["buffer += ", a, ";"] : (a.appendToBuffer = !0, a);
      }, initializeBuffer: function () {
        return this.quotedString("");
      }, compile: function (a, b, c, d) {
        this.environment = a, this.options = b, this.stringParams = this.options.stringParams, this.trackIds = this.options.trackIds, this.precompile = !d, this.name = this.environment.name, this.isChild = !!c, this.context = c || { decorators: [], programs: [], environments: [] }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.aliases = {}, this.registers = { list: [] }, this.hashes = [], this.compileStack = [], this.inlineStack = [], this.blockParams = [], this.compileChildren(a, b), this.useDepths = this.useDepths || a.useDepths || a.useDecorators || this.options.compat, this.useBlockParams = this.useBlockParams || a.useBlockParams;var e = a.opcodes,
            f = void 0,
            g = void 0,
            h = void 0,
            i = void 0;for (h = 0, i = e.length; h < i; h++) f = e[h], this.source.currentLocation = f.loc, g = g || f.loc, this[f.opcode].apply(this, f.args);if (this.source.currentLocation = g, this.pushSource(""), this.stackSlot || this.inlineStack.length || this.compileStack.length) throw new j["default"]("Compile completed with content left on stack");this.decorators.isEmpty() ? this.decorators = void 0 : (this.useDecorators = !0, this.decorators.prepend("var decorators = container.decorators;\n"), this.decorators.push("return fn;"), d ? this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]) : (this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n"), this.decorators.push("}\n"), this.decorators = this.decorators.merge()));var k = this.createFunctionContext(d);if (this.isChild) return k;var l = { compiler: this.compilerInfo(), main: k };this.decorators && (l.main_d = this.decorators, l.useDecorators = !0);var m = this.context,
            n = m.programs,
            o = m.decorators;for (h = 0, i = n.length; h < i; h++) n[h] && (l[h] = n[h], o[h] && (l[h + "_d"] = o[h], l.useDecorators = !0));return this.environment.usePartial && (l.usePartial = !0), this.options.data && (l.useData = !0), this.useDepths && (l.useDepths = !0), this.useBlockParams && (l.useBlockParams = !0), this.options.compat && (l.compat = !0), d ? l.compilerOptions = this.options : (l.compiler = JSON.stringify(l.compiler), this.source.currentLocation = { start: { line: 1, column: 0 } }, l = this.objectLiteral(l), b.srcName ? (l = l.toStringWithSourceMap({ file: b.destName }), l.map = l.map && l.map.toString()) : l = l.toString()), l;
      }, preamble: function () {
        this.lastContext = 0, this.source = new m["default"](this.options.srcName), this.decorators = new m["default"](this.options.srcName);
      }, createFunctionContext: function (a) {
        var b = "",
            c = this.stackVars.concat(this.registers.list);c.length > 0 && (b += ", " + c.join(", "));var d = 0;for (var e in this.aliases) {
          var f = this.aliases[e];this.aliases.hasOwnProperty(e) && f.children && f.referenceCount > 1 && (b += ", alias" + ++d + "=" + e, f.children[0] = "alias" + d);
        }var g = ["container", "depth0", "helpers", "partials", "data"];(this.useBlockParams || this.useDepths) && g.push("blockParams"), this.useDepths && g.push("depths");var h = this.mergeSource(b);return a ? (g.push(h), Function.apply(this, g)) : this.source.wrap(["function(", g.join(","), ") {\n  ", h, "}"]);
      }, mergeSource: function (a) {
        var b = this.environment.isSimple,
            c = !this.forceBuffer,
            d = void 0,
            e = void 0,
            f = void 0,
            g = void 0;return this.source.each(function (a) {
          a.appendToBuffer ? (f ? a.prepend("  + ") : f = a, g = a) : (f && (e ? f.prepend("buffer += ") : d = !0, g.add(";"), f = g = void 0), e = !0, b || (c = !1));
        }), c ? f ? (f.prepend("return "), g.add(";")) : e || this.source.push('return "";') : (a += ", buffer = " + (d ? "" : this.initializeBuffer()), f ? (f.prepend("return buffer + "), g.add(";")) : this.source.push("return buffer;")), a && this.source.prepend("var " + a.substring(2) + (d ? "" : ";\n")), this.source.merge();
      }, blockValue: function (a) {
        var b = this.aliasable("helpers.blockHelperMissing"),
            c = [this.contextName(0)];this.setupHelperArgs(a, 0, c);var d = this.popStack();c.splice(1, 0, d), this.push(this.source.functionCall(b, "call", c));
      }, ambiguousBlockValue: function () {
        var a = this.aliasable("helpers.blockHelperMissing"),
            b = [this.contextName(0)];this.setupHelperArgs("", 0, b, !0), this.flushInline();var c = this.topStack();b.splice(1, 0, c), this.pushSource(["if (!", this.lastHelper, ") { ", c, " = ", this.source.functionCall(a, "call", b), "}"]);
      }, appendContent: function (a) {
        this.pendingContent ? a = this.pendingContent + a : this.pendingLocation = this.source.currentLocation, this.pendingContent = a;
      }, append: function () {
        if (this.isInline()) this.replaceStack(function (a) {
          return [" != null ? ", a, ' : ""'];
        }), this.pushSource(this.appendToBuffer(this.popStack()));else {
          var a = this.popStack();this.pushSource(["if (", a, " != null) { ", this.appendToBuffer(a, void 0, !0), " }"]), this.environment.isSimple && this.pushSource(["else { ", this.appendToBuffer("''", void 0, !0), " }"]);
        }
      }, appendEscaped: function () {
        this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
      }, getContext: function (a) {
        this.lastContext = a;
      }, pushContext: function () {
        this.pushStackLiteral(this.contextName(this.lastContext));
      }, lookupOnContext: function (a, b, c, d) {
        var e = 0;d || !this.options.compat || this.lastContext ? this.pushContext() : this.push(this.depthedLookup(a[e++])), this.resolvePath("context", a, e, b, c);
      }, lookupBlockParam: function (a, b) {
        this.useBlockParams = !0, this.push(["blockParams[", a[0], "][", a[1], "]"]), this.resolvePath("context", b, 1);
      }, lookupData: function (a, b, c) {
        a ? this.pushStackLiteral("container.data(data, " + a + ")") : this.pushStackLiteral("data"), this.resolvePath("data", b, 0, !0, c);
      }, resolvePath: function (a, b, c, d, e) {
        var g = this;if (this.options.strict || this.options.assumeObjects) return void this.push(f(this.options.strict && e, this, b, a));for (var h = b.length; c < h; c++) this.replaceStack(function (e) {
          var f = g.nameLookup(e, b[c], a);return d ? [" && ", f] : [" != null ? ", f, " : ", e];
        });
      }, resolvePossibleLambda: function () {
        this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
      }, pushStringParam: function (a, b) {
        this.pushContext(), this.pushString(b), "SubExpression" !== b && ("string" == typeof a ? this.pushString(a) : this.pushStackLiteral(a));
      }, emptyHash: function (a) {
        this.trackIds && this.push("{}"), this.stringParams && (this.push("{}"), this.push("{}")), this.pushStackLiteral(a ? "undefined" : "{}");
      }, pushHash: function () {
        this.hash && this.hashes.push(this.hash), this.hash = { values: [], types: [], contexts: [], ids: [] };
      }, popHash: function () {
        var a = this.hash;this.hash = this.hashes.pop(), this.trackIds && this.push(this.objectLiteral(a.ids)), this.stringParams && (this.push(this.objectLiteral(a.contexts)), this.push(this.objectLiteral(a.types))), this.push(this.objectLiteral(a.values));
      }, pushString: function (a) {
        this.pushStackLiteral(this.quotedString(a));
      }, pushLiteral: function (a) {
        this.pushStackLiteral(a);
      }, pushProgram: function (a) {
        null != a ? this.pushStackLiteral(this.programExpression(a)) : this.pushStackLiteral(null);
      }, registerDecorator: function (a, b) {
        var c = this.nameLookup("decorators", b, "decorator"),
            d = this.setupHelperArgs(b, a);this.decorators.push(["fn = ", this.decorators.functionCall(c, "", ["fn", "props", "container", d]), " || fn;"]);
      }, invokeHelper: function (a, b, c) {
        var d = this.popStack(),
            e = this.setupHelper(a, b),
            f = c ? [e.name, " || "] : "",
            g = ["("].concat(f, d);this.options.strict || g.push(" || ", this.aliasable("helpers.helperMissing")), g.push(")"), this.push(this.source.functionCall(g, "call", e.callParams));
      }, invokeKnownHelper: function (a, b) {
        var c = this.setupHelper(a, b);this.push(this.source.functionCall(c.name, "call", c.callParams));
      }, invokeAmbiguous: function (a, b) {
        this.useRegister("helper");var c = this.popStack();this.emptyHash();var d = this.setupHelper(0, a, b),
            e = this.lastHelper = this.nameLookup("helpers", a, "helper"),
            f = ["(", "(helper = ", e, " || ", c, ")"];this.options.strict || (f[0] = "(helper = ", f.push(" != null ? helper : ", this.aliasable("helpers.helperMissing"))), this.push(["(", f, d.paramsInit ? ["),(", d.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", d.callParams), " : helper))"]);
      }, invokePartial: function (a, b, c) {
        var d = [],
            e = this.setupParams(b, 1, d);a && (b = this.popStack(), delete e.name), c && (e.indent = JSON.stringify(c)), e.helpers = "helpers", e.partials = "partials", e.decorators = "container.decorators", a ? d.unshift(b) : d.unshift(this.nameLookup("partials", b, "partial")), this.options.compat && (e.depths = "depths"), e = this.objectLiteral(e), d.push(e), this.push(this.source.functionCall("container.invokePartial", "", d));
      }, assignToHash: function (a) {
        var b = this.popStack(),
            c = void 0,
            d = void 0,
            e = void 0;this.trackIds && (e = this.popStack()), this.stringParams && (d = this.popStack(), c = this.popStack());var f = this.hash;c && (f.contexts[a] = c), d && (f.types[a] = d), e && (f.ids[a] = e), f.values[a] = b;
      }, pushId: function (a, b, c) {
        "BlockParam" === a ? this.pushStackLiteral("blockParams[" + b[0] + "].path[" + b[1] + "]" + (c ? " + " + JSON.stringify("." + c) : "")) : "PathExpression" === a ? this.pushString(b) : "SubExpression" === a ? this.pushStackLiteral("true") : this.pushStackLiteral("null");
      }, compiler: e, compileChildren: function (a, b) {
        for (var c = a.children, d = void 0, e = void 0, f = 0, g = c.length; f < g; f++) {
          d = c[f], e = new this.compiler();var h = this.matchExistingProgram(d);if (null == h) {
            this.context.programs.push("");var i = this.context.programs.length;d.index = i, d.name = "program" + i, this.context.programs[i] = e.compile(d, b, this.context, !this.precompile), this.context.decorators[i] = e.decorators, this.context.environments[i] = d, this.useDepths = this.useDepths || e.useDepths, this.useBlockParams = this.useBlockParams || e.useBlockParams, d.useDepths = this.useDepths, d.useBlockParams = this.useBlockParams;
          } else d.index = h.index, d.name = "program" + h.index, this.useDepths = this.useDepths || h.useDepths, this.useBlockParams = this.useBlockParams || h.useBlockParams;
        }
      }, matchExistingProgram: function (a) {
        for (var b = 0, c = this.context.environments.length; b < c; b++) {
          var d = this.context.environments[b];if (d && d.equals(a)) return d;
        }
      }, programExpression: function (a) {
        var b = this.environment.children[a],
            c = [b.index, "data", b.blockParams];return (this.useBlockParams || this.useDepths) && c.push("blockParams"), this.useDepths && c.push("depths"), "container.program(" + c.join(", ") + ")";
      }, useRegister: function (a) {
        this.registers[a] || (this.registers[a] = !0, this.registers.list.push(a));
      }, push: function (a) {
        return a instanceof d || (a = this.source.wrap(a)), this.inlineStack.push(a), a;
      }, pushStackLiteral: function (a) {
        this.push(new d(a));
      }, pushSource: function (a) {
        this.pendingContent && (this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation)), this.pendingContent = void 0), a && this.source.push(a);
      }, replaceStack: function (a) {
        var b = ["("],
            c = void 0,
            e = void 0,
            f = void 0;if (!this.isInline()) throw new j["default"]("replaceStack on non-inline");var g = this.popStack(!0);if (g instanceof d) c = [g.value], b = ["(", c], f = !0;else {
          e = !0;var h = this.incrStack();b = ["((", this.push(h), " = ", g, ")"], c = this.topStack();
        }var i = a.call(this, c);f || this.popStack(), e && this.stackSlot--, this.push(b.concat(i, ")"));
      }, incrStack: function () {
        return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push("stack" + this.stackSlot), this.topStackName();
      }, topStackName: function () {
        return "stack" + this.stackSlot;
      }, flushInline: function () {
        var a = this.inlineStack;this.inlineStack = [];for (var b = 0, c = a.length; b < c; b++) {
          var e = a[b];if (e instanceof d) this.compileStack.push(e);else {
            var f = this.incrStack();this.pushSource([f, " = ", e, ";"]), this.compileStack.push(f);
          }
        }
      }, isInline: function () {
        return this.inlineStack.length;
      }, popStack: function (a) {
        var b = this.isInline(),
            c = (b ? this.inlineStack : this.compileStack).pop();if (!a && c instanceof d) return c.value;if (!b) {
          if (!this.stackSlot) throw new j["default"]("Invalid stack pop");this.stackSlot--;
        }return c;
      }, topStack: function () {
        var a = this.isInline() ? this.inlineStack : this.compileStack,
            b = a[a.length - 1];return b instanceof d ? b.value : b;
      }, contextName: function (a) {
        return this.useDepths && a ? "depths[" + a + "]" : "depth" + a;
      }, quotedString: function (a) {
        return this.source.quotedString(a);
      }, objectLiteral: function (a) {
        return this.source.objectLiteral(a);
      }, aliasable: function (a) {
        var b = this.aliases[a];return b ? (b.referenceCount++, b) : (b = this.aliases[a] = this.source.wrap(a), b.aliasable = !0, b.referenceCount = 1, b);
      }, setupHelper: function (a, b, c) {
        var d = [],
            e = this.setupHelperArgs(b, a, d, c),
            f = this.nameLookup("helpers", b, "helper"),
            g = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");return { params: d, paramsInit: e, name: f, callParams: [g].concat(d) };
      }, setupParams: function (a, b, c) {
        var d = {},
            e = [],
            f = [],
            g = [],
            h = !c,
            i = void 0;h && (c = []), d.name = this.quotedString(a), d.hash = this.popStack(), this.trackIds && (d.hashIds = this.popStack()), this.stringParams && (d.hashTypes = this.popStack(), d.hashContexts = this.popStack());var j = this.popStack(),
            k = this.popStack();(k || j) && (d.fn = k || "container.noop", d.inverse = j || "container.noop");for (var l = b; l--;) i = this.popStack(), c[l] = i, this.trackIds && (g[l] = this.popStack()), this.stringParams && (f[l] = this.popStack(), e[l] = this.popStack());return h && (d.args = this.source.generateArray(c)), this.trackIds && (d.ids = this.source.generateArray(g)), this.stringParams && (d.types = this.source.generateArray(f), d.contexts = this.source.generateArray(e)), this.options.data && (d.data = "data"), this.useBlockParams && (d.blockParams = "blockParams"), d;
      }, setupHelperArgs: function (a, b, c, d) {
        var e = this.setupParams(a, b, c);return e = this.objectLiteral(e), d ? (this.useRegister("options"), c.push("options"), ["options=", e]) : c ? (c.push(e), "") : e;
      } }, function () {
      for (var a = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" "), b = e.RESERVED_WORDS = {}, c = 0, d = a.length; c < d; c++) b[a[c]] = !0;
    }(), e.isValidJavaScriptVariableName = function (a) {
      return !e.RESERVED_WORDS[a] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(a);
    }, b["default"] = e, a.exports = b["default"];
  }, function (a, b, c) {
    "use strict";
    function d(a, b, c) {
      if (f.isArray(a)) {
        for (var d = [], e = 0, g = a.length; e < g; e++) d.push(b.wrap(a[e], c));return d;
      }return "boolean" == typeof a || "number" == typeof a ? a + "" : a;
    }function e(a) {
      this.srcFile = a, this.source = [];
    }b.__esModule = !0;var f = c(5),
        g = void 0;try {} catch (h) {}g || (g = function (a, b, c, d) {
      this.src = "", d && this.add(d);
    }, g.prototype = { add: function (a) {
        f.isArray(a) && (a = a.join("")), this.src += a;
      }, prepend: function (a) {
        f.isArray(a) && (a = a.join("")), this.src = a + this.src;
      }, toStringWithSourceMap: function () {
        return { code: this.toString() };
      }, toString: function () {
        return this.src;
      } }), e.prototype = { isEmpty: function () {
        return !this.source.length;
      }, prepend: function (a, b) {
        this.source.unshift(this.wrap(a, b));
      }, push: function (a, b) {
        this.source.push(this.wrap(a, b));
      }, merge: function () {
        var a = this.empty();return this.each(function (b) {
          a.add(["  ", b, "\n"]);
        }), a;
      }, each: function (a) {
        for (var b = 0, c = this.source.length; b < c; b++) a(this.source[b]);
      }, empty: function () {
        var a = this.currentLocation || { start: {} };return new g(a.start.line, a.start.column, this.srcFile);
      }, wrap: function (a) {
        var b = arguments.length <= 1 || void 0 === arguments[1] ? this.currentLocation || { start: {} } : arguments[1];return a instanceof g ? a : (a = d(a, this, b), new g(b.start.line, b.start.column, this.srcFile, a));
      }, functionCall: function (a, b, c) {
        return c = this.generateList(c), this.wrap([a, b ? "." + b + "(" : "(", c, ")"]);
      }, quotedString: function (a) {
        return '"' + (a + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
      }, objectLiteral: function (a) {
        var b = [];for (var c in a) if (a.hasOwnProperty(c)) {
          var e = d(a[c], this);"undefined" !== e && b.push([this.quotedString(c), ":", e]);
        }var f = this.generateList(b);return f.prepend("{"), f.add("}"), f;
      }, generateList: function (a) {
        for (var b = this.empty(), c = 0, e = a.length; c < e; c++) c && b.add(","), b.add(d(a[c], this));return b;
      }, generateArray: function (a) {
        var b = this.generateList(a);return b.prepend("["), b.add("]"), b;
      } }, b["default"] = e, a.exports = b["default"];
  }]);
});

'use strict';

$__System.register('1b', ['1a'], function (_export) {
    if (typeof Handlebars === 'undefined') {
        var Handlebars;
    }
    if (typeof templates === 'undefined') {
        var templates = {};
    }
    return {
        setters: [function (_handlebars) {
            Handlebars = _handlebars['default'];
        }],
        execute: function () {

            if (typeof templates === 'undefined') {
                var templates = {};
            }templates['adult-question'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "<div class=\"result adult-question\">\n    <p class=\"padded\">\n        " + container.escapeExpression((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, "adultInfo", { "name": "local", "hash": {}, "data": data })) + "\n    </p>\n" + ((stack1 = container.invokePartial(partials["partials/buttons"], depth0, { "name": "partials/buttons", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "</div>\n";
                }, "usePartial": true, "useData": true });
            templates['calculator'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<div class=\"instant calculator\" >\n    <div class=\"header padded\">\n      <p class=\"title\">\n        <a\n          id=\"calc-answer\"\n          class=\"result\"\n          data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n        >\n          = " + alias4((helper = (helper = helpers.result || (depth0 != null ? depth0.result : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "result", "hash": {}, "data": data }) : helper)) + "\n          <span class=\"tooltip\">\n            " + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, "Click anywhere to copy", { "name": "local", "hash": {}, "data": data })) + "\n          </span>\n        </a>\n    </p>\n\n    </div>\n</div>\n";
                }, "useData": true });
            templates['category'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "<div class=\"category\">\n    " + container.escapeExpression((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "title", "hash": {}, "data": data }) : helper)) + "\n</div>\n";
                }, "useData": true });
            templates['currency'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                    &#183; " + ((stack1 = container.invokePartial(partials["partials/source"], depth0, { "name": "partials/source", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                    &#183; " + ((stack1 = container.invokePartial(partials["partials/timestamp"], depth0, { "name": "partials/timestamp", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<div class=\"instant currency white-background\" >\n    <div class=\"header padded\">\n        <p class=\"title\">\n            <a\n                class=\"result\"\n                data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n            >\n                = " + alias4((helper = (helper = helpers.toAmount || (depth0 != null ? depth0.toAmount : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "toAmount", "hash": {}, "data": data }) : helper)) + " " + alias4((helper = (helper = helpers.toCurrencyName || (depth0 != null ? depth0.toCurrencyName : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "toCurrencyName", "hash": {}, "data": data }) : helper)) + "\n                <span class=\"tooltip\">\n                    " + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, "Click anywhere to copy", { "name": "local", "hash": {}, "data": data })) + "\n                </span>\n            </a>\n        </p>\n        <p class=\"subtitle\">\n            <span>\n                " + alias4((helper = (helper = helpers.multiplyer || (depth0 != null ? depth0.multiplyer : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "multiplyer", "hash": {}, "data": data }) : helper)) + " " + alias4((helper = (helper = helpers.fromCurrency || (depth0 != null ? depth0.fromCurrency : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "fromCurrency", "hash": {}, "data": data }) : helper)) + " = " + alias4((helper = (helper = helpers.conversionRate || (depth0 != null ? depth0.conversionRate : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "conversionRate", "hash": {}, "data": data }) : helper)) + " " + alias4((helper = (helper = helpers.toCurrency || (depth0 != null ? depth0.toCurrency : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "toCurrency", "hash": {}, "data": data }) : helper)) + " " + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, "no_legal_disclaimer", { "name": "local", "hash": {}, "data": data })) + "\n" + ((stack1 = helpers["with"].call(alias1, depth0 != null ? depth0.sourceWrapper : depth0, { "name": "with", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.updated : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            </span>\n        </p>\n    </div>\n</div>\n";
                }, "usePartial": true, "useData": true });
            templates['emphasis'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = (helpers.even || depth0 && depth0.even || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, data && data.index, { "name": "even", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.program(4, data, 0), "data": data })) != null ? stack1 : "";
                }, "2": function (container, depth0, helpers, partials, data) {
                    return "<em>" + container.escapeExpression(container.lambda(depth0, depth0)) + "</em>";
                }, "4": function (container, depth0, helpers, partials, data) {
                    return container.escapeExpression(container.lambda(depth0, depth0));
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers.each.call(depth0 != null ? depth0 : container.nullContext || {}, depth0, { "name": "each", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['flight'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "          <span> &#183; " + container.escapeExpression((helper = (helper = helpers.statusDetail || (depth0 != null ? depth0.statusDetail : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "statusDetail", "hash": {}, "data": data }) : helper)) + "</span>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    return " strike-through ";
                }, "5": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "              <span\n                class=\"estimate-depart-time bold " + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.departure : depth0) != null ? stack1.actualTime : stack1, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\"\n              >\n                " + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.departure : depth0) != null ? stack1.scheduledTime : stack1, depth0)) + "\n              </span>\n";
                }, "7": function (container, depth0, helpers, partials, data) {
                    return " early\n                  ";
                }, "9": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.lateDeparture : depth0, { "name": "if", "hash": {}, "fn": container.program(10, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "10": function (container, depth0, helpers, partials, data) {
                    return " late\n                  ";
                }, "12": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                <span\n                  class=\"estimate-arrival-time bold " + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.actualTime : stack1, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\"\n                >\n                  " + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.scheduledTime : stack1, depth0)) + "\n                </span>\n";
                }, "14": function (container, depth0, helpers, partials, data) {
                    return " early\n                    ";
                }, "16": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.lateArrival : depth0, { "name": "if", "hash": {}, "fn": container.program(17, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "17": function (container, depth0, helpers, partials, data) {
                    return " late\n                    ";
                }, "19": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                  &#183; " + ((stack1 = container.invokePartial(partials["partials/timestamp"], depth0, { "name": "partials/timestamp", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression,
                        alias5 = container.lambda;

                    return "<div class='result instant'>\n  <div class=\"padded\">\n    <div class=\"header\">\n      <span class=\"title\">" + alias4((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "name", "hash": {}, "data": data }) : helper)) + "</span>\n    </div>\n    <div class=\"flight-details white-background\" data-status=\"" + alias4((helper = (helper = helpers.flightStatus || (depth0 != null ? depth0.flightStatus : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "flightStatus", "hash": {}, "data": data }) : helper)) + "\">\n\n      <div class=\"flight-status\">\n        <span>" + alias4((helper = (helper = helpers.status || (depth0 != null ? depth0.status : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "status", "hash": {}, "data": data }) : helper)) + "</span>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.statusDetail : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "      </div>\n\n      <div class=\"flight-flex-container\">\n        <span class=\"depart-city\">\n          " + alias4(alias5((stack1 = depth0 != null ? depth0.departure : depth0) != null ? stack1.locationShortcut : stack1, depth0)) + "\n        </span>\n        <div class=\"flight-progress-container\">\n\n          <div class=\"flight-progress\">\n              <div class=\"flight-progress-bar\" style=\"left:" + alias4((helper = (helper = helpers.planePosition || (depth0 != null ? depth0.planePosition : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "planePosition", "hash": {}, "data": data }) : helper)) + "%\"></div>\n          </div>\n        </div>\n        <span class=\"arrival-city " + ((stack1 = helpers["if"].call(alias1, (stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.actualLocation : stack1, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\">\n          " + alias4(alias5((stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.locationShortcut : stack1, depth0)) + "\n        </span>\n        &#160;\n        <span class=\"actual-arrival-city\">\n          " + alias4(alias5((stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.actualLocation : stack1, depth0)) + "\n        </span>\n      </div>\n\n      <div class=\"depart-arrival\">\n        <div class=\"depart\">\n          <div>\n             " + alias4(alias5((stack1 = depth0 != null ? depth0.departure : depth0) != null ? stack1.locationName : stack1, depth0)) + "\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.showDepartureScheduledTime : depth0, { "name": "if", "hash": {}, "fn": container.program(5, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\n            <span class=\"depart-time\n                  " + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.earlyDeparture : depth0, { "name": "if", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.program(9, data, 0), "data": data })) != null ? stack1 : "") + "\"\n            >\n              " + alias4(alias5((stack1 = depth0 != null ? depth0.departure : depth0) != null ? stack1.actualTime : stack1, depth0)) + "\n            </span>\n          </div>\n\n          <div>" + alias4(alias5((stack1 = depth0 != null ? depth0.departure : depth0) != null ? stack1.estimateActualDate : stack1, depth0)) + " </div>\n          <div class=\"bold\">\n            " + alias4(alias5((stack1 = depth0 != null ? depth0.departure : depth0) != null ? stack1.terminal : stack1, depth0)) + " &#183; " + alias4(alias5((stack1 = depth0 != null ? depth0.departure : depth0) != null ? stack1.gate : stack1, depth0)) + "\n          </div>\n        </div>\n\n        <div class=\"arrival\">\n          <div>\n            " + alias4(alias5((stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.locationName : stack1, depth0)) + "\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.showArrivalScheduledTime : depth0, { "name": "if", "hash": {}, "fn": container.program(12, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "              <span class=\"arrival-time\n                    " + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.earlyArrival : depth0, { "name": "if", "hash": {}, "fn": container.program(14, data, 0), "inverse": container.program(16, data, 0), "data": data })) != null ? stack1 : "") + "\"\n              >\n                " + alias4(alias5((stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.actualTime : stack1, depth0)) + "\n              </span>\n          </div>\n          <div>" + alias4(alias5((stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.estimateActualDate : stack1, depth0)) + " </div>\n          <div class=\"bold\">\n            " + alias4(alias5((stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.terminal : stack1, depth0)) + " &#183; " + alias4(alias5((stack1 = depth0 != null ? depth0.arrival : depth0) != null ? stack1.gate : stack1, depth0)) + "\n          </div>\n        </div>\n      </div>\n      <p class=\"subtitle flight-timestamp\">\n          <span>\n" + ((stack1 = container.invokePartial(partials["partials/source"], depth0, { "name": "partials/source", "data": data, "indent": "              ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.updated : depth0, { "name": "if", "hash": {}, "fn": container.program(19, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "          </span>\n      </p>\n    </div>\n  </div>\n</div>\n";
                }, "usePartial": true, "useData": true });
            templates['generic'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<a class=\"result " + alias4((helper = (helper = helpers.cssClasses || (depth0 != null ? depth0.cssClasses : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "cssClasses", "hash": {}, "data": data }) : helper)) + "\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = container.invokePartial(partials["partials/logo"], depth0, { "name": "partials/logo", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/abstract"], depth0, { "name": "partials/abstract", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "</a>\n" + ((stack1 = container.invokePartial(partials["partials/share-location"], depth0, { "name": "partials/share-location", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/images"], depth0, { "name": "partials/images", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/lotto"], depth0, { "name": "partials/lotto", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/anchors"], depth0, { "name": "partials/anchors", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/news"], depth0, { "name": "partials/news", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/videos"], depth0, { "name": "partials/videos", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/buttons"], depth0, { "name": "partials/buttons", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/social-buttons"], depth0, { "name": "partials/social-buttons", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/local"], depth0, { "name": "partials/local", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/offer/injected-offer"], depth0, { "name": "partials/offer/injected-offer", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "");
                }, "usePartial": true, "useData": true });
            templates['history'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = container.escapeExpression,
                        alias2 = depth0 != null ? depth0 : container.nullContext || {},
                        alias3 = helpers.helperMissing,
                        alias4 = "function";

                    return "    <span class=\"timeline\" style=\"background-color: #" + alias1(container.lambda((stack1 = depth0 != null ? depth0.logo : depth0) != null ? stack1.backgroundColor : stack1, depth0)) + "\"></span>\n\n    <a class=\"result\" data-url=\"" + alias1((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias3, typeof helper === alias4 ? helper.call(alias2, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias1((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias3, typeof helper === alias4 ? helper.call(alias2, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = container.invokePartial(partials["partials/logo"], depth0, { "name": "partials/logo", "data": data, "indent": "        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/abstract"], depth0, { "name": "partials/abstract", "data": data, "indent": "        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/images"], depth0, { "name": "partials/images", "data": data, "indent": "        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "    </a>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = container.invokePartial(partials.generic, depth0, { "name": "generic", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.url : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/lotto"], depth0, { "name": "partials/lotto", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/news"], depth0, { "name": "partials/news", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.results : depth0, { "name": "each", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/buttons"], depth0, { "name": "partials/buttons", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "");
                }, "usePartial": true, "useData": true });
            templates['lotto'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "      <div class=\"row\">\n        <div class=\"lotto-item-wrapper " + container.escapeExpression((helper = (helper = helpers.classNames || (depth0 != null ? depth0.classNames : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(alias1, { "name": "classNames", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.result : depth0, { "name": "each", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "        </div>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.description : depth0, { "name": "if", "hash": {}, "fn": container.program(4, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.table : depth0, { "name": "if", "hash": {}, "fn": container.program(6, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "      </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    return "            <div class=\"item\">\n              " + container.escapeExpression(container.lambda(depth0, depth0)) + "\n            </div>\n";
                }, "4": function (container, depth0, helpers, partials, data) {
                    return "          <span class=\"description\">" + container.escapeExpression((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.description : depth0, { "name": "local", "hash": {}, "data": data })) + "</span>\n";
                }, "6": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "          <div id=\"lotto-table\">\n            <div class=\"table-head\">\n" + ((stack1 = helpers.each.call(alias1, (stack1 = depth0 != null ? depth0.table : depth0) != null ? stack1.columns : stack1, { "name": "each", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            </div>\n" + ((stack1 = helpers.each.call(alias1, (stack1 = depth0 != null ? depth0.table : depth0) != null ? stack1.data : stack1, { "name": "each", "hash": {}, "fn": container.program(9, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "          </div>\n";
                }, "7": function (container, depth0, helpers, partials, data) {
                    return "                <span>" + container.escapeExpression((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0, { "name": "local", "hash": {}, "data": data })) + "</span>\n";
                }, "9": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "              <div class=\"table-row\">\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : container.nullContext || {}, depth0, { "name": "each", "hash": {}, "fn": container.program(10, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "              </div>\n";
                }, "10": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                    <span>\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : container.nullContext || {}, depth0, { "name": "each", "hash": {}, "fn": container.program(11, data, 0), "inverse": container.program(13, data, 0), "data": data })) != null ? stack1 : "") + "                    </span>\n";
                }, "11": function (container, depth0, helpers, partials, data) {
                    return "                            " + container.escapeExpression(container.lambda(depth0, depth0)) + "<br />\n";
                }, "13": function (container, depth0, helpers, partials, data) {
                    return "                            " + container.escapeExpression(container.lambda(depth0, depth0)) + "\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<a class=\"result\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = container.invokePartial(partials["partials/logo"], depth0, { "name": "partials/logo", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/abstract"], depth0, { "name": "partials/abstract", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "</a>\n\n<div class=\"padded\">\n  <div class=\"lotto white-background\">\n    <p class=\"lotto-date\">" + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, "lotto-gewinnzahlen", { "name": "local", "hash": {}, "data": data })) + " &#8226; " + alias4((helper = (helper = helpers.localeDate || (depth0 != null ? depth0.localeDate : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "localeDate", "hash": {}, "data": data }) : helper)) + "</p>\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.lottoResults : depth0, { "name": "each", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    <p class=\"no-guarantee\">" + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, "no-guarantee", { "name": "local", "hash": {}, "data": data })) + "</p>\n  </div>\n</div>\n\n" + ((stack1 = container.invokePartial(partials["partials/buttons"], depth0, { "name": "partials/buttons", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "");
                }, "usePartial": true, "useData": true });
            templates['main'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    return "<div id=\"cliqz-popup\">\n    <div id=\"cliqz-dropdown\" data-extension-id=\"" + container.escapeExpression(container.lambda(depth0, depth0)) + "\">\n    </div>\n</div>\n";
                }, "useData": true });
            templates['movie-cinema'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<a class=\"result\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = container.invokePartial(partials["partials/logo"], depth0, { "name": "partials/logo", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/abstract"], depth0, { "name": "partials/abstract", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "</a>\n\n<div class=\"movie-cinema\">\n" + ((stack1 = container.invokePartial(partials["partials/movie-cinema/movie"], depth0, { "name": "partials/movie-cinema/movie", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/local"], depth0, { "name": "partials/local", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/share-location"], depth0, { "name": "partials/share-location", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/movie-cinema/show-time"], depth0, { "name": "partials/movie-cinema/show-time", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "</div>\n";
                }, "usePartial": true, "useData": true });
            templates['navigate-to'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<a\n    class=\"result\"\n    data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n    href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\"\n>\n" + ((stack1 = container.invokePartial(partials["partials/logo"], depth0, { "name": "partials/logo", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "    <div class=\"abstract\">\n        <p>\n            <span class=\"strong\">" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "</span>\n            <span class=\"divider\">&#8212;</span>\n            <span class=\"url\">" + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, "visit", { "name": "local", "hash": {}, "data": data })) + "</span>\n        </p>\n    </div>\n</a>\n";
                }, "usePartial": true, "useData": true });
            templates['news-story'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<div class=\"news-story thumbnail-blocks\">\n    <a class=\"result " + alias4((helper = (helper = helpers.cssClasses || (depth0 != null ? depth0.cssClasses : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "cssClasses", "hash": {}, "data": data }) : helper)) + "\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = container.invokePartial(partials["partials/logo"], depth0, { "name": "partials/logo", "data": data, "indent": "        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "        <div class=\"abstract\">\n" + ((stack1 = (helpers.exists || depth0 && depth0.exists || alias2).call(alias1, depth0 != null ? depth0.thumbnail : depth0, { "name": "exists", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\n            <div class=\"content\">\n                <p>\n                    <span data-extra=\"title\" class=\"title\">\n                        " + alias4((helpers.emphasis || depth0 && depth0.emphasis || alias2).call(alias1, depth0 != null ? depth0.title : depth0, depth0 != null ? depth0.query : depth0, 2, true, { "name": "emphasis", "hash": {}, "data": data })) + "\n                    </span>\n                </p>\n\n                <p>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.description : depth0, { "name": "if", "hash": {}, "fn": container.program(9, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                </p>\n                <p>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.publishedAt : depth0, { "name": "if", "hash": {}, "fn": container.program(11, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.friendlyUrl : depth0, { "name": "if", "hash": {}, "fn": container.program(13, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                </p>\n            </div>\n        </div>\n    </a>\n</div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.thumbnail : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.program(6, data, 0), "data": data })) != null ? stack1 : "";
                }, "3": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "                    <div class=\"thumbnail\">\n                        <img src=\"" + container.escapeExpression((helper = (helper = helpers.thumbnail || (depth0 != null ? depth0.thumbnail : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(alias1, { "name": "thumbnail", "hash": {}, "data": data }) : helper)) + "\" data-extra=\"image\" />\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.duration : depth0, { "name": "if", "hash": {}, "fn": container.program(4, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                    </div>\n";
                }, "4": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                            <span class=\"duration\">&#9658; " + container.escapeExpression((helper = (helper = helpers.duration || (depth0 != null ? depth0.duration : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "duration", "hash": {}, "data": data }) : helper)) + "</span>\n";
                }, "6": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                    <div class=\"thumbnail\">\n                        <span class=\"mask\"></span>\n                        <span class=\"no-thumbnail\" " + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.logoDetails : depth0) != null ? stack1.style : stack1, { "name": "if", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ">\n                            " + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.logoDetails : depth0) != null ? stack1.text : stack1, depth0)) + "\n                        </span>\n                    </div>\n";
                }, "7": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "style=\"" + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.logoDetails : depth0) != null ? stack1.style : stack1, depth0)) + "\"";
                }, "9": function (container, depth0, helpers, partials, data) {
                    return "                        <span class=\"description\" data-extra=\"description\">\n                            " + container.escapeExpression((helpers.emphasis || depth0 && depth0.emphasis || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.description : depth0, depth0 != null ? depth0.query : depth0, 2, true, { "name": "emphasis", "hash": {}, "data": data })) + "\n                        </span>\n";
                }, "11": function (container, depth0, helpers, partials, data) {
                    return "                        <span class=\"published-at subtitle attention\">\n                            " + container.escapeExpression((helpers.agoline || depth0 && depth0.agoline || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.publishedAt : depth0, { "name": "agoline", "hash": {}, "data": data })) + "\n                        </span>\n";
                }, "13": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                        <span class=\"url\">\n                            " + container.escapeExpression((helper = (helper = helpers.friendlyUrl || (depth0 != null ? depth0.friendlyUrl : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "friendlyUrl", "hash": {}, "data": data }) : helper)) + "\n                        </span>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["with"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.newsStoryResult : depth0, { "name": "with", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['offer'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "<div class=\"result offer\">\n" + ((stack1 = container.invokePartial(partials["partials/logo"], depth0, { "name": "partials/logo", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/offer/abstract"], depth0, { "name": "partials/offer/abstract", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "</div>\n";
                }, "usePartial": true, "useData": true });
            templates['partials/abstract'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.thumbnail : depth0, { "name": "if", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.program(5, data, 0), "data": data })) != null ? stack1 : "";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "            <div class=\"thumbnail\">\n                <img src=\"" + container.escapeExpression((helper = (helper = helpers.thumbnail || (depth0 != null ? depth0.thumbnail : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(alias1, { "name": "thumbnail", "hash": {}, "data": data }) : helper)) + "\" data-extra=\"image\" />\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.duration : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            </div>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                    <span class=\"duration\">&#9658; " + container.escapeExpression((helper = (helper = helpers.duration || (depth0 != null ? depth0.duration : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "duration", "hash": {}, "data": data }) : helper)) + "</span>\n";
                }, "5": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "            <div class=\"thumbnail\">\n                <span class=\"mask\"></span>\n                <span class=\"no-thumbnail\" " + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.logoDetails : depth0) != null ? stack1.style : stack1, { "name": "if", "hash": {}, "fn": container.program(6, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ">\n                    " + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.logoDetails : depth0) != null ? stack1.text : stack1, depth0)) + "\n                </span>\n            </div>\n";
                }, "6": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "style=\"" + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.logoDetails : depth0) != null ? stack1.style : stack1, depth0)) + "\"";
                }, "8": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                <span class=\"divider\">&#8212;</span>\n                <span data-extra=\"url\" class=\"url\">" + container.escapeExpression((helper = (helper = helpers.friendlyUrl || (depth0 != null ? depth0.friendlyUrl : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "friendlyUrl", "hash": {}, "data": data }) : helper)) + "</span>\n";
                }, "10": function (container, depth0, helpers, partials, data) {
                    return "              <span class=\"published-at subtitle attention\">\n                  " + container.escapeExpression((helpers.agoline || depth0 && depth0.agoline || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.publishedAt : depth0, { "name": "agoline", "hash": {}, "data": data })) + "\n              </span>\n";
                }, "12": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return ((stack1 = helpers.unless.call(alias1, depth0 != null ? depth0.isHistory : depth0, { "name": "unless", "hash": {}, "fn": container.program(13, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                <span class=\"description\" data-extra=\"description\">" + container.escapeExpression((helpers.emphasis || depth0 && depth0.emphasis || helpers.helperMissing).call(alias1, depth0 != null ? depth0.description : depth0, depth0 != null ? depth0.query : depth0, 2, true, { "name": "emphasis", "hash": {}, "data": data })) + "</span>\n";
                }, "13": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.isAd : depth0, { "name": "if", "hash": {}, "fn": container.program(14, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "14": function (container, depth0, helpers, partials, data) {
                    return "                        <span class=\"ad\">Anzeige</span>\n";
                }, "16": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                <span class=\"description\" data-extra=\"full-url\">" + container.escapeExpression((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "url", "hash": {}, "data": data }) : helper)) + "</span>\n";
                }, "18": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = container.escapeExpression;

                    return "                <span class=\"video-views subtitle normal\">\n                    " + alias3((helper = (helper = helpers.videoViews || (depth0 != null ? depth0.videoViews : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, { "name": "videoViews", "hash": {}, "data": data }) : helper)) + " " + alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "views", { "name": "local", "hash": {}, "data": data })) + "\n                </span>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing;

                    return "<div class=\"abstract\">\n" + ((stack1 = (helpers.exists || depth0 && depth0.exists || alias2).call(alias1, depth0 != null ? depth0.thumbnail : depth0, { "name": "exists", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\n    <div class=\"content\">\n        <p>\n            <span data-extra=\"title\" class=\"title\">" + container.escapeExpression((helpers.emphasis || depth0 && depth0.emphasis || alias2).call(alias1, depth0 != null ? depth0.title : depth0, depth0 != null ? depth0.query : depth0, 2, true, { "name": "emphasis", "hash": {}, "data": data })) + "</span>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.friendlyUrl : depth0, { "name": "if", "hash": {}, "fn": container.program(8, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "        </p>\n\n        <p>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.publishedAt : depth0, { "name": "if", "hash": {}, "fn": container.program(10, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.description : depth0, { "name": "if", "hash": {}, "fn": container.program(12, data, 0), "inverse": container.program(16, data, 0), "data": data })) != null ? stack1 : "") + "\n\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.videoViews : depth0, { "name": "if", "hash": {}, "fn": container.program(18, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "        </p>\n    </div>\n</div>\n";
                }, "useData": true });
            templates['partials/anchors'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class=\"anchors padded\">\n" + ((stack1 = helpers.each.call(alias1, (helpers.take || depth0 && depth0.take || helpers.helperMissing).call(alias1, depth0 != null ? depth0.anchorResults : depth0, 4, { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "            <a\n                class=\"result\"\n                title=\"" + alias4((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "title", "hash": {}, "data": data }) : helper)) + "\"\n                data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n                href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\"\n            >\n                " + alias4((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "title", "hash": {}, "data": data }) : helper)) + "\n            </a>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.anchorResults : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['partials/buttons'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class='buttons padded'>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.internalResultsLogo : depth0, { "name": "if", "hash": {}, "fn": container.program(2, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers.each.call(alias1, (helpers.take || depth0 && depth0.take || helpers.helperMissing).call(alias1, depth0 != null ? depth0.internalResults : depth0, depth0 != null ? depth0.internalResultsLimit : depth0, { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(4, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "            <span class=\"dot\" style=\"background-color: #" + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.logo : depth0) != null ? stack1.backgroundColor : stack1, depth0)) + "\"></span>\n";
                }, "4": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "            <a\n                id=\"" + alias4((helper = (helper = helpers.elementId || (depth0 != null ? depth0.elementId : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "elementId", "hash": {}, "data": data }) : helper)) + "\"\n                class=\"result btn " + alias4((helper = (helper = helpers.className || (depth0 != null ? depth0.className : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "className", "hash": {}, "data": data }) : helper)) + "\"\n                data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n                href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\"\n            >\n                " + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, (helpers.concatLocale || depth0 && depth0.concatLocale || alias2).call(alias1, depths[1] != null ? depths[1].localePrefix : depths[1], depth0 != null ? depth0.title : depth0, { "name": "concatLocale", "hash": {}, "data": data }), { "name": "local", "hash": {}, "data": data })) + "\n            </a>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.internalResults : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true, "useDepths": true });
            templates['partials/images'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class='images padded'>\n" + ((stack1 = helpers.each.call(alias1, (helpers.take || depth0 && depth0.take || helpers.helperMissing).call(alias1, depth0 != null ? depth0.imageResults : depth0, 4, { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "            <a\n                class=\"result\"\n                data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n                href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\"\n                data-extra=\"image\"\n            >\n                <img src=\"" + alias4((helper = (helper = helpers.thumbnail || (depth0 != null ? depth0.thumbnail : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "thumbnail", "hash": {}, "data": data }) : helper)) + "\" />\n            </a>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.imageResults : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['partials/local'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression,
                        alias3 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class=\"padded\">\n        <div class=\"local-result-wrapper white-background clearfix\">\n            <a\n                data-url=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.mapResult : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                href=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.mapResult : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                class=\"result local-map\"\n                data-extra=\"map\"\n                >\n            </a>\n            <div class=\"local-info\">\n" + ((stack1 = helpers["if"].call(alias3, depth0 != null ? depth0.address : depth0, { "name": "if", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias3, depth0 != null ? depth0.phoneNumber : depth0, { "name": "if", "hash": {}, "fn": container.program(5, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                <div class=\"other-info\">\n" + ((stack1 = helpers["if"].call(alias3, depth0 != null ? depth0.openingStatus : depth0, { "name": "if", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias3, depth0 != null ? depth0.ratingImg : depth0, { "name": "if", "hash": {}, "fn": container.program(9, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                </div>\n            </div>\n        </div>\n    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "                    <div class=\"local-address\">\n                        <a\n                            class=\"result\"\n                            data-url=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.address : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                        >\n                            " + alias2(alias1((stack1 = depth0 != null ? depth0.address : depth0) != null ? stack1.displayText : stack1, depth0)) + "\n                        </a>\n" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.distance : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                    </div>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    return "                            &#183;\n                            <span>\n                                " + container.escapeExpression((helpers.distance || depth0 && depth0.distance || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.distance : depth0, { "name": "distance", "hash": {}, "data": data })) + "\n                            </span>\n";
                }, "5": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "                    <div class=\"local-phone\">\n                        <a\n                            class=\"result\"\n                            data-url=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.phoneNumber : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                        >\n                            " + alias2(alias1((stack1 = depth0 != null ? depth0.phoneNumber : depth0) != null ? stack1.displayText : stack1, depth0)) + "\n                        </a>\n                    </div>\n";
                }, "7": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "                        &#183;\n                        <span>\n                            " + alias2(alias1((stack1 = depth0 != null ? depth0.openingStatus : depth0) != null ? stack1.timeInfo : stack1, depth0)) + "\n                        </span>\n                        <span extra=\"open-hour\" style=\"color: " + alias2(alias1((stack1 = depth0 != null ? depth0.openingStatus : depth0) != null ? stack1.color : stack1, depth0)) + "\">\n                            " + alias2((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.openingStatus : depth0) != null ? stack1.sttText : stack1, { "name": "local", "hash": {}, "data": data })) + "\n                        </span>\n";
                }, "9": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                        <img class=\"rating-img\" width=\"90\" src=\"" + container.escapeExpression((helper = (helper = helpers.ratingImg || (depth0 != null ? depth0.ratingImg : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "ratingImg", "hash": {}, "data": data }) : helper)) + "\" alt=\"\" />\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["with"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.localResult : depth0, { "name": "with", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['partials/logo'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "            style=\"" + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.logo : depth0) != null ? stack1.style : stack1, depth0)) + "\"\n            class=\"logo\"\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.isHistory : depth0, { "name": "if", "hash": {}, "fn": container.program(4, data, 0), "inverse": container.program(6, data, 0), "data": data })) != null ? stack1 : "") + "        ";
                }, "4": function (container, depth0, helpers, partials, data) {
                    return "                class=\"logo logo-blank\"\n";
                }, "6": function (container, depth0, helpers, partials, data) {
                    return "                class=\"logo\"\n";
                }, "8": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "style=\"background-color: #" + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.logo : depth0) != null ? stack1.backgroundColor : stack1, depth0)) + "\"";
                }, "10": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "        <span class=\"icon " + alias4((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "icon", "hash": {}, "data": data }) : helper)) + "\" data-extra=\"icon-" + alias4((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "icon", "hash": {}, "data": data }) : helper)) + "\"></span>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "<div class=\"icons\">\n\n    <span data-extra=\"logo\"\n" + ((stack1 = helpers["if"].call(alias1, (stack1 = depth0 != null ? depth0.logo : depth0) != null ? stack1.style : stack1, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.program(3, data, 0), "data": data })) != null ? stack1 : "") + ">\n        " + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.logo : depth0) != null ? stack1.text : stack1, depth0)) + "\n    </span>\n    <span class=\"micro-logo\" data-extra=\"logo\"\n        " + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.logo : depth0, { "name": "if", "hash": {}, "fn": container.program(8, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ">\n    </span>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.icon : depth0, { "name": "if", "hash": {}, "fn": container.program(10, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "</div>\n";
                }, "useData": true });
            templates['partials/lotto'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = container.escapeExpression;

                    return "    <div class=\"padded\">\n      <div class=\"lotto white-background\">\n        <p class=\"lotto-date\">" + alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "lotto-gewinnzahlen", { "name": "local", "hash": {}, "data": data })) + " &#8226; " + alias3((helper = (helper = helpers.localeDate || (depth0 != null ? depth0.localeDate : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, { "name": "localeDate", "hash": {}, "data": data }) : helper)) + "</p>\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.lottoResults : depth0, { "name": "each", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "        <p class=\"no-guarantee\">" + alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "no-guarantee", { "name": "local", "hash": {}, "data": data })) + "</p>\n      </div>\n    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "          <div class=\"row\">\n            <div class=\"lotto-item-wrapper " + container.escapeExpression((helper = (helper = helpers.classNames || (depth0 != null ? depth0.classNames : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(alias1, { "name": "classNames", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.result : depth0, { "name": "each", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            </div>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.description : depth0, { "name": "if", "hash": {}, "fn": container.program(5, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.table : depth0, { "name": "if", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "          </div>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    return "                <div class=\"item\">\n                  " + container.escapeExpression(container.lambda(depth0, depth0)) + "\n                </div>\n";
                }, "5": function (container, depth0, helpers, partials, data) {
                    return "              <span class=\"description\">" + container.escapeExpression((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.description : depth0, { "name": "local", "hash": {}, "data": data })) + "</span>\n";
                }, "7": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "              <div id=\"lotto-table\">\n                <div class=\"table-head\">\n" + ((stack1 = helpers.each.call(alias1, (stack1 = depth0 != null ? depth0.table : depth0) != null ? stack1.columns : stack1, { "name": "each", "hash": {}, "fn": container.program(8, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                </div>\n" + ((stack1 = helpers.each.call(alias1, (stack1 = depth0 != null ? depth0.table : depth0) != null ? stack1.data : stack1, { "name": "each", "hash": {}, "fn": container.program(10, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "              </div>\n";
                }, "8": function (container, depth0, helpers, partials, data) {
                    return "                    <span>" + container.escapeExpression((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0, { "name": "local", "hash": {}, "data": data })) + "</span>\n";
                }, "10": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                  <div class=\"table-row\">\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : container.nullContext || {}, depth0, { "name": "each", "hash": {}, "fn": container.program(11, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                  </div>\n";
                }, "11": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                        <span>\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : container.nullContext || {}, depth0, { "name": "each", "hash": {}, "fn": container.program(12, data, 0), "inverse": container.program(14, data, 0), "data": data })) != null ? stack1 : "") + "                        </span>\n";
                }, "12": function (container, depth0, helpers, partials, data) {
                    return "                                " + container.escapeExpression(container.lambda(depth0, depth0)) + "<br />\n";
                }, "14": function (container, depth0, helpers, partials, data) {
                    return "                                " + container.escapeExpression(container.lambda(depth0, depth0)) + "\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.lottoResults : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['partials/movie-cinema/movie'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = container.lambda,
                        alias3 = container.escapeExpression;

                    return "    <div class=\"padded\">\n        <div class=\"movie white-background\">\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.imageUrl : depth0, { "name": "if", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            <div class=\"info\">\n                <p>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.ratingInfo : depth0, { "name": "if", "hash": {}, "fn": container.program(4, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.reviewsInfo : depth0, { "name": "if", "hash": {}, "fn": container.program(6, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                </p>\n                <p class=\"director\">\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.directorInfo : depth0, { "name": "if", "hash": {}, "fn": container.program(8, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                </p>\n                <p class=\"stars\">\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.starsInfo : depth0, { "name": "if", "hash": {}, "fn": container.program(10, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                    <span>\n                        <a\n                            class=\"result\"\n                            data-url=\"" + alias3(alias2((stack1 = depth0 != null ? depth0.fullCastInfo : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                            href=\"" + alias3(alias2((stack1 = depth0 != null ? depth0.fullCastInfo : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                        >\n                            " + alias3((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(alias1, (stack1 = depth0 != null ? depth0.fullCastInfo : depth0) != null ? stack1.title : stack1, { "name": "local", "hash": {}, "data": data })) + "\n                        </a>\n                    </span>\n                </p>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.trailerInfo : depth0, { "name": "if", "hash": {}, "fn": container.program(16, data, 0), "inverse": container.program(18, data, 0), "data": data })) != null ? stack1 : "") + "            </div>\n        </div>\n    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                <div class=\"image\" style=\"background-image: url(" + container.escapeExpression((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "imageUrl", "hash": {}, "data": data }) : helper)) + ")\"></div>\n";
                }, "4": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "                        <span class=\"rating-img\" style=\"background-image: url(" + alias2(alias1((stack1 = depth0 != null ? depth0.ratingInfo : depth0) != null ? stack1.img : stack1, depth0)) + ")\"></span>\n                        <span class=\"score\">\n                            <span>" + alias2(alias1((stack1 = depth0 != null ? depth0.ratingInfo : depth0) != null ? stack1.score : stack1, depth0)) + "</span>\n                            <span>/ " + alias2(alias1((stack1 = depth0 != null ? depth0.ratingInfo : depth0) != null ? stack1.scale : stack1, depth0)) + "</span>\n                        </span>\n";
                }, "6": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "                        <a\n                            class=\"result reviews\"\n                            data-url=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.reviewsInfo : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                            href=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.reviewsInfo : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                        >\n                            " + alias2(alias1((stack1 = depth0 != null ? depth0.reviewsInfo : depth0) != null ? stack1.nVote : stack1, depth0)) + " " + alias2((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.reviewsInfo : depth0) != null ? stack1.title : stack1, { "name": "local", "hash": {}, "data": data })) + "\n                        </a>\n";
                }, "8": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "                        <span>" + alias2(alias1((stack1 = depth0 != null ? depth0.directorInfo : depth0) != null ? stack1.title : stack1, depth0)) + ":</span>\n                        <a\n                            class=\"result\"\n                            data-url=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.directorInfo : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                            href=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.directorInfo : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                        >\n                            " + alias2(alias1((stack1 = depth0 != null ? depth0.directorInfo : depth0) != null ? stack1.name : stack1, depth0)) + "\n                        </a>\n";
                }, "10": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "                        <span>" + container.escapeExpression((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(alias1, "cinema-movie-cast", { "name": "local", "hash": {}, "data": data })) + ":</span>\n                        <span class=\"stars-list\">\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.starsInfo : depth0, { "name": "each", "hash": {}, "fn": container.program(11, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                        </span>\n";
                }, "11": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "                            <span>\n                                " + container.escapeExpression(container.lambda(depth0, depth0)) + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : container.nullContext || {}, data && data.last, { "name": "unless", "hash": {}, "fn": container.program(12, data, 0), "inverse": container.program(14, data, 0), "data": data })) != null ? stack1 : "") + "\n                            </span>\n";
                }, "12": function (container, depth0, helpers, partials, data) {
                    return ",";
                }, "14": function (container, depth0, helpers, partials, data) {
                    return " &#183;";
                }, "16": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "                    <div class=\"trailer\">\n                        <a\n                            class=\"result\"\n                            data-url=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.trailerInfo : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                            href=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.trailerInfo : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n                        >\n                            <div class=\"trailer-icon\"></div>\n                            <span>" + alias2((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.trailerInfo : depth0) != null ? stack1.title : stack1, { "name": "local", "hash": {}, "data": data })) + "</span>\n                        </a>\n                    </div>\n";
                }, "18": function (container, depth0, helpers, partials, data) {
                    return "                    <div class=\"trailer disabled\">\n                        <span>\n                            <div class=\"trailer-icon\"></div>\n                            <span>" + container.escapeExpression((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, "cinema-movie-trailer", { "name": "local", "hash": {}, "data": data })) + "</span>\n                        </span>\n                    </div>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.isMovieEZ : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['partials/movie-cinema/show-time'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = container.escapeExpression,
                        alias4 = "function";

                    return "<div class=\"show-time padded\">\n    <div class=\"title\">\n        <span>" + alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "cinema-movie-showtimes", { "name": "local", "hash": {}, "data": data })) + " &#183; " + alias3((helper = (helper = helpers.headerTitle || (depth0 != null ? depth0.headerTitle : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, { "name": "headerTitle", "hash": {}, "data": data }) : helper)) + "</span>\n        <span>&#183; <span class=\"location-icon\"></span> " + alias3((helper = (helper = helpers.cityName || (depth0 != null ? depth0.cityName : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, { "name": "cityName", "hash": {}, "data": data }) : helper)) + "</span>\n    </div>\n    <div class=\"wrapper dropdown-tabs white-background\">\n        <div class=\"background-placeholder\"></div>\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.showTimesInfo : depth0, { "name": "each", "hash": {}, "fn": container.program(2, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.showTimesInfo : depth0, { "name": "each", "hash": {}, "fn": container.program(5, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n    <div>\n" + ((stack1 = helpers["if"].call(alias1, (stack1 = depth0 != null ? depth0.expandButton : depth0) != null ? stack1.show : stack1, { "name": "if", "hash": {}, "fn": container.program(8, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n</div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "            <input class=\"tab-radio-input\" type=\"radio\" name=\"tabs\" id=\"tab-" + alias4((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\" " + ((stack1 = helpers["if"].call(alias1, data && data.first, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "/>\n            <label class=\"dropdown-tab-label\" for=\"tab-" + alias4((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\">" + alias4((helper = (helper = helpers.showDate || (depth0 != null ? depth0.showDate : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "showDate", "hash": {}, "data": data }) : helper)) + "</label>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    return "checked=\"checked\"";
                }, "5": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing;

                    return "            <div id=\"tab-block-" + container.escapeExpression((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\"\n                 class=\"tab-block\"\n            >\n                <div class=\"table\">\n" + ((stack1 = helpers.each.call(alias1, (helpers.take || depth0 && depth0.take || alias2).call(alias1, depth0 != null ? depth0.rows : depth0, depths[1] != null ? depths[1].showTimesLimit : depths[1], { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(6, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                </div>\n            </div>\n";
                }, "6": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = container.invokePartial(partials["partials/movie-cinema/showtime-row"], depth0, { "name": "partials/movie-cinema/showtime-row", "data": data, "indent": "                        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "";
                }, "8": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.escapeExpression;

                    return "            <a\n                class=\"result expand-btn\"\n                data-url=\"" + alias1(container.lambda((stack1 = depth0 != null ? depth0.expandButton : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n            >\n                " + alias1((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.expandButton : depth0) != null ? stack1.title : stack1, { "name": "local", "hash": {}, "data": data })) + "\n            </a>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.isShowtimesAvailable : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true, "useDepths": true });
            templates['partials/movie-cinema/showtime-row'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "        <span title=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.cinemaInfo : depth0) != null ? stack1.name : stack1, depth0)) + "\">" + alias2(alias1((stack1 = depth0 != null ? depth0.cinemaInfo : depth0) != null ? stack1.name : stack1, depth0)) + "</span>\n        <span>\n" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.cinemaInfo : depth0) != null ? stack1.distance : stack1, { "name": "if", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            <span title=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.cinemaInfo : depth0) != null ? stack1.address : stack1, depth0)) + "\">" + alias2(alias1((stack1 = depth0 != null ? depth0.cinemaInfo : depth0) != null ? stack1.address : stack1, depth0)) + "</span>\n        </span>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "            <span class=\"distance\">" + container.escapeExpression((helpers.distance || depth0 && depth0.distance || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.cinemaInfo : depth0) != null ? stack1.distance : stack1, { "name": "distance", "hash": {}, "data": data })) + "</span> &#183;\n";
                }, "4": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "        <span class=\"movie-title\" title=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.movieInfo : depth0) != null ? stack1.title : stack1, depth0)) + "\">" + alias2(alias1((stack1 = depth0 != null ? depth0.movieInfo : depth0) != null ? stack1.title : stack1, depth0)) + "</span>\n";
                }, "6": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1,
                        helper,
                        alias1 = container.escapeExpression,
                        alias2 = depth0 != null ? depth0 : container.nullContext || {};

                    return "        <span class=\"show-time-span\">\n            <a\n                class=\"result\"\n                data-extra=\"showtime_row_" + alias1(container.lambda(container.data(data, 1) && container.data(data, 1).index, depth0)) + "\"\n" + ((stack1 = helpers["if"].call(alias2, depth0 != null ? depth0.url : depth0, { "name": "if", "hash": {}, "fn": container.program(7, data, 0, blockParams, depths), "inverse": container.program(9, data, 0, blockParams, depths), "data": data })) != null ? stack1 : "") + "            >\n                " + alias1((helper = (helper = helpers.displayTime || (depth0 != null ? depth0.displayTime : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(alias2, { "name": "displayTime", "hash": {}, "data": data }) : helper)) + "\n" + ((stack1 = helpers["if"].call(alias2, depth0 != null ? depth0.movieLanguage : depth0, { "name": "if", "hash": {}, "fn": container.program(11, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias2, depth0 != null ? depth0.is3D : depth0, { "name": "if", "hash": {}, "fn": container.program(13, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            </a>\n        </span>\n";
                }, "7": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "                    data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n                    href=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n";
                }, "9": function (container, depth0, helpers, partials, data) {
                    return "                    data-url=\"#\"\n                    disabled=\"true\"\n";
                }, "11": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                    <span>" + container.escapeExpression((helper = (helper = helpers.movieLanguage || (depth0 != null ? depth0.movieLanguage : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "movieLanguage", "hash": {}, "data": data }) : helper)) + "</span>\n";
                }, "13": function (container, depth0, helpers, partials, data) {
                    return "                    <span>&#183; 3D</span>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "<div class=\"show-time-row\">\n    <div class=\"cinema-info table-cell\">\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.cinemaInfo : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.movieInfo : depth0, { "name": "if", "hash": {}, "fn": container.program(4, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n    <div class=\"show-time-info table-cell\">\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.showTimes : depth0, { "name": "each", "hash": {}, "fn": container.program(6, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n</div>\n";
                }, "useData": true, "useDepths": true });
            templates['partials/news'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class=\"news thumbnail-blocks\">\n" + ((stack1 = helpers.each.call(alias1, (helpers.take || depth0 && depth0.take || helpers.helperMissing).call(alias1, depth0 != null ? depth0.newsResults : depth0, depth0 != null ? depth0.newsResultsLimit : depth0, { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = container.invokePartial(partials.generic, depth0, { "name": "generic", "data": data, "indent": "            ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.newsResults : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['partials/offer/abstract'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "    <div class=\"thumbnail\">\n        <img src=\"" + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.offerResult : depth0) != null ? stack1.thumbnail : stack1, depth0)) + "\" data-extra=\"image\" />\n    </div>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                    <span class=\"divider\">&#8212;</span>\n                    <span data-extra=\"url\" class=\"url\">" + container.escapeExpression((helper = (helper = helpers.friendlyUrl || (depth0 != null ? depth0.friendlyUrl : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "friendlyUrl", "hash": {}, "data": data }) : helper)) + "</span>\n";
                }, "5": function (container, depth0, helpers, partials, data) {
                    return "            <p>\n                <span class=\"ad\">Anzeige</span>\n                <span class=\"description\" data-extra=\"description\">\n                    " + container.escapeExpression((helpers.emphasis || depth0 && depth0.emphasis || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.description : depth0, depth0 != null ? depth0.query : depth0, 2, true, { "name": "emphasis", "hash": {}, "data": data })) + "\n                </span>\n            </p>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<div class=\"abstract\">\n" + ((stack1 = helpers["if"].call(alias1, (stack1 = depth0 != null ? depth0.offerResult : depth0) != null ? stack1.thumbnail : stack1, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    <div class=\"content\">\n        <a\n            class=\"result\"\n            data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n            href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\"\n        >\n            <p>\n                <span data-extra=\"title\" class=\"title\">\n                    " + alias4((helpers.emphasis || depth0 && depth0.emphasis || alias2).call(alias1, depth0 != null ? depth0.title : depth0, depth0 != null ? depth0.query : depth0, 2, true, { "name": "emphasis", "hash": {}, "data": data })) + "\n                </span>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.friendlyUrl : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            </p>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.description : depth0, { "name": "if", "hash": {}, "fn": container.program(5, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "        </a>\n        <p>\n" + ((stack1 = container.invokePartial(partials["partials/offer/promo-code"], depth0, { "name": "partials/offer/promo-code", "data": data, "indent": "            ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "        </p>\n    </div>\n</div>\n";
                }, "usePartial": true, "useData": true });
            templates['partials/offer/injected-offer'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "<div class=\"injected-offer clearfix padded\">\n    <div class=\"wrapper white-background\">\n" + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.offerResult : depth0) != null ? stack1.showThumbnail : stack1, { "name": "if", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "        <div class=\"offer-content\">\n            <a\n                class=\"result non-selectable offer-title\"\n                data-url=\"" + alias2(alias1((stack1 = (stack1 = depth0 != null ? depth0.offerResult : depth0) != null ? stack1.offerSource : stack1) != null ? stack1.url : stack1, depth0)) + "\"\n                href=\"" + alias2(alias1((stack1 = (stack1 = depth0 != null ? depth0.offerResult : depth0) != null ? stack1.offerSource : stack1) != null ? stack1.url : stack1, depth0)) + "\"\n                data-extra=\"use\"\n            >\n                " + alias2(alias1((stack1 = (stack1 = depth0 != null ? depth0.offerResult : depth0) != null ? stack1.offerSource : stack1) != null ? stack1.title : stack1, depth0)) + "\n            </a>\n            <div class=\"offer-code\">\n                <span class=\"ad-label\">Anzeige</span>\n" + ((stack1 = container.invokePartial(partials["partials/offer/promo-code"], depth0, { "name": "partials/offer/promo-code", "data": data, "indent": "                ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "            </div>\n        </div>\n    </div>\n</div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "        <div class=\"thumbnail\">\n            <img src=\"" + container.escapeExpression(container.lambda((stack1 = depth0 != null ? depth0.offerResult : depth0) != null ? stack1.thumbnail : stack1, depth0)) + "\" data-extra=\"image\" />\n        </div>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.offerResult : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['partials/offer/promo-code'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "    <a\n        class=\"result promo-code\"\n        data-url=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.promoCode : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n        href=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.promoCode : depth0) != null ? stack1.url : stack1, depth0)) + "\"\n    >\n        PROMOTION CODE: " + alias2(alias1((stack1 = depth0 != null ? depth0.promoCode : depth0) != null ? stack1.title : stack1, depth0)) + "\n        <span class=\"tooltip-copied\">\n            Kopiert\n        </span>\n        <span class=\"tooltip\">\n            Klicken zum Kopieren\n        </span>\n    </a>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["with"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.offerResult : depth0, { "name": "with", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['partials/share-location'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "	<div class=\"location\">\n" + ((stack1 = container.invokePartial(partials["partials/buttons"], depth0, { "name": "partials/buttons", "data": data, "indent": "\t\t", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "	</div>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["with"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.shareLocationButtonsWrapper : depth0, { "name": "with", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['partials/soccer/liga-table'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "        <div class=\"table-row\">\n            <div class=\"table-cell\">" + alias4((helper = (helper = helpers.rank || (depth0 != null ? depth0.rank : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "rank", "hash": {}, "data": data }) : helper)) + "</div>\n            <div class=\"table-cell club-logo\">\n                <div style=\"background-image:url(" + alias4((helper = (helper = helpers.logo || (depth0 != null ? depth0.logo : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "logo", "hash": {}, "data": data }) : helper)) + ")\"></div>\n            </div>\n            <div class=\"table-cell club-name\">" + alias4((helper = (helper = helpers.club || (depth0 != null ? depth0.club : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "club", "hash": {}, "data": data }) : helper)) + "</div>\n            <div class=\"table-cell\">" + alias4((helper = (helper = helpers.played || (depth0 != null ? depth0.played : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "played", "hash": {}, "data": data }) : helper)) + "</div>\n            <div class=\"table-cell\">" + alias4((helper = (helper = helpers.won || (depth0 != null ? depth0.won : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "won", "hash": {}, "data": data }) : helper)) + "</div>\n            <div class=\"table-cell\">" + alias4((helper = (helper = helpers.lost || (depth0 != null ? depth0.lost : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "lost", "hash": {}, "data": data }) : helper)) + "</div>\n            <div class=\"table-cell\">" + alias4((helper = (helper = helpers.drawn || (depth0 != null ? depth0.drawn : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "drawn", "hash": {}, "data": data }) : helper)) + "</div>\n            <div class=\"table-cell\">" + alias4((helper = (helper = helpers.goals || (depth0 != null ? depth0.goals : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "goals", "hash": {}, "data": data }) : helper)) + "</div>\n            <div class=\"table-cell\">" + alias4((helper = (helper = helpers.goalsDiff || (depth0 != null ? depth0.goalsDiff : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "goalsDiff", "hash": {}, "data": data }) : helper)) + "</div>\n            <div class=\"table-cell\">" + alias4((helper = (helper = helpers.points || (depth0 != null ? depth0.points : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "points", "hash": {}, "data": data }) : helper)) + "</div>\n        </div>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression,
                        alias3 = depth0 != null ? depth0 : container.nullContext || {};

                    return "<div class=\"table\">\n    <div class=\"table-header\">\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.rank : stack1, depth0)) + "</div>\n        <div class=\"table-cell\"></div>\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.club : stack1, depth0)) + "</div>\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.played : stack1, depth0)) + "</div>\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.won : stack1, depth0)) + "</div>\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.lost : stack1, depth0)) + "</div>\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.drawn : stack1, depth0)) + "</div>\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.goals : stack1, depth0)) + "</div>\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.goalsDiff : stack1, depth0)) + "</div>\n        <div class=\"table-cell\">" + alias2(alias1((stack1 = depth0 != null ? depth0.header : depth0) != null ? stack1.points : stack1, depth0)) + "</div>\n    </div>\n" + ((stack1 = helpers.each.call(alias3, (helpers.take || depth0 && depth0.take || helpers.helperMissing).call(alias3, depth0 != null ? depth0.data : depth0, depth0 != null ? depth0.rowsLimit : depth0, { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "</div>\n";
                }, "useData": true });
            templates['partials/soccer/ligaEZ1Game'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class=\"wrapper\">\n        <div class=\"table\">\n" + ((stack1 = helpers.each.call(alias1, (helpers.take || depth0 && depth0.take || helpers.helperMissing).call(alias1, depth0 != null ? depth0.ligaEZ1Game : depth0, depth0 != null ? depth0.itemsLimit : depth0, { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "        </div>\n    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = container.invokePartial(partials["partials/soccer/ticker"], depth0, { "name": "partials/soccer/ticker", "data": data, "indent": "                ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.ligaEZ1Game : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['partials/soccer/ligaEZGroup'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class=\"wrapper dropdown-tabs\">\n        <div class=\"background-placeholder\"></div>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.groupTableHeader : depth0, { "name": "if", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.ligaEZGroup : depth0, { "name": "each", "hash": {}, "fn": container.program(4, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.ligaEZGroup : depth0, { "name": "each", "hash": {}, "fn": container.program(7, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "            <label class=\"dropdown-tab-label\">" + container.escapeExpression((helper = (helper = helpers.groupTableHeader || (depth0 != null ? depth0.groupTableHeader : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "groupTableHeader", "hash": {}, "data": data }) : helper)) + "</label>\n";
                }, "4": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "            <input class=\"tab-radio-input\" type=\"radio\" name=\"tabs\" id=\"tab-" + alias4((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\" " + ((stack1 = helpers["if"].call(alias1, data && data.first, { "name": "if", "hash": {}, "fn": container.program(5, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "/>\n            <label class=\"dropdown-tab-label\" for=\"tab-" + alias4((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\">" + alias4((helper = (helper = helpers.groupName || (depth0 != null ? depth0.groupName : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "groupName", "hash": {}, "data": data }) : helper)) + "</label>\n";
                }, "5": function (container, depth0, helpers, partials, data) {
                    return "checked=\"checked\"";
                }, "7": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "            <div id=\"tab-block-" + container.escapeExpression((helper = (helper = helpers.index || data && data.index) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\"\n                 class=\"tab-block\"\n            >\n" + ((stack1 = helpers["with"].call(alias1, depth0 != null ? depth0.ligaEZTable : depth0, { "name": "with", "hash": {}, "fn": container.program(8, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            </div>\n";
                }, "8": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = container.invokePartial(partials["partials/soccer/liga-table"], depth0, { "name": "partials/soccer/liga-table", "data": data, "indent": "                    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.ligaEZGroup : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['partials/soccer/ligaEZTable'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "    <div class=\"wrapper\">\n" + ((stack1 = helpers["with"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.ligaEZTable : depth0, { "name": "with", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = container.invokePartial(partials["partials/soccer/liga-table"], depth0, { "name": "partials/soccer/liga-table", "data": data, "indent": "            ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.ligaEZTable : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['partials/soccer/liveTicker'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class=\"wrapper dropdown-tabs\">\n        <div class=\"background-placeholder\"></div>\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.liveTicker : depth0, { "name": "each", "hash": {}, "fn": container.program(2, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.liveTicker : depth0, { "name": "each", "hash": {}, "fn": container.program(5, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "            <input class=\"tab-radio-input\" type=\"radio\" name=\"tabs\" id=\"tab-" + alias4((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\" " + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.isCurrent : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "/>\n            <label class=\"dropdown-tab-label\" for=\"tab-" + alias4((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\">" + alias4((helper = (helper = helpers.round || (depth0 != null ? depth0.round : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "round", "hash": {}, "data": data }) : helper)) + "</label>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    return "checked=\"checked\"";
                }, "5": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing;

                    return "            <div id=\"tab-block-" + container.escapeExpression((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\"\n                 class=\"tab-block\"\n            >\n                <div class=\"table\">\n" + ((stack1 = helpers.each.call(alias1, (helpers.take || depth0 && depth0.take || alias2).call(alias1, depth0 != null ? depth0.allResults : depth0, depths[1] != null ? depths[1].itemsLimit : depths[1], { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(6, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "                </div>\n            </div>\n";
                }, "6": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = container.invokePartial(partials["partials/soccer/ticker"], depth0, { "name": "partials/soccer/ticker", "data": data, "indent": "                        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data, blockParams, depths) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.liveTicker : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0, blockParams, depths), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true, "useDepths": true });
            templates['partials/soccer/news-injection'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = container.escapeExpression;

                    return "    <p class=\"news-injection-title\">" + alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "soccer-news-title", { "name": "local", "hash": {}, "data": data })) + "</p>\n    <div class=\"news-injection column-" + alias3((helper = (helper = helpers.numberOfNews || (depth0 != null ? depth0.numberOfNews : depth0)) != null ? helper : alias2, typeof helper === "function" ? helper.call(alias1, { "name": "numberOfNews", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = container.invokePartial(partials["partials/news"], depth0, { "name": "partials/news", "data": data, "indent": "        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "    </div>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.newsAvailable : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['partials/soccer/ticker'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    return "live";
                }, "3": function (container, depth0, helpers, partials, data) {
                    return "            <span class=\"is-live\">Live</span>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<a class=\"table-row result non-selectable\" data-extra=\"game_row_" + alias4((helper = (helper = helpers.index || data && data.index) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "index", "hash": {}, "data": data }) : helper)) + "\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\">\n    <div class=\"table-cell club-logo\">\n        <div style=\"background-image:url(" + alias4((helper = (helper = helpers.hostLogo || (depth0 != null ? depth0.hostLogo : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "hostLogo", "hash": {}, "data": data }) : helper)) + ")\"></div>\n    </div>\n    <div class=\"table-cell host fixed-width\">" + alias4((helpers.emphasis || depth0 && depth0.emphasis || alias2).call(alias1, depth0 != null ? depth0.host : depth0, depth0 != null ? depth0.query : depth0, 2, true, { "name": "emphasis", "hash": {}, "data": data })) + "</div>\n    <div class=\"table-cell scored " + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.isLive : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\">\n        <span>" + alias4((helper = (helper = helpers.scored || (depth0 != null ? depth0.scored : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "scored", "hash": {}, "data": data }) : helper)) + "</span>\n    </div>\n    <div class=\"table-cell fixed-width\">" + alias4((helpers.emphasis || depth0 && depth0.emphasis || alias2).call(alias1, depth0 != null ? depth0.guest : depth0, depth0 != null ? depth0.query : depth0, 2, true, { "name": "emphasis", "hash": {}, "data": data })) + "</div>\n    <div class=\"table-cell club-logo\">\n        <div style=\"background-image:url(" + alias4((helper = (helper = helpers.guestLogo || (depth0 != null ? depth0.guestLogo : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "guestLogo", "hash": {}, "data": data }) : helper)) + ")\"></div>\n    </div>\n    <div class=\"table-cell time\">" + alias4((helper = (helper = helpers.gameTime || (depth0 != null ? depth0.gameTime : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "gameTime", "hash": {}, "data": data }) : helper)) + "</div>\n    <div class=\"table-cell\">\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.isLive : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n    <div class=\"table-cell\">\n        <div class=\"league-logo\" style=\"background-image: url(" + alias4((helper = (helper = helpers.leagueLogo || (depth0 != null ? depth0.leagueLogo : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "leagueLogo", "hash": {}, "data": data }) : helper)) + ")\" title=\"" + alias4((helper = (helper = helpers.leagueName || (depth0 != null ? depth0.leagueName : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "leagueName", "hash": {}, "data": data }) : helper)) + "\">\n        </div>\n    </div>\n</a>\n";
                }, "useData": true });
            templates['partials/social-buttons'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class='social-buttons " + ((stack1 = helpers.unless.call(alias1, depth0 != null ? depth0.internalResults : depth0, { "name": "unless", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "'>\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.socialResults : depth0, { "name": "each", "hash": {}, "fn": container.program(4, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    return "padded";
                }, "4": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "            <a\n                class=\"result social-icon\"\n                data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n                href=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\"\n            >\n                <div style=\"background-image:url(" + alias4((helper = (helper = helpers.image || (depth0 != null ? depth0.image : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "image", "hash": {}, "data": data }) : helper)) + ")\"></div>\n            </a>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.socialResults : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['partials/source-timestamp'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = container.escapeExpression,
                        alias4 = "function";

                    return alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "source", { "name": "local", "hash": {}, "data": data })) + ": " + alias3((helper = (helper = helpers.source || (depth0 != null ? depth0.source : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, { "name": "source", "hash": {}, "data": data }) : helper)) + "\n&#183; " + alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "updated", { "name": "local", "hash": {}, "data": data })) + ": " + alias3((helper = (helper = helpers.updated || (depth0 != null ? depth0.updated : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, { "name": "updated", "hash": {}, "data": data }) : helper));
                }, "useData": true });
            templates['partials/source'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = container.escapeExpression,
                        alias4 = "function";

                    return alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "source", { "name": "local", "hash": {}, "data": data })) + ": <a class=\"source-link result\" data-url=\"" + alias3((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias3((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\">" + alias3((helper = (helper = helpers.source || (depth0 != null ? depth0.source : depth0)) != null ? helper : alias2, typeof helper === alias4 ? helper.call(alias1, { "name": "source", "hash": {}, "data": data }) : helper)) + "</a>\n";
                }, "useData": true });
            templates['partials/timestamp'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = container.escapeExpression;

                    return alias3((helpers.local || depth0 && depth0.local || alias2).call(alias1, "updated", { "name": "local", "hash": {}, "data": data })) + ": " + alias3((helpers.agoDuration || depth0 && depth0.agoDuration || alias2).call(alias1, depth0 != null ? depth0.updated : depth0, { "name": "agoDuration", "hash": {}, "data": data }));
                }, "useData": true });
            templates['partials/videos'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "    <div class=\"videos thumbnail-blocks\">\n" + ((stack1 = helpers.each.call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.videoResults : depth0, { "name": "each", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = container.invokePartial(partials.generic, depth0, { "name": "generic", "data": data, "indent": "            ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.videoResults : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['results'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class=\"" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.isHistory : depth0, { "name": "if", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\">\n" + ((stack1 = container.invokePartial(helpers.lookup.call(alias1, depth0, "template", { "name": "lookup", "hash": {}, "data": data }), depth0, { "data": data, "indent": "        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return "history " + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.url : depth0, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "");
                }, "3": function (container, depth0, helpers, partials, data) {
                    return "cluster";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers.each.call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.results : depth0, { "name": "each", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "usePartial": true, "useData": true });
            templates['search'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var helper;

                    return "                    " + container.escapeExpression((helper = (helper = helpers.displayText || (depth0 != null ? depth0.displayText : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(depth0 != null ? depth0 : container.nullContext || {}, { "name": "displayText", "hash": {}, "data": data }) : helper)) + "\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    return "                    " + container.escapeExpression((helpers.emphasis || depth0 && depth0.emphasis || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.displayText : depth0, depth0 != null ? depth0.query : depth0, 1, true, { "name": "emphasis", "hash": {}, "data": data })) + "\n";
                }, "5": function (container, depth0, helpers, partials, data) {
                    return "                <span class=\"divider\">&#8212;</span>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<a class=\"result search\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\">\n    <div class=\"icons\">\n        <span class=\"icon " + alias4((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "icon", "hash": {}, "data": data }) : helper)) + "\"></span>\n    </div>\n    <div class=\"abstract\">\n        <p>\n            <span class=\"strong\">\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.defaultSearchResult : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.program(3, data, 0), "data": data })) != null ? stack1 : "") + "            </span>\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.displayText : depth0, { "name": "if", "hash": {}, "fn": container.program(5, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "            <span class=\"url\">" + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, "searchWith", depth0 != null ? depth0.engine : depth0, { "name": "local", "hash": {}, "data": data })) + "</span>\n        </p>\n    </div>\n</a>\n";
                }, "useData": true });
            templates['sessions'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<a id=\"" + alias4((helper = (helper = helpers.elementId || (depth0 != null ? depth0.elementId : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "elementId", "hash": {}, "data": data }) : helper)) + "\" class=\"result sessions\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\">\n    <div class=\"icons\">\n        <span class=\"icon history-tool\"></span>\n    </div>\n    <div class=\"abstract\">\n        <p>\n            <span class=\"\">\n                " + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, "results_found_in_history", { "name": "local", "hash": {}, "data": data })) + "\n            </span>\n        </p>\n    </div>\n</a>\n";
                }, "useData": true });
            templates['soccer'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.lambda,
                        alias2 = container.escapeExpression;

                    return "<a class=\"result soccer-title\" data-url=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.subResult : depth0) != null ? stack1.url : stack1, depth0)) + "\" href=\"" + alias2(alias1((stack1 = depth0 != null ? depth0.subResult : depth0) != null ? stack1.url : stack1, depth0)) + "\">\n        <span class=\"padded\">" + alias2(alias1((stack1 = depth0 != null ? depth0.subResult : depth0) != null ? stack1.title : stack1, depth0)) + "</span>\n        <span class=\"soccer-domain divider\">&#8212;</span>\n        <span class=\"soccer-domain\">" + alias2((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, "soccer-api-provider", { "name": "local", "hash": {}, "data": data })) + "</span>\n    </a>\n";
                }, "3": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = container.escapeExpression;

                    return "                <a class=\"result expand-btn\" data-url=\"" + alias1(container.lambda((stack1 = depth0 != null ? depth0.expandButton : depth0) != null ? stack1.url : stack1, depth0)) + "\">\n                    " + alias1((helpers.local || depth0 && depth0.local || helpers.helperMissing).call(depth0 != null ? depth0 : container.nullContext || {}, (stack1 = depth0 != null ? depth0.expandButton : depth0) != null ? stack1.title : stack1, { "name": "local", "hash": {}, "data": data })) + "\n                </a>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression,
                        alias5 = container.lambda;

                    return "<a class=\"result\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias4((helper = (helper = helpers.displayUrl || (depth0 != null ? depth0.displayUrl : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "displayUrl", "hash": {}, "data": data }) : helper)) + "\">\n" + ((stack1 = container.invokePartial(partials["partials/logo"], depth0, { "name": "partials/logo", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + ((stack1 = container.invokePartial(partials["partials/abstract"], depth0, { "name": "partials/abstract", "data": data, "indent": "    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "</a>\n\n" + ((stack1 = container.invokePartial(partials["partials/buttons"], depth0, { "name": "partials/buttons", "data": data, "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "\n" + ((stack1 = helpers["if"].call(alias1, depth0 != null ? depth0.subResult : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\n<div class=\"padded\">\n    <div class=\"soccer\">\n\n" + ((stack1 = container.invokePartial(helpers.lookup.call(alias1, depth0, "currentPartial", { "name": "lookup", "hash": {}, "data": data }), depth0, { "data": data, "indent": "        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "\n        <div>\n" + ((stack1 = helpers["if"].call(alias1, (stack1 = depth0 != null ? depth0.expandButton : depth0) != null ? stack1.show : stack1, { "name": "if", "hash": {}, "fn": container.program(3, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\n            <a class=\"result powered-by\" data-url=\"" + alias4(alias5((stack1 = depth0 != null ? depth0.poweredByResult : depth0) != null ? stack1.url : stack1, depth0)) + "\" href=\"" + alias4(alias5((stack1 = depth0 != null ? depth0.poweredByResult : depth0) != null ? stack1.url : stack1, depth0)) + "\">\n                " + alias4((helpers.local || depth0 && depth0.local || alias2).call(alias1, (stack1 = depth0 != null ? depth0.poweredByResult : depth0) != null ? stack1.title : stack1, { "name": "local", "hash": {}, "data": data })) + "\n            </a>\n        </div>\n\n" + ((stack1 = container.invokePartial(partials["partials/soccer/news-injection"], depth0, { "name": "partials/soccer/news-injection", "data": data, "indent": "        ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "\n    </div>\n</div>\n";
                }, "usePartial": true, "useData": true });
            templates['suggestions'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {};

                    return "    <div class=\"padded suggestions\">\n" + ((stack1 = helpers.each.call(alias1, (helpers.take || depth0 && depth0.take || helpers.helperMissing).call(alias1, depth0 != null ? depth0.suggestionResults : depth0, depth0 != null ? depth0.suggestionsLimit : depth0, { "name": "take", "hash": {}, "data": data }), { "name": "each", "hash": {}, "fn": container.program(2, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "    </div>\n";
                }, "2": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "            <a class=\"result\" data-url=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\" href=\"" + alias4((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "url", "hash": {}, "data": data }) : helper)) + "\">\n                <div class=\"icons\">\n                    <span class=\"icon search\"></span>\n                </div>\n                " + alias4((helpers.emphasis || depth0 && depth0.emphasis || alias2).call(alias1, depth0 != null ? depth0.displayText : depth0, depth0 != null ? depth0.query : depth0, 1, true, { "name": "emphasis", "hash": {}, "data": data })) + "\n            </a>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1;

                    return (stack1 = helpers["if"].call(depth0 != null ? depth0 : container.nullContext || {}, depth0 != null ? depth0.suggestionAvailable : depth0, { "name": "if", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "";
                }, "useData": true });
            templates['time'] = Handlebars.template({ "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "<div class=\"time padded\">\n    <p>" + alias4((helper = (helper = helpers.answer || (depth0 != null ? depth0.answer : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "answer", "hash": {}, "data": data }) : helper)) + " " + alias4((helper = (helper = helpers.location || (depth0 != null ? depth0.location : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "location", "hash": {}, "data": data }) : helper)) + "</p>\n    <p>" + alias4((helper = (helper = helpers.expression || (depth0 != null ? depth0.expression : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "expression", "hash": {}, "data": data }) : helper)) + ", " + alias4((helper = (helper = helpers.timeZone || (depth0 != null ? depth0.timeZone : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "timeZone", "hash": {}, "data": data }) : helper)) + "</p>\n</div>\n";
                }, "useData": true });
            templates['weather'] = Handlebars.template({ "1": function (container, depth0, helpers, partials, data) {
                    var helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = helpers.helperMissing,
                        alias3 = "function",
                        alias4 = container.escapeExpression;

                    return "                <div class=\"weather-item\">\n                    <div class=\"date\">" + alias4((helper = (helper = helpers.weekday || (depth0 != null ? depth0.weekday : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "weekday", "hash": {}, "data": data }) : helper)) + "</div>\n                    <img width=\"55\" height=\"55\" src=\"" + alias4((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "icon", "hash": {}, "data": data }) : helper)) + "\" />\n                    <div class=\"temp\">\n                        " + alias4((helper = (helper = helpers.max || (depth0 != null ? depth0.max : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "max", "hash": {}, "data": data }) : helper)) + "  " + alias4((helper = (helper = helpers.min || (depth0 != null ? depth0.min : depth0)) != null ? helper : alias2, typeof helper === alias3 ? helper.call(alias1, { "name": "min", "hash": {}, "data": data }) : helper)) + "\n                    </div>\n                </div>\n";
                }, "compiler": [7, ">= 4.0.0"], "main": function (container, depth0, helpers, partials, data) {
                    var stack1,
                        helper,
                        alias1 = depth0 != null ? depth0 : container.nullContext || {},
                        alias2 = container.escapeExpression,
                        alias3 = container.lambda;

                    return "<div class=\"result instant weather\">\n    <div class=\"header padded\">\n        <span class=\"title\">" + alias2((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing, typeof helper === "function" ? helper.call(alias1, { "name": "title", "hash": {}, "data": data }) : helper)) + "</span>\n    </div>\n\n    <div class=\"forecast padded\">\n        <div class=\"forecast-container white-background\">\n            <div class=\"weather-item\">\n                <div class=\"date\">" + alias2(alias3((stack1 = depth0 != null ? depth0.today : depth0) != null ? stack1.date : stack1, depth0)) + "</div>\n                <img width=\"55\" height=\"55\" src=\"" + alias2(alias3((stack1 = depth0 != null ? depth0.today : depth0) != null ? stack1.icon : stack1, depth0)) + "\" />\n                <div class=\"temp\">\n                    " + alias2(alias3((stack1 = depth0 != null ? depth0.today : depth0) != null ? stack1.maxTemp : stack1, depth0)) + " " + alias2(alias3((stack1 = depth0 != null ? depth0.today : depth0) != null ? stack1.minTemp : stack1, depth0)) + "\n                </div>\n            </div>\n\n" + ((stack1 = helpers.each.call(alias1, depth0 != null ? depth0.forecast : depth0, { "name": "each", "hash": {}, "fn": container.program(1, data, 0), "inverse": container.noop, "data": data })) != null ? stack1 : "") + "\n            <div class=\"source\">\n                <div class=\"source-container\">\n" + ((stack1 = container.invokePartial(partials["partials/source"], depth0, { "name": "partials/source", "data": data, "indent": "                    ", "helpers": helpers, "partials": partials, "decorators": container.decorators })) != null ? stack1 : "") + "                </div>\n            </div>\n        </div>\n    </div>\n</div>\n";
                }, "usePartial": true, "useData": true });

            _export('default', templates);
        }
    };
});

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;
})({ 1: [function (require, module, exports) {
        "use strict";
        /*
        Copyright (c) 2014 Petka Antonov
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.
        */

        function Url() {
            //For more efficient internal representation and laziness.
            //The non-underscore versions of these properties are accessor functions
            //defined on the prototype.
            this._protocol = null;
            this._href = "";
            this._port = -1;
            this._query = null;

            this.auth = null;
            this.slashes = null;
            this.host = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.pathname = null;

            this._prependSlash = false;
        }

        var querystring = require("querystring");

        Url.queryString = querystring;

        Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
            if (typeof str !== "string") {
                throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
            }
            var start = 0;
            var end = str.length - 1;

            //Trim leading and trailing ws
            while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;
            while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;

            start = this._parseProtocol(str, start, end);

            //Javascript doesn't have host
            if (this._protocol !== "javascript") {
                start = this._parseHost(str, start, end, hostDenotesSlash);
                var proto = this._protocol;
                if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
                    this.hostname = this.host = "";
                }
            }

            if (start <= end) {
                var ch = str.charCodeAt(start);

                if (ch === 0x2F /*'/'*/ || ch === 0x5C /*'\'*/) {
                        this._parsePath(str, start, end, disableAutoEscapeChars);
                    } else if (ch === 0x3F /*'?'*/) {
                        this._parseQuery(str, start, end, disableAutoEscapeChars);
                    } else if (ch === 0x23 /*'#'*/) {
                        this._parseHash(str, start, end, disableAutoEscapeChars);
                    } else if (this._protocol !== "javascript") {
                    this._parsePath(str, start, end, disableAutoEscapeChars);
                } else {
                    //For javascript the pathname is just the rest of it
                    this.pathname = str.slice(start, end + 1);
                }
            }

            if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
                this.pathname = "/";
            }

            if (parseQueryString) {
                var search = this.search;
                if (search == null) {
                    search = this.search = "";
                }
                if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                        search = search.slice(1);
                    }
                //This calls a setter function, there is no .query data property
                this.query = Url.queryString.parse(search);
            }
        };

        Url.prototype.resolve = function Url$resolve(relative) {
            return this.resolveObject(Url.parse(relative, false, true)).format();
        };

        Url.prototype.format = function Url$format() {
            var auth = this.auth || "";

            if (auth) {
                auth = encodeURIComponent(auth);
                auth = auth.replace(/%3A/i, ":");
                auth += "@";
            }

            var protocol = this.protocol || "";
            var pathname = this.pathname || "";
            var hash = this.hash || "";
            var search = this.search || "";
            var query = "";
            var hostname = this.hostname || "";
            var port = this.port || "";
            var host = false;
            var scheme = "";

            //Cache the result of the getter function
            var q = this.query;
            if (q && typeof q === "object") {
                query = Url.queryString.stringify(q);
            }

            if (!search) {
                search = query ? "?" + query : "";
            }

            if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/) protocol += ":";

            if (this.host) {
                host = auth + this.host;
            } else if (hostname) {
                var ip6 = hostname.indexOf(":") > -1;
                if (ip6) hostname = "[" + hostname + "]";
                host = auth + hostname + (port ? ":" + port : "");
            }

            var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;

            if (protocol) scheme = protocol + (slashes ? "//" : "");else if (slashes) scheme = "//";

            if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {
                    pathname = "/" + pathname;
                }
            if (search && search.charCodeAt(0) !== 0x3F /*'?'*/) search = "?" + search;
            if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/) hash = "#" + hash;

            pathname = escapePathName(pathname);
            search = escapeSearch(search);

            return scheme + (host === false ? "" : host) + pathname + search + hash;
        };

        Url.prototype.resolveObject = function Url$resolveObject(relative) {
            if (typeof relative === "string") relative = Url.parse(relative, false, true);

            var result = this._clone();

            // hash is always overridden, no matter what.
            // even href="" will remove it.
            result.hash = relative.hash;

            // if the relative url is empty, then there"s nothing left to do here.
            if (!relative.href) {
                result._href = "";
                return result;
            }

            // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative._protocol) {
                relative._copyPropsTo(result, true);

                if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
                    result.pathname = "/";
                }
                result._href = "";
                return result;
            }

            if (relative._protocol && relative._protocol !== result._protocol) {
                // if it"s a known url protocol, then changing
                // the protocol does weird things
                // first, if it"s not file:, then we MUST have a host,
                // and if there was a path
                // to begin with, then we MUST have a path.
                // if it is file:, then the host is dropped,
                // because that"s known to be hostless.
                // anything else is assumed to be absolute.
                if (!slashProtocols[relative._protocol]) {
                    relative._copyPropsTo(result, false);
                    result._href = "";
                    return result;
                }

                result._protocol = relative._protocol;
                if (!relative.host && relative._protocol !== "javascript") {
                    var relPath = (relative.pathname || "").split("/");
                    while (relPath.length && !(relative.host = relPath.shift()));
                    if (!relative.host) relative.host = "";
                    if (!relative.hostname) relative.hostname = "";
                    if (relPath[0] !== "") relPath.unshift("");
                    if (relPath.length < 2) relPath.unshift("");
                    result.pathname = relPath.join("/");
                } else {
                    result.pathname = relative.pathname;
                }

                result.search = relative.search;
                result.host = relative.host || "";
                result.auth = relative.auth;
                result.hostname = relative.hostname || relative.host;
                result._port = relative._port;
                result.slashes = result.slashes || relative.slashes;
                result._href = "";
                return result;
            }

            var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/;
            var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 0x2F /*'/'*/;
            var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;

            var removeAllDots = mustEndAbs;

            var srcPath = result.pathname && result.pathname.split("/") || [];
            var relPath = relative.pathname && relative.pathname.split("/") || [];
            var psychotic = result._protocol && !slashProtocols[result._protocol];

            // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // result.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {
                result.hostname = "";
                result._port = -1;
                if (result.host) {
                    if (srcPath[0] === "") srcPath[0] = result.host;else srcPath.unshift(result.host);
                }
                result.host = "";
                if (relative._protocol) {
                    relative.hostname = "";
                    relative._port = -1;
                    if (relative.host) {
                        if (relPath[0] === "") relPath[0] = relative.host;else relPath.unshift(relative.host);
                    }
                    relative.host = "";
                }
                mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
            }

            if (isRelAbs) {
                // it"s absolute.
                result.host = relative.host ? relative.host : result.host;
                result.hostname = relative.hostname ? relative.hostname : result.hostname;
                result.search = relative.search;
                srcPath = relPath;
                // fall through to the dot-handling below.
            } else if (relPath.length) {
                // it"s relative
                // throw away the existing file, and take the new path instead.
                if (!srcPath) srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                result.search = relative.search;
            } else if (relative.search) {
                // just pull out the search.
                // like href="?foo".
                // Put this after the other two cases because it simplifies the booleans
                if (psychotic) {
                    result.hostname = result.host = srcPath.shift();
                    //occationaly the auth can get stuck only in host
                    //this especialy happens in cases like
                    //url.resolveObject("mailto:local1@domain1", "local2@domain2")
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                result.search = relative.search;
                result._href = "";
                return result;
            }

            if (!srcPath.length) {
                // no path at all.  easy.
                // we"ve already handled the other stuff above.
                result.pathname = null;
                result._href = "";
                return result;
            }

            // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";

            // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
                last = srcPath[i];
                if (last === ".") {
                    srcPath.splice(i, 1);
                } else if (last === "..") {
                    srcPath.splice(i, 1);
                    up++;
                } else if (up) {
                    srcPath.splice(i, 1);
                    up--;
                }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
                for (; up--; up) {
                    srcPath.unshift("..");
                }
            }

            if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {
                srcPath.unshift("");
            }

            if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                srcPath.push("");
            }

            var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/;

            // put the host back
            if (psychotic) {
                result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                //occationaly the auth can get stuck only in host
                //this especialy happens in cases like
                //url.resolveObject("mailto:local1@domain1", "local2@domain2")
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }

            mustEndAbs = mustEndAbs || result.host && srcPath.length;

            if (mustEndAbs && !isAbsolute) {
                srcPath.unshift("");
            }

            result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result._href = "";
            return result;
        };

        var punycode = require("punycode");
        Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            return punycode.toASCII(hostname);
        };

        var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
            if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {
                return pathname;
            }
            //Avoid closure creation to keep this inlinable
            return _escapePath(pathname);
        };

        var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
            if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;
            //Avoid closure creation to keep this inlinable
            return _escapeSearch(search);
        };

        Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
            var doLowerCase = false;
            var protocolCharacters = this._protocolCharacters;

            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);

                if (ch === 0x3A /*':'*/) {
                        var protocol = str.slice(start, i);
                        if (doLowerCase) protocol = protocol.toLowerCase();
                        this._protocol = protocol;
                        return i + 1;
                    } else if (protocolCharacters[ch] === 1) {
                    if (ch < 0x61 /*'a'*/) doLowerCase = true;
                } else {
                    return start;
                }
            }
            return start;
        };

        Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
            var auth = str.slice(start, end + 1);
            if (decode) {
                auth = decodeURIComponent(auth);
            }
            this.auth = auth;
        };

        Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
            //Internal format is integer for more efficient parsing
            //and for efficient trimming of leading zeros
            var port = 0;
            //Distinguish between :0 and : (no port number at all)
            var hadChars = false;

            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);

                if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {
                        port = 10 * port + (ch - 0x30 /*'0'*/);
                        hadChars = true;
                    } else break;
            }
            if (port === 0 && !hadChars) {
                return 0;
            }

            this._port = port;
            return i - start;
        };

        Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
            var hostEndingCharacters = this._hostEndingCharacters;
            var first = str.charCodeAt(start);
            var second = str.charCodeAt(start + 1);
            if ((first === 0x2F /*'/'*/ || first === 0x5C /*'\'*/) && (second === 0x2F /*'/'*/ || second === 0x5C /*'\'*/)) {
                this.slashes = true;

                //The string starts with //
                if (start === 0) {
                    //The string is just "//"
                    if (end < 2) return start;
                    //If slashes do not denote host and there is no auth,
                    //there is no host when the string starts with //
                    var hasAuth = containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);
                    if (!hasAuth && !slashesDenoteHost) {
                        this.slashes = null;
                        return start;
                    }
                }
                //There is a host that starts after the //
                start += 2;
            }
            //If there is no slashes, there is no hostname if
            //1. there was no protocol at all
            else if (!this._protocol ||
                //2. there was a protocol that requires slashes
                //e.g. in 'http:asd' 'asd' is not a hostname
                slashProtocols[this._protocol]) {
                    return start;
                }

            var doLowerCase = false;
            var idna = false;
            var hostNameStart = start;
            var hostNameEnd = end;
            var lastCh = -1;
            var portLength = 0;
            var charsAfterDot = 0;
            var authNeedsDecoding = false;

            var j = -1;

            //Find the last occurrence of an @-sign until hostending character is met
            //also mark if decoding is needed for the auth portion
            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);

                if (ch === 0x40 /*'@'*/) {
                        j = i;
                    }
                    //This check is very, very cheap. Unneeded decodeURIComponent is very
                    //very expensive
                else if (ch === 0x25 /*'%'*/) {
                            authNeedsDecoding = true;
                        } else if (hostEndingCharacters[ch] === 1) {
                        break;
                    }
            }

            //@-sign was found at index j, everything to the left from it
            //is auth part
            if (j > -1) {
                this._parseAuth(str, start, j - 1, authNeedsDecoding);
                //hostname starts after the last @-sign
                start = hostNameStart = j + 1;
            }

            //Host name is starting with a [
            if (str.charCodeAt(start) === 0x5B /*'['*/) {
                    for (var i = start + 1; i <= end; ++i) {
                        var ch = str.charCodeAt(i);

                        //Assume valid IP6 is between the brackets
                        if (ch === 0x5D /*']'*/) {
                                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {
                                        portLength = this._parsePort(str, i + 2, end) + 1;
                                    }
                                var hostname = str.slice(start + 1, i).toLowerCase();
                                this.hostname = hostname;
                                this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
                                this.pathname = "/";
                                return i + portLength + 1;
                            }
                    }
                    //Empty hostname, [ starts a path
                    return start;
                }

            for (var i = start; i <= end; ++i) {
                if (charsAfterDot > 62) {
                    this.hostname = this.host = str.slice(start, i);
                    return i;
                }
                var ch = str.charCodeAt(i);

                if (ch === 0x3A /*':'*/) {
                        portLength = this._parsePort(str, i + 1, end) + 1;
                        hostNameEnd = i - 1;
                        break;
                    } else if (ch < 0x61 /*'a'*/) {
                        if (ch === 0x2E /*'.'*/) {
                                //Node.js ignores this error
                                /*
                                if (lastCh === DOT || lastCh === -1) {
                                    this.hostname = this.host = "";
                                    return start;
                                }
                                */
                                charsAfterDot = -1;
                            } else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {
                                doLowerCase = true;
                            }
                            //Valid characters other than ASCII letters -, _, +, 0-9
                        else if (!(ch === 0x2D /*'-'*/ || ch === 0x5F /*'_'*/ || ch === 0x2B /*'+'*/ || 0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/)) {
                                if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
                                    this._prependSlash = true;
                                }
                                hostNameEnd = i - 1;
                                break;
                            }
                    } else if (ch >= 0x7B /*'{'*/) {
                        if (ch <= 0x7E /*'~'*/) {
                                if (this._noPrependSlashHostEnders[ch] === 0) {
                                    this._prependSlash = true;
                                }
                                hostNameEnd = i - 1;
                                break;
                            }
                        idna = true;
                    }
                lastCh = ch;
                charsAfterDot++;
            }

            //Node.js ignores this error
            /*
            if (lastCh === DOT) {
                hostNameEnd--;
            }
            */

            if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
                var hostname = str.slice(hostNameStart, hostNameEnd + 1);
                if (doLowerCase) hostname = hostname.toLowerCase();
                if (idna) hostname = this._hostIdna(hostname);
                this.hostname = hostname;
                this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
            }

            return hostNameEnd + 1 + portLength;
        };

        Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
            if (!noProtocol) {
                input._protocol = this._protocol;
            }
            input._href = this._href;
            input._port = this._port;
            input._prependSlash = this._prependSlash;
            input.auth = this.auth;
            input.slashes = this.slashes;
            input.host = this.host;
            input.hostname = this.hostname;
            input.hash = this.hash;
            input.search = this.search;
            input.pathname = this.pathname;
        };

        Url.prototype._clone = function Url$_clone() {
            var ret = new Url();
            ret._protocol = this._protocol;
            ret._href = this._href;
            ret._port = this._port;
            ret._prependSlash = this._prependSlash;
            ret.auth = this.auth;
            ret.slashes = this.slashes;
            ret.host = this.host;
            ret.hostname = this.hostname;
            ret.hash = this.hash;
            ret.search = this.search;
            ret.pathname = this.pathname;
            return ret;
        };

        Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
            var cur = start;
            var i = start;
            var ret = "";
            var autoEscapeMap = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
            for (; i <= end; ++i) {
                var ch = str.charCodeAt(i);
                var escaped = autoEscapeMap[ch];

                if (escaped !== "" && escaped !== undefined) {
                    if (cur < i) ret += str.slice(cur, i);
                    ret += escaped;
                    cur = i + 1;
                }
            }
            if (cur < i + 1) ret += str.slice(cur, i);
            return ret;
        };

        Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
            var pathStart = start;
            var pathEnd = end;
            var escape = false;
            var autoEscapeCharacters = this._autoEscapeCharacters;

            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);
                if (ch === 0x23 /*'#'*/) {
                        this._parseHash(str, i, end, disableAutoEscapeChars);
                        pathEnd = i - 1;
                        break;
                    } else if (ch === 0x3F /*'?'*/) {
                        this._parseQuery(str, i, end, disableAutoEscapeChars);
                        pathEnd = i - 1;
                        break;
                    } else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
                    escape = true;
                }
            }

            if (pathStart > pathEnd) {
                this.pathname = "/";
                return;
            }

            var path;
            if (escape) {
                path = this._getComponentEscaped(str, pathStart, pathEnd, false);
            } else {
                path = str.slice(pathStart, pathEnd + 1);
            }
            this.pathname = this._prependSlash ? "/" + path : path;
        };

        Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
            var queryStart = start;
            var queryEnd = end;
            var escape = false;
            var autoEscapeCharacters = this._autoEscapeCharacters;

            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);

                if (ch === 0x23 /*'#'*/) {
                        this._parseHash(str, i, end, disableAutoEscapeChars);
                        queryEnd = i - 1;
                        break;
                    } else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
                    escape = true;
                }
            }

            if (queryStart > queryEnd) {
                this.search = "";
                return;
            }

            var query;
            if (escape) {
                query = this._getComponentEscaped(str, queryStart, queryEnd, true);
            } else {
                query = str.slice(queryStart, queryEnd + 1);
            }
            this.search = query;
        };

        Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
            if (start > end) {
                this.hash = "";
                return;
            }

            this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
        };

        Object.defineProperty(Url.prototype, "port", {
            get: function () {
                if (this._port >= 0) {
                    return "" + this._port;
                }
                return null;
            },
            set: function (v) {
                if (v == null) {
                    this._port = -1;
                } else {
                    this._port = parseInt(v, 10);
                }
            }
        });

        Object.defineProperty(Url.prototype, "query", {
            get: function () {
                var query = this._query;
                if (query != null) {
                    return query;
                }
                var search = this.search;

                if (search) {
                    if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                            search = search.slice(1);
                        }
                    if (search !== "") {
                        this._query = search;
                        return search;
                    }
                }
                return search;
            },
            set: function (v) {
                this._query = v;
            }
        });

        Object.defineProperty(Url.prototype, "path", {
            get: function () {
                var p = this.pathname || "";
                var s = this.search || "";
                if (p || s) {
                    return p + s;
                }
                return p == null && s ? "/" + s : null;
            },
            set: function () {}
        });

        Object.defineProperty(Url.prototype, "protocol", {
            get: function () {
                var proto = this._protocol;
                return proto ? proto + ":" : proto;
            },
            set: function (v) {
                if (typeof v === "string") {
                    var end = v.length - 1;
                    if (v.charCodeAt(end) === 0x3A /*':'*/) {
                            this._protocol = v.slice(0, end);
                        } else {
                        this._protocol = v;
                    }
                } else if (v == null) {
                    this._protocol = null;
                }
            }
        });

        Object.defineProperty(Url.prototype, "href", {
            get: function () {
                var href = this._href;
                if (!href) {
                    href = this._href = this.format();
                }
                return href;
            },
            set: function (v) {
                this._href = v;
            }
        });

        Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
            if (str instanceof Url) return str;
            var ret = new Url();
            ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
            return ret;
        };

        Url.format = function Url$Format(obj) {
            if (typeof obj === "string") {
                obj = Url.parse(obj);
            }
            if (!(obj instanceof Url)) {
                return Url.prototype.format.call(obj);
            }
            return obj.format();
        };

        Url.resolve = function Url$Resolve(source, relative) {
            return Url.parse(source, false, true).resolve(relative);
        };

        Url.resolveObject = function Url$ResolveObject(source, relative) {
            if (!source) return relative;
            return Url.parse(source, false, true).resolveObject(relative);
        };

        function _escapePath(pathname) {
            return pathname.replace(/[?#]/g, function (match) {
                return encodeURIComponent(match);
            });
        }

        function _escapeSearch(search) {
            return search.replace(/#/g, function (match) {
                return encodeURIComponent(match);
            });
        }

        //Search `char1` (integer code for a character) in `string`
        //starting from `fromIndex` and ending at `string.length - 1`
        //or when a stop character is found
        function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
            var len = string.length;
            for (var i = fromIndex; i < len; ++i) {
                var ch = string.charCodeAt(i);

                if (ch === char1) {
                    return true;
                } else if (stopCharacterTable[ch] === 1) {
                    return false;
                }
            }
            return false;
        }

        //See if `char1` or `char2` (integer codes for characters)
        //is contained in `string`
        function containsCharacter2(string, char1, char2) {
            for (var i = 0, len = string.length; i < len; ++i) {
                var ch = string.charCodeAt(i);
                if (ch === char1 || ch === char2) return true;
            }
            return false;
        }

        //Makes an array of 128 uint8's which represent boolean values.
        //Spec is an array of ascii code points or ascii code point ranges
        //ranges are expressed as [start, end]

        //Create a table with the characters 0x30-0x39 (decimals '0' - '9') and
        //0x7A (lowercaseletter 'z') as `true`:
        //
        //var a = makeAsciiTable([[0x30, 0x39], 0x7A]);
        //a[0x30]; //1
        //a[0x15]; //0
        //a[0x35]; //1
        function makeAsciiTable(spec) {
            var ret = new Uint8Array(128);
            spec.forEach(function (item) {
                if (typeof item === "number") {
                    ret[item] = 1;
                } else {
                    var start = item[0];
                    var end = item[1];
                    for (var j = start; j <= end; ++j) {
                        ret[j] = 1;
                    }
                }
            });

            return ret;
        }

        var autoEscape = ["<", ">", "\"", "`", " ", "\r", "\n", "\t", "{", "}", "|", "\\", "^", "`", "'"];

        var autoEscapeMap = new Array(128);

        for (var i = 0, len = autoEscapeMap.length; i < len; ++i) {
            autoEscapeMap[i] = "";
        }

        for (var i = 0, len = autoEscape.length; i < len; ++i) {
            var c = autoEscape[i];
            var esc = encodeURIComponent(c);
            if (esc === c) {
                esc = escape(c);
            }
            autoEscapeMap[c.charCodeAt(0)] = esc;
        }
        var afterQueryAutoEscapeMap = autoEscapeMap.slice();
        autoEscapeMap[0x5C /*'\'*/] = "/";

        var slashProtocols = Url.prototype._slashProtocols = {
            http: true,
            https: true,
            gopher: true,
            file: true,
            ftp: true,

            "http:": true,
            "https:": true,
            "gopher:": true,
            "file:": true,
            "ftp:": true
        };

        //Optimize back from normalized object caused by non-identifier keys
        function f() {}
        f.prototype = slashProtocols;

        Url.prototype._protocolCharacters = makeAsciiTable([[0x61 /*'a'*/, 0x7A /*'z'*/], [0x41 /*'A'*/, 0x5A /*'Z'*/], 0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/
        ]);

        Url.prototype._hostEndingCharacters = makeAsciiTable([0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/, 0x5C /*'\'*/
        ]);

        Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function (v) {
            return v.charCodeAt(0);
        }));

        //If these characters end a host name, the path will not be prepended a /
        Url.prototype._noPrependSlashHostEnders = makeAsciiTable(["<", ">", "'", "`", " ", "\r", "\n", "\t", "{", "}", "|", "^", "`", "\"", "%", ";"].map(function (v) {
            return v.charCodeAt(0);
        }));

        Url.prototype._autoEscapeMap = autoEscapeMap;
        Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;

        module.exports = Url;

        Url.replace = function Url$Replace() {
            require.cache.url = {
                exports: Url
            };
        };
    }, { "punycode": 2, "querystring": 5 }], 2: [function (require, module, exports) {
        (function (global) {
            /*! https://mths.be/punycode v1.4.1 by @mathias */
            ;(function (root) {

                /** Detect free variables */
                var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
                var freeModule = typeof module == 'object' && module && !module.nodeType && module;
                var freeGlobal = typeof global == 'object' && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                    root = freeGlobal;
                }

                /**
                 * The `punycode` object.
                 * @name punycode
                 * @type Object
                 */
                var punycode,


                /** Highest positive signed 32-bit float value */
                maxInt = 2147483647,
                    // aka. 0x7FFFFFFF or 2^31-1

                /** Bootstring parameters */
                base = 36,
                    tMin = 1,
                    tMax = 26,
                    skew = 38,
                    damp = 700,
                    initialBias = 72,
                    initialN = 128,
                    // 0x80
                delimiter = '-',
                    // '\x2D'

                /** Regular expressions */
                regexPunycode = /^xn--/,
                    regexNonASCII = /[^\x20-\x7E]/,
                    // unprintable ASCII chars + non-ASCII chars
                regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
                    // RFC 3490 separators

                /** Error messages */
                errors = {
                    'overflow': 'Overflow: input needs wider integers to process',
                    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                    'invalid-input': 'Invalid input'
                },


                /** Convenience shortcuts */
                baseMinusTMin = base - tMin,
                    floor = Math.floor,
                    stringFromCharCode = String.fromCharCode,


                /** Temporary variable */
                key;

                /*--------------------------------------------------------------------------*/

                /**
                 * A generic error utility function.
                 * @private
                 * @param {String} type The error type.
                 * @returns {Error} Throws a `RangeError` with the applicable error message.
                 */
                function error(type) {
                    throw new RangeError(errors[type]);
                }

                /**
                 * A generic `Array#map` utility function.
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} callback The function that gets called for every array
                 * item.
                 * @returns {Array} A new array of values returned by the callback function.
                 */
                function map(array, fn) {
                    var length = array.length;
                    var result = [];
                    while (length--) {
                        result[length] = fn(array[length]);
                    }
                    return result;
                }

                /**
                 * A simple `Array#map`-like wrapper to work with domain name strings or email
                 * addresses.
                 * @private
                 * @param {String} domain The domain name or email address.
                 * @param {Function} callback The function that gets called for every
                 * character.
                 * @returns {Array} A new string of characters returned by the callback
                 * function.
                 */
                function mapDomain(string, fn) {
                    var parts = string.split('@');
                    var result = '';
                    if (parts.length > 1) {
                        // In email addresses, only the domain name should be punycoded. Leave
                        // the local part (i.e. everything up to `@`) intact.
                        result = parts[0] + '@';
                        string = parts[1];
                    }
                    // Avoid `split(regex)` for IE8 compatibility. See #17.
                    string = string.replace(regexSeparators, '\x2E');
                    var labels = string.split('.');
                    var encoded = map(labels, fn).join('.');
                    return result + encoded;
                }

                /**
                 * Creates an array containing the numeric code points of each Unicode
                 * character in the string. While JavaScript uses UCS-2 internally,
                 * this function will convert a pair of surrogate halves (each of which
                 * UCS-2 exposes as separate characters) into a single code point,
                 * matching UTF-16.
                 * @see `punycode.ucs2.encode`
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode.ucs2
                 * @name decode
                 * @param {String} string The Unicode input string (UCS-2).
                 * @returns {Array} The new array of code points.
                 */
                function ucs2decode(string) {
                    var output = [],
                        counter = 0,
                        length = string.length,
                        value,
                        extra;
                    while (counter < length) {
                        value = string.charCodeAt(counter++);
                        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                            // high surrogate, and there is a next character
                            extra = string.charCodeAt(counter++);
                            if ((extra & 0xFC00) == 0xDC00) {
                                // low surrogate
                                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                            } else {
                                // unmatched surrogate; only append this code unit, in case the next
                                // code unit is the high surrogate of a surrogate pair
                                output.push(value);
                                counter--;
                            }
                        } else {
                            output.push(value);
                        }
                    }
                    return output;
                }

                /**
                 * Creates a string based on an array of numeric code points.
                 * @see `punycode.ucs2.decode`
                 * @memberOf punycode.ucs2
                 * @name encode
                 * @param {Array} codePoints The array of numeric code points.
                 * @returns {String} The new Unicode string (UCS-2).
                 */
                function ucs2encode(array) {
                    return map(array, function (value) {
                        var output = '';
                        if (value > 0xFFFF) {
                            value -= 0x10000;
                            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                            value = 0xDC00 | value & 0x3FF;
                        }
                        output += stringFromCharCode(value);
                        return output;
                    }).join('');
                }

                /**
                 * Converts a basic code point into a digit/integer.
                 * @see `digitToBasic()`
                 * @private
                 * @param {Number} codePoint The basic numeric code point value.
                 * @returns {Number} The numeric value of a basic code point (for use in
                 * representing integers) in the range `0` to `base - 1`, or `base` if
                 * the code point does not represent a value.
                 */
                function basicToDigit(codePoint) {
                    if (codePoint - 48 < 10) {
                        return codePoint - 22;
                    }
                    if (codePoint - 65 < 26) {
                        return codePoint - 65;
                    }
                    if (codePoint - 97 < 26) {
                        return codePoint - 97;
                    }
                    return base;
                }

                /**
                 * Converts a digit/integer into a basic code point.
                 * @see `basicToDigit()`
                 * @private
                 * @param {Number} digit The numeric value of a basic code point.
                 * @returns {Number} The basic code point whose value (when used for
                 * representing integers) is `digit`, which needs to be in the range
                 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                 * used; else, the lowercase form is used. The behavior is undefined
                 * if `flag` is non-zero and `digit` has no uppercase form.
                 */
                function digitToBasic(digit, flag) {
                    //  0..25 map to ASCII a..z or A..Z
                    // 26..35 map to ASCII 0..9
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }

                /**
                 * Bias adaptation function as per section 3.4 of RFC 3492.
                 * https://tools.ietf.org/html/rfc3492#section-3.4
                 * @private
                 */
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                        delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }

                /**
                 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                 * symbols.
                 * @memberOf punycode
                 * @param {String} input The Punycode string of ASCII-only symbols.
                 * @returns {String} The resulting string of Unicode symbols.
                 */
                function decode(input) {
                    // Don't use UCS-2
                    var output = [],
                        inputLength = input.length,
                        out,
                        i = 0,
                        n = initialN,
                        bias = initialBias,
                        basic,
                        j,
                        index,
                        oldi,
                        w,
                        k,
                        digit,
                        t,

                    /** Cached calculation results */
                    baseMinusT;

                    // Handle the basic code points: let `basic` be the number of input code
                    // points before the last delimiter, or `0` if there is none, then copy
                    // the first basic code points to the output.

                    basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                        basic = 0;
                    }

                    for (j = 0; j < basic; ++j) {
                        // if it's not a basic code point
                        if (input.charCodeAt(j) >= 0x80) {
                            error('not-basic');
                        }
                        output.push(input.charCodeAt(j));
                    }

                    // Main decoding loop: start just after the last delimiter if any basic code
                    // points were copied; start at the beginning otherwise.

                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                        // `index` is the index of the next character to be consumed.
                        // Decode a generalized variable-length integer into `delta`,
                        // which gets added to `i`. The overflow checking is easier
                        // if we increase `i` as we go, then subtract off its starting
                        // value at the end to obtain `delta`.
                        for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                            if (index >= inputLength) {
                                error('invalid-input');
                            }

                            digit = basicToDigit(input.charCodeAt(index++));

                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                error('overflow');
                            }

                            i += digit * w;
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                            if (digit < t) {
                                break;
                            }

                            baseMinusT = base - t;
                            if (w > floor(maxInt / baseMinusT)) {
                                error('overflow');
                            }

                            w *= baseMinusT;
                        }

                        out = output.length + 1;
                        bias = adapt(i - oldi, out, oldi == 0);

                        // `i` was supposed to wrap around from `out` to `0`,
                        // incrementing `n` each time, so we'll fix that now:
                        if (floor(i / out) > maxInt - n) {
                            error('overflow');
                        }

                        n += floor(i / out);
                        i %= out;

                        // Insert `n` at position `i` of the output
                        output.splice(i++, 0, n);
                    }

                    return ucs2encode(output);
                }

                /**
                 * Converts a string of Unicode symbols (e.g. a domain name label) to a
                 * Punycode string of ASCII-only symbols.
                 * @memberOf punycode
                 * @param {String} input The string of Unicode symbols.
                 * @returns {String} The resulting Punycode string of ASCII-only symbols.
                 */
                function encode(input) {
                    var n,
                        delta,
                        handledCPCount,
                        basicLength,
                        bias,
                        j,
                        m,
                        q,
                        k,
                        t,
                        currentValue,
                        output = [],

                    /** `inputLength` will hold the number of code points in `input`. */
                    inputLength,

                    /** Cached calculation results */
                    handledCPCountPlusOne,
                        baseMinusT,
                        qMinusT;

                    // Convert the input in UCS-2 to Unicode
                    input = ucs2decode(input);

                    // Cache the length
                    inputLength = input.length;

                    // Initialize the state
                    n = initialN;
                    delta = 0;
                    bias = initialBias;

                    // Handle the basic code points
                    for (j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue < 0x80) {
                            output.push(stringFromCharCode(currentValue));
                        }
                    }

                    handledCPCount = basicLength = output.length;

                    // `handledCPCount` is the number of code points that have been handled;
                    // `basicLength` is the number of basic code points.

                    // Finish the basic string - if it is not empty - with a delimiter
                    if (basicLength) {
                        output.push(delimiter);
                    }

                    // Main encoding loop:
                    while (handledCPCount < inputLength) {

                        // All non-basic code points < n have been handled already. Find the next
                        // larger one:
                        for (m = maxInt, j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue >= n && currentValue < m) {
                                m = currentValue;
                            }
                        }

                        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                        // but guard against overflow
                        handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                            error('overflow');
                        }

                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;

                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];

                            if (currentValue < n && ++delta > maxInt) {
                                error('overflow');
                            }

                            if (currentValue == n) {
                                // Represent delta as a generalized variable-length integer
                                for (q = delta, k = base;; /* no condition */k += base) {
                                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                    if (q < t) {
                                        break;
                                    }
                                    qMinusT = q - t;
                                    baseMinusT = base - t;
                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                    q = floor(qMinusT / baseMinusT);
                                }

                                output.push(stringFromCharCode(digitToBasic(q, 0)));
                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                delta = 0;
                                ++handledCPCount;
                            }
                        }

                        ++delta;
                        ++n;
                    }
                    return output.join('');
                }

                /**
                 * Converts a Punycode string representing a domain name or an email address
                 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                 * it doesn't matter if you call it on a string that has already been
                 * converted to Unicode.
                 * @memberOf punycode
                 * @param {String} input The Punycoded domain name or email address to
                 * convert to Unicode.
                 * @returns {String} The Unicode representation of the given Punycode
                 * string.
                 */
                function toUnicode(input) {
                    return mapDomain(input, function (string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                }

                /**
                 * Converts a Unicode string representing a domain name or an email address to
                 * Punycode. Only the non-ASCII parts of the domain name will be converted,
                 * i.e. it doesn't matter if you call it with a domain that's already in
                 * ASCII.
                 * @memberOf punycode
                 * @param {String} input The domain name or email address to convert, as a
                 * Unicode string.
                 * @returns {String} The Punycode representation of the given domain name or
                 * email address.
                 */
                function toASCII(input) {
                    return mapDomain(input, function (string) {
                        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
                    });
                }

                /*--------------------------------------------------------------------------*/

                /** Define the public API */
                punycode = {
                    /**
                     * A string representing the current Punycode.js version number.
                     * @memberOf punycode
                     * @type String
                     */
                    'version': '1.4.1',
                    /**
                     * An object of methods to convert from JavaScript's internal character
                     * representation (UCS-2) to Unicode code points, and back.
                     * @see <https://mathiasbynens.be/notes/javascript-encoding>
                     * @memberOf punycode
                     * @type Object
                     */
                    'ucs2': {
                        'decode': ucs2decode,
                        'encode': ucs2encode
                    },
                    'decode': decode,
                    'encode': encode,
                    'toASCII': toASCII,
                    'toUnicode': toUnicode
                };

                /** Expose `punycode` */
                // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                    define('punycode', function () {
                        return punycode;
                    });
                } else if (freeExports && freeModule) {
                    if (module.exports == freeExports) {
                        // in Node.js, io.js, or RingoJS v0.8.0+
                        freeModule.exports = punycode;
                    } else {
                        // in Narwhal or RingoJS v0.7.0-
                        for (key in punycode) {
                            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                        }
                    }
                } else {
                    // in Rhino or a web browser
                    root.punycode = punycode;
                }
            })(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 3: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        'use strict';

        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }

        module.exports = function (qs, sep, eq, options) {
            sep = sep || '&';
            eq = eq || '=';
            var obj = {};

            if (typeof qs !== 'string' || qs.length === 0) {
                return obj;
            }

            var regexp = /\+/g;
            qs = qs.split(sep);

            var maxKeys = 1000;
            if (options && typeof options.maxKeys === 'number') {
                maxKeys = options.maxKeys;
            }

            var len = qs.length;
            // maxKeys <= 0 means that we should not limit keys count
            if (maxKeys > 0 && len > maxKeys) {
                len = maxKeys;
            }

            for (var i = 0; i < len; ++i) {
                var x = qs[i].replace(regexp, '%20'),
                    idx = x.indexOf(eq),
                    kstr,
                    vstr,
                    k,
                    v;

                if (idx >= 0) {
                    kstr = x.substr(0, idx);
                    vstr = x.substr(idx + 1);
                } else {
                    kstr = x;
                    vstr = '';
                }

                k = decodeURIComponent(kstr);
                v = decodeURIComponent(vstr);

                if (!hasOwnProperty(obj, k)) {
                    obj[k] = v;
                } else if (isArray(obj[k])) {
                    obj[k].push(v);
                } else {
                    obj[k] = [obj[k], v];
                }
            }

            return obj;
        };

        var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
        };
    }, {}], 4: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        'use strict';

        var stringifyPrimitive = function (v) {
            switch (typeof v) {
                case 'string':
                    return v;

                case 'boolean':
                    return v ? 'true' : 'false';

                case 'number':
                    return isFinite(v) ? v : '';

                default:
                    return '';
            }
        };

        module.exports = function (obj, sep, eq, name) {
            sep = sep || '&';
            eq = eq || '=';
            if (obj === null) {
                obj = undefined;
            }

            if (typeof obj === 'object') {
                return map(objectKeys(obj), function (k) {
                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                    if (isArray(obj[k])) {
                        return map(obj[k], function (v) {
                            return ks + encodeURIComponent(stringifyPrimitive(v));
                        }).join(sep);
                    } else {
                        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                    }
                }).join(sep);
            }

            if (!name) return '';
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };

        var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
        };

        function map(xs, f) {
            if (xs.map) return xs.map(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
                res.push(f(xs[i], i));
            }
            return res;
        }

        var objectKeys = Object.keys || function (obj) {
            var res = [];
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
        };
    }, {}], 5: [function (require, module, exports) {
        'use strict';

        exports.decode = exports.parse = require('./decode');
        exports.encode = exports.stringify = require('./encode');
    }, { "./decode": 3, "./encode": 4 }], 6: [function (require, module, exports) {
        $__System.register("1c", [], function (_export) {
            "use strict";

            _export('default', require('fast-url-parser'));

            return {
                setters: [],
                execute: function () {}
            };
        });
    }, { "fast-url-parser": 1 }] }, {}, [6]);
(function e(t, n, r) {
	function s(o, u) {
		if (!n[o]) {
			if (!t[o]) {
				var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
			}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
				var n = t[o][1][e];return s(n ? n : e);
			}, l, l.exports, e, t, n, r);
		}return n[o].exports;
	}var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;
})({ 1: [function (require, module, exports) {
		//     JavaScript Expression Parser (JSEP) 0.3.0
		//     JSEP may be freely distributed under the MIT License
		//     http://jsep.from.so/

		/*global module: true, exports: true, console: true */
		(function (root) {
			'use strict';
			// Node Types
			// ----------

			// This is the full set of types that any JSEP node can be.
			// Store them here to save space when minified

			var COMPOUND = 'Compound',
			    IDENTIFIER = 'Identifier',
			    MEMBER_EXP = 'MemberExpression',
			    LITERAL = 'Literal',
			    THIS_EXP = 'ThisExpression',
			    CALL_EXP = 'CallExpression',
			    UNARY_EXP = 'UnaryExpression',
			    BINARY_EXP = 'BinaryExpression',
			    LOGICAL_EXP = 'LogicalExpression',
			    CONDITIONAL_EXP = 'ConditionalExpression',
			    ARRAY_EXP = 'ArrayExpression',
			    PERIOD_CODE = 46,
			    // '.'
			COMMA_CODE = 44,
			    // ','
			SQUOTE_CODE = 39,
			    // single quote
			DQUOTE_CODE = 34,
			    // double quotes
			OPAREN_CODE = 40,
			    // (
			CPAREN_CODE = 41,
			    // )
			OBRACK_CODE = 91,
			    // [
			CBRACK_CODE = 93,
			    // ]
			QUMARK_CODE = 63,
			    // ?
			SEMCOL_CODE = 59,
			    // ;
			COLON_CODE = 58,
			    // :

			throwError = function (message, index) {
				var error = new Error(message + ' at character ' + index);
				error.index = index;
				error.description = message;
				throw error;
			},


			// Operations
			// ----------

			// Set `t` to `true` to save space (when minified, not gzipped)
			t = true,

			// Use a quickly-accessible map to store all of the unary operators
			// Values are set to `true` (it really doesn't matter)
			unary_ops = { '-': t, '!': t, '~': t, '+': t },

			// Also use a map for the binary operations but set their values to their
			// binary precedence for quick reference:
			// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
			binary_ops = {
				'||': 1, '&&': 2, '|': 3, '^': 4, '&': 5,
				'==': 6, '!=': 6, '===': 6, '!==': 6,
				'<': 7, '>': 7, '<=': 7, '>=': 7,
				'<<': 8, '>>': 8, '>>>': 8,
				'+': 9, '-': 9,
				'*': 10, '/': 10, '%': 10
			},

			// Get return the longest key length of any object
			getMaxKeyLen = function (obj) {
				var max_len = 0,
				    len;
				for (var key in obj) {
					if ((len = key.length) > max_len && obj.hasOwnProperty(key)) {
						max_len = len;
					}
				}
				return max_len;
			},
			    max_unop_len = getMaxKeyLen(unary_ops),
			    max_binop_len = getMaxKeyLen(binary_ops),

			// Literals
			// ----------
			// Store the values to return for the various literals we may encounter
			literals = {
				'true': true,
				'false': false,
				'null': null
			},

			// Except for `this`, which is special. This could be changed to something like `'self'` as well
			this_str = 'this',

			// Returns the precedence of a binary operator or `0` if it isn't a binary operator
			binaryPrecedence = function (op_val) {
				return binary_ops[op_val] || 0;
			},

			// Utility function (gets called from multiple places)
			// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
			createBinaryExpression = function (operator, left, right) {
				var type = operator === '||' || operator === '&&' ? LOGICAL_EXP : BINARY_EXP;
				return {
					type: type,
					operator: operator,
					left: left,
					right: right
				};
			},

			// `ch` is a character code in the next three functions
			isDecimalDigit = function (ch) {
				return ch >= 48 && ch <= 57; // 0...9
			},
			    isIdentifierStart = function (ch) {
				return ch === 36 || ch === 95 || // `$` and `_`
				ch >= 65 && ch <= 90 || // A...Z
				ch >= 97 && ch <= 122; // a...z
			},
			    isIdentifierPart = function (ch) {
				return ch === 36 || ch === 95 || // `$` and `_`
				ch >= 65 && ch <= 90 || // A...Z
				ch >= 97 && ch <= 122 || // a...z
				ch >= 48 && ch <= 57; // 0...9
			},


			// Parsing
			// -------
			// `expr` is a string with the passed in expression
			jsep = function (expr) {
				// `index` stores the character number we are currently at while `length` is a constant
				// All of the gobbles below will modify `index` as we move along
				var index = 0,
				    charAtFunc = expr.charAt,
				    charCodeAtFunc = expr.charCodeAt,
				    exprI = function (i) {
					return charAtFunc.call(expr, i);
				},
				    exprICode = function (i) {
					return charCodeAtFunc.call(expr, i);
				},
				    length = expr.length,


				// Push `index` up to the next non-space character
				gobbleSpaces = function () {
					var ch = exprICode(index);
					// space or tab
					while (ch === 32 || ch === 9) {
						ch = exprICode(++index);
					}
				},


				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function () {
					var test = gobbleBinaryExpression(),
					    consequent,
					    alternate;
					gobbleSpaces();
					if (exprICode(index) === QUMARK_CODE) {
						// Ternary expression: test ? consequent : alternate
						index++;
						consequent = gobbleExpression();
						if (!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if (exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if (!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},


				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function () {
					gobbleSpaces();
					var biop,
					    to_check = expr.substr(index, max_binop_len),
					    tc_len = to_check.length;
					while (tc_len > 0) {
						if (binary_ops.hasOwnProperty(to_check)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},


				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function () {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if (!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop) };

					right = gobbleToken();
					if (!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while (biop = gobbleBinaryOp()) {
						prec = binaryPrecedence(biop);

						if (prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						// Reduce: make a binary expression from the three topmost entries.
						while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if (!node) {
							throwError("Expected expression after " + biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while (i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);
						i -= 2;
					}
					return node;
				},


				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function () {
					var ch, to_check, tc_len;

					gobbleSpaces();
					ch = exprICode(index);

					if (isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if (isIdentifierStart(ch) || ch === OPAREN_CODE) {
						// open parenthesis
						// `foo`, `bar.baz`
						return gobbleVariable();
					} else if (ch === OBRACK_CODE) {
						return gobbleArray();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while (tc_len > 0) {
							if (unary_ops.hasOwnProperty(to_check)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}

						return false;
					}
				},

				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function () {
					var number = '',
					    ch,
					    chCode;
					while (isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if (exprICode(index) === PERIOD_CODE) {
						// can start with a decimal marker
						number += exprI(index++);

						while (isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}

					ch = exprI(index);
					if (ch === 'e' || ch === 'E') {
						// exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if (ch === '+' || ch === '-') {
							// exponent sign
							number += exprI(index++);
						}
						while (isDecimalDigit(exprICode(index))) {
							//exponent itself
							number += exprI(index++);
						}
						if (!isDecimalDigit(exprICode(index - 1))) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}

					chCode = exprICode(index);
					// Check to make sure this isn't a variable name that start with a number (123abc)
					if (isIdentifierStart(chCode)) {
						throwError('Variable names cannot start with a number (' + number + exprI(index) + ')', index);
					} else if (chCode === PERIOD_CODE) {
						throwError('Unexpected period', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},


				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function () {
					var str = '',
					    quote = exprI(index++),
					    closed = false,
					    ch;

					while (index < length) {
						ch = exprI(index++);
						if (ch === quote) {
							closed = true;
							break;
						} else if (ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch (ch) {
								case 'n':
									str += '\n';break;
								case 'r':
									str += '\r';break;
								case 't':
									str += '\t';break;
								case 'b':
									str += '\b';break;
								case 'f':
									str += '\f';break;
								case 'v':
									str += '\x0B';break;
							}
						} else {
							str += ch;
						}
					}

					if (!closed) {
						throwError('Unclosed quote after "' + str + '"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},


				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function () {
					var ch = exprICode(index),
					    start = index,
					    identifier;

					if (isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while (index < length) {
						ch = exprICode(index);
						if (isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if (literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if (identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},


				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function (termination) {
					var ch_i,
					    args = [],
					    node;
					while (index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if (ch_i === termination) {
							// done parsing
							index++;
							break;
						} else if (ch_i === COMMA_CODE) {
							// between expressions
							index++;
						} else {
							node = gobbleExpression();
							if (!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					return args;
				},


				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function () {
					var ch_i, node;
					ch_i = exprICode(index);

					if (ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while (ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if (ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if (ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if (ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if (ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},


				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function () {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if (exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},


				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function () {
					index++;
					return {
						type: ARRAY_EXP,
						elements: gobbleArguments(CBRACK_CODE)
					};
				},
				    nodes = [],
				    ch_i,
				    node;

				while (index < length) {
					ch_i = exprICode(index);

					// Expressions can be separated by semicolons, commas, or just inferred without any
					// separators
					if (ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
						index++; // ignore separators
					} else {
						// Try to gobble each expression individually
						if (node = gobbleExpression()) {
							nodes.push(node);
							// If we weren't able to find a binary expression and are out of room, then
							// the expression passed in probably has too much
						} else if (index < length) {
							throwError('Unexpected "' + exprI(index) + '"', index);
						}
					}
				}

				// If there's only one expression just try returning the expression
				if (nodes.length === 1) {
					return nodes[0];
				} else {
					return {
						type: COMPOUND,
						body: nodes
					};
				}
			};

			// To be filled in by the template
			jsep.version = '0.3.0';
			jsep.toString = function () {
				return 'JavaScript Expression Parser (JSEP) v' + jsep.version;
			};

			/**
    * @method jsep.addUnaryOp
    * @param {string} op_name The name of the unary op to add
    * @return jsep
    */
			jsep.addUnaryOp = function (op_name) {
				unary_ops[op_name] = t;return this;
			};

			/**
    * @method jsep.addBinaryOp
    * @param {string} op_name The name of the binary op to add
    * @param {number} precedence The precedence of the binary op (can be a float)
    * @return jsep
    */
			jsep.addBinaryOp = function (op_name, precedence) {
				max_binop_len = Math.max(op_name.length, max_binop_len);
				binary_ops[op_name] = precedence;
				return this;
			};

			/**
    * @method jsep.removeUnaryOp
    * @param {string} op_name The name of the unary op to remove
    * @return jsep
    */
			jsep.removeUnaryOp = function (op_name) {
				delete unary_ops[op_name];
				if (op_name.length === max_unop_len) {
					max_unop_len = getMaxKeyLen(unary_ops);
				}
				return this;
			};

			/**
    * @method jsep.removeBinaryOp
    * @param {string} op_name The name of the binary op to remove
    * @return jsep
    */
			jsep.removeBinaryOp = function (op_name) {
				delete binary_ops[op_name];
				if (op_name.length === max_binop_len) {
					max_binop_len = getMaxKeyLen(binary_ops);
				}
				return this;
			};

			// In desktop environments, have a way to restore the old value for `jsep`
			if (typeof exports === 'undefined') {
				var old_jsep = root.jsep;
				// The star of the show! It's a function!
				root.jsep = jsep;
				// And a courteous function willing to move out of the way for other similarly-named objects!
				jsep.noConflict = function () {
					if (root.jsep === jsep) {
						root.jsep = old_jsep;
					}
					return jsep;
				};
			} else {
				// In Node.JS environments
				if (typeof module !== 'undefined' && module.exports) {
					exports = module.exports = jsep;
				} else {
					exports.parse = jsep;
				}
			}
		})(this);
	}, {}], 2: [function (require, module, exports) {
		$__System.register("1d", [], function (_export) {
			"use strict";

			_export("default", require('jsep'));

			return {
				setters: [],
				execute: function () {}
			};
		});
	}, { "jsep": 1 }] }, {}, [2]);
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;
})({ 1: [function (require, module, exports) {
    'use strict';

    var KEYWORDS = ['multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum', 'maxLength', 'minLength', 'pattern', 'additionalItems', 'maxItems', 'minItems', 'uniqueItems', 'maxProperties', 'minProperties', 'required', 'additionalProperties', 'enum', 'format', 'const'];

    module.exports = function (metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split('/');
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++) keywords = keywords[segments[j]];

        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [schema, { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#' }]
            };
          }
        }
      }

      return metaSchema;
    };
  }, {}], 2: [function (require, module, exports) {
    'use strict';

    var compileSchema = require('./compile'),
        resolve = require('./compile/resolve'),
        Cache = require('./cache'),
        SchemaObject = require('./compile/schema_obj'),
        stableStringify = require('fast-json-stable-stringify'),
        formats = require('./compile/formats'),
        rules = require('./compile/rules'),
        $dataMetaSchema = require('./$data'),
        patternGroups = require('./patternGroups'),
        util = require('./compile/util'),
        co = require('co');

    module.exports = Ajv;

    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;

    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;

    Ajv.prototype.compileAsync = require('./compile/async');
    var customKeyword = require('./keyword');
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;

    var errorClasses = require('./compile/error_classes');
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;

    var META_SCHEMA_ID = 'http://json-schema.org/draft-06/schema';

    var META_IGNORE_OPTIONS = ['removeAdditional', 'useDefaults', 'coerceTypes'];
    var META_SUPPORT_DATA = ['/properties'];

    /**
     * Creates validator instance.
     * Usage: `Ajv(opts)`
     * @param {Object} opts optional options
     * @return {Object} ajv instance
     */
    function Ajv(opts) {
      if (!(this instanceof Ajv)) return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      var schemaUriFormat = this._schemaUriFormat = this._formats['uri-reference'];
      this._schemaUriFormatFunc = function (str) {
        return schemaUriFormat.test(str);
      };

      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);

      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
      if (opts.serialize === undefined) opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);

      if (opts.formats) addInitialFormats(this);
      addDraft6MetaSchema(this);
      if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
      addInitialSchemas(this);
      if (opts.patternGroups) patternGroups(this);
    }

    /**
     * Validate data using schema
     * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
     * @this   Ajv
     * @param  {String|Object} schemaKeyRef key, ref or schema object
     * @param  {Any} data to be validated
     * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
     */
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == 'string') {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }

      var valid = v(data);
      if (v.$async === true) return this._opts.async == '*' ? co(valid) : valid;
      this.errors = v.errors;
      return valid;
    }

    /**
     * Create validating function for passed schema.
     * @this   Ajv
     * @param  {Object} schema schema object
     * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
     * @return {Function} validating function
     */
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, undefined, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }

    /**
     * Adds schema to the instance.
     * @this   Ajv
     * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
     * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
     * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
     * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
     * @return {Ajv} this for method chaining
     */
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== undefined && typeof id != 'string') throw new Error('schema id must be string');
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }

    /**
     * Add schema that will be used to validate other schemas
     * options in META_IGNORE_OPTIONS are alway set to false
     * @this   Ajv
     * @param {Object} schema schema object
     * @param {String} key optional schema key
     * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
     * @return {Ajv} this for method chaining
     */
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }

    /**
     * Validate schema
     * @this   Ajv
     * @param {Object} schema schema to validate
     * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
     * @return {Boolean} true if schema is valid
     */
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != 'string') throw new Error('$schema must be a string');
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn('meta-schema not available');
        this.errors = null;
        return true;
      }
      var currentUriFormat = this._formats.uri;
      this._formats.uri = typeof currentUriFormat == 'function' ? this._schemaUriFormatFunc : this._schemaUriFormat;
      var valid;
      try {
        valid = this.validate($schema, schema);
      } finally {
        this._formats.uri = currentUriFormat;
      }
      if (!valid && throwOrLogError) {
        var message = 'schema is invalid: ' + this.errorsText();
        if (this._opts.validateSchema == 'log') this.logger.error(message);else throw new Error(message);
      }
      return valid;
    }

    function defaultMeta(self) {
      var meta = self._opts.meta;
      self._opts.defaultMeta = typeof meta == 'object' ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined;
      return self._opts.defaultMeta;
    }

    /**
     * Get compiled schema from the instance by `key` or `ref`.
     * @this   Ajv
     * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
     * @return {Function} schema validating function (with property `schema`).
     */
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case 'object':
          return schemaObj.validate || this._compile(schemaObj);
        case 'string':
          return this.getSchema(schemaObj);
        case 'undefined':
          return _getSchemaFragment(this, keyRef);
      }
    }

    function _getSchemaFragment(self, ref) {
      var res = resolve.schema.call(self, { schema: {} }, ref);
      if (res) {
        var schema = res.schema,
            root = res.root,
            baseId = res.baseId;
        var v = compileSchema.call(self, schema, root, undefined, baseId);
        self._fragments[ref] = new SchemaObject({
          ref: ref,
          fragment: true,
          schema: schema,
          root: root,
          baseId: baseId,
          validate: v
        });
        return v;
      }
    }

    function _getSchemaObj(self, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
    }

    /**
     * Remove cached schema(s).
     * If no parameter is passed all schemas but meta-schemas are removed.
     * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
     * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
     * @this   Ajv
     * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
     * @return {Ajv} this for method chaining
     */
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case 'undefined':
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case 'string':
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj) this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case 'object':
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }

    function _removeAllSchemas(self, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }

    /* @this   Ajv */
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != 'object' && typeof schema != 'boolean') throw new Error('schema should be object or boolean');
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached) return cached;

      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema) checkUnique(this, id);

      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema))) this.validateSchema(schema, true);

      var localRefs = resolve.ids.call(this, schema);

      var schemaObj = new SchemaObject({
        id: id,
        schema: schema,
        localRefs: localRefs,
        cacheKey: cacheKey,
        meta: meta
      });

      if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);

      if (willValidate && recursiveMeta) this.validateSchema(schema, true);

      return schemaObj;
    }

    /* @this   Ajv */
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true) callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;

      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }

      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta) this._opts = currentOpts;
      }

      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;

      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(null, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }

    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case '$id':
          return _get$Id;
        case 'id':
          return _getId;
        default:
          return _get$IdOrId;
      }
    }

    /* @this   Ajv */
    function _getId(schema) {
      if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
      return schema.id;
    }

    /* @this   Ajv */
    function _get$Id(schema) {
      if (schema.id) this.logger.warn('schema id ignored', schema.id);
      return schema.$id;
    }

    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id) throw new Error('schema $id is different from id');
      return schema.$id || schema.id;
    }

    /**
     * Convert array of error message objects to string
     * @this   Ajv
     * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
     * @param  {Object} options optional options with properties `separator` and `dataVar`.
     * @return {String} human readable string with all errors descriptions
     */
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors) return 'No errors';
      options = options || {};
      var separator = options.separator === undefined ? ', ' : options.separator;
      var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

      var text = '';
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }

    /**
     * Add custom format
     * @this   Ajv
     * @param {String} name format name
     * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
     * @return {Ajv} this for method chaining
     */
    function addFormat(name, format) {
      if (typeof format == 'string') format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }

    function addDraft6MetaSchema(self) {
      var $dataSchema;
      if (self._opts.$data) {
        $dataSchema = require('./refs/$data.json');
        self.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self._opts.meta === false) return;
      var metaSchema = require('./refs/json-schema-draft-06.json');
      if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
    }

    function addInitialSchemas(self) {
      var optsSchemas = self._opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
    }

    function addInitialFormats(self) {
      for (var name in self._opts.formats) {
        var format = self._opts.formats[name];
        self.addFormat(name, format);
      }
    }

    function checkUnique(self, id) {
      if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id "' + id + '" already exists');
    }

    function getMetaSchemaOptions(self) {
      var metaOpts = util.copy(self._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++) delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }

    function setLogger(self) {
      var logger = self._opts.logger;
      if (logger === false) {
        self.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === undefined) logger = console;
        if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error)) throw new Error('logger must implement log, warn and error methods');
        self.logger = logger;
      }
    }

    function noop() {}
  }, { "./$data": 1, "./cache": 3, "./compile": 8, "./compile/async": 5, "./compile/error_classes": 6, "./compile/formats": 7, "./compile/resolve": 9, "./compile/rules": 10, "./compile/schema_obj": 11, "./compile/util": 13, "./keyword": 37, "./patternGroups": 38, "./refs/$data.json": 39, "./refs/json-schema-draft-06.json": 40, "co": 44, "fast-json-stable-stringify": 45 }], 3: [function (require, module, exports) {
    'use strict';

    var Cache = module.exports = function Cache() {
      this._cache = {};
    };

    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };

    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };

    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };

    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }, {}], 4: [function (require, module, exports) {
    'use strict';

    //all requires must be explicit because browserify won't work with dynamic requires

    module.exports = {
      '$ref': require('../dotjs/ref'),
      allOf: require('../dotjs/allOf'),
      anyOf: require('../dotjs/anyOf'),
      const: require('../dotjs/const'),
      contains: require('../dotjs/contains'),
      dependencies: require('../dotjs/dependencies'),
      'enum': require('../dotjs/enum'),
      format: require('../dotjs/format'),
      items: require('../dotjs/items'),
      maximum: require('../dotjs/_limit'),
      minimum: require('../dotjs/_limit'),
      maxItems: require('../dotjs/_limitItems'),
      minItems: require('../dotjs/_limitItems'),
      maxLength: require('../dotjs/_limitLength'),
      minLength: require('../dotjs/_limitLength'),
      maxProperties: require('../dotjs/_limitProperties'),
      minProperties: require('../dotjs/_limitProperties'),
      multipleOf: require('../dotjs/multipleOf'),
      not: require('../dotjs/not'),
      oneOf: require('../dotjs/oneOf'),
      pattern: require('../dotjs/pattern'),
      properties: require('../dotjs/properties'),
      propertyNames: require('../dotjs/propertyNames'),
      required: require('../dotjs/required'),
      uniqueItems: require('../dotjs/uniqueItems'),
      validate: require('../dotjs/validate')
    };
  }, { "../dotjs/_limit": 14, "../dotjs/_limitItems": 15, "../dotjs/_limitLength": 16, "../dotjs/_limitProperties": 17, "../dotjs/allOf": 18, "../dotjs/anyOf": 19, "../dotjs/const": 20, "../dotjs/contains": 21, "../dotjs/dependencies": 23, "../dotjs/enum": 24, "../dotjs/format": 25, "../dotjs/items": 26, "../dotjs/multipleOf": 27, "../dotjs/not": 28, "../dotjs/oneOf": 29, "../dotjs/pattern": 30, "../dotjs/properties": 31, "../dotjs/propertyNames": 32, "../dotjs/ref": 33, "../dotjs/required": 34, "../dotjs/uniqueItems": 35, "../dotjs/validate": 36 }], 5: [function (require, module, exports) {
    'use strict';

    var MissingRefError = require('./error_classes').MissingRef;

    module.exports = compileAsync;

    /**
     * Creates validating function for passed schema with asynchronous loading of missing schemas.
     * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
     * @this  Ajv
     * @param {Object}   schema schema object
     * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
     * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
     * @return {Promise} promise that resolves with a validating function.
     */
    function compileAsync(schema, meta, callback) {
      /* eslint no-shadow: 0 */
      /* global Promise */
      /* jshint validthis: true */
      var self = this;
      if (typeof this._opts.loadSchema != 'function') throw new Error('options.loadSchema should be a function');

      if (typeof meta == 'function') {
        callback = meta;
        meta = undefined;
      }

      var p = loadMetaSchemaOf(schema).then(function () {
        var schemaObj = self._addSchema(schema, undefined, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });

      if (callback) {
        p.then(function (v) {
          callback(null, v);
        }, callback);
      }

      return p;

      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self.getSchema($schema) ? compileAsync.call(self, { $ref: $schema }, true) : Promise.resolve();
      }

      function _compileAsync(schemaObj) {
        try {
          return self._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError) return loadMissingSchema(e);
          throw e;
        }

        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

          var schemaPromise = self._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }

          return schemaPromise.then(function (sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function () {
                if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
              });
            }
          }).then(function () {
            return _compileAsync(schemaObj);
          });

          function removePromise() {
            delete self._loadingSchemas[ref];
          }

          function added(ref) {
            return self._refs[ref] || self._schemas[ref];
          }
        }
      }
    }
  }, { "./error_classes": 6 }], 6: [function (require, module, exports) {
    'use strict';

    var resolve = require('./resolve');

    module.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };

    function ValidationError(errors) {
      this.message = 'validation failed';
      this.errors = errors;
      this.ajv = this.validation = true;
    }

    MissingRefError.message = function (baseId, ref) {
      return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
    };

    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }

    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }, { "./resolve": 9 }], 7: [function (require, module, exports) {
    'use strict';

    var util = require('./util');

    var DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
    var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    // uri-template: https://tools.ietf.org/html/rfc6570
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    // @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
    // var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
    var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$|^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;

    module.exports = formats;

    function formats(mode) {
      mode = mode == 'full' ? 'full' : 'fast';
      return util.copy(formats[mode]);
    }

    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
      'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\/)\/?[^\s]*$/i,
      'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i,
      'uri-template': URITEMPLATE,
      url: URL,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex: regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      'json-pointer': JSON_POINTER,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      'relative-json-pointer': RELATIVE_JSON_POINTER
    };

    formats.full = {
      date: date,
      time: time,
      'date-time': date_time,
      uri: uri,
      'uri-reference': URIREF,
      'uri-template': URITEMPLATE,
      url: URL,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&''*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: hostname,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex: regex,
      uuid: UUID,
      'json-pointer': JSON_POINTER,
      'relative-json-pointer': RELATIVE_JSON_POINTER
    };

    function date(str) {
      // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
      var matches = str.match(DATE);
      if (!matches) return false;

      var month = +matches[1];
      var day = +matches[2];
      return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
    }

    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches) return false;

      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
    }

    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      // http://tools.ietf.org/html/rfc3339#section-5.6
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }

    function hostname(str) {
      // https://tools.ietf.org/html/rfc1034#section-3.5
      // https://tools.ietf.org/html/rfc1123#section-2
      return str.length <= 255 && HOSTNAME.test(str);
    }

    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }

    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str)) return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }, { "./util": 13 }], 8: [function (require, module, exports) {
    'use strict';

    var resolve = require('./resolve'),
        util = require('./util'),
        errorClasses = require('./error_classes'),
        stableStringify = require('fast-json-stable-stringify');

    var validateGenerator = require('../dotjs/validate');

    /**
     * Functions below are used inside compiled validations function
     */

    var co = require('co');
    var ucs2length = util.ucs2length;
    var equal = require('fast-deep-equal');

    // this error is thrown by async schemas to return validation errors via exception
    var ValidationError = errorClasses.Validation;

    module.exports = compile;

    /**
     * Compiles schema to validation function
     * @this   Ajv
     * @param  {Object} schema schema object
     * @param  {Object} root object with information about the root schema for this schema
     * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
     * @param  {String} baseId base ID for IDs in the schema
     * @return {Function} validation function
     */
    function compile(schema, root, localRefs, baseId) {
      /* jshint validthis: true, evil: true */
      /* eslint no-shadow: 0 */
      var self = this,
          opts = this._opts,
          refVal = [undefined],
          refs = {},
          patterns = [],
          patternsHash = {},
          defaults = [],
          defaultsHash = {},
          customRules = [];

      root = root || { schema: schema, refVal: refVal, refs: refs };

      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling) return compilation.callValidate = callValidate;

      var formats = this._formats;
      var RULES = this.RULES;

      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode) cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }

      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(null, arguments);
        callValidate.errors = validate.errors;
        return result;
      }

      function localCompile(_schema, _root, localRefs, baseId) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema) return compile.call(self, _schema, _root, localRefs, baseId);

        var $async = _schema.$async === true;

        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot: isRoot,
          baseId: baseId,
          root: _root,
          schemaPath: '',
          errSchemaPath: '#',
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES: RULES,
          validate: validateGenerator,
          util: util,
          resolve: resolve,
          resolveRef: resolveRef,
          usePattern: usePattern,
          useDefault: useDefault,
          useCustomRule: useCustomRule,
          opts: opts,
          formats: formats,
          logger: self.logger,
          self: self
        });

        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;

        if (opts.processCode) sourceCode = opts.processCode(sourceCode);
        // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
        var validate;
        try {
          var makeValidate = new Function('self', 'RULES', 'formats', 'root', 'refVal', 'defaults', 'customRules', 'co', 'equal', 'ucs2length', 'ValidationError', sourceCode);

          validate = makeValidate(self, RULES, formats, root, refVal, defaults, customRules, co, equal, ucs2length, ValidationError);

          refVal[0] = validate;
        } catch (e) {
          self.logger.error('Error compiling schema, function code:', sourceCode);
          throw e;
        }

        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async) validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns: patterns,
            defaults: defaults
          };
        }

        return validate;
      }

      function resolveRef(baseId, ref, isRoot) {
        ref = resolve.url(baseId, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== undefined) {
          _refVal = refVal[refIndex];
          refCode = 'refVal[' + refIndex + ']';
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== undefined) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }

        refCode = addLocalRef(ref);
        var v = resolve.call(self, localCompile, root, ref);
        if (v === undefined) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId);
          }
        }

        if (v === undefined) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v);
          return resolvedRef(v, refCode);
        }
      }

      function addLocalRef(ref, v) {
        var refId = refVal.length;
        refVal[refId] = v;
        refs[ref] = refId;
        return 'refVal' + refId;
      }

      function removeLocalRef(ref) {
        delete refs[ref];
      }

      function replaceLocalRef(ref, v) {
        var refId = refs[ref];
        refVal[refId] = v;
      }

      function resolvedRef(refVal, code) {
        return typeof refVal == 'object' || typeof refVal == 'boolean' ? { code: code, schema: refVal, inline: true } : { code: code, $async: refVal && refVal.$async };
      }

      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === undefined) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return 'pattern' + index;
      }

      function useDefault(value) {
        switch (typeof value) {
          case 'boolean':
          case 'number':
            return '' + value;
          case 'string':
            return util.toQuotedString(value);
          case 'object':
            if (value === null) return 'null';
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === undefined) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return 'default' + index;
        }
      }

      function useCustomRule(rule, schema, parentSchema, it) {
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema && self._opts.validateSchema !== false) {
          var valid = validateSchema(schema);
          if (!valid) {
            var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
            if (self._opts.validateSchema == 'log') self.logger.error(message);else throw new Error(message);
          }
        }

        var compile = rule.definition.compile,
            inline = rule.definition.inline,
            macro = rule.definition.macro;

        var validate;
        if (compile) {
          validate = compile.call(self, schema, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self, schema, parentSchema, it);
          if (opts.validateSchema !== false) self.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self, it, rule.keyword, schema, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate) return;
        }

        if (validate === undefined) throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

        var index = customRules.length;
        customRules[index] = validate;

        return {
          code: 'customRule' + index,
          validate: validate
        };
      }
    }

    /**
     * Checks if the schema is currently compiled
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
     */
    function checkCompiling(schema, root, baseId) {
      /* jshint validthis: true */
      var index = compIndex.call(this, schema, root, baseId);
      if (index >= 0) return { index: index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema: schema,
        root: root,
        baseId: baseId
      };
      return { index: index, compiling: false };
    }

    /**
     * Removes the schema from the currently compiled list
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     */
    function endCompiling(schema, root, baseId) {
      /* jshint validthis: true */
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0) this._compilations.splice(i, 1);
    }

    /**
     * Index of schema compilation in the currently compiled list
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     * @return {Integer} compilation index
     */
    function compIndex(schema, root, baseId) {
      /* jshint validthis: true */
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
      }
      return -1;
    }

    function patternCode(i, patterns) {
      return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
    }

    function defaultCode(i) {
      return 'var default' + i + ' = defaults[' + i + '];';
    }

    function refValCode(i, refVal) {
      return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
    }

    function customRuleCode(i) {
      return 'var customRule' + i + ' = customRules[' + i + '];';
    }

    function vars(arr, statement) {
      if (!arr.length) return '';
      var code = '';
      for (var i = 0; i < arr.length; i++) code += statement(i, arr);
      return code;
    }
  }, { "../dotjs/validate": 36, "./error_classes": 6, "./resolve": 9, "./util": 13, "co": 44, "fast-deep-equal": 41, "fast-json-stable-stringify": 45 }], 9: [function (require, module, exports) {
    'use strict';

    var url = require('url'),
        equal = require('fast-deep-equal'),
        util = require('./util'),
        SchemaObject = require('./schema_obj'),
        traverse = require('json-schema-traverse');

    module.exports = resolve;

    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;

    /**
     * [resolve and compile the references ($ref)]
     * @this   Ajv
     * @param  {Function} compile reference to schema compilation funciton (localCompile)
     * @param  {Object} root object with information about the root schema for the current schema
     * @param  {String} ref reference to resolve
     * @return {Object|Function} schema object (if the schema can be inlined) or validation function
     */
    function resolve(compile, root, ref) {
      /* jshint validthis: true */
      var refVal = this._refs[ref];
      if (typeof refVal == 'string') {
        if (this._refs[refVal]) refVal = this._refs[refVal];else return resolve.call(this, compile, root, refVal);
      }

      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }

      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }

      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
      } else if (schema !== undefined) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, undefined, baseId);
      }

      return v;
    }

    /**
     * Resolve schema, its root and baseId
     * @this Ajv
     * @param  {Object} root root object with properties schema, refVal, refs
     * @param  {String} ref  reference to resolve
     * @return {Object} object with properties schema, root, baseId
     */
    function resolveSchema(root, ref) {
      /* jshint validthis: true */
      var p = url.parse(ref, false, true),
          refPath = _getFullPath(p),
          baseId = getFullPath(this._getId(root.schema));
      if (refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == 'string') {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            if (id == normalizeId(ref)) return { schema: refVal, root: root, baseId: baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema) return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }

    /* @this Ajv */
    function resolveRecursive(root, ref, parsedRef) {
      /* jshint validthis: true */
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }

    var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
    /* @this Ajv */
    function getJsonPointer(parsedRef, baseId, schema, root) {
      /* jshint validthis: true */
      parsedRef.hash = parsedRef.hash || '';
      if (parsedRef.hash.slice(0, 2) != '#/') return;
      var parts = parsedRef.hash.split('/');

      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === undefined) break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id) baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== undefined && schema !== root.schema) return { schema: schema, root: root, baseId: baseId };
    }

    var SIMPLE_INLINED = util.toHash(['type', 'format', 'pattern', 'maxLength', 'minLength', 'maxProperties', 'minProperties', 'maxItems', 'minItems', 'maximum', 'minimum', 'uniqueItems', 'multipleOf', 'required', 'enum']);
    function inlineRef(schema, limit) {
      if (limit === false) return false;
      if (limit === undefined || limit === true) return checkNoRef(schema);else if (limit) return countKeys(schema) <= limit;
    }

    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == 'object' && !checkNoRef(item)) return false;
        }
      } else {
        for (var key in schema) {
          if (key == '$ref') return false;
          item = schema[key];
          if (typeof item == 'object' && !checkNoRef(item)) return false;
        }
      }
      return true;
    }

    function countKeys(schema) {
      var count = 0,
          item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == 'object') count += countKeys(item);
          if (count == Infinity) return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == '$ref') return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == 'object') count += countKeys(item) + 1;
            if (count == Infinity) return Infinity;
          }
        }
      }
      return count;
    }

    function getFullPath(id, normalize) {
      if (normalize !== false) id = normalizeId(id);
      var p = url.parse(id, false, true);
      return _getFullPath(p);
    }

    function _getFullPath(p) {
      var protocolSeparator = p.protocol || p.href.slice(0, 2) == '//' ? '//' : '';
      return (p.protocol || '') + protocolSeparator + (p.host || '') + (p.path || '') + '#';
    }

    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
    }

    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return url.resolve(baseId, id);
    }

    /* @this Ajv */
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { '': schemaId };
      var fullPaths = { '': getFullPath(schemaId, false) };
      var localRefs = {};
      var self = this;

      traverse(schema, { allKeys: true }, function (sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === '') return;
        var id = self._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
        if (keyIndex !== undefined) fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

        if (typeof id == 'string') {
          id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);

          var refVal = self._refs[id];
          if (typeof refVal == 'string') refVal = self._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema)) throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == '#') {
              if (localRefs[id] && !equal(sch, localRefs[id])) throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });

      return localRefs;
    }
  }, { "./schema_obj": 11, "./util": 13, "fast-deep-equal": 41, "json-schema-traverse": 46, "url": 42 }], 10: [function (require, module, exports) {
    'use strict';

    var ruleModules = require('./_rules'),
        toHash = require('./util').toHash;

    module.exports = function rules() {
      var RULES = [{ type: 'number',
        rules: [{ 'maximum': ['exclusiveMaximum'] }, { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] }, { type: 'string',
        rules: ['maxLength', 'minLength', 'pattern', 'format'] }, { type: 'array',
        rules: ['maxItems', 'minItems', 'uniqueItems', 'contains', 'items'] }, { type: 'object',
        rules: ['maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames', { 'properties': ['additionalProperties', 'patternProperties'] }] }, { rules: ['$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf'] }];

      var ALL = ['type'];
      var KEYWORDS = ['additionalItems', '$schema', '$id', 'id', 'title', 'description', 'default', 'definitions'];
      var TYPES = ['number', 'integer', 'string', 'array', 'object', 'boolean', 'null'];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);

      RULES.forEach(function (group) {
        group.rules = group.rules.map(function (keyword) {
          var implKeywords;
          if (typeof keyword == 'object') {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function (k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword: keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });

        if (group.type) RULES.types[group.type] = group;
      });

      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};

      return RULES;
    };
  }, { "./_rules": 4, "./util": 13 }], 11: [function (require, module, exports) {
    'use strict';

    var util = require('./util');

    module.exports = SchemaObject;

    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }, { "./util": 13 }], 12: [function (require, module, exports) {
    'use strict';

    // https://mathiasbynens.be/notes/javascript-encoding
    // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode

    module.exports = function ucs2length(str) {
      var length = 0,
          len = str.length,
          pos = 0,
          value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
          // high surrogate, and there is a next character
          value = str.charCodeAt(pos);
          if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
        }
      }
      return length;
    };
  }, {}], 13: [function (require, module, exports) {
    'use strict';

    module.exports = {
      copy: copy,
      checkDataType: checkDataType,
      checkDataTypes: checkDataTypes,
      coerceToTypes: coerceToTypes,
      toHash: toHash,
      getProperty: getProperty,
      escapeQuotes: escapeQuotes,
      equal: require('fast-deep-equal'),
      ucs2length: require('./ucs2length'),
      varOccurences: varOccurences,
      varReplace: varReplace,
      cleanUpCode: cleanUpCode,
      finalCleanUpCode: finalCleanUpCode,
      schemaHasRules: schemaHasRules,
      schemaHasRulesExcept: schemaHasRulesExcept,
      toQuotedString: toQuotedString,
      getPathExpr: getPathExpr,
      getPath: getPath,
      getData: getData,
      unescapeFragment: unescapeFragment,
      unescapeJsonPointer: unescapeJsonPointer,
      escapeFragment: escapeFragment,
      escapeJsonPointer: escapeJsonPointer
    };

    function copy(o, to) {
      to = to || {};
      for (var key in o) to[key] = o[key];
      return to;
    }

    function checkDataType(dataType, data, negate) {
      var EQUAL = negate ? ' !== ' : ' === ',
          AND = negate ? ' || ' : ' && ',
          OK = negate ? '!' : '',
          NOT = negate ? '' : '!';
      switch (dataType) {
        case 'null':
          return data + EQUAL + 'null';
        case 'array':
          return OK + 'Array.isArray(' + data + ')';
        case 'object':
          return '(' + OK + data + AND + 'typeof ' + data + EQUAL + '"object"' + AND + NOT + 'Array.isArray(' + data + '))';
        case 'integer':
          return '(typeof ' + data + EQUAL + '"number"' + AND + NOT + '(' + data + ' % 1)' + AND + data + EQUAL + data + ')';
        default:
          return 'typeof ' + data + EQUAL + '"' + dataType + '"';
      }
    }

    function checkDataTypes(dataTypes, data) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, true);
        default:
          var code = '';
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? '(' : '(!' + data + ' || ';
            code += 'typeof ' + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number) delete types.integer;
          for (var t in types) code += (code ? ' && ' : '') + checkDataType(t, data, true);

          return code;
      }
    }

    var COERCE_TO_TYPES = toHash(['string', 'number', 'integer', 'boolean', 'null']);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t]) types[types.length] = t;else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
        }
        if (types.length) return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
        return ['array'];
      }
    }

    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
      return hash;
    }

    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == 'number' ? '[' + key + ']' : IDENTIFIER.test(key) ? '.' + key : "['" + escapeQuotes(key) + "']";
    }

    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, '\\$&').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\f/g, '\\f').replace(/\t/g, '\\t');
    }

    function varOccurences(str, dataVar) {
      dataVar += '[^0-9]';
      var matches = str.match(new RegExp(dataVar, 'g'));
      return matches ? matches.length : 0;
    }

    function varReplace(str, dataVar, expr) {
      dataVar += '([^0-9])';
      expr = expr.replace(/\$/g, '$$$$');
      return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
    }

    var EMPTY_ELSE = /else\s*{\s*}/g,
        EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g,
        EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
    function cleanUpCode(out) {
      return out.replace(EMPTY_ELSE, '').replace(EMPTY_IF_NO_ELSE, '').replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
    }

    var ERRORS_REGEXP = /[^v.]errors/g,
        REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g,
        REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g,
        RETURN_VALID = 'return errors === 0;',
        RETURN_TRUE = 'validate.errors = null; return true;',
        RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/,
        RETURN_DATA_ASYNC = 'return data;',
        ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g,
        REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

    function finalCleanUpCode(out, async) {
      var matches = out.match(ERRORS_REGEXP);
      if (matches && matches.length == 2) {
        out = async ? out.replace(REMOVE_ERRORS_ASYNC, '').replace(RETURN_ASYNC, RETURN_DATA_ASYNC) : out.replace(REMOVE_ERRORS, '').replace(RETURN_VALID, RETURN_TRUE);
      }

      matches = out.match(ROOTDATA_REGEXP);
      if (!matches || matches.length !== 3) return out;
      return out.replace(REMOVE_ROOTDATA, '');
    }

    function schemaHasRules(schema, rules) {
      if (typeof schema == 'boolean') return !schema;
      for (var key in schema) if (rules[key]) return true;
    }

    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
      for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
    }

    function toQuotedString(str) {
      return '\'' + escapeQuotes(str) + '\'';
    }

    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers // false by default
      ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')') : isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'';
      return joinPaths(currentPath, path);
    }

    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers // false by default
      ? toQuotedString('/' + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }

    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === '') return 'rootData';
      if ($data[0] == '/') {
        if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
        jsonPointer = $data;
        data = 'rootData';
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == '#') {
          if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
          return paths[lvl - up];
        }

        if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
        data = 'data' + (lvl - up || '');
        if (!jsonPointer) return data;
      }

      var expr = data;
      var segments = jsonPointer.split('/');
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += ' && ' + data;
        }
      }
      return expr;
    }

    function joinPaths(a, b) {
      if (a == '""') return b;
      return (a + ' + ' + b).replace(/' \+ '/g, '');
    }

    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }

    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }

    function escapeJsonPointer(str) {
      return str.replace(/~/g, '~0').replace(/\//g, '~1');
    }

    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, '/').replace(/~0/g, '~');
    }
  }, { "./ucs2length": 12, "fast-deep-equal": 41 }], 14: [function (require, module, exports) {
    'use strict';

    module.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == 'maximum',
          $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
          $schemaExcl = it.schema[$exclusiveKeyword],
          $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
          $op = $isMax ? '<' : '>',
          $notOp = $isMax ? '>' : '<',
          $errorKeyword = undefined;
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
            $exclusive = 'exclusive' + $lvl,
            $exclType = 'exclType' + $lvl,
            $exclIsNumber = 'exclIsNumber' + $lvl,
            $opExpr = 'op' + $lvl,
            $opStr = '\' + ' + $opExpr + ' + \'';
        out += ' var schemaExcl' + $lvl + ' = ' + $schemaValueExcl + '; ';
        $schemaValueExcl = 'schemaExcl' + $lvl;
        out += ' var ' + $exclusive + '; var ' + $exclType + ' = typeof ' + $schemaValueExcl + '; if (' + $exclType + ' != \'boolean\' && ' + $exclType + ' != \'undefined\' && ' + $exclType + ' != \'number\') { ';
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'' + $exclusiveKeyword + ' should be boolean\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else if ( ';
        if ($isData) {
          out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
        }
        out += ' ' + $exclType + ' == \'number\' ? ( (' + $exclusive + ' = ' + $schemaValue + ' === undefined || ' + $schemaValueExcl + ' ' + $op + '= ' + $schemaValue + ') ? ' + $data + ' ' + $notOp + '= ' + $schemaValueExcl + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) : ( (' + $exclusive + ' = ' + $schemaValueExcl + ' === true) ? ' + $data + ' ' + $notOp + '= ' + $schemaValue + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' + $data + ' !== ' + $data + ') { var op' + $lvl + ' = ' + $exclusive + ' ? \'' + $op + '\' : \'' + $op + '=\';';
      } else {
        var $exclIsNumber = typeof $schemaExcl == 'number',
            $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = '\'' + $opStr + '\'';
          out += ' if ( ';
          if ($isData) {
            out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
          }
          out += ' ( ' + $schemaValue + ' === undefined || ' + $schemaExcl + ' ' + $op + '= ' + $schemaValue + ' ? ' + $data + ' ' + $notOp + '= ' + $schemaExcl + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' + $data + ' !== ' + $data + ') { ';
        } else {
          if ($exclIsNumber && $schema === undefined) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += '=';
          } else {
            if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
              $notOp += '=';
            } else {
              $exclusive = false;
              $opStr += '=';
            }
          }
          var $opExpr = '\'' + $opStr + '\'';
          out += ' if ( ';
          if ($isData) {
            out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
          }
          out += ' ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' || ' + $data + ' !== ' + $data + ') { ';
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { comparison: ' + $opExpr + ', limit: ' + $schemaValue + ', exclusive: ' + $exclusive + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be ' + $opStr + ' ';
          if ($isData) {
            out += '\' + ' + $schemaValue;
          } else {
            out += '' + $schemaValue + '\'';
          }
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 15: [function (require, module, exports) {
    'use strict';

    module.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == 'maxItems' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }
      out += ' ' + $data + '.length ' + $op + ' ' + $schemaValue + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have ';
          if ($keyword == 'maxItems') {
            out += 'more';
          } else {
            out += 'less';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + $schema;
          }
          out += ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 16: [function (require, module, exports) {
    'use strict';

    module.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == 'maxLength' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }
      if (it.opts.unicode === false) {
        out += ' ' + $data + '.length ';
      } else {
        out += ' ucs2length(' + $data + ') ';
      }
      out += ' ' + $op + ' ' + $schemaValue + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT be ';
          if ($keyword == 'maxLength') {
            out += 'longer';
          } else {
            out += 'shorter';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + $schema;
          }
          out += ' characters\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 17: [function (require, module, exports) {
    'use strict';

    module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == 'maxProperties' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }
      out += ' Object.keys(' + $data + ').length ' + $op + ' ' + $schemaValue + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have ';
          if ($keyword == 'maxProperties') {
            out += 'more';
          } else {
            out += 'less';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + $schema;
          }
          out += ' properties\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 18: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $currentBaseId = $it.baseId,
          $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch,
            $i = -1,
            l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + it.validate($it) + ' ';
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += ' if (' + $nextValid + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += ' if (true) { ';
        } else {
          out += ' ' + $closingBraces.slice(0, -1) + ' ';
        }
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 19: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $noEmptySchema = $schema.every(function ($sch) {
        return it.util.schemaHasRules($sch, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += ' var ' + $errs + ' = errors; var ' + $valid + ' = false;  ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch,
              $i = -1,
              l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + it.validate($it) + ' ';
            $it.baseId = $currentBaseId;
            out += ' ' + $valid + ' = ' + $valid + ' || ' + $nextValid + '; if (!' + $valid + ') { ';
            $closingBraces += '}';
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + $closingBraces + ' if (!' + $valid + ') {   var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'anyOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should match some schema in anyOf\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError(vErrors); ';
          } else {
            out += ' validate.errors = vErrors; return false; ';
          }
        }
        out += ' } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
        if (it.opts.allErrors) {
          out += ' } ';
        }
        out = it.util.cleanUpCode(out);
      } else {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      }
      return out;
    };
  }, {}], 20: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_const(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += ' var schema' + $lvl + ' = validate.schema' + $schemaPath + ';';
      }
      out += 'var ' + $valid + ' = equal(' + $data + ', schema' + $lvl + '); if (!' + $valid + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'const' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be equal to constant\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' }';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 21: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $idx = 'i' + $lvl,
          $dataNxt = $it.dataLevel = it.dataLevel + 1,
          $nextData = 'data' + $dataNxt,
          $currentBaseId = it.baseId,
          $nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
      out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += ' var ' + $nextValid + ' = false; for (var ' + $idx + ' = 0; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + '[' + $idx + ']';
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
        } else {
          out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
        }
        out += ' if (' + $nextValid + ') break; }  ';
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + $closingBraces + ' if (!' + $nextValid + ') {';
      } else {
        out += ' if (' + $data + '.length == 0) {';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'contains' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should contain a valid item\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } else { ';
      if ($nonEmptySchema) {
        out += '  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
      }
      if (it.opts.allErrors) {
        out += ' } ';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 22: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this,
          $definition = 'definition' + $lvl,
          $rDef = $rule.definition,
          $closingBraces = '';
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = 'keywordValidate' + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += ' var ' + $definition + ' = RULES.custom[\'' + $keyword + '\'].definition; var ' + $validateCode + ' = ' + $definition + '.validate;';
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate) return;
        $schemaValue = 'validate.schema' + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + '.errors',
          $i = 'i' + $lvl,
          $ruleErr = 'ruleErr' + $lvl,
          $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
      if (!($inline || $macro)) {
        out += '' + $ruleErrs + ' = null;';
      }
      out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
      if ($isData && $rDef.$data) {
        $closingBraces += '}';
        out += ' if (' + $schemaValue + ' === undefined) { ' + $valid + ' = true; } else { ';
        if ($validateSchema) {
          $closingBraces += '}';
          out += ' ' + $valid + ' = ' + $definition + '.validateSchema(' + $schemaValue + '); if (' + $valid + ') { ';
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += ' ' + $ruleValidate.validate + ' ';
        } else {
          out += ' ' + $valid + ' = ' + $ruleValidate.validate + '; ';
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = '';
        $it.level++;
        var $nextValid = 'valid' + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = '';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        out += '  ' + $validateCode + '.call( ';
        if (it.opts.passContext) {
          out += 'this';
        } else {
          out += 'self';
        }
        if ($compile || $rDef.schema === false) {
          out += ' , ' + $data + ' ';
        } else {
          out += ' , ' + $schemaValue + ' , ' + $data + ' , validate.schema' + it.schemaPath + ' ';
        }
        out += ' , (dataPath || \'\')';
        if (it.errorPath != '""') {
          out += ' + ' + it.errorPath;
        }
        var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
            $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' , ' + $parentData + ' , ' + $parentDataProperty + ' , rootData )  ';
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += ' ' + $valid + ' = ';
          if ($asyncKeyword) {
            out += '' + it.yieldAwait;
          }
          out += '' + def_callRuleValidate + '; ';
        } else {
          if ($asyncKeyword) {
            $ruleErrs = 'customErrors' + $lvl;
            out += ' var ' + $ruleErrs + ' = null; try { ' + $valid + ' = ' + it.yieldAwait + def_callRuleValidate + '; } catch (e) { ' + $valid + ' = false; if (e instanceof ValidationError) ' + $ruleErrs + ' = e.errors; else throw e; } ';
          } else {
            out += ' ' + $ruleErrs + ' = null; ' + $valid + ' = ' + def_callRuleValidate + '; ';
          }
        }
      }
      if ($rDef.modifying) {
        out += ' if (' + $parentData + ') ' + $data + ' = ' + $parentData + '[' + $parentDataProperty + '];';
      }
      out += '' + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        out += ' if ( ';
        if ($rDef.valid === undefined) {
          out += ' !';
          if ($macro) {
            out += '' + $nextValid;
          } else {
            out += '' + $valid;
          }
        } else {
          out += ' ' + !$rDef.valid + ' ';
        }
        out += ') { ';
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { keyword: \'' + $rule.keyword + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != 'full') {
              out += '  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + '; if (' + $ruleErr + '.schemaPath === undefined) { ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
              }
              out += ' } ';
            }
          } else {
            if ($rDef.errors === false) {
              out += ' ' + def_customError + ' ';
            } else {
              out += ' if (' + $errs + ' == errors) { ' + def_customError + ' } else {  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + '; if (' + $ruleErr + '.schemaPath === undefined) { ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
              }
              out += ' } } ';
            }
          }
        } else if ($macro) {
          out += '   var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { keyword: \'' + $rule.keyword + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError(vErrors); ';
            } else {
              out += ' validate.errors = vErrors; return false; ';
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += ' ' + def_customError + ' ';
          } else {
            out += ' if (Array.isArray(' + $ruleErrs + ')) { if (vErrors === null) vErrors = ' + $ruleErrs + '; else vErrors = vErrors.concat(' + $ruleErrs + '); errors = vErrors.length;  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + ';  ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
            }
            out += ' } } else { ' + def_customError + ' } ';
          }
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' else { ';
        }
      }
      return out;
    };
  }, {}], 23: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $schemaDeps = {},
          $propertyDeps = {},
          $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += 'var ' + $errs + ' = errors;';
      var $currentErrorPath = it.errorPath;
      out += 'var missing' + $lvl + ';';
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += ' if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
          if ($ownProperties) {
            out += ' && Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($property) + '\') ';
          }
          if ($breakOnError) {
            out += ' && ( ';
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey,
                  $i = -1,
                  l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += ' || ';
                }
                var $prop = it.util.getProperty($propertyKey),
                    $useData = $data + $prop;
                out += ' ( ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') && (missing' + $lvl + ' = ' + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
              }
            }
            out += ')) {  ';
            var $propertyPath = 'missing' + $lvl,
                $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'dependencies' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { property: \'' + it.util.escapeQuotes($property) + '\', missingProperty: \'' + $missingProperty + '\', depsCount: ' + $deps.length + ', deps: \'' + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + it.util.escapeQuotes($deps[0]);
                } else {
                  out += 'properties ' + it.util.escapeQuotes($deps.join(", "));
                }
                out += ' when property ' + it.util.escapeQuotes($property) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          } else {
            out += ' ) { ';
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey,
                  i2 = -1,
                  l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey),
                    $missingProperty = it.util.escapeQuotes($propertyKey),
                    $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += ' if ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') {  var err =   '; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + 'dependencies' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { property: \'' + it.util.escapeQuotes($property) + '\', missingProperty: \'' + $missingProperty + '\', depsCount: ' + $deps.length + ', deps: \'' + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'should have ';
                    if ($deps.length == 1) {
                      out += 'property ' + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += 'properties ' + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += ' when property ' + it.util.escapeQuotes($property) + ' is present\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
              }
            }
          }
          out += ' }   ';
          if ($breakOnError) {
            $closingBraces += '}';
            out += ' else { ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          out += ' ' + $nextValid + ' = true; if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
          if ($ownProperties) {
            out += ' && Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($property) + '\') ';
          }
          out += ') { ';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
          out += '  ' + it.validate($it) + ' ';
          $it.baseId = $currentBaseId;
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
      if ($breakOnError) {
        out += '   ' + $closingBraces + ' if (' + $errs + ' == errors) {';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 24: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = 'i' + $lvl,
          $vSchema = 'schema' + $lvl;
      if (!$isData) {
        out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + ';';
      }
      out += 'var ' + $valid + ';';
      if ($isData) {
        out += ' if (schema' + $lvl + ' === undefined) ' + $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' + $valid + ' = false; else {';
      }
      out += '' + $valid + ' = false;for (var ' + $i + '=0; ' + $i + '<' + $vSchema + '.length; ' + $i + '++) if (equal(' + $data + ', ' + $vSchema + '[' + $i + '])) { ' + $valid + ' = true; break; }';
      if ($isData) {
        out += '  }  ';
      }
      out += ' if (!' + $valid + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'enum' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { allowedValues: schema' + $lvl + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be equal to one of the allowed values\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' }';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 25: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_format(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats,
          $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = 'format' + $lvl,
            $isObject = 'isObject' + $lvl,
            $formatType = 'formatType' + $lvl;
        out += ' var ' + $format + ' = formats[' + $schemaValue + ']; var ' + $isObject + ' = typeof ' + $format + ' == \'object\' && !(' + $format + ' instanceof RegExp) && ' + $format + '.validate; var ' + $formatType + ' = ' + $isObject + ' && ' + $format + '.type || \'string\'; if (' + $isObject + ') { ';
        if (it.async) {
          out += ' var async' + $lvl + ' = ' + $format + '.async; ';
        }
        out += ' ' + $format + ' = ' + $format + '.validate; } if (  ';
        if ($isData) {
          out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'string\') || ';
        }
        out += ' (';
        if ($unknownFormats != 'ignore') {
          out += ' (' + $schemaValue + ' && !' + $format + ' ';
          if ($allowUnknown) {
            out += ' && self._opts.unknownFormats.indexOf(' + $schemaValue + ') == -1 ';
          }
          out += ') || ';
        }
        out += ' (' + $format + ' && ' + $formatType + ' == \'' + $ruleType + '\' && !(typeof ' + $format + ' == \'function\' ? ';
        if (it.async) {
          out += ' (async' + $lvl + ' ? ' + it.yieldAwait + ' ' + $format + '(' + $data + ') : ' + $format + '(' + $data + ')) ';
        } else {
          out += ' ' + $format + '(' + $data + ') ';
        }
        out += ' : ' + $format + '.test(' + $data + '))))) {';
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == 'ignore') {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += ' if (true) { ';
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += ' if (true) { ';
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || 'string';
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += ' if (true) { ';
          }
          return out;
        }
        if ($async) {
          if (!it.async) throw new Error('async format in sync schema');
          var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
          out += ' if (!(' + it.yieldAwait + ' ' + $formatRef + '(' + $data + '))) { ';
        } else {
          out += ' if (! ';
          var $formatRef = 'formats' + it.util.getProperty($schema);
          if ($isObject) $formatRef += '.validate';
          if (typeof $format == 'function') {
            out += ' ' + $formatRef + '(' + $data + ') ';
          } else {
            out += ' ' + $formatRef + '.test(' + $data + ') ';
          }
          out += ') { ';
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'format' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { format:  ';
        if ($isData) {
          out += '' + $schemaValue;
        } else {
          out += '' + it.util.toQuotedString($schema);
        }
        out += '  } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match format "';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + it.util.escapeQuotes($schema);
          }
          out += '"\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + it.util.toQuotedString($schema);
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 26: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_items(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $idx = 'i' + $lvl,
          $dataNxt = $it.dataLevel = it.dataLevel + 1,
          $nextData = 'data' + $dataNxt,
          $currentBaseId = it.baseId;
      out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += ' ' + $valid + ' = ' + $data + '.length <= ' + $schema.length + '; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalItems';
          out += '  if (!' + $valid + ') {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + 'additionalItems' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schema.length + ' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should NOT have more than ' + $schema.length + ' items\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' } ';
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += '}';
            out += ' else { ';
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch,
              $i = -1,
              l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $i + ') { ';
              var $passData = $data + '[' + $i + ']';
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + '[' + $i + ']';
              $it.errSchemaPath = $errSchemaPath + '/' + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              out += ' }  ';
              if ($breakOnError) {
                out += ' if (' + $nextValid + ') { ';
                $closingBraces += '}';
              }
            }
          }
        }
        if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + '.additionalItems';
          $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
          out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $schema.length + ') {  for (var ' + $idx + ' = ' + $schema.length + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + '[' + $idx + ']';
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + $nextValid + ') break; ';
          }
          out += ' } }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += '  for (var ' + $idx + ' = ' + 0 + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + '[' + $idx + ']';
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
        } else {
          out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
        }
        if ($breakOnError) {
          out += ' if (!' + $nextValid + ') break; ';
        }
        out += ' }';
      }
      if ($breakOnError) {
        out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 27: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      out += 'var division' + $lvl + ';if (';
      if ($isData) {
        out += ' ' + $schemaValue + ' !== undefined && ( typeof ' + $schemaValue + ' != \'number\' || ';
      }
      out += ' (division' + $lvl + ' = ' + $data + ' / ' + $schemaValue + ', ';
      if (it.opts.multipleOfPrecision) {
        out += ' Math.abs(Math.round(division' + $lvl + ') - division' + $lvl + ') > 1e-' + it.opts.multipleOfPrecision + ' ';
      } else {
        out += ' division' + $lvl + ' !== parseInt(division' + $lvl + ') ';
      }
      out += ' ) ';
      if ($isData) {
        out += '  )  ';
      }
      out += ' ) {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'multipleOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { multipleOf: ' + $schemaValue + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be multiple of ';
          if ($isData) {
            out += '\' + ' + $schemaValue;
          } else {
            out += '' + $schemaValue + '\'';
          }
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 28: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_not(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += ' var ' + $errs + ' = errors;  ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += ' ' + it.validate($it) + ' ';
        $it.createErrors = true;
        if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' if (' + $nextValid + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'not' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT be valid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
        if (it.opts.allErrors) {
          out += ' } ';
        }
      } else {
        out += '  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'not' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT be valid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      }
      return out;
    };
  }, {}], 29: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      out += 'var ' + $errs + ' = errors;var prevValid' + $lvl + ' = false;var ' + $valid + ' = false;';
      var $currentBaseId = $it.baseId;
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch,
            $i = -1,
            l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + it.validate($it) + ' ';
            $it.baseId = $currentBaseId;
          } else {
            out += ' var ' + $nextValid + ' = true; ';
          }
          if ($i) {
            out += ' if (' + $nextValid + ' && prevValid' + $lvl + ') ' + $valid + ' = false; else { ';
            $closingBraces += '}';
          }
          out += ' if (' + $nextValid + ') ' + $valid + ' = prevValid' + $lvl + ' = true;';
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += '' + $closingBraces + 'if (!' + $valid + ') {   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'oneOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match exactly one schema in oneOf\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
      out += '} else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; }';
      if (it.opts.allErrors) {
        out += ' } ';
      }
      return out;
    };
  }, {}], 30: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
      out += 'if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'string\') || ';
      }
      out += ' !' + $regexp + '.test(' + $data + ') ) {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'pattern' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { pattern:  ';
        if ($isData) {
          out += '' + $schemaValue;
        } else {
          out += '' + it.util.toQuotedString($schema);
        }
        out += '  } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match pattern "';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + it.util.escapeQuotes($schema);
          }
          out += '"\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + it.util.toQuotedString($schema);
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 31: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $key = 'key' + $lvl,
          $idx = 'idx' + $lvl,
          $dataNxt = $it.dataLevel = it.dataLevel + 1,
          $nextData = 'data' + $dataNxt,
          $dataProperties = 'dataProperties' + $lvl;
      var $schemaKeys = Object.keys($schema || {}),
          $pProperties = it.schema.patternProperties || {},
          $pPropertyKeys = Object.keys($pProperties),
          $aProperties = it.schema.additionalProperties,
          $someProperties = $schemaKeys.length || $pPropertyKeys.length,
          $noAdditional = $aProperties === false,
          $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
          $removeAdditional = it.opts.removeAdditional,
          $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
          $ownProperties = it.opts.ownProperties,
          $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
      if (it.opts.patternGroups) {
        var $pgProperties = it.schema.patternGroups || {},
            $pgPropertyKeys = Object.keys($pgProperties);
      }
      out += 'var ' + $errs + ' = errors;var ' + $nextValid + ' = true;';
      if ($ownProperties) {
        out += ' var ' + $dataProperties + ' = undefined;';
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
        } else {
          out += ' for (var ' + $key + ' in ' + $data + ') { ';
        }
        if ($someProperties) {
          out += ' var isAdditional' + $lvl + ' = !(false ';
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 5) {
              out += ' || validate.schema' + $schemaPath + '[' + $key + '] ';
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey,
                    i1 = -1,
                    l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += ' || ' + $key + ' == ' + it.util.toQuotedString($propertyKey) + ' ';
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty,
                  $i = -1,
                  l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += ' || ' + it.usePattern($pProperty) + '.test(' + $key + ') ';
              }
            }
          }
          if (it.opts.patternGroups && $pgPropertyKeys.length) {
            var arr3 = $pgPropertyKeys;
            if (arr3) {
              var $pgProperty,
                  $i = -1,
                  l3 = arr3.length - 1;
              while ($i < l3) {
                $pgProperty = arr3[$i += 1];
                out += ' || ' + it.usePattern($pgProperty) + '.test(' + $key + ') ';
              }
            }
          }
          out += ' ); if (isAdditional' + $lvl + ') { ';
        }
        if ($removeAdditional == 'all') {
          out += ' delete ' + $data + '[' + $key + ']; ';
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = '\' + ' + $key + ' + \'';
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += ' delete ' + $data + '[' + $key + ']; ';
            } else {
              out += ' ' + $nextValid + ' = false; ';
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + '/additionalProperties';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + 'additionalProperties' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { additionalProperty: \'' + $additionalProperty + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should NOT have additional properties\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + __err + ']); ';
                } else {
                  out += ' validate.errors = [' + __err + ']; return false; ';
                }
              } else {
                out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += ' break; ';
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == 'failing') {
              out += ' var ' + $errs + ' = errors;  ';
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + '.additionalProperties';
              $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              out += ' if (!' + $nextValid + ') { errors = ' + $errs + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + $data + '[' + $key + ']; }  ';
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + '.additionalProperties';
              $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              if ($breakOnError) {
                out += ' if (!' + $nextValid + ') break; ';
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += ' } ';
        }
        out += ' }  ';
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr4 = $schemaKeys;
        if (arr4) {
          var $propertyKey,
              i4 = -1,
              l4 = arr4.length - 1;
          while (i4 < l4) {
            $propertyKey = arr4[i4 += 1];
            var $sch = $schema[$propertyKey];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey),
                  $passData = $data + $prop,
                  $hasDefault = $useDefaults && $sch.default !== undefined;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += ' var ' + $nextData + ' = ' + $passData + '; ';
              }
              if ($hasDefault) {
                out += ' ' + $code + ' ';
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += ' if ( ' + $useData + ' === undefined ';
                  if ($ownProperties) {
                    out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                  }
                  out += ') { ' + $nextValid + ' = false; ';
                  var $currentErrorPath = it.errorPath,
                      $currErrSchemaPath = $errSchemaPath,
                      $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + '/required';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'';
                      if (it.opts._errorDataPathProperty) {
                        out += 'is a required property';
                      } else {
                        out += 'should have required property \\\'' + $missingProperty + '\\\'';
                      }
                      out += '\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + __err + ']); ';
                    } else {
                      out += ' validate.errors = [' + __err + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += ' } else { ';
                } else {
                  if ($breakOnError) {
                    out += ' if ( ' + $useData + ' === undefined ';
                    if ($ownProperties) {
                      out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                    }
                    out += ') { ' + $nextValid + ' = true; } else { ';
                  } else {
                    out += ' if (' + $useData + ' !== undefined ';
                    if ($ownProperties) {
                      out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                    }
                    out += ' ) { ';
                  }
                }
                out += ' ' + $code + ' } ';
              }
            }
            if ($breakOnError) {
              out += ' if (' + $nextValid + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr5 = $pPropertyKeys;
        if (arr5) {
          var $pProperty,
              i5 = -1,
              l5 = arr5.length - 1;
          while (i5 < l5) {
            $pProperty = arr5[i5 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
              } else {
                out += ' for (var ' + $key + ' in ' + $data + ') { ';
              }
              out += ' if (' + it.usePattern($pProperty) + '.test(' + $key + ')) { ';
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              if ($breakOnError) {
                out += ' if (!' + $nextValid + ') break; ';
              }
              out += ' } ';
              if ($breakOnError) {
                out += ' else ' + $nextValid + ' = true; ';
              }
              out += ' }  ';
              if ($breakOnError) {
                out += ' if (' + $nextValid + ') { ';
                $closingBraces += '}';
              }
            }
          }
        }
      }
      if (it.opts.patternGroups && $pgPropertyKeys.length) {
        var arr6 = $pgPropertyKeys;
        if (arr6) {
          var $pgProperty,
              i6 = -1,
              l6 = arr6.length - 1;
          while (i6 < l6) {
            $pgProperty = arr6[i6 += 1];
            var $pgSchema = $pgProperties[$pgProperty],
                $sch = $pgSchema.schema;
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + '.patternGroups' + it.util.getProperty($pgProperty) + '.schema';
              $it.errSchemaPath = it.errSchemaPath + '/patternGroups/' + it.util.escapeFragment($pgProperty) + '/schema';
              out += ' var pgPropCount' + $lvl + ' = 0;  ';
              if ($ownProperties) {
                out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
              } else {
                out += ' for (var ' + $key + ' in ' + $data + ') { ';
              }
              out += ' if (' + it.usePattern($pgProperty) + '.test(' + $key + ')) { pgPropCount' + $lvl + '++; ';
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              if ($breakOnError) {
                out += ' if (!' + $nextValid + ') break; ';
              }
              out += ' } ';
              if ($breakOnError) {
                out += ' else ' + $nextValid + ' = true; ';
              }
              out += ' }  ';
              if ($breakOnError) {
                out += ' if (' + $nextValid + ') { ';
                $closingBraces += '}';
              }
              var $pgMin = $pgSchema.minimum,
                  $pgMax = $pgSchema.maximum;
              if ($pgMin !== undefined || $pgMax !== undefined) {
                out += ' var ' + $valid + ' = true; ';
                var $currErrSchemaPath = $errSchemaPath;
                if ($pgMin !== undefined) {
                  var $limit = $pgMin,
                      $reason = 'minimum',
                      $moreOrLess = 'less';
                  out += ' ' + $valid + ' = pgPropCount' + $lvl + ' >= ' + $pgMin + '; ';
                  $errSchemaPath = it.errSchemaPath + '/patternGroups/minimum';
                  out += '  if (!' + $valid + ') {   ';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + 'patternGroups' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { reason: \'' + $reason + '\', limit: ' + $limit + ', pattern: \'' + it.util.escapeQuotes($pgProperty) + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'should NOT have ' + $moreOrLess + ' than ' + $limit + ' properties matching pattern "' + it.util.escapeQuotes($pgProperty) + '"\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + __err + ']); ';
                    } else {
                      out += ' validate.errors = [' + __err + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  out += ' } ';
                  if ($pgMax !== undefined) {
                    out += ' else ';
                  }
                }
                if ($pgMax !== undefined) {
                  var $limit = $pgMax,
                      $reason = 'maximum',
                      $moreOrLess = 'more';
                  out += ' ' + $valid + ' = pgPropCount' + $lvl + ' <= ' + $pgMax + '; ';
                  $errSchemaPath = it.errSchemaPath + '/patternGroups/maximum';
                  out += '  if (!' + $valid + ') {   ';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + 'patternGroups' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { reason: \'' + $reason + '\', limit: ' + $limit + ', pattern: \'' + it.util.escapeQuotes($pgProperty) + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'should NOT have ' + $moreOrLess + ' than ' + $limit + ' properties matching pattern "' + it.util.escapeQuotes($pgProperty) + '"\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + __err + ']); ';
                    } else {
                      out += ' validate.errors = [' + __err + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  out += ' } ';
                }
                $errSchemaPath = $currErrSchemaPath;
                if ($breakOnError) {
                  out += ' if (' + $valid + ') { ';
                  $closingBraces += '}';
                }
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 32: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = 'key' + $lvl,
            $idx = 'idx' + $lvl,
            $i = 'i' + $lvl,
            $invalidName = '\' + ' + $key + ' + \'',
            $dataNxt = $it.dataLevel = it.dataLevel + 1,
            $nextData = 'data' + $dataNxt,
            $dataProperties = 'dataProperties' + $lvl,
            $ownProperties = it.opts.ownProperties,
            $currentBaseId = it.baseId;
        out += ' var ' + $errs + ' = errors; ';
        if ($ownProperties) {
          out += ' var ' + $dataProperties + ' = undefined; ';
        }
        if ($ownProperties) {
          out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
        } else {
          out += ' for (var ' + $key + ' in ' + $data + ') { ';
        }
        out += ' var startErrs' + $lvl + ' = errors; ';
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
        } else {
          out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' if (!' + $nextValid + ') { for (var ' + $i + '=startErrs' + $lvl + '; ' + $i + '<errors; ' + $i + '++) { vErrors[' + $i + '].propertyName = ' + $key + '; }   var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'propertyNames' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { propertyName: \'' + $invalidName + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'property name \\\'' + $invalidName + '\\\' is invalid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError(vErrors); ';
          } else {
            out += ' validate.errors = vErrors; return false; ';
          }
        }
        if ($breakOnError) {
          out += ' break; ';
        }
        out += ' } }';
      }
      if ($breakOnError) {
        out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 33: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $async, $refCode;
      if ($schema == '#' || $schema == '#/') {
        if (it.isRoot) {
          $async = it.async;
          $refCode = 'validate';
        } else {
          $async = it.root.schema.$async === true;
          $refCode = 'root.refVal[0]';
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === undefined) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == 'fail') {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + '$ref' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { ref: \'' + it.util.escapeQuotes($schema) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'can\\\'t resolve reference ' + it.util.escapeQuotes($schema) + '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: ' + it.util.toQuotedString($schema) + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            if ($breakOnError) {
              out += ' if (false) { ';
            }
          } else if (it.opts.missingRefs == 'ignore') {
            it.logger.warn($message);
            if ($breakOnError) {
              out += ' if (true) { ';
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = 'valid' + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = '';
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += ' ' + $code + ' ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
          }
        } else {
          $async = $refVal.$async === true;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        if (it.opts.passContext) {
          out += ' ' + $refCode + '.call(this, ';
        } else {
          out += ' ' + $refCode + '( ';
        }
        out += ' ' + $data + ', (dataPath || \'\')';
        if (it.errorPath != '""') {
          out += ' + ' + it.errorPath;
        }
        var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
            $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' , ' + $parentData + ' , ' + $parentDataProperty + ', rootData)  ';
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async) throw new Error('async schema referenced by sync schema');
          if ($breakOnError) {
            out += ' var ' + $valid + '; ';
          }
          out += ' try { ' + it.yieldAwait + ' ' + __callValidate + '; ';
          if ($breakOnError) {
            out += ' ' + $valid + ' = true; ';
          }
          out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
          if ($breakOnError) {
            out += ' ' + $valid + ' = false; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' if (' + $valid + ') { ';
          }
        } else {
          out += ' if (!' + __callValidate + ') { if (vErrors === null) vErrors = ' + $refCode + '.errors; else vErrors = vErrors.concat(' + $refCode + '.errors); errors = vErrors.length; } ';
          if ($breakOnError) {
            out += ' else { ';
          }
        }
      }
      return out;
    };
  }, {}], 34: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_required(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = 'schema' + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property,
                i1 = -1,
                l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath,
            $loopRequired = $isData || $required.length >= it.opts.loopRequired,
            $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += ' var missing' + $lvl + '; ';
          if ($loopRequired) {
            if (!$isData) {
              out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
            }
            var $i = 'i' + $lvl,
                $propertyPath = 'schema' + $lvl + '[' + $i + ']',
                $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += ' var ' + $valid + ' = true; ';
            if ($isData) {
              out += ' if (schema' + $lvl + ' === undefined) ' + $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' + $valid + ' = false; else {';
            }
            out += ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { ' + $valid + ' = ' + $data + '[' + $vSchema + '[' + $i + ']] !== undefined ';
            if ($ownProperties) {
              out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';
            }
            out += '; if (!' + $valid + ') break; } ';
            if ($isData) {
              out += '  }  ';
            }
            out += '  if (!' + $valid + ') {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + $missingProperty + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else { ';
          } else {
            out += ' if ( ';
            var arr2 = $required;
            if (arr2) {
              var $propertyKey,
                  $i = -1,
                  l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += ' || ';
                }
                var $prop = it.util.getProperty($propertyKey),
                    $useData = $data + $prop;
                out += ' ( ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') && (missing' + $lvl + ' = ' + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
              }
            }
            out += ') {  ';
            var $propertyPath = 'missing' + $lvl,
                $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + $missingProperty + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else { ';
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
            }
            var $i = 'i' + $lvl,
                $propertyPath = 'schema' + $lvl + '[' + $i + ']',
                $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += ' if (' + $vSchema + ' && !Array.isArray(' + $vSchema + ')) {  var err =   '; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + $missingProperty + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + $vSchema + ' !== undefined) { ';
            }
            out += ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { if (' + $data + '[' + $vSchema + '[' + $i + ']] === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + $missingProperty + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
            if ($isData) {
              out += '  }  ';
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey,
                  i3 = -1,
                  l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey),
                    $missingProperty = it.util.escapeQuotes($propertyKey),
                    $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += ' if ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') {  var err =   '; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'';
                    if (it.opts._errorDataPathProperty) {
                      out += 'is a required property';
                    } else {
                      out += 'should have required property \\\'' + $missingProperty + '\\\'';
                    }
                    out += '\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += ' if (true) {';
      }
      return out;
    };
  }, {}], 35: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += ' var ' + $valid + '; if (' + $schemaValue + ' === false || ' + $schemaValue + ' === undefined) ' + $valid + ' = true; else if (typeof ' + $schemaValue + ' != \'boolean\') ' + $valid + ' = false; else { ';
        }
        out += ' var ' + $valid + ' = true; if (' + $data + '.length > 1) { var i = ' + $data + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + $data + '[i], ' + $data + '[j])) { ' + $valid + ' = false; break outer; } } } } ';
        if ($isData) {
          out += '  }  ';
        }
        out += ' if (!' + $valid + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'uniqueItems' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { i: i, j: j } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema:  ';
            if ($isData) {
              out += 'validate.schema' + $schemaPath;
            } else {
              out += '' + $schema;
            }
            out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' else { ';
        }
      } else {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      }
      return out;
    };
  }, {}], 36: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = '';
      var $async = it.schema.$async === true,
          $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
          $id = it.self._getId(it.schema);
      if (it.isTop) {
        if ($async) {
          it.async = true;
          var $es7 = it.opts.async == 'es7';
          it.yieldAwait = $es7 ? 'await' : 'yield';
        }
        out += ' var validate = ';
        if ($async) {
          if ($es7) {
            out += ' (async function ';
          } else {
            if (it.opts.async != '*') {
              out += 'co.wrap';
            }
            out += '(function* ';
          }
        } else {
          out += ' (function ';
        }
        out += ' (data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
        }
      }
      if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
        var $keyword = 'false schema';
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = 'data' + ($dataLvl || '');
        var $valid = 'valid' + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += ' var ' + $valid + ' = false; ';
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
            if (it.opts.messages !== false) {
              out += ' , message: \'boolean schema is false\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += ' return data; ';
            } else {
              out += ' validate.errors = null; return true; ';
            }
          } else {
            out += ' var ' + $valid + ' = true; ';
          }
        }
        if (it.isTop) {
          out += ' }); return validate; ';
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop,
            $lvl = it.level = 0,
            $dataLvl = it.dataLevel = 0,
            $data = 'data';
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [undefined];
        out += ' var vErrors = null; ';
        out += ' var errors = 0;     ';
        out += ' if (rootData === undefined) rootData = data; ';
      } else {
        var $lvl = it.level,
            $dataLvl = it.dataLevel,
            $data = 'data' + ($dataLvl || '');
        if ($id) it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async) throw new Error('async schema in sync schema');
        out += ' var errs_' + $lvl + ' = errors;';
      }
      var $valid = 'valid' + $lvl,
          $breakOnError = !it.opts.allErrors,
          $closingBraces1 = '',
          $closingBraces2 = '';
      var $errorKeyword;
      var $typeSchema = it.schema.type,
          $typeIsArray = Array.isArray($typeSchema);
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == 'fail') {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + '.type',
              $errSchemaPath = it.errSchemaPath + '/type';
          var $schemaPath = it.schemaPath + '.type',
              $errSchemaPath = it.errSchemaPath + '/type',
              $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
          out += ' if (' + it.util[$method]($typeSchema, $data, true) + ') { ';
          if ($coerceToTypes) {
            var $dataType = 'dataType' + $lvl,
                $coerced = 'coerced' + $lvl;
            out += ' var ' + $dataType + ' = typeof ' + $data + '; ';
            if (it.opts.coerceTypes == 'array') {
              out += ' if (' + $dataType + ' == \'object\' && Array.isArray(' + $data + ')) ' + $dataType + ' = \'array\'; ';
            }
            out += ' var ' + $coerced + ' = undefined; ';
            var $bracesCoercion = '';
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type,
                  $i = -1,
                  l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($i) {
                  out += ' if (' + $coerced + ' === undefined) { ';
                  $bracesCoercion += '}';
                }
                if (it.opts.coerceTypes == 'array' && $type != 'array') {
                  out += ' if (' + $dataType + ' == \'array\' && ' + $data + '.length == 1) { ' + $coerced + ' = ' + $data + ' = ' + $data + '[0]; ' + $dataType + ' = typeof ' + $data + ';  } ';
                }
                if ($type == 'string') {
                  out += ' if (' + $dataType + ' == \'number\' || ' + $dataType + ' == \'boolean\') ' + $coerced + ' = \'\' + ' + $data + '; else if (' + $data + ' === null) ' + $coerced + ' = \'\'; ';
                } else if ($type == 'number' || $type == 'integer') {
                  out += ' if (' + $dataType + ' == \'boolean\' || ' + $data + ' === null || (' + $dataType + ' == \'string\' && ' + $data + ' && ' + $data + ' == +' + $data + ' ';
                  if ($type == 'integer') {
                    out += ' && !(' + $data + ' % 1)';
                  }
                  out += ')) ' + $coerced + ' = +' + $data + '; ';
                } else if ($type == 'boolean') {
                  out += ' if (' + $data + ' === \'false\' || ' + $data + ' === 0 || ' + $data + ' === null) ' + $coerced + ' = false; else if (' + $data + ' === \'true\' || ' + $data + ' === 1) ' + $coerced + ' = true; ';
                } else if ($type == 'null') {
                  out += ' if (' + $data + ' === \'\' || ' + $data + ' === 0 || ' + $data + ' === false) ' + $coerced + ' = null; ';
                } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
                  out += ' if (' + $dataType + ' == \'string\' || ' + $dataType + ' == \'number\' || ' + $dataType + ' == \'boolean\' || ' + $data + ' == null) ' + $coerced + ' = [' + $data + ']; ';
                }
              }
            }
            out += ' ' + $bracesCoercion + ' if (' + $coerced + ' === undefined) {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
              if ($typeIsArray) {
                out += '' + $typeSchema.join(",");
              } else {
                out += '' + $typeSchema;
              }
              out += '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should be ';
                if ($typeIsArray) {
                  out += '' + $typeSchema.join(",");
                } else {
                  out += '' + $typeSchema;
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else {  ';
            var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
                $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
            out += ' ' + $data + ' = ' + $coerced + '; ';
            if (!$dataLvl) {
              out += 'if (' + $parentData + ' !== undefined)';
            }
            out += ' ' + $parentData + '[' + $parentDataProperty + '] = ' + $coerced + '; } ';
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
              if ($typeIsArray) {
                out += '' + $typeSchema.join(",");
              } else {
                out += '' + $typeSchema;
              }
              out += '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should be ';
                if ($typeIsArray) {
                  out += '' + $typeSchema.join(",");
                } else {
                  out += '' + $typeSchema;
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          }
          out += ' } ';
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += ' ' + it.RULES.all.$ref.code(it, '$ref') + ' ';
        if ($breakOnError) {
          out += ' } if (errors === ';
          if ($top) {
            out += '0';
          } else {
            out += 'errs_' + $lvl;
          }
          out += ') { ';
          $closingBraces2 += '}';
        }
      } else {
        if (it.opts.v5 && it.schema.patternGroups) {
          it.logger.warn('keyword "patternGroups" is deprecated and disabled. Use option patternGroups: true to enable.');
        }
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup,
              i2 = -1,
              l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += ' if (' + it.util.checkDataType($rulesGroup.type, $data) + ') { ';
              }
              if (it.opts.useDefaults && !it.compositeRule) {
                if ($rulesGroup.type == 'object' && it.schema.properties) {
                  var $schema = it.schema.properties,
                      $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey,
                        i3 = -1,
                        l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== undefined) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        out += '  if (' + $passData + ' === undefined) ' + $passData + ' = ';
                        if (it.opts.useDefaults == 'shared') {
                          out += ' ' + it.useDefault($sch.default) + ' ';
                        } else {
                          out += ' ' + JSON.stringify($sch.default) + ' ';
                        }
                        out += '; ';
                      }
                    }
                  }
                } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch,
                        $i = -1,
                        l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== undefined) {
                        var $passData = $data + '[' + $i + ']';
                        out += '  if (' + $passData + ' === undefined) ' + $passData + ' = ';
                        if (it.opts.useDefaults == 'shared') {
                          out += ' ' + it.useDefault($sch.default) + ' ';
                        } else {
                          out += ' ' + JSON.stringify($sch.default) + ' ';
                        }
                        out += '; ';
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule,
                    i5 = -1,
                    l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += ' ' + $code + ' ';
                      if ($breakOnError) {
                        $closingBraces1 += '}';
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += ' ' + $closingBraces1 + ' ';
                $closingBraces1 = '';
              }
              if ($rulesGroup.type) {
                out += ' } ';
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += ' else { ';
                  var $schemaPath = it.schemaPath + '.type',
                      $errSchemaPath = it.errSchemaPath + '/type';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
                    if ($typeIsArray) {
                      out += '' + $typeSchema.join(",");
                    } else {
                      out += '' + $typeSchema;
                    }
                    out += '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'should be ';
                      if ($typeIsArray) {
                        out += '' + $typeSchema.join(",");
                      } else {
                        out += '' + $typeSchema;
                      }
                      out += '\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + __err + ']); ';
                    } else {
                      out += ' validate.errors = [' + __err + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  out += ' } ';
                }
              }
              if ($breakOnError) {
                out += ' if (errors === ';
                if ($top) {
                  out += '0';
                } else {
                  out += 'errs_' + $lvl;
                }
                out += ') { ';
                $closingBraces2 += '}';
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += ' ' + $closingBraces2 + ' ';
      }
      if ($top) {
        if ($async) {
          out += ' if (errors === 0) return data;           ';
          out += ' else throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; ';
          out += ' return errors === 0;       ';
        }
        out += ' }); return validate;';
      } else {
        out += ' var ' + $valid + ' = errors === errs_' + $lvl + ';';
      }
      out = it.util.cleanUpCode(out);
      if ($top) {
        out = it.util.finalCleanUpCode(out, $async);
      }

      function $shouldUseGroup($rulesGroup) {
        var rules = $rulesGroup.rules;
        for (var i = 0; i < rules.length; i++) if ($shouldUseRule(rules[i])) return true;
      }

      function $shouldUseRule($rule) {
        return it.schema[$rule.keyword] !== undefined || $rule.implements && $ruleImplementsSomeKeyword($rule);
      }

      function $ruleImplementsSomeKeyword($rule) {
        var impl = $rule.implements;
        for (var i = 0; i < impl.length; i++) if (it.schema[impl[i]] !== undefined) return true;
      }
      return out;
    };
  }, {}], 37: [function (require, module, exports) {
    'use strict';

    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require('./dotjs/custom');

    module.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword
    };

    /**
     * Define custom keyword
     * @this  Ajv
     * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
     * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
     * @return {Ajv} this for method chaining
     */
    function addKeyword(keyword, definition) {
      /* jshint validthis: true */
      /* eslint no-shadow: 0 */
      var RULES = this.RULES;

      if (RULES.keywords[keyword]) throw new Error('Keyword ' + keyword + ' is already defined');

      if (!IDENTIFIER.test(keyword)) throw new Error('Keyword ' + keyword + ' is not a valid identifier');

      if (definition) {
        if (definition.macro && definition.valid !== undefined) throw new Error('"valid" option cannot be used with macro keywords');

        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          var i,
              len = dataType.length;
          for (i = 0; i < len; i++) checkDataType(dataType[i]);
          for (i = 0; i < len; i++) _addRule(keyword, dataType[i], definition);
        } else {
          if (dataType) checkDataType(dataType);
          _addRule(keyword, dataType, definition);
        }

        var $data = definition.$data === true && this._opts.$data;
        if ($data && !definition.validate) throw new Error('$data support: "validate" function is not defined');

        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if ($data) {
            metaSchema = {
              anyOf: [metaSchema, { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#' }]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }

      RULES.keywords[keyword] = RULES.all[keyword] = true;

      function _addRule(keyword, dataType, definition) {
        var ruleGroup;
        for (var i = 0; i < RULES.length; i++) {
          var rg = RULES[i];
          if (rg.type == dataType) {
            ruleGroup = rg;
            break;
          }
        }

        if (!ruleGroup) {
          ruleGroup = { type: dataType, rules: [] };
          RULES.push(ruleGroup);
        }

        var rule = {
          keyword: keyword,
          definition: definition,
          custom: true,
          code: customRuleCode,
          implements: definition.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword] = rule;
      }

      function checkDataType(dataType) {
        if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
      }

      return this;
    }

    /**
     * Get keyword
     * @this  Ajv
     * @param {String} keyword pre-defined or custom keyword.
     * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
     */
    function getKeyword(keyword) {
      /* jshint validthis: true */
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }

    /**
     * Remove keyword
     * @this  Ajv
     * @param {String} keyword pre-defined or custom keyword.
     * @return {Ajv} this for method chaining
     */
    function removeKeyword(keyword) {
      /* jshint validthis: true */
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
  }, { "./dotjs/custom": 22 }], 38: [function (require, module, exports) {
    'use strict';

    var META_SCHEMA_ID = 'http://json-schema.org/draft-06/schema';

    module.exports = function (ajv) {
      var defaultMeta = ajv._opts.defaultMeta;
      var metaSchemaRef = typeof defaultMeta == 'string' ? { $ref: defaultMeta } : ajv.getSchema(META_SCHEMA_ID) ? { $ref: META_SCHEMA_ID } : {};

      ajv.addKeyword('patternGroups', {
        // implemented in properties.jst
        metaSchema: {
          type: 'object',
          additionalProperties: {
            type: 'object',
            required: ['schema'],
            properties: {
              maximum: {
                type: 'integer',
                minimum: 0
              },
              minimum: {
                type: 'integer',
                minimum: 0
              },
              schema: metaSchemaRef
            },
            additionalProperties: false
          }
        }
      });
      ajv.RULES.all.properties.implements.push('patternGroups');
    };
  }, {}], 39: [function (require, module, exports) {
    module.exports = {
      "$schema": "http://json-schema.org/draft-06/schema#",
      "$id": "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#",
      "description": "Meta-schema for $data reference (JSON-schema extension proposal)",
      "type": "object",
      "required": ["$data"],
      "properties": {
        "$data": {
          "type": "string",
          "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
        }
      },
      "additionalProperties": false
    };
  }, {}], 40: [function (require, module, exports) {
    module.exports = {
      "$schema": "http://json-schema.org/draft-06/schema#",
      "$id": "http://json-schema.org/draft-06/schema#",
      "title": "Core schema meta-schema",
      "definitions": {
        "schemaArray": {
          "type": "array",
          "minItems": 1,
          "items": { "$ref": "#" }
        },
        "nonNegativeInteger": {
          "type": "integer",
          "minimum": 0
        },
        "nonNegativeIntegerDefault0": {
          "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }]
        },
        "simpleTypes": {
          "enum": ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        "stringArray": {
          "type": "array",
          "items": { "type": "string" },
          "uniqueItems": true,
          "default": []
        }
      },
      "type": ["object", "boolean"],
      "properties": {
        "$id": {
          "type": "string",
          "format": "uri-reference"
        },
        "$schema": {
          "type": "string",
          "format": "uri"
        },
        "$ref": {
          "type": "string",
          "format": "uri-reference"
        },
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "default": {},
        "examples": {
          "type": "array",
          "items": {}
        },
        "multipleOf": {
          "type": "number",
          "exclusiveMinimum": 0
        },
        "maximum": {
          "type": "number"
        },
        "exclusiveMaximum": {
          "type": "number"
        },
        "minimum": {
          "type": "number"
        },
        "exclusiveMinimum": {
          "type": "number"
        },
        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "pattern": {
          "type": "string",
          "format": "regex"
        },
        "additionalItems": { "$ref": "#" },
        "items": {
          "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
          "default": {}
        },
        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "uniqueItems": {
          "type": "boolean",
          "default": false
        },
        "contains": { "$ref": "#" },
        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": { "$ref": "#" },
        "definitions": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "properties": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "patternProperties": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }]
          }
        },
        "propertyNames": { "$ref": "#" },
        "const": {},
        "enum": {
          "type": "array",
          "minItems": 1,
          "uniqueItems": true
        },
        "type": {
          "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
            "type": "array",
            "items": { "$ref": "#/definitions/simpleTypes" },
            "minItems": 1,
            "uniqueItems": true
          }]
        },
        "format": { "type": "string" },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
      },
      "default": {}
    };
  }, {}], 41: [function (require, module, exports) {
    'use strict';

    module.exports = function equal(a, b) {
      if (a === b) return true;

      var arrA = Array.isArray(a),
          arrB = Array.isArray(b),
          i;

      if (arrA && arrB) {
        if (a.length != b.length) return false;
        for (i = 0; i < a.length; i++) if (!equal(a[i], b[i])) return false;
        return true;
      }

      if (arrA != arrB) return false;

      if (a && b && typeof a === 'object' && typeof b === 'object') {
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) return false;

        var dateA = a instanceof Date,
            dateB = b instanceof Date;
        if (dateA && dateB) return a.getTime() == b.getTime();
        if (dateA != dateB) return false;

        var regexpA = a instanceof RegExp,
            regexpB = b instanceof RegExp;
        if (regexpA && regexpB) return a.toString() == b.toString();
        if (regexpA != regexpB) return false;

        for (i = 0; i < keys.length; i++) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

        for (i = 0; i < keys.length; i++) if (!equal(a[keys[i]], b[keys[i]])) return false;

        return true;
      }

      return false;
    };
  }, {}], 42: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    var punycode = require('punycode');
    var util = require('./util');

    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;

    exports.Url = Url;

    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }

    // Reference: RFC 3986, RFC 1808, RFC 2396

    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,


    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),

    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
        hostEndingChars = ['/', '?', '#'],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },

    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },

    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
        querystring = require('querystring');

    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url) return url;

      var u = new Url();
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }

    Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }

      // Copy chrome, IE, opera backslash-handling behavior.
      // Back slashes before the query string get converted to forward slashes
      // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
          splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
          uSplit = url.split(splitter),
          slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, '/');
      url = uSplit.join(splitter);

      var rest = url;

      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();

      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = '';
            this.query = {};
          }
          return this;
        }
      }

      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }

      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }

      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) hostEnd = rest.length;

        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost();

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                this.hostname = validParts.join('.');
                break;
              }
            }
          }
        }

        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = '';
        } else {
          // hostnames are always lower case.
          this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
          // IDNA Support: Returns a punycoded representation of "domain".
          // It only converts parts of the domain name that
          // have non-ASCII characters, i.e. it doesn't matter if
          // you call it with a domain that already is ASCII-only.
          this.hostname = punycode.toASCII(this.hostname);
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }

      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1) continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }

      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
      }
      if (rest) this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = '/';
      }

      //to support http.request
      if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
      }

      // finally, reconstruct the href based on what has been validated.
      this.href = this.format();
      return this;
    };

    // format a parsed object into a url string
    function urlFormat(obj) {
      // ensure it's an object, and not a string url.
      // If it's an obj, this is a no-op.
      // this way, you can call url_format() on strings
      // to clean up potentially wonky urls.
      if (util.isString(obj)) obj = urlParse(obj);
      if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
      return obj.format();
    }

    Url.prototype.format = function () {
      var auth = this.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }

      var protocol = this.protocol || '',
          pathname = this.pathname || '',
          hash = this.hash || '',
          host = false,
          query = '';

      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
        if (this.port) {
          host += ':' + this.port;
        }
      }

      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }

      var search = this.search || query && '?' + query || '';

      if (protocol && protocol.substr(-1) !== ':') protocol += ':';

      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }

      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;

      pathname = pathname.replace(/[?#]/g, function (match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');

      return protocol + host + pathname + search + hash;
    };

    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }

    Url.prototype.resolve = function (relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };

    function urlResolveObject(source, relative) {
      if (!source) return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }

    Url.prototype.resolveObject = function (relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }

      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }

      // hash is always overridden, no matter what.
      // even href="" will remove it.
      result.hash = relative.hash;

      // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format();
        return result;
      }

      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== 'protocol') result[rkey] = relative[rkey];
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
      }

      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }

      var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
          isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
          mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
          removeAllDots = mustEndAbs,
          srcPath = result.pathname && result.pathname.split('/') || [],
          relPath = relative.pathname && relative.pathname.split('/') || [],
          psychotic = result.protocol && !slashedProtocol[result.protocol];

      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }

      if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === '' ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
      }

      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }

      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }

      if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }

      if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
        srcPath.push('');
      }

      var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

      // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }

      mustEndAbs = mustEndAbs || result.host && srcPath.length;

      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }

      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      }

      //to support request.http
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };

    Url.prototype.parseHost = function () {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) this.hostname = host;
    };
  }, { "./util": 43, "punycode": 47, "querystring": 50 }], 43: [function (require, module, exports) {
    'use strict';

    module.exports = {
      isString: function (arg) {
        return typeof arg === 'string';
      },
      isObject: function (arg) {
        return typeof arg === 'object' && arg !== null;
      },
      isNull: function (arg) {
        return arg === null;
      },
      isNullOrUndefined: function (arg) {
        return arg == null;
      }
    };
  }, {}], 44: [function (require, module, exports) {

    /**
     * slice() reference.
     */

    var slice = Array.prototype.slice;

    /**
     * Expose `co`.
     */

    module.exports = co['default'] = co.co = co;

    /**
     * Wrap the given generator `fn` into a
     * function that returns a promise.
     * This is a separate function so that
     * every `co()` call doesn't create a new,
     * unnecessary closure.
     *
     * @param {GeneratorFunction} fn
     * @return {Function}
     * @api public
     */

    co.wrap = function (fn) {
      createPromise.__generatorFunction__ = fn;
      return createPromise;
      function createPromise() {
        return co.call(this, fn.apply(this, arguments));
      }
    };

    /**
     * Execute the generator function or a generator
     * and return a promise.
     *
     * @param {Function} fn
     * @return {Promise}
     * @api public
     */

    function co(gen) {
      var ctx = this;
      var args = slice.call(arguments, 1);

      // we wrap everything in a promise to avoid promise chaining,
      // which leads to memory leak errors.
      // see https://github.com/tj/co/issues/180
      return new Promise(function (resolve, reject) {
        if (typeof gen === 'function') gen = gen.apply(ctx, args);
        if (!gen || typeof gen.next !== 'function') return resolve(gen);

        onFulfilled();

        /**
         * @param {Mixed} res
         * @return {Promise}
         * @api private
         */

        function onFulfilled(res) {
          var ret;
          try {
            ret = gen.next(res);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }

        /**
         * @param {Error} err
         * @return {Promise}
         * @api private
         */

        function onRejected(err) {
          var ret;
          try {
            ret = gen.throw(err);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }

        /**
         * Get the next value in the generator,
         * return a promise.
         *
         * @param {Object} ret
         * @return {Promise}
         * @api private
         */

        function next(ret) {
          if (ret.done) return resolve(ret.value);
          var value = toPromise.call(ctx, ret.value);
          if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
          return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"'));
        }
      });
    }

    /**
     * Convert a `yield`ed value into a promise.
     *
     * @param {Mixed} obj
     * @return {Promise}
     * @api private
     */

    function toPromise(obj) {
      if (!obj) return obj;
      if (isPromise(obj)) return obj;
      if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
      if ('function' == typeof obj) return thunkToPromise.call(this, obj);
      if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
      if (isObject(obj)) return objectToPromise.call(this, obj);
      return obj;
    }

    /**
     * Convert a thunk to a promise.
     *
     * @param {Function}
     * @return {Promise}
     * @api private
     */

    function thunkToPromise(fn) {
      var ctx = this;
      return new Promise(function (resolve, reject) {
        fn.call(ctx, function (err, res) {
          if (err) return reject(err);
          if (arguments.length > 2) res = slice.call(arguments, 1);
          resolve(res);
        });
      });
    }

    /**
     * Convert an array of "yieldables" to a promise.
     * Uses `Promise.all()` internally.
     *
     * @param {Array} obj
     * @return {Promise}
     * @api private
     */

    function arrayToPromise(obj) {
      return Promise.all(obj.map(toPromise, this));
    }

    /**
     * Convert an object of "yieldables" to a promise.
     * Uses `Promise.all()` internally.
     *
     * @param {Object} obj
     * @return {Promise}
     * @api private
     */

    function objectToPromise(obj) {
      var results = new obj.constructor();
      var keys = Object.keys(obj);
      var promises = [];
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var promise = toPromise.call(this, obj[key]);
        if (promise && isPromise(promise)) defer(promise, key);else results[key] = obj[key];
      }
      return Promise.all(promises).then(function () {
        return results;
      });

      function defer(promise, key) {
        // predefine the key in the result
        results[key] = undefined;
        promises.push(promise.then(function (res) {
          results[key] = res;
        }));
      }
    }

    /**
     * Check if `obj` is a promise.
     *
     * @param {Object} obj
     * @return {Boolean}
     * @api private
     */

    function isPromise(obj) {
      return 'function' == typeof obj.then;
    }

    /**
     * Check if `obj` is a generator.
     *
     * @param {Mixed} obj
     * @return {Boolean}
     * @api private
     */

    function isGenerator(obj) {
      return 'function' == typeof obj.next && 'function' == typeof obj.throw;
    }

    /**
     * Check if `obj` is a generator function.
     *
     * @param {Mixed} obj
     * @return {Boolean}
     * @api private
     */
    function isGeneratorFunction(obj) {
      var constructor = obj.constructor;
      if (!constructor) return false;
      if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
      return isGenerator(constructor.prototype);
    }

    /**
     * Check for plain object.
     *
     * @param {Mixed} val
     * @return {Boolean}
     * @api private
     */

    function isObject(val) {
      return Object == val.constructor;
    }
  }, {}], 45: [function (require, module, exports) {
    'use strict';

    module.exports = function (data, opts) {
      if (!opts) opts = {};
      if (typeof opts === 'function') opts = { cmp: opts };
      var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;

      var cmp = opts.cmp && function (f) {
        return function (node) {
          return function (a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);

      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
          node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
          out = '[';
          for (i = 0; i < node.length; i++) {
            if (i) out += ',';
            out += stringify(node[i]) || 'null';
          }
          return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify('__cycle__');
          throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);

          if (!value) continue;
          if (out) out += ',';
          out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
      }(data);
    };
  }, {}], 46: [function (require, module, exports) {
    'use strict';

    var traverse = module.exports = function (schema, opts, cb) {
      if (typeof opts == 'function') {
        cb = opts;
        opts = {};
      }
      _traverse(opts, cb, schema, '', schema);
    };

    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };

    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };

    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };

    traverse.skipKeywords = {
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };

    function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++) _traverse(opts, cb, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == 'object') {
              for (var prop in sch) _traverse(opts, cb, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, cb, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
          }
        }
      }
    }

    function escapeJsonPtr(str) {
      return str.replace(/~/g, '~0').replace(/\//g, '~1');
    }
  }, {}], 47: [function (require, module, exports) {
    (function (global) {
      /*! https://mths.be/punycode v1.4.1 by @mathias */
      ;(function (root) {

        /** Detect free variables */
        var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
        var freeModule = typeof module == 'object' && module && !module.nodeType && module;
        var freeGlobal = typeof global == 'object' && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }

        /**
         * The `punycode` object.
         * @name punycode
         * @type Object
         */
        var punycode,


        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647,
            // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            // 0x80
        delimiter = '-',
            // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            // RFC 3490 separators

        /** Error messages */
        errors = {
          'overflow': 'Overflow: input needs wider integers to process',
          'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
          'invalid-input': 'Invalid input'
        },


        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,


        /** Temporary variable */
        key;

        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error(type) {
          throw new RangeError(errors[type]);
        }

        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
          var length = array.length;
          var result = [];
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }

        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
          var parts = string.split('@');
          var result = '';
          if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
          }
          // Avoid `split(regex)` for IE8 compatibility. See #17.
          string = string.replace(regexSeparators, '\x2E');
          var labels = string.split('.');
          var encoded = map(labels, fn).join('.');
          return result + encoded;
        }

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
          var output = [],
              counter = 0,
              length = string.length,
              value,
              extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
              // high surrogate, and there is a next character
              extra = string.charCodeAt(counter++);
              if ((extra & 0xFC00) == 0xDC00) {
                // low surrogate
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
              } else {
                // unmatched surrogate; only append this code unit, in case the next
                // code unit is the high surrogate of a surrogate pair
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }

        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        function ucs2encode(array) {
          return map(array, function (value) {
            var output = '';
            if (value > 0xFFFF) {
              value -= 0x10000;
              output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
              value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
            return output;
          }).join('');
        }

        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }

        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        function digitToBasic(digit, flag) {
          //  0..25 map to ASCII a..z or A..Z
          // 26..35 map to ASCII 0..9
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * https://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }

        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        function decode(input) {
          // Don't use UCS-2
          var output = [],
              inputLength = input.length,
              out,
              i = 0,
              n = initialN,
              bias = initialBias,
              basic,
              j,
              index,
              oldi,
              w,
              k,
              digit,
              t,

          /** Cached calculation results */
          baseMinusT;

          // Handle the basic code points: let `basic` be the number of input code
          // points before the last delimiter, or `0` if there is none, then copy
          // the first basic code points to the output.

          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }

          for (j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
              error('not-basic');
            }
            output.push(input.charCodeAt(j));
          }

          // Main decoding loop: start just after the last delimiter if any basic code
          // points were copied; start at the beginning otherwise.

          for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

              if (index >= inputLength) {
                error('invalid-input');
              }

              digit = basicToDigit(input.charCodeAt(index++));

              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error('overflow');
              }

              i += digit * w;
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

              if (digit < t) {
                break;
              }

              baseMinusT = base - t;
              if (w > floor(maxInt / baseMinusT)) {
                error('overflow');
              }

              w *= baseMinusT;
            }

            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);

            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
              error('overflow');
            }

            n += floor(i / out);
            i %= out;

            // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);
          }

          return ucs2encode(output);
        }

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        function encode(input) {
          var n,
              delta,
              handledCPCount,
              basicLength,
              bias,
              j,
              m,
              q,
              k,
              t,
              currentValue,
              output = [],

          /** `inputLength` will hold the number of code points in `input`. */
          inputLength,

          /** Cached calculation results */
          handledCPCountPlusOne,
              baseMinusT,
              qMinusT;

          // Convert the input in UCS-2 to Unicode
          input = ucs2decode(input);

          // Cache the length
          inputLength = input.length;

          // Initialize the state
          n = initialN;
          delta = 0;
          bias = initialBias;

          // Handle the basic code points
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
              output.push(stringFromCharCode(currentValue));
            }
          }

          handledCPCount = basicLength = output.length;

          // `handledCPCount` is the number of code points that have been handled;
          // `basicLength` is the number of basic code points.

          // Finish the basic string - if it is not empty - with a delimiter
          if (basicLength) {
            output.push(delimiter);
          }

          // Main encoding loop:
          while (handledCPCount < inputLength) {

            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }

            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error('overflow');
            }

            delta += (m - n) * handledCPCountPlusOne;
            n = m;

            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];

              if (currentValue < n && ++delta > maxInt) {
                error('overflow');
              }

              if (currentValue == n) {
                // Represent delta as a generalized variable-length integer
                for (q = delta, k = base;; /* no condition */k += base) {
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  qMinusT = q - t;
                  baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }

                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }

            ++delta;
            ++n;
          }
          return output.join('');
        }

        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        function toUnicode(input) {
          return mapDomain(input, function (string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }

        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        function toASCII(input) {
          return mapDomain(input, function (string) {
            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
          });
        }

        /*--------------------------------------------------------------------------*/

        /** Define the public API */
        punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          'version': '1.4.1',
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          'ucs2': {
            'decode': ucs2decode,
            'encode': ucs2encode
          },
          'decode': decode,
          'encode': encode,
          'toASCII': toASCII,
          'toUnicode': toUnicode
        };

        /** Expose `punycode` */
        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          define('punycode', function () {
            return punycode;
          });
        } else if (freeExports && freeModule) {
          if (module.exports == freeExports) {
            // in Node.js, io.js, or RingoJS v0.8.0+
            freeModule.exports = punycode;
          } else {
            // in Narwhal or RingoJS v0.7.0-
            for (key in punycode) {
              punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
            }
          }
        } else {
          // in Rhino or a web browser
          root.punycode = punycode;
        }
      })(this);
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {}], 48: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    module.exports = function (qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};

      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }

      var regexp = /\+/g;
      qs = qs.split(sep);

      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }

      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }

      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr,
            vstr,
            k,
            v;

        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }

      return obj;
    };

    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
  }, {}], 49: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    var stringifyPrimitive = function (v) {
      switch (typeof v) {
        case 'string':
          return v;

        case 'boolean':
          return v ? 'true' : 'false';

        case 'number':
          return isFinite(v) ? v : '';

        default:
          return '';
      }
    };

    module.exports = function (obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }

      if (typeof obj === 'object') {
        return map(objectKeys(obj), function (k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (isArray(obj[k])) {
            return map(obj[k], function (v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }

      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };

    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };

    function map(xs, f) {
      if (xs.map) return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
      }
      return res;
    }

    var objectKeys = Object.keys || function (obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
      }
      return res;
    };
  }, {}], 50: [function (require, module, exports) {
    'use strict';

    exports.decode = exports.parse = require('./decode');
    exports.encode = exports.stringify = require('./encode');
  }, { "./decode": 48, "./encode": 49 }], 51: [function (require, module, exports) {
    $__System.register("1e", [], function (_export) {
      "use strict";

      _export("default", require('ajv'));

      return {
        setters: [],
        execute: function () {}
      };
    });
  }, { "ajv": 2 }] }, {}, [51]);
$__System.register('a', ['19', '1a', '1b', '1c', '1d', '1e'], function (_export, _context) {
  "use strict";

  var tldjs, Handlebars, templates, fastUrlParser, jsep, Ajv;
  return {
    setters: [function (_2) {
      tldjs = _2.default;
    }, function (_a) {
      Handlebars = _a.default;
    }, function (_b) {
      templates = _b.default;
    }, function (_c) {
      fastUrlParser = _c.default;
    }, function (_d2) {
      jsep = _d2.default;
    }, function (_e2) {
      Ajv = _e2.default;
    }],
    execute: function () {

      /* global window */
      var window$1 = typeof window !== 'undefined' ? window : undefined;

      /* global global, Services, Components, XPCOMUtils, debugModules */

      Components.utils.import('resource://gre/modules/XPCOMUtils.jsm');
      Components.utils.import('resource://gre/modules/Services.jsm');

      const debugModules = {};

      // TODO: @remusao webrequest-pipeline/page-store require chrome
      const chrome$1 = {};

      const fakeGlobal = Object.create(null);
      /**
       * exporting a global object to allow access to javascript buildins like
       * Object, Symbol
       */
      /* eslint-disable func-names, prefer-arrow-callback, new-cap */
      const safeGlobal = new Proxy(fakeGlobal, {
        get(target, key) {
          if (fakeGlobal[key]) {
            return fakeGlobal[key];
          }

          if (typeof window !== "undefined") {
            return window[key];
          }

          if (typeof global !== "undefined") {
            return global[key];
          }
        }
      });

      var config = {
        "platform": "firefox",
        "baseURL": "chrome://cliqz/content/",
        "testsBasePath": "./build/cliqz@cliqz.com/chrome/content",
        "testem_launchers": ["unit-node", "Chrome"],
        "testem_launchers_ci": ["unit-node"],
        "pack": "cd build && fab package:version=$VERSION,cert_path=$CLIQZ_CERT_PATH,cert_pass_path=$CLIQZ_CERT_PASS_PATH",
        "publish": "cd build && fab publish:beta=$CLIQZ_BETA,channel=$CLIQZ_CHANNEL,pre=$CLIQZ_PRE_RELEASE,version=$VERSION,cert_path=$CLIQZ_CERT_PATH,cert_pass_path=$CLIQZ_CERT_PASS_PATH",
        "settings": {
          "id": "cliqz@cliqz.com",
          "name": "Cliqz",
          "channel": "04",
          "homepageURL": "https://cliqz.com/",
          "freshTabNews": true,
          "showDataCollectionMessage": true,
          "antitrackingButton": true,
          "showNewBrandAlert": false,
          "suggestions": false,
          "ENDPOINT_BLIND_SIGNER": "https://hpn-sign.cliqz.com/sign",
          "ENDPOINT_USER_REG": "https://hpn-sign.cliqz.com/register",
          "ENDPOINT_SOURCE_MAP_PROVIDER": "https://hpn-collector.cliqz.com/sourcemapjson?q=1",
          "ENDPOINT_LOOKUP_TABLE_PROVIDER": "https://hpn-collector.cliqz.com/v2/lookuptable?q=1",
          "ENDPOINT_KEYS_PROVIDER": "https://hpn-collector.cliqz.com/signerKey?q=1",
          "ENDPOINT_PROXY_LIST_PROVIDER": "https://hpn-collector.cliqz.com/v2/proxyList?q=1",
          "ENDPOINT_PATTERNSURL": "https://cdn.cliqz.com/human-web/patterns",
          "ENDPOINT_ANONPATTERNSURL": "https://cdn.cliqz.com/human-web/patterns-anon",
          "ENDPOINT_CONFIGURL": "https://safe-browsing.cliqz.com/config",
          "ENDPOINT_SAFE_QUORUM_ENDPOINT": "https://safe-browsing-quorum.cliqz.com/",
          "ENDPOINT_SAFE_QUORUM_PROVIDER": "https://safe-browsing-quorum.cliqz.com/config",
          "KEY_DS_PUBKEY": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwXo4hXvboKHCggNJ0UNFvZQfDWi0jNcF1kBHthxilMu6LB/hFrSMQ+/FgTqVE36cCezWE0K1UcwmYGVsuqxcvql82RfCmYUVBroJ3UFG8qnetYfU5FOk43C555p5l5HzlF8QilcCUBCO4SCj9lEZ3/8FJboCupTqxEUq7nwUgaNZOiGKMdDUBZJO1tW4LSH4lj9IAZccEJ5HKVmJKopQ3hmzWgDqowxni4NQz+0DnsSfCGAupKaJDxjfajJosX5i674rgdHbZGtgHB3M9jhc6HFNPcmtUgLwgtUtRwMhSnya6q/O06euouNi1h0m5eRrWeMRlJSdUnelLSU8QNy7LQIDAQAB",
          "KEY_SECURE_LOGGER_PUBKEY": "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAh5HhcRAn6+6woXQXl/NtZ+fOooNglZct/HSpYuqkcmrPauHW7EuOSq5bvpBZRTDROjR/kUPomqVZIzqhdCFPA8BwXSCz7hAel2Q157vtBvh9sngMMLXb5Fgzef5N4EuKO8pL5KrS+I9tfZac41vFJSdpgAirZYhh+tdcQQ1z0Qv/Rw0zOXjfvddCz3gEv2gB9KsLMVnTS1J4YOOgfza2adg9Ebz1z99DiF4vtCwn0IUwH/3ToTBwJLbMnC3Ol43yBNk8rgK2mkgCi614vOSD3hnVmio+iW6+AUklM8VPl6l7hEK9cljJY+9UsMVmTrvaFbMPwS6AdZCXKTmNdaMJcy3zSOXu5zvzihoQLwAu9LM3l2eVk0Mw0K7JXOP20fc8BtzWCOLYVP32r4R0BNuhTtvGqjHNZHPJN5OwaxkLpn2dujL9uDWGjRiOItKMVq/nOqmNGghrbf8IOaKT7VQhqOU4cXRkB/uF1UjYETBavwUZAxx9Wd/cMcAGmKiDxighxxQ29jDufl+2WG065tmJz+zCxmgrPh6Zb3KFUxPTe6yksAhWJhmGShA9v20t84M5c6NpZXoUsFcVja6XxzHeSB8dWq9Uu5QcZ83Gz/ronwdEjT2OGTtBgOFeTDqLYUgphC1gcUEHOCnTNXRMQOXqGwBfZHp+Mq61QcMq2rNS7xECAwEAAQ==",
          "HW_CHANNEL": "ff-amo",
          "HPN_CHANNEL": "cliqz",
          "NEW_TAB_URL": "chrome://cliqz/content/freshtab/home.html",
          "ICONS": {
            "active": {
              "default": "control-center/images/cc-active.svg",
              "dark": "control-center/images/cc-active-dark.svg"
            },
            "inactive": {
              "default": "control-center/images/cc-critical.svg",
              "dark": "control-center/images/cc-critical-dark.svg"
            },
            "critical": {
              "default": "control-center/images/cc-critical.svg",
              "dark": "control-center/images/cc-critical-dark.svg"
            }
          },
          "BACKGROUNDS": {
            "active": "#471647",
            "inactive": "#471647",
            "critical": "#471647",
            "off": "#471647"
          },
          "CONFIG_PROVIDER": "https://api.cliqz.com/api/v1/config",
          "OFFERS_BE_BASE_URL": "https://offers-api.cliqz.com",
          "CDN_BASEURL": "https://cdn.cliqz.com",
          "ALLOWED_COUNTRY_CODES": ["de", "at", "ch", "es", "us", "fr", "nl", "gb", "it", "se"],
          "frameScriptWhitelist": []
        },
        "default_prefs": {
          "modules.history-analyzer.enabled": false
        },
        "modules": ["core", "core-cliqz", "dropdown", "firefox-specific", "static", "autocomplete", "geolocation", "ui", "last-query", "human-web", "anti-phishing", "context-menu", "freshtab", "webrequest-pipeline", "antitracking", "performance", "hpn", "control-center", "offers-v2", "history-analyzer", "offers-cc", "browser-panel", "message-center", "offboarding", "anolysis", "market-analysis", "abtests"],
        "subprojects": [{
          "src": "node_modules/@cliqz-oss/pouchdb/dist",
          "include": ["pouchdb.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/handlebars/dist",
          "include": ["handlebars.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/jquery/dist",
          "include": ["jquery.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/mathjs/dist",
          "include": ["math.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/moment/min",
          "include": ["moment.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/moment-range/dist",
          "include": ["moment-range.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/pako/dist",
          "include": ["pako.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/react/umd",
          "include": ["react.production.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/react-dom/umd",
          "include": ["react-dom.production.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/simple-statistics/dist",
          "include": ["simple-statistics.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/ua-parser-js/dist",
          "include": ["ua-parser.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/rxjs/bundles",
          "include": ["Rx.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/tooltipster/dist/css/plugins/tooltipster/sideTip/themes",
          "include": ["tooltipster-sideTip-shadow.min.css"],
          "dest": "vendor"
        }, {
          "src": "node_modules/tooltipster/dist/js",
          "include": ["tooltipster.bundle.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/tooltipster/dist/css",
          "include": ["tooltipster.bundle.min.css"],
          "dest": "vendor"
        }],
        "systemDefault": {
          "transpiler": false,
          "packageConfigPaths": ["node_modules/*/package.json"],
          "map": {
            "handlebars": "node_modules/handlebars/dist/handlebars.min.js",
            "jquery": "node_modules/jquery/dist/jquery.min.js",
            "mathjs": "node_modules/mathjs/dist/math.min.js",
            "BigInt": "node_modules/BigInt/src/BigInt.js",
            "react": "node_modules/react/cjs/react.production.min.js",
            "chai": "node_modules/chai/chai.js",
            "chai-dom": "node_modules/chai-dom/chai-dom.js",
            "react-dom": "node_modules/react-dom/cjs/react-dom.production.min.js",
            "qrcodejs": "node_modules/qrcodejs/qrcode.min.js",
            "plugin-json": "node_modules/systemjs-plugin-json/json.js"
          },
          "paths": {
            "specific/*": "./specific/firefox/*",
            "modules/*": "modules/*",
            "modules": "modules",
            "node_modules/*": "./node_modules/*",
            "*": "./node_modules/*"
          },
          "meta": {
            "specific/*": {
              "format": "global"
            },
            "BigInt": {
              "format": "cjs"
            },
            "*.json": {
              "loader": "plugin-json"
            }
          },
          "packages": {
            "object-assign": {
              "main": "./index.js"
            },
            "modules": {
              "defaultJSExtensions": true,
              "map": {
                "./platform/tldjs": "node_modules/tldjs/index.js"
              },
              "meta": {
                "./platform/lib/zlib.lib.js": {
                  "format": "cjs"
                },
                "./platform/lib/sanitize-filename.js": {
                  "format": "system"
                },
                "./platform/lib/cron-parser.js": {
                  "format": "system"
                },
                "./platform/video-downloader/lib/ytdl-core.js": {
                  "format": "system"
                },
                "./platform/fast-url-parser.js": {
                  "format": "system"
                },
                "./platform/lib/deep-equal.js": {
                  "format": "system"
                },
                "./platform/lib/ajv.js": {
                  "format": "system"
                },
                "./platform/lib/jsep.js": {
                  "format": "system"
                },
                "*/templates.js": {
                  "format": "system"
                }
              }
            }
          }
        },
        "builderDefault": {
          "externals": ["react", "react-dom", "jquery", "handlebars", "mathjs"],
          "globalDeps": {
            "react": "React",
            "react-dom": "ReactDOM",
            "jquery": "$",
            "handlebars": "Handlebars",
            "mathjs": "mathLib"
          },
          "sourceMaps": false,
          "lowResSourceMaps": true,
          "sourceMapContents": true,
          "globalName": "CliqzGlobal",
          "rollup": true
        },
        "bundleConfigs": {
          "modules/core/app.bundle.js": {
            "systemConfig": {
              "transpiler": false,
              "packageConfigPaths": ["node_modules/*/package.json"],
              "map": {
                "handlebars": "node_modules/handlebars/dist/handlebars.min.js",
                "jquery": "node_modules/jquery/dist/jquery.min.js",
                "mathjs": "node_modules/mathjs/dist/math.min.js",
                "BigInt": "node_modules/BigInt/src/BigInt.js",
                "react": "node_modules/react/cjs/react.production.min.js",
                "chai": "node_modules/chai/chai.js",
                "chai-dom": "node_modules/chai-dom/chai-dom.js",
                "react-dom": "node_modules/react-dom/cjs/react-dom.production.min.js",
                "qrcodejs": "node_modules/qrcodejs/qrcode.min.js",
                "plugin-json": "node_modules/systemjs-plugin-json/json.js"
              },
              "paths": {
                "specific/*": "./specific/firefox/*",
                "modules/*": "modules/*",
                "modules": "modules",
                "node_modules/*": "./node_modules/*",
                "*": "./node_modules/*"
              },
              "meta": {
                "specific/*": {
                  "format": "global"
                },
                "BigInt": {
                  "format": "cjs"
                },
                "*.json": {
                  "loader": "plugin-json"
                }
              },
              "packages": {
                "object-assign": {
                  "main": "./index.js"
                },
                "modules": {
                  "defaultJSExtensions": true,
                  "map": {
                    "./platform/tldjs": "node_modules/tldjs/index.js"
                  },
                  "meta": {
                    "./platform/lib/zlib.lib.js": {
                      "format": "cjs"
                    },
                    "./platform/lib/sanitize-filename.js": {
                      "format": "system"
                    },
                    "./platform/lib/cron-parser.js": {
                      "format": "system"
                    },
                    "./platform/video-downloader/lib/ytdl-core.js": {
                      "format": "system"
                    },
                    "./platform/fast-url-parser.js": {
                      "format": "system"
                    },
                    "./platform/lib/deep-equal.js": {
                      "format": "system"
                    },
                    "./platform/lib/ajv.js": {
                      "format": "system"
                    },
                    "./platform/lib/jsep.js": {
                      "format": "system"
                    },
                    "*/templates.js": {
                      "format": "system"
                    }
                  }
                },
                "modules/dropdown": {
                  "handlebars": "../platform/lib/handlebars"
                }
              }
            },
            "builderConfig": {
              "externals": ["mathjs"],
              "globalDeps": {
                "mathjs": "mathLib"
              },
              "sourceMaps": false,
              "lowResSourceMaps": true,
              "sourceMapContents": true,
              "globalName": "CliqzGlobal",
              "rollup": true
            }
          }
        },
        "environment": "production",
        "sourceMaps": false,
        "debugPages": true,
        "EXTENSION_VERSION": "2.24.8",
        "instrumentFunctions": ""
      };

      /* global Components, console */
      try {
        Components.utils.import("resource://gre/modules/Console.jsm");
      } catch (e) {
        // Older version of Firefox
        Components.utils.import("resource://gre/modules/devtools/Console.jsm");
      }

      const prefs$1 = Services.prefs.getBranch('');
      const complexRegEx = /^chrome:\/\/.+\/locale\/.+\.properties/;

      function prefixPref(pref) {
        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'extensions.cliqz.';

        return `${prefix}${pref}`;
      }

      function getPref(key, defaultValue, prefix) {
        const pref = prefixPref(key, prefix);
        try {
          switch (prefs$1.getPrefType(pref)) {
            case 128:
              return prefs$1.getBoolPref(pref);
            case 32:
              {
                let charVal = prefs$1.getCharPref(pref);

                // it might be a complex value
                if (complexRegEx.test(charVal)) {
                  try {
                    charVal = prefs$1.getComplexValue(pref, Components.interfaces.nsIPrefLocalizedString).data;
                  } catch (e) {
                    console.log(`Error fetching pref: ${pref}`);
                  }
                }

                return charVal;
              }
            case 64:
              return prefs$1.getIntPref(pref);
            default:
              return defaultValue;
          }
        } catch (e) {
          return defaultValue;
        }
      }

      function setPref(key, value, prefix) {
        const pref = prefixPref(key, prefix);

        switch (typeof value) {
          case 'boolean':
            prefs$1.setBoolPref(pref, value);break;
          case 'number':
            prefs$1.setIntPref(pref, value);break;
          case 'string':
            prefs$1.setCharPref(pref, value);break;
          default:
            Services.console.logStringMessage('WARNING: Unable to save "' + pref);break;
        }
      }

      function hasPref(key, prefix) {
        const pref = prefixPref(key, prefix);
        return prefs$1.getPrefType(pref) !== 0;
      }

      function clearPref(key, prefix) {
        const pref = prefixPref(key, prefix);
        prefs$1.clearUserPref(pref);
      }

      function enableChangeEvents() {}

      function disableChangeEvents() {}

      function init$1() {
        return Promise.resolve();
      }

      var prefs = {
        /**
         * Get a value from preferences db
         * @param {string}  pref - preference identifier
         * @param {*=}      defautlValue - returned value in case pref is not defined
         * @param {string=} prefix - prefix for pref
         */
        get: getPref,
        /**
         * Set a value in preferences db
         * @param {string}  pref - preference identifier
         * @param {string=} prefix - prefix for pref
         */
        set: setPref,
        /**
         * Check if there is a value in preferences db
         * @param {string}  pref - preference identifier
         * @param {string=} prefix - prefix for pref
         */
        has: hasPref,
        /**
         * Clear value in preferences db
         * @param {string}  pref - preference identifier
         * @param {string=} prefix - prefix for pref
         */
        clear: clearPref,

        enableChangeEvents,

        disableChangeEvents,

        /**
         * Set a value of type object in preferences db
         * @param {string}  pref - preference identifier
         */
        getObject(key) {
          return JSON.parse(this.get(key, '{}'));
        },

        /**
         * Set a value in preferences db
         * @param {string}  pref - preference identifier
         * @param {object|function}
         */
        setObject(key, value) {
          if (value instanceof Function) {
            const prevValue = this.getObject(key);
            const newValue = value(prevValue);
            this.setObject(key, newValue);
          } else if (typeof value === 'object') {
            this.set(key, JSON.stringify(value));
          } else {
            throw new TypeError();
          }
        },

        init: init$1

      };

      /* globals __DEV__ */
      // detect dev flag on react-native
      const devMode = typeof global !== 'undefined' && global.__DEV__ === true;
      // either take flag from prefs, or global dev mode flag
      // We need to put a try, catch, to avoid content-scripts throwing error, while trying to get the prefs.
      // Should look for a cleaner solutions at some point. for isLoggingEnabled, isDeveloper.

      function isLoggingEnabled() {
        try {
          return prefs.get('showConsoleLogs', devMode || false);
        } catch (ee) {
          return false;
        }
      }

      function isDeveloper() {
        try {
          return prefs.get('developer', devMode || false);
        } catch (ee) {
          return false;
        }
      }

      let log$1;
      let error$1;
      let debug;
      let warn;

      if (isLoggingEnabled()) {
        log$1 = console.log.bind(console, 'Cliqz');
        error$1 = console.error.bind(console, 'Cliqz error');
        warn = console.warn.bind(console, 'Cliqz warning');
        if (isDeveloper()) {
          debug = log$1;
        } else {
          debug = () => {};
        }
      } else {
        log$1 = () => {};
        error$1 = () => {};
        debug = () => {};
        warn = () => {};
      }

      var console$1 = {
        log: log$1,
        error: error$1,
        debug,
        warn
      };

      function nextTick(fn) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        return Promise.resolve().then(() => fn(...args));
      }

      /*
       * This method implements the publish subscribe design pattern
       *
       * Event naming scheme:
       *    cliqz.module_name.event_name
       *
       *  single sender -> multiple potential recipients
       *    for example: cliqz.core.urlbar_focus (inform others about urlbar focus)
       *    module_name describes sender
       *  multiple potential senders -> single recipient
       *    for example: cliqz.msg_center.show_message (tell the message center to show a message)
       *    module_name describes recipient (this is more like a RPC)
       */

      var CliqzEvents = CliqzEvents || {
        //use a javascript object to push the message ids and the callbacks
        cache: {},
        tickCallbacks: [],
        /*
         * Publish events of interest with a specific id
         */
        queue: [],

        pub: function pub(id) {
          const args = Array.prototype.slice.call(arguments, 1);

          const callbacks = (CliqzEvents.cache[id] || []).map(ev => {
            return nextTick(() => {
              ev.apply(null, args);
            }).catch(e => {
              console$1.error(`CliqzEvents error: ${id}`, e);
            });
          });

          const finishedPromise = Promise.all(callbacks).then(() => {
            const index = this.queue.indexOf(finishedPromise);
            this.queue.splice(index, 1);
            if (this.queue.length === 0) {
              this.triggerNextTick();
            }
          });
          this.queue.push(finishedPromise);
        },

        triggerNextTick() {
          this.tickCallbacks.forEach(cb => {
            try {
              cb();
            } catch (e) {}
          });
          this.tickCallbacks = [];
        },

        nextTick() {
          let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};

          this.tickCallbacks = this.tickCallbacks || [];
          this.tickCallbacks.push(cb);
        },

        /* Subscribe to events of interest
         * with a specific id and a callback
         * to be executed when the event is observed
         */
        sub: function sub(id, fn) {
          CliqzEvents.cache[id] = CliqzEvents.cache[id] || [];
          CliqzEvents.cache[id].push(fn);
        },

        subscribe(eventName, callback, that) {
          let cb;
          if (that) {
            cb = callback.bind(that);
          } else {
            cb = callback;
          }

          CliqzEvents.sub(eventName, cb);

          return {
            unsubscribe() {
              CliqzEvents.un_sub(eventName, cb);
            }
          };
        },

        un_sub: function un_sub(id, fn) {
          if (!CliqzEvents.cache[id] || CliqzEvents.cache[id].length === 0) {
            console$1.error(id, "Trying to unsubscribe event that had no subscribers");
            return;
          }

          let index = CliqzEvents.cache[id].indexOf(fn);
          if (index > -1) {
            CliqzEvents.cache[id].splice(index, 1);
          } else {
            console$1.error(id, "Trying to unsubscribe an unknown listener");
          }
        },

        clean_channel: function clean_channel(id) {
          if (!CliqzEvents.cache[id]) {
            throw "Trying to unsubscribe an unknown channel";
          }
          CliqzEvents.cache[id] = [];
        },

        /**
         * Adds a listener to eventTarget for events of type eventType, and republishes them
         *  through CliqzEvents with id cliqzEventName.
         */
        proxyEvent(cliqzEventName, eventTarget, eventType) {
          let propagate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          let transform = arguments[4];

          const publisher = CliqzEvents.pub.bind(CliqzEvents, cliqzEventName);

          function handler() {
            const args = transform ? transform.apply(null, arguments) : arguments;
            publisher.apply(null, args);
          }

          eventTarget.addEventListener(eventType, handler, propagate);
          return {
            unsubscribe() {
              eventTarget.removeEventListener(eventType, handler);
            }
          };
        },

        nextId: function nextId() {
          nextId.id = nextId.id || 0;
          nextId.id += 1;
          return nextId.id;
        }
      };

      let subscribe = CliqzEvents.subscribe;

      // String compression used Firefox API.
      // Based on https://gist.github.com/Endyl/c12438b6e68bbca1bab5
      const CC = Components.Constructor;
      const Ci$2 = Components.interfaces;
      const Cc$1 = Components.classes;

      const UncompressConverter = CC('@mozilla.org/streamconv;1?from=gzip&to=uncompressed', 'nsIStreamConverter', 'asyncConvertData');
      const CompressConverter = CC('@mozilla.org/streamconv;1?from=uncompressed&to=gzip', 'nsIStreamConverter', 'asyncConvertData');
      const StringInputStream = CC('@mozilla.org/io/string-input-stream;1', 'nsIStringInputStream');

      /**
       * For request simulation
       */
      function Accumulator() {
        this.buffer = [];
      }
      Accumulator.prototype = {
        buffer: null,
        onStartRequest: function onStartRequest(aRequest, aContext) {},
        onStopRequest: function onStopRequest(aRequest, aContext, aStatusCode) {},
        onDataAvailable: function onDataAvailable(aRequest, aContext, aInputStream, aOffset, aCount) {
          var stream, input;

          stream = Cc$1["@mozilla.org/binaryinputstream;1"].createInstance(Ci$2.nsIBinaryInputStream);
          stream.setInputStream(aInputStream);

          input = stream.readByteArray(aCount);

          this.buffer = this.buffer.concat(input);
        }
      };

      function simulateRequest(aConverter, aStream, aContentLength) {
        aConverter.onStartRequest(null, null);
        aConverter.onDataAvailable(null, null, aStream, 0, aContentLength);
        aConverter.onStopRequest(null, null, 201 /* 417 */);
      }

      function compressString(aString) {
        var accumulator, converter, stream, utf8String;

        // Converts a Javascript string into UTF-8 encoding
        // (see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html)
        utf8String = unescape(encodeURIComponent(aString));
        accumulator = new Accumulator();
        converter = new CompressConverter('uncompresssed', 'gzip', accumulator, null);
        stream = new StringInputStream();
        stream.data = utf8String;
        simulateRequest(converter, stream, utf8String.length);

        return Uint8Array.from(accumulator.buffer);
      }

      function uncompressString(aString) {
        var accumulator, converter, stream;

        accumulator = new Accumulator();
        converter = new UncompressConverter('gzip', 'uncompressed', accumulator, null);
        stream = new StringInputStream();
        stream.data = String.fromCharCode.apply(null, aString);
        simulateRequest(converter, stream, aString.length);

        return String.fromCharCode.apply(null, accumulator.buffer);
      }

      function compatabilityCheck() {
        return Uint8Array.from !== undefined;
      }

      var compress$1 = false;
      var decompress$1 = false;

      if (compatabilityCheck()) {
        compress$1 = compressString;
        decompress$1 = uncompressString;
      }

      /**
       *  Compress a string
       *
       *  @param {string} string to compress
       *  @returns {UInt8Array} compressed data
       */
      let compress$$1 = compress$1 || false;

      /**
       *  Decompress a Gzip compressed string
       *
       *  @param {UInt8Array} gzipped data
       *  @returns {string} decompressed string
       */

      const Ci$3 = Components.interfaces;

      let XMLHttpRequestFactory = () => {
        if (typeof XMLHttpRequest === 'undefined') {
          // imported by default in bootstrap scope but not present in
          // process scripts by default
          Components.utils.importGlobalProperties(['XMLHttpRequest']);
        }
        return XMLHttpRequest;
      };

      function setPrivateFlags(request) {
        if (request.channel) {
          request.channel.loadFlags |= Ci$3.nsIRequest.LOAD_ANONYMOUS | Ci$3.nsIRequest.LOAD_BYPASS_CACHE | Ci$3.nsIRequest.INHIBIT_PERSISTENT_CACHING;
        }
      }

      function setBackgroundRequest(request) {
        req.mozBackgroundRequest = true;
      }

      const chromeUrlHandler = false;

      /* global fetch */
      if (typeof fetch === 'undefined') {
        Components.utils.importGlobalProperties(['fetch']);
      }

      function fetchFactory() {
        return fetch;
      }

      /** Legacy httpHandler implementation, based on XMLHttpRequest.
       *
       *  If you want to make HTTP requests, please check out the fetch API (platform/fetch)
       */
      function defaultHttpHandler(method, url, callback, onerror, timeout, data, sync, encoding, background) {
        if (method === 'GET' && url.startsWith('chrome://') && chromeUrlHandler) {
          chromeUrlHandler(url, callback, onerror);
          return;
        }
        const XMLHttpRequest = XMLHttpRequestFactory();
        var req = new XMLHttpRequest();
        req.timestamp = +new Date();
        if (background) {
          setBackgroundRequest(req);
        }
        req.open(method, url, !sync);
        setPrivateFlags(req);
        req.overrideMimeType && req.overrideMimeType('application/json');
        req.setRequestHeader('Content-Type', 'application/json');

        // headers for compressed data
        if (encoding) {
          req.setRequestHeader('Content-Encoding', encoding);
        }

        req.onload = function () {
          if (!parseInt) return; //parseInt is not a function after extension disable/uninstall

          var statusClass = parseInt(req.status / 100);
          if (statusClass == 2 || statusClass == 3 || statusClass == 0 /* local files */) {
              callback && callback(req);
            } else {
            const error = `loaded with non-200 ${url} (status=${req.status} ${req.statusText}) CLIQZEnvironment.httpHandler`;
            console$1.log(error);
            onerror && onerror(error);
          }
        };
        req.onerror = function () {
          const error = `error loading ${url} (status=${req.status} ${req.statusText}) CLIQZEnvironment.httpHandler`;
          console$1.log(error);
          onerror && onerror(error);
        };
        req.ontimeout = function () {
          const error = `timeout for ${url} CLIQZEnvironment.httpHandler`;
          console$1.log(error);
          onerror && onerror(error);
        };

        if (callback) {
          if (timeout) {
            req.timeout = parseInt(timeout);
          } else {
            req.timeout = ['POST', 'PUT'].indexOf(method) >= 0 ? 10000 : 1000;
          }
        }

        req.send(data);
        return req;
      }

      let activeHandler = defaultHttpHandler;

      function httpHandler$1() {
        return activeHandler(...arguments);
      }

      /**
       *  Replace default http handler with fn
       */
      function overrideHttpHandler(fn) {
        activeHandler = fn;
      }

      const compressionAvailable = Boolean(compress$$1);
      let compressionExclusions = new Set();

      function compressionEnabled(url) {
        return compressionAvailable && !compressionExclusions.has(url);
      }

      /**
       *  Add a url for which we should not compress when using promiseHttpHandler
       */
      function addCompressionExclusion(url) {
        compressionExclusions.add(url);
      }

      function promiseHttpHandler(method, url, data, timeout, compressedPost) {
        return new Promise(function (resolve, reject) {
          // gzip.compress may be false if there is no implementation for this platform
          // or maybe it is not loaded yet
          if (method === 'POST' && compressedPost && compressionEnabled(url)) {
            const dataLength = data.length;
            data = compress$$1(data);
            console$1.log("Compressed request to " + url + ", bytes saved = " + (dataLength - data.length) + " (" + (100 * (dataLength - data.length) / dataLength).toFixed(1) + "%)", "CLIQZEnvironment.httpHandler");
            httpHandler$1(method, url, resolve, reject, timeout, data, undefined, 'gzip');
          } else {
            httpHandler$1(method, url, resolve, reject, timeout, data);
          }
        });
      }

      // TODO: please just use Components
      const Cu$1 = Components.utils;
      const Ci$1 = Components.interfaces;
      const Cc = Components.classes;

      try {
        Cu$1.import('resource://gre/modules/XPCOMUtils.jsm');
        Cu$1.import('resource://gre/modules/NewTabUtils.jsm');
      } catch (e) {}

      var CLIQZEnvironment = {
        setTimeout,
        setInterval,
        clearTimeout,
        clearInterval,
        Promise,
        RESULTS_PROVIDER: 'https://api.cliqz.com/api/v2/results?nrh=1&q=',
        RICH_HEADER: 'https://api.cliqz.com/api/v2/rich-header?path=/v2/map',
        LOG: 'https://stats.cliqz.com',
        TEMPLATES_PATH: 'chrome://cliqz/content/static/templates/',
        SKIN_PATH: 'chrome://cliqz/content/static/skin/',
        prefs: Cc['@mozilla.org/preferences-service;1'].getService(Ci$1.nsIPrefService).getBranch(''),
        RERANKERS: [],
        RESULTS_TIMEOUT: 1000, // 1 second
        TEMPLATES: {},
        MESSAGE_TEMPLATES: [],
        PARTIALS: [],
        CLIQZ_ONBOARDING: "about:onboarding",
        CLIQZ_ONBOARDING_URL: "chrome://cliqz/content/onboarding-v3/index.html",
        BASE_CONTENT_URL: "chrome://cliqz/content/",
        BROWSER_ONBOARDING_PREF: "browserOnboarding",

        init: function init() {},

        unload: function unload() {},

        getAllCliqzPrefs: function getAllCliqzPrefs() {
          return Cc['@mozilla.org/preferences-service;1'].getService(Ci$1.nsIPrefService).getBranch('extensions.cliqz.').getChildList('');
        },

        isUnknownTemplate: function isUnknownTemplate(template) {
          return template && CLIQZEnvironment.TEMPLATES.hasOwnProperty(template) == false;
        },
        isDefaultBrowser: function isDefaultBrowser() {
          try {
            var shell = Components.classes["@mozilla.org/browser/shell-service;1"].getService(Components.interfaces.nsIShellService);
            if (shell) {
              return shell.isDefaultBrowser(false);
            }
          } catch (e) {}

          return null;
        },
        openLink: function openLink(win, url, newTab, newWindow, newPrivateWindow, focus) {
          // make sure there is a protocol (this is required
          // for storing it properly in Firefoxe's history DB)
          if (url.indexOf("://") == -1 && url.trim().indexOf('about:') != 0) {
            url = "http://" + url;
          }

          // Firefox history boosts URLs that are typed in the URL bar, autocompleted,
          // or selected from the history dropbdown; thus, mark page the user is
          // going to see as "typed" (i.e, the value Firefox would assign to such URLs)
          try {
            var historyService = Cc["@mozilla.org/browser/nav-history-service;1"].getService(Ci$1.nsINavHistoryService);
            var ioService = Components.classes["@mozilla.org/network/io-service;1"].getService(Components.interfaces.nsIIOService);
            var urlObject = ioService.newURI(url, null, null);
            historyService.markPageAsTyped(urlObject);
          } catch (e) {}

          if (newTab) {
            const tab = win.gBrowser.addTab(url);
            if (focus) {
              win.gBrowser.selectedTab = tab;
            }
            return tab;
          } else if (newWindow) {
            win.open(url, '_blank');
          } else if (newPrivateWindow) {
            win.openLinkIn(url, "window", { private: true });
          } else {
            // Set urlbar value to url immediately
            if (win.CLIQZ.Core.urlbar) {
              win.CLIQZ.Core.urlbar.value = url;
            }
            //win.openUILink(url);
            win.gBrowser.loadURI(url);
          }
        },
        copyResult: function copyResult(val) {
          var gClipboardHelper = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper);
          gClipboardHelper.copyString(val);
        },
        isPrivate: function isPrivate(win) {
          // try to get the current active window
          if (!win) win = CLIQZEnvironment.getWindow();

          // return false if we still do not have a window
          if (!win) return false;

          if (win && win.cliqzIsPrivate === undefined) {
            try {
              // Firefox 20+
              Cu$1.import('resource://gre/modules/PrivateBrowsingUtils.jsm');
              win.cliqzIsPrivate = PrivateBrowsingUtils.isWindowPrivate(win);
            } catch (e) {
              // pre Firefox 20
              try {
                win.cliqzIsPrivate = Cc['@mozilla.org/privatebrowsing;1'].getService(Ci$1.nsIPrivateBrowsingService).privateBrowsingEnabled;
              } catch (ex) {
                Cu$1.reportError(ex);
                win.cliqzIsPrivate = true;
              }
            }
          }

          return win.cliqzIsPrivate;
        },

        /**
         * @param {ChromeWindow} win - browser window to check.
         * @return whether |win|'s current tab is in private mode.
         */
        isOnPrivateTab: function isOnPrivateTab(win) {
          return win && win.gBrowser.selectedBrowser !== undefined && win.gBrowser.selectedBrowser.loadContext.usePrivateBrowsing;
        },

        getWindow: function getWindow() {
          var wm = Cc['@mozilla.org/appshell/window-mediator;1'].getService(Ci$1.nsIWindowMediator);
          return wm.getMostRecentWindow("navigator:browser");
        },
        getWindowID: function getWindowID(win) {
          win = win || CLIQZEnvironment.getWindow();
          var util = win.QueryInterface(Ci$1.nsIInterfaceRequestor).getInterface(Ci$1.nsIDOMWindowUtils);
          return util.outerWindowID;
        },
        openTabInWindow: function openTabInWindow(win, url) {
          let relatedToCurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          var tBrowser = win.document.getElementById('content');
          var tab = tBrowser.addTab(url, { relatedToCurrent: relatedToCurrent });
          tBrowser.selectedTab = tab;
        },
        // TODO: move this
        trk: [],
        telemetry: function (url) {
          var trkTimer = null,
              telemetrySeq = -1,
              telemetryReq = null,
              telemetrySending = [],
              TELEMETRY_MAX_SIZE = 500;

          function getNextSeq() {
            if (telemetrySeq == -1) telemetrySeq = prefs.get('telemetrySeq', 0);

            telemetrySeq = (telemetrySeq + 1) % 2147483647;

            return telemetrySeq;
          }

          function pushTelemetry() {
            prefs.set('telemetrySeq', telemetrySeq);
            if (telemetryReq) return;

            // put current data aside in case of failure
            telemetrySending = CLIQZEnvironment.trk.slice(0);
            CLIQZEnvironment.trk = [];

            console$1.log('push telemetry data: ' + telemetrySending.length + ' elements', "pushTelemetry");

            telemetryReq = promiseHttpHandler('POST', CLIQZEnvironment.LOG, JSON.stringify(telemetrySending), 10000, true);
            telemetryReq.then(pushTelemetryCallback);
            telemetryReq.catch(pushTelemetryError);
          }

          function pushTelemetryCallback(req) {
            try {
              var response = JSON.parse(req.response);

              if (response.new_session) {
                prefs.set('session', response.new_session);
              }
              telemetrySending = [];
              telemetryReq = null;
            } catch (e) {}
          }

          function pushTelemetryError(req) {
            // pushTelemetry failed, put data back in queue to be sent again later
            console$1.log('push telemetry failed: ' + telemetrySending.length + ' elements', "pushTelemetry");
            CLIQZEnvironment.trk = telemetrySending.concat(CLIQZEnvironment.trk);

            // Remove some old entries if too many are stored, to prevent unbounded growth when problems with network.
            var slice_pos = CLIQZEnvironment.trk.length - TELEMETRY_MAX_SIZE + 100;
            if (slice_pos > 0) {
              console$1.log('discarding ' + slice_pos + ' old telemetry data', "pushTelemetry");
              CLIQZEnvironment.trk = CLIQZEnvironment.trk.slice(slice_pos);
            }

            telemetrySending = [];
            telemetryReq = null;
          }

          return function (msg, instantPush) {
            // no telemetry in private windows & tabs
            if (msg.type !== 'environment' && CliqzUtils.isPrivateMode()) {
              return;
            }

            console$1.log(msg, 'Utils.telemetry');
            if (!prefs.get('telemetry', true)) return;
            msg.session = prefs.get('session');
            msg.ts = Date.now();
            msg.seq = getNextSeq();

            CLIQZEnvironment.trk.push(msg);
            CLIQZEnvironment.clearTimeout(trkTimer);
            if (instantPush || CLIQZEnvironment.trk.length % 100 == 0) {
              pushTelemetry();
            } else {
              trkTimer = CLIQZEnvironment.setTimeout(pushTelemetry, 60000);
            }
          };
        }(),
        _isSearchServiceInitialized: (() => {
          if (Services.search.init) {
            Services.search.init(() => {
              CLIQZEnvironment._isSearchServiceInitialized = true;
            });
            return false;
          }
          return true;
        })(),
        getDefaultSearchEngine() {
          var searchEngines = CLIQZEnvironment.getSearchEngines();
          return searchEngines.filter(function (se) {
            return se.default;
          })[0];
        },
        getSearchEngines: function getSearchEngines() {
          let blackListed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          const SEARCH_ENGINES = CLIQZEnvironment._isSearchServiceInitialized ? {
            defaultEngine: Services.search.defaultEngine,
            engines: Services.search.getEngines()
          } : {
            defaultEngine: null,
            engines: []
          };

          return SEARCH_ENGINES.engines.filter(e => !e.hidden && e.iconURI != null && blackListed.indexOf(e.name) < 0).map(e => {
            return {
              name: e.name,
              alias: e.alias,
              default: e === SEARCH_ENGINES.defaultEngine,
              icon: e.iconURI.spec,
              base_url: e.searchForm,
              urlDetails: CliqzUtils.getDetailsFromUrl(e.searchForm),
              getSubmissionForQuery: function getSubmissionForQuery(q, type) {
                // 'keyword' is used by one of the Mozilla probes
                // to measure source for search actions
                // https://dxr.mozilla.org/mozilla-central/rev/e4107773cffb1baefd5446666fce22c4d6eb0517/browser/locales/searchplugins/google.xml#15
                const submission = e.getSubmission(q, type, 'keyword');

                // some engines cannot create submissions for all types
                // eg 'application/x-suggestions+json'
                if (submission) {
                  return submission.uri.spec;
                } else {
                  return null;
                }
              }
            };
          });
        },

        updateAlias: function updateAlias(name, newAlias) {
          Services.search.getEngineByName(name).alias = newAlias;
        },
        getEngineByAlias: function getEngineByAlias(alias) {
          return CLIQZEnvironment.getSearchEngines().find(engine => {
            return engine.alias === alias;
          });
        },
        getEngineByName: function getEngineByName(name) {
          return CLIQZEnvironment.getSearchEngines().find(engine => {
            return engine.name === name;
          });
        },
        addEngineWithDetails: function addEngineWithDetails(engine) {
          const existedEngine = Services.search.getEngineByName(engine.name);
          if (existedEngine) {
            // Update the engine alias in case it has been removed
            if (!existedEngine.alias) {
              existedEngine.alias = engine.key;
            }

            return;
          }

          Services.search.addEngineWithDetails(engine.name, engine.iconURL, engine.key, engine.name, engine.method, engine.url);
          if (engine.encoding) {
            Services.search.getEngineByName(engine.name).wrappedJSObject._queryCharset = engine.encoding;
          }
        },
        /* eslint no-param-reassign: ["error", { "props": false }] */
        restoreHiddenSearchEngines: function restoreHiddenSearchEngines() {
          // YouTube - special case
          const SEARCH_ENGINE_ALIAS = {
            youtube: '#yt',
            'youtube-de': '#yt'
          };

          Services.search.getEngines().forEach(e => {
            if (e.hidden === true) {
              e.hidden = false;
              // Restore the alias as well
              if (!e.alias && e.identifier) {
                if (SEARCH_ENGINE_ALIAS[e.identifier]) {
                  e.alias = SEARCH_ENGINE_ALIAS[e.identifier];
                } else {
                  e.alias = `#${e.identifier.toLowerCase().substring(0, 2)}`;
                }
              }
            }
          });
        },
        /*
          We want to remove the search engine in order to update it by addEngineWithDetails function
          If the search engines are stored in user profile, we can remove them
        */
        removeEngine: function removeEngine(name) {
          let engine = Services.search.getEngineByName(name);
          if (engine) {
            Services.search.removeEngine(engine);
          }
          // Check if the engine has been removed or not
          engine = Services.search.getEngineByName(name);
          // If not, search engines cannot be removed since they are stored in global location
          // removeEngine will just hide the engine, we can restore it by unhiding it
          if (engine) {
            engine.hidden = false;
          }
        },
        // from ContextMenu
        openPopup: function openPopup(contextMenu, ev, x, y) {
          contextMenu.openPopupAtScreen(x, y, false);
        },
        /**
         * Construct a uri from a url
         * @param {string}  aUrl - url
         * @param {string}  aOriginCharset - optional character set for the URI
         * @param {nsIURI}  aBaseURI - base URI for the spec
         */
        makeUri: function makeUri(aUrl, aOriginCharset, aBaseURI) {
          var uri;
          try {
            uri = Services.io.newURI(aUrl, aOriginCharset, aBaseURI);
          } catch (e) {
            uri = null;
          }
          return uri;
        },
        getNoResults: function getNoResults(q) {

          var res = CLIQZEnvironment.Result.cliqz({
            template: 'noResult',
            snippet: {},
            type: 'rh',
            subType: { empty: true }
          }, q);

          return res;
        }
      };

      /*
       * In Firefox this method will return undefined is called too early in
       * browser lifecycle. On some older versions like 2x it may even crash
       * entire process.
       */
      var getStorage = function () {
        let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "chrome://cliqz/content/";

        const uri = Services.io.newURI(url, '', null);
        const ssm = Components.classes['@mozilla.org/scriptsecuritymanager;1'].getService(Components.interfaces.nsIScriptSecurityManager);

        const principal = ssm.createCodebasePrincipal(uri, {});

        const dsm = Components.classes['@mozilla.org/dom/localStorage-manager;1'].getService(Components.interfaces.nsIDOMStorageManager);

        if (dsm.getLocalStorageForPrincipal) {
          return dsm.getLocalStorageForPrincipal(principal, '');
        } else {
          // FF57 +
          const win = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator).getMostRecentWindow("navigator:browser");

          return dsm.createStorage(win, principal, '');
        }
      };

      /**
      * @namespace core
      */
      class Storage {

        constructor(url) {
          // if not called as constructor, still act as one
          if (!(this instanceof Storage)) {
            return new Storage(url);
          }

          this.storage = getStorage.bind(null, url);
          this.url = url;
        }

        getItem(key) {
          return this.storage().getItem(key);
        }

        setItem(key, value) {
          return this.storage().setItem(key, value);
        }

        removeItem(key) {
          return this.storage().removeItem(key);
        }

        clear() {
          return this.storage().clear();
        }

        /**
         * @method setObject
         * @param key {string}
         * @param object
         */
        setObject(key, object) {
          this.storage().setItem(key, JSON.stringify(object));
        }

        /**
         * @method getObject
         * @param key {string}
         * @param notFound {Boolean}
         */
        getObject(key) {
          let notFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          const o = this.storage().getItem(key);
          if (o) {
            return JSON.parse(o);
          }
          return notFound;
        }
      }

      function isURI(text) {
        try {
          Services.io.newURI(text, 'UTF-8', null);
          return true;
        } catch (e) {
          return false;
        }
      }

      class URI {
        constructor(url) {
          this.uri = Services.io.newURI(url, 'UTF-8', null);
        }

        get cleanHost() {
          let cleanHost = this.uri.host;
          if (this.uri.host.toLowerCase().indexOf('www.') === 0) {
            cleanHost = this.uri.host.slice(4);
          }
          return cleanHost;
        }
        get path() {
          // Services.io.newURI().path changed in Fx 57 and returns undefined
          // in case there is no path. It was returning '/' in Fx56 and bellow
          return this.uri.path || '/';
        }
      }

      function fixURL(url) {
        let fixedURL = url;
        let redirectedToSearch = false;
        /* eslint-disable no-bitwise */
        const fixupFlags = Services.uriFixup.FIXUP_FLAG_NONE | Services.uriFixup.FIXUP_FLAGS_MAKE_ALTERNATE_URI | Services.uriFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS;
        /* eslint-enable no-bitwise */

        try {
          const platformURLFixup = Services.uriFixup.getFixupURIInfo(url, fixupFlags);
          redirectedToSearch = platformURLFixup.keywordAsSent !== '';
          fixedURL = platformURLFixup.fixedURI.spec;
        } catch (e) {
          // uriFixup can fail if URI is malformed or could not be fixed
        }

        if (redirectedToSearch && url.indexOf('://') === -1) {
          // Platform fixup converted URL to search request and there was no protocol in initial URL.
          // Try to fix it again with protocol.
          fixedURL = fixURL(`://${fixedURL}`);
        }

        return fixedURL;
      }

      function equal(url1, url2) {
        let uri1;
        let uri2;

        try {
          uri1 = Services.io.newURI(url1, 'UTF-8', null);
          uri2 = Services.io.newURI(url2, 'UTF-8', null);
        } catch (e) {
          return false;
        }

        return uri1.equals(uri2);
      }

      /* eslint no-underscore-dangle: off */
      /* eslint no-param-reassign: off */
      class LRU {
        constructor(size) {
          this.maxSize = size;

          // LRU structure
          this.reset = () => {
            this.cache = new Map();
            this.head = null;
            this.tail = null;
            this.size = 0;
          };
          this.reset();
        }

        /*
         * Check if value associated with `key` is stored in cache.
         * Does not update position of the entry.
         *
         * @param key
         */
        has(key) {
          return this.cache.has(key);
        }

        /* Retrieve value associated with `key` from cache. If it doesn't
         * exist, return `undefined`, otherwise, update position of the
         * entry to "most recent seen".
         *
         * @param key - Key of value we want to get.
         */
        get(key) {
          const node = this.cache.get(key);

          if (node) {
            this._touch(node);
            return node.value;
          }
          return undefined;
        }

        /* Associate a new `value` to `key` in cache. If `key` isn't already
         * present in cache, create a new node at the position "most recent seen".
         * Otherwise, change the value associated with `key` and refresh the
         * position of the entry to "most recent seen".
         *
         * @param key   - Key add to the cache.
         * @param value - Value associated with key.
         */
        set(key, value) {
          let node = this.cache.get(key);

          if (node) {
            // Hit - update value
            node.value = value;
            this._touch(node);
          } else {
            // Miss - Create a new node
            node = this._newNode(key, value);

            // Forget about oldest node
            if (this.size >= this.maxSize) {
              this.cache.delete(this.tail.key);
              this._remove(this.tail);
            }

            this.cache.set(key, node);
            this._pushFront(node);
          }
        }

        // Private interface (Linked List)

        /* Create a new node (key, value) to store in the cache */
        _newNode(key, value) {
          return {
            prev: null,
            next: null,
            key,
            value
          };
        }

        /* Refresh timestamp of `node` by moving it to the front of the list.
         * It the becomes the (key, value) seen most recently.
         */
        _touch(node) {
          this._remove(node);
          this._pushFront(node);
        }

        /* Remove `node` from the list. */
        _remove(node) {
          if (node) {
            // Update previous node
            if (node.prev === null) {
              this.head = node.next;
            } else {
              node.prev.next = node.next;
            }

            // Update next node
            if (node.next === null) {
              this.tail = node.prev;
            } else {
              node.next.prev = node.prev;
            }

            this.size -= 1;
          }
        }

        /* Add `node` in front of the list (most recent element). */
        _pushFront(node) {
          if (node) {
            // Replace first node of the list
            node.prev = null;
            node.next = this.head;

            if (this.head !== null) {
              this.head.prev = node;
            }

            this.head = node;

            // Case: List was empty
            if (this.tail === null) {
              this.tail = node;
            }

            this.size += 1;
          }
        }
      }

      /* Fixed length lookup cache. Allows expensive operations to be cached for later lookup. Once
       * the cache limit is exceeded, least recently used values are removed.
       */
      class FixedSizeCache {
        /* @param {function} buildValue - used to build a new value from key in case of cache miss.
         * @param {number} size - maximum elements stored in cache.
         * @param {function} buildKey - [Optional] used to extract key from argument.
         */
        constructor(buildValue, size, buildKey) {
          this._buildValue = buildValue;
          this._buildKey = buildKey;
          this._maxKeySize = 1000;

          // Statistics
          this._hitCounter = 0;
          this._missCounter = 0;

          this.lru = new LRU(size);
        }

        /* Try to retrieve the value associated with `key` from the cache. If it's
         * not present, build it using `buildValue` and store it in the cache.
         *
         * This method always returns a value either from the LRU cache, or from a
         * direct call to `buildValue`.
         */
        get(argument) {
          const key = this._buildKey ? this._buildKey(argument) : argument;
          let value = this.lru.get(key);

          if (value !== undefined) {
            // Cache hit
            this._hitCounter += 1;
            return value;
          }
          // Cache miss
          this._missCounter += 1;

          // Compute value
          value = this._buildValue(argument);

          // if key is large, don't cache
          if (!key || key.length > this._maxKeySize) {
            return value;
          }

          this.lru.set(key, value);
          return value;
        }
      }

      var _slicedToArray$1 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const UrlRegExp = /^(([a-z\d]([a-z\d-]*[a-z\d])?)\.)+[a-z]{2,}(\:\d+)?$/i;

      function tryFn(fn) {
        return function () {
          try {
            return fn(...arguments);
          } catch (e) {
            return arguments.length <= 0 ? undefined : arguments[0];
          }
        };
      }

      function isUrl(input) {
        if (!input) {
          return false;
        }
        // TODO: handle ip addresses
        if (isURI(input)) {
          return true;
        } else {
          //step 1 remove eventual protocol
          const protocolPos = input.indexOf('://');
          if (protocolPos != -1 && protocolPos <= 6) {
            input = input.slice(protocolPos + 3);
          }
          //step2 remove path & everything after
          input = input.split('/')[0];
          //step3 run the regex
          return UrlRegExp.test(input) || isIpAddress(input);
        }
      }

      function isLocalhost(host, isIPv4, isIPv6) {
        if (host == "localhost") return true;
        if (isIPv4 && host.substr(0, 3) == "127") return true;
        if (isIPv6 && host == "::1") return true;

        return false;
      }

      /*
      strip protocol from url
      */

      // IP Validation

      const ipv4_part = "0*([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"; // numbers 0 - 255
      const ipv4_regex = new RegExp("^" + ipv4_part + "\\." + ipv4_part + "\\." + ipv4_part + "\\." + ipv4_part + "([:]([0-9])+)?$"); // port number
      const ipv6_regex = new RegExp("^\\[?(([0-9]|[a-f]|[A-F])*[:.]+([0-9]|[a-f]|[A-F])+[:.]*)+[\\]]?([:][0-9]+)?$");
      const schemeRE = /^(\S+?):(\/\/)?(.*)$/i;

      function isIpv4Address(host) {
        return ipv4_regex.test(host);
      }

      function isIpv6Address(host) {
        return ipv6_regex.test(host);
      }

      function isIpAddress(host) {
        return isIpv4Address(host) || isIpv6Address(host);
      }

      function extractSimpleURI(url) {
        return new URI(url);
      }

      const tryDecodeURI = tryFn(decodeURI);
      const tryDecodeURIComponent = tryFn(decodeURIComponent);
      const tryEncodeURI = tryFn(encodeURI);
      const tryEncodeURIComponent = tryFn(encodeURIComponent);

      function equals(url1, url2) {
        if (!url1 || !url2) {
          return false;
        }

        if (url1 === url2) {
          return true;
        }

        try {
          if (decodeURI(url1) === decodeURI(url2)) {
            return true;
          }
        } catch (e) {
          return false;
        }

        if (equal(url1, url2)) {
          return true;
        }

        return false;
      }

      function isCliqzAction(url) {
        return url.match(/^cliqz-actions,/);
      }

      function cleanMozillaActions() {
        let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        let action;
        if (url.indexOf("moz-action:") == 0) {
          const parts = url.match(/^moz-action:([^,]+),(.*)$/);
          action = parts[1];
          url = parts[2];
          try {
            // handle cases like: moz-action:visiturl,{"url": "..."}
            const mozActionUrl = JSON.parse(url).url;
            if (mozActionUrl) {
              url = decodeURIComponent(mozActionUrl);
            }
          } catch (e) {}
        }
        return [action, url];
      }

      function stripTrailingSlash(str) {
        if (str.substr(-1) === '/') {
          return str.substr(0, str.length - 1);
        }
        return str;
      }

      function _getDetailsFromUrl(originalUrl) {
        var _cleanMozillaActions = cleanMozillaActions(originalUrl),
            _cleanMozillaActions2 = _slicedToArray$1(_cleanMozillaActions, 2),
            action = _cleanMozillaActions2[0],
            originalUrl = _cleanMozillaActions2[1];
        // exclude protocol


        var url = originalUrl,
            scheme = '',
            slashes = '',
            name = '',
            tld = '',
            subdomains = [],
            path = '',
            query = '',
            fragment = '';

        // remove scheme
        const schemeMatch = schemeRE.exec(url);
        if (schemeMatch) {
          scheme = schemeMatch[1];
          slashes = schemeMatch[2] || '';
          url = schemeMatch[3];
        }
        const ssl = scheme == 'https';

        // separate hostname from path, etc. Could be separated from rest by /, ? or #
        var host = url.split(/[\/\#\?]/)[0].toLowerCase();
        var path = url.replace(host, '');

        // separate username:password@ from host
        var userpass_host = host.split('@');
        if (userpass_host.length > 1) host = userpass_host[1];

        // Parse Port number
        var port = "";

        var isIPv4 = isIpv4Address(host);
        var isIPv6 = isIpv6Address(host);

        var indexOfColon = host.indexOf(":");
        if ((!isIPv6 || isIPv4) && indexOfColon >= 0) {
          port = host.substr(indexOfColon + 1);
          host = host.substr(0, indexOfColon);
        } else if (isIPv6) {
          // If an IPv6 address has a port number, it will be right after a closing bracket ] : format [ip_v6]:port
          var endOfIP = host.indexOf(']:');
          if (endOfIP >= 0) {
            port = host.split(']:')[1];
            host = host.split(']:')[0].replace('[', '').replace(']', '');
          }
        }

        // extract query and fragment from url
        var query = '';
        var query_idx = path.indexOf('?');
        if (query_idx != -1) {
          query = path.substr(query_idx + 1);
        }

        var fragment = '';
        var fragment_idx = path.indexOf('#');
        if (fragment_idx != -1) {
          fragment = path.substr(fragment_idx + 1);
        }

        // remove query and fragment from path
        path = path.replace('?' + query, '');
        path = path.replace('#' + fragment, '');
        query = query.replace('#' + fragment, '');

        // extra - all path, query and fragment
        var extra = path;
        if (query) extra += "?" + query;
        if (fragment) extra += "#" + fragment;

        isIPv4 = isIpv4Address(host);
        isIPv6 = isIpv6Address(host);
        var localhost = isLocalhost(host, isIPv4, isIPv6);

        // find parts of hostname
        if (!isIPv4 && !isIPv6 && !localhost) {
          try {
            let hostWithoutTld = host;
            tld = getPublicSuffix(host);

            if (tld) {
              hostWithoutTld = host.slice(0, -(tld.length + 1)); // +1 for the '.'
            }

            // Get subdomains
            subdomains = hostWithoutTld.split('.');
            // Get the domain name w/o subdomains and w/o TLD
            name = subdomains.pop();

            //remove www if exists
            // TODO: I don't think this is the right place to do this.
            //       Disabled for now, but check there are no issues.
            // host = host.indexOf('www.') == 0 ? host.slice(4) : host;
          } catch (e) {
            name = "";
            host = "";
            //CliqzUtils.log('WARNING Failed for: ' + originalUrl, 'CliqzUtils.getDetailsFromUrl');
          }
        } else {
          name = localhost ? "localhost" : "IP";
        }

        // remove www from beginning, we need cleanHost in the friendly url
        var cleanHost = host;
        if (host.toLowerCase().indexOf('www.') == 0) {
          cleanHost = host.slice(4);
        }

        var friendly_url = cleanHost + extra;
        if (scheme && scheme != 'http' && scheme != 'https') friendly_url = scheme + ":" + slashes + friendly_url;
        //remove trailing slash from the end
        friendly_url = stripTrailingSlash(friendly_url);

        //Handle case where we have only tld for example http://cliqznas
        if (cleanHost === tld) {
          name = tld;
        }

        var urlDetails = {
          action,
          originalUrl,
          scheme: scheme ? scheme + ':' : '',
          name,
          domain: tld ? name + '.' + tld : '',
          tld,
          subdomains,
          path,
          query,
          fragment,
          extra,
          host,
          cleanHost,
          ssl,
          port,
          friendly_url
        };

        return urlDetails;
      }

      const urlDetailsCache = new FixedSizeCache(_getDetailsFromUrl, 50);

      function getDetailsFromUrl(url) {
        return urlDetailsCache.get(url);
      }

      /* eslint-disable */

      var TLDs = { gw: 'cc', gu: 'cc', gt: 'cc', gs: 'cc', gr: 'cc', gq: 'cc', gp: 'cc', dance: 'na', tienda: 'na', gy: 'cc', gg: 'cc', gf: 'cc', ge: 'cc', gd: 'cc', gb: 'cc', ga: 'cc', edu: 'na', gn: 'cc', gm: 'cc', gl: 'cc', '\u516C\u53F8': 'na', gi: 'cc', gh: 'cc', tz: 'cc', zone: 'na', tv: 'cc', tw: 'cc', tt: 'cc', immobilien: 'na', tr: 'cc', tp: 'cc', tn: 'cc', to: 'cc', tl: 'cc', bike: 'na', tj: 'cc', tk: 'cc', th: 'cc', tf: 'cc', tg: 'cc', td: 'cc', tc: 'cc', coop: 'na', '\u043E\u043D\u043B\u0430\u0439\u043D': 'na', cool: 'na', ro: 'cc', vu: 'cc', democrat: 'na', guitars: 'na', qpon: 'na', '\u0441\u0440\u0431': 'cc', zm: 'cc', tel: 'na', futbol: 'na', za: 'cc', '\u0628\u0627\u0632\u0627\u0631': 'na', '\u0440\u0444': 'cc', zw: 'cc', blue: 'na', mu: 'cc', '\u0E44\u0E17\u0E22': 'cc', asia: 'na', marketing: 'na', '\u6D4B\u8BD5': 'na', international: 'na', net: 'na', '\u65B0\u52A0\u5761': 'cc', okinawa: 'na', '\u0BAA\u0BB0\u0BBF\u0B9F\u0BCD\u0B9A\u0BC8': 'na', '\u05D8\u05E2\u05E1\u05D8': 'na', '\uC0BC\uC131': 'na', sexy: 'na', institute: 'na', '\u53F0\u7063': 'cc', pics: 'na', '\u516C\u76CA': 'na', '\u673A\u6784': 'na', social: 'na', domains: 'na', '\u9999\u6E2F': 'cc', '\u96C6\u56E2': 'na', limo: 'na', '\u043C\u043E\u043D': 'cc', tools: 'na', nagoya: 'na', properties: 'na', camera: 'na', today: 'na', club: 'na', company: 'na', glass: 'na', berlin: 'na', me: 'cc', md: 'cc', mg: 'cc', mf: 'cc', ma: 'cc', mc: 'cc', tokyo: 'na', mm: 'cc', ml: 'cc', mo: 'cc', mn: 'cc', mh: 'cc', mk: 'cc', cat: 'na', reviews: 'na', mt: 'cc', mw: 'cc', mv: 'cc', mq: 'cc', mp: 'cc', ms: 'cc', mr: 'cc', cab: 'na', my: 'cc', mx: 'cc', mz: 'cc', '\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8': 'cc', wang: 'na', estate: 'na', clothing: 'na', monash: 'na', guru: 'na', technology: 'na', travel: 'na', '\u30C6\u30B9\u30C8': 'na', pink: 'na', fr: 'cc', '\uD14C\uC2A4\uD2B8': 'na', farm: 'na', lighting: 'na', fi: 'cc', fj: 'cc', fk: 'cc', fm: 'cc', fo: 'cc', sz: 'cc', kaufen: 'na', sx: 'cc', ss: 'cc', sr: 'cc', sv: 'cc', su: 'cc', st: 'cc', sk: 'cc', sj: 'cc', si: 'cc', sh: 'cc', so: 'cc', sn: 'cc', sm: 'cc', sl: 'cc', sc: 'cc', sb: 'cc', rentals: 'na', sg: 'cc', se: 'cc', sd: 'cc', '\u7EC4\u7EC7\u673A\u6784': 'na', shoes: 'na', '\u4E2D\u570B': 'cc', industries: 'na', lb: 'cc', lc: 'cc', la: 'cc', lk: 'cc', li: 'cc', lv: 'cc', lt: 'cc', lu: 'cc', lr: 'cc', ls: 'cc', holiday: 'na', ly: 'cc', coffee: 'na', ceo: 'na', '\u5728\u7EBF': 'na', ye: 'cc', '\u0625\u062E\u062A\u0628\u0627\u0631': 'na', ninja: 'na', yt: 'cc', name: 'na', moda: 'na', eh: 'cc', '\u0628\u06BE\u0627\u0631\u062A': 'cc', ee: 'cc', house: 'na', eg: 'cc', ec: 'cc', vote: 'na', eu: 'cc', et: 'cc', es: 'cc', er: 'cc', ru: 'cc', rw: 'cc', '\u0AAD\u0ABE\u0AB0\u0AA4': 'cc', rs: 'cc', boutique: 'na', re: 'cc', '\u0633\u0648\u0631\u064A\u0629': 'cc', gov: 'na', '\u043E\u0440\u0433': 'na', red: 'na', foundation: 'na', pub: 'na', vacations: 'na', org: 'na', training: 'na', recipes: 'na', '\u0438\u0441\u043F\u044B\u0442\u0430\u043D\u0438\u0435': 'na', '\u4E2D\u6587\u7F51': 'na', support: 'na', onl: 'na', '\u4E2D\u4FE1': 'na', voto: 'na', florist: 'na', '\u0DBD\u0D82\u0D9A\u0DCF': 'cc', '\u049B\u0430\u0437': 'cc', management: 'na', '\u0645\u0635\u0631': 'cc', '\u0622\u0632\u0645\u0627\u06CC\u0634\u06CC': 'na', kiwi: 'na', academy: 'na', sy: 'cc', cards: 'na', '\u0938\u0902\u0917\u0920\u0928': 'na', pro: 'na', kred: 'na', sa: 'cc', mil: 'na', '\u6211\u7231\u4F60': 'na', agency: 'na', '\u307F\u3093\u306A': 'na', equipment: 'na', mango: 'na', luxury: 'na', villas: 'na', '\u653F\u52A1': 'na', singles: 'na', systems: 'na', plumbing: 'na', '\u03B4\u03BF\u03BA\u03B9\u03BC\u03AE': 'na', '\u062A\u0648\u0646\u0633': 'cc', '\u067E\u0627\u06A9\u0633\u062A\u0627\u0646': 'cc', gallery: 'na', kg: 'cc', ke: 'cc', '\u09AC\u09BE\u0982\u09B2\u09BE': 'cc', ki: 'cc', kh: 'cc', kn: 'cc', km: 'cc', kr: 'cc', kp: 'cc', kw: 'cc', link: 'na', ky: 'cc', voting: 'na', cruises: 'na', '\u0639\u0645\u0627\u0646': 'cc', cheap: 'na', solutions: 'na', '\u6E2C\u8A66': 'na', neustar: 'na', partners: 'na', '\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE': 'cc', menu: 'na', arpa: 'na', flights: 'na', rich: 'na', do: 'cc', dm: 'cc', dj: 'cc', dk: 'cc', photography: 'na', de: 'cc', watch: 'na', dz: 'cc', supplies: 'na', report: 'na', tips: 'na', '\u10D2\u10D4': 'cc', bar: 'na', qa: 'cc', shiksha: 'na', '\u0443\u043A\u0440': 'cc', vision: 'na', wiki: 'na', '\u0642\u0637\u0631': 'cc', '\uD55C\uAD6D': 'cc', computer: 'na', best: 'na', voyage: 'na', expert: 'na', diamonds: 'na', email: 'na', wf: 'cc', jobs: 'na', bargains: 'na', '\u79FB\u52A8': 'na', jp: 'cc', jm: 'cc', jo: 'cc', ws: 'cc', je: 'cc', kitchen: 'na', '\u0A2D\u0A3E\u0A30\u0A24': 'cc', '\u0627\u06CC\u0631\u0627\u0646': 'cc', ua: 'cc', buzz: 'na', com: 'na', uno: 'na', ck: 'cc', ci: 'cc', ch: 'cc', co: 'cc', cn: 'cc', cm: 'cc', cl: 'cc', cc: 'cc', ca: 'cc', cg: 'cc', cf: 'cc', community: 'na', cd: 'cc', cz: 'cc', cy: 'cc', cx: 'cc', cr: 'cc', cw: 'cc', cv: 'cc', cu: 'cc', pr: 'cc', ps: 'cc', pw: 'cc', pt: 'cc', holdings: 'na', wien: 'na', py: 'cc', ai: 'cc', pa: 'cc', pf: 'cc', pg: 'cc', pe: 'cc', pk: 'cc', ph: 'cc', pn: 'cc', pl: 'cc', pm: 'cc', '\u53F0\u6E7E': 'cc', aero: 'na', catering: 'na', photos: 'na', '\u092A\u0930\u0940\u0915\u094D\u0937\u093E': 'na', graphics: 'na', '\u0641\u0644\u0633\u0637\u064A\u0646': 'cc', '\u09AD\u09BE\u09B0\u09A4': 'cc', ventures: 'na', va: 'cc', vc: 'cc', ve: 'cc', vg: 'cc', iq: 'cc', vi: 'cc', is: 'cc', ir: 'cc', it: 'cc', vn: 'cc', im: 'cc', il: 'cc', io: 'cc', in: 'cc', ie: 'cc', id: 'cc', tattoo: 'na', education: 'na', parts: 'na', events: 'na', '\u0C2D\u0C3E\u0C30\u0C24\u0C4D': 'cc', cleaning: 'na', kim: 'na', contractors: 'na', mobi: 'na', center: 'na', photo: 'na', nf: 'cc', '\u0645\u0644\u064A\u0633\u064A\u0627': 'cc', wed: 'na', supply: 'na', '\u7F51\u7EDC': 'na', '\u0441\u0430\u0439\u0442': 'na', careers: 'na', build: 'na', '\u0627\u0644\u0627\u0631\u062F\u0646': 'cc', bid: 'na', biz: 'na', '\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629': 'cc', gift: 'na', '\u0434\u0435\u0442\u0438': 'na', works: 'na', '\u6E38\u620F': 'na', tm: 'cc', exposed: 'na', productions: 'na', koeln: 'na', dating: 'na', christmas: 'na', bd: 'cc', be: 'cc', bf: 'cc', bg: 'cc', ba: 'cc', bb: 'cc', bl: 'cc', bm: 'cc', bn: 'cc', bo: 'cc', bh: 'cc', bi: 'cc', bj: 'cc', bt: 'cc', bv: 'cc', bw: 'cc', bq: 'cc', br: 'cc', bs: 'cc', post: 'na', by: 'cc', bz: 'cc', om: 'cc', ruhr: 'na', '\u0627\u0645\u0627\u0631\u0627\u062A': 'cc', repair: 'na', xyz: 'na', '\u0634\u0628\u0643\u0629': 'na', viajes: 'na', museum: 'na', fish: 'na', '\u0627\u0644\u062C\u0632\u0627\u0626\u0631': 'cc', hr: 'cc', ht: 'cc', hu: 'cc', hk: 'cc', construction: 'na', hn: 'cc', solar: 'na', hm: 'cc', info: 'na', '\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD': 'cc', uy: 'cc', uz: 'cc', us: 'cc', um: 'cc', uk: 'cc', ug: 'cc', builders: 'na', ac: 'cc', camp: 'na', ae: 'cc', ad: 'cc', ag: 'cc', af: 'cc', int: 'na', am: 'cc', al: 'cc', ao: 'cc', an: 'cc', aq: 'cc', as: 'cc', ar: 'cc', au: 'cc', at: 'cc', aw: 'cc', ax: 'cc', az: 'cc', ni: 'cc', codes: 'na', nl: 'cc', no: 'cc', na: 'cc', nc: 'cc', ne: 'cc', actor: 'na', ng: 'cc', '\u092D\u093E\u0930\u0924': 'cc', nz: 'cc', '\u0633\u0648\u062F\u0627\u0646': 'cc', np: 'cc', nr: 'cc', nu: 'cc', xxx: 'na', '\u4E16\u754C': 'na', kz: 'cc', enterprises: 'na', land: 'na', '\u0627\u0644\u0645\u063A\u0631\u0628': 'cc', '\u4E2D\u56FD': 'cc', directory: 'na' };

      /**
       * Extrach the domain from an url, ignoring the schema and parameters.
       */
      function _extractHostname(url) {
        if (typeof url !== 'string') {
          return '';
        }

        let domain = url;

        // We need to check that the index is <= because this protocol could appear
        // as a value of a parameter in the URL.
        const indexOfProtocol = url.indexOf('://');
        if (indexOfProtocol !== -1 && indexOfProtocol <= 6) {
          domain = url.substr(indexOfProtocol + 3);
        }

        const indexOfSlash = domain.indexOf('/');
        if (indexOfSlash !== -1) {
          domain = domain.substr(0, indexOfSlash);
        }

        if (domain.startsWith('www.')) {
          domain = domain.substr(4);
        }

        if (domain.endsWith('.')) {
          domain = domain.substr(0, domain.length - 1);
        }

        return domain;
      }

      // Use our faster `extractHostname` implementation in tldjs
      const tlds = tldjs.fromUserSettings({
        // Note: in the next version, tld.js should not require `validHost` as a
        // first argument.
        extractHostname: (validHosts, url) => _extractHostname(url),
        validHosts: ['localhost']
      });

      function parse(url) {
        const parsed = tlds.parse(url);

        // TODO - ip addr handling could be integrated in tld.js library
        // Specific handling of IP addresses
        if (isIpAddress(parsed.hostname)) {
          parsed.domain = parsed.hostname;
        } else if (parsed.domain === null) {
          // Some hostname will not play well with the `getDomain` function if they
          // also constitute a valid public suffix (eg: googleapis.com)
          parsed.domain = parsed.suffix;
        }

        return parsed;
      }

      function getGeneralDomain(url) {
        return parse(url).domain;
      }

      function getPublicSuffix(url) {
        return parse(url).suffix;
      }

      function sameGeneralDomain(domain1, domain2) {
        return domain1 === domain2 || getGeneralDomain(domain1) === getGeneralDomain(domain2);
      }

      /*
       * This module determines the language of visited pages and
       * creates a list of known languages for a user
       *
       */

      // we keep a different preferences namespace than cliqz so that it does not get
      // removed after a re-install or sent during a logging signal
      var CliqzLanguage = {
        DOMAIN_THRESHOLD: 3,
        READING_THRESHOLD: 10000,
        LOG_KEY: 'CliqzLanguage',
        LOCALE_HASH: 333,
        currentState: {},
        cron: 24 * 60 * 60 * 1000, // default one day
        checkInterval: 5 * 60 * 1000, // default 5 min
        removeHashId: null,

        getLocale: function getLocale() {
          return CliqzLanguage.normalizeLocale(CliqzUtils.getPref('general.useragent.locale', '', ''));
        },

        // load from the about:config settings
        init: function init(window) {

          CliqzLanguage.window = window;
          if (this.removeHashId == null) {
            this.removeHashId = CliqzUtils.setInterval(this.updateTicker.bind(this), this.checkInterval);
          }

          if (CliqzUtils.hasPref('data', 'extensions.cliqz-lang.')) {
            try {
              // catch empty value or malformed json
              CliqzLanguage.currentState = JSON.parse(CliqzUtils.getPref('data', {}, 'extensions.cliqz-lang.'));
            } catch (e) {}
          }
          let localeLangs = [];
          let max_value = 0;
          // transform legacy data
          for (let lang in CliqzLanguage.currentState) {
            if (CliqzLanguage.currentState[lang] == 'locale' || CliqzLanguage.currentState[lang].indexOf(257) != -1) {
              localeLangs.push(lang);
            }
            if (CliqzLanguage.currentState[lang] instanceof Array) {
              max_value = Math.max(max_value, CliqzLanguage.currentState[lang].length);
            }
          }
          if (localeLangs.length) {
            let max_len = Math.max(CliqzLanguage.DOMAIN_THRESHOLD + 1, max_value);

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = localeLangs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                let locale = _step.value;

                var original_array = CliqzLanguage.currentState[locale];
                if (original_array == "locale") {

                  CliqzLanguage.currentState[locale] = CliqzLanguage.createHashes(max_len);
                } else if (original_array.length < max_len) {
                  CliqzLanguage.currentState[locale] = CliqzLanguage.createHashes(max_len);
                }

                // add 'locale' hash
                CliqzLanguage.currentState[locale][0] = CliqzLanguage.LOCALE_HASH;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          var ll = CliqzLanguage.getLocale();
          if (ll && CliqzLanguage.currentState[ll] == null) {
            // we found new locale
            CliqzLanguage.currentState[ll] = CliqzLanguage.createHashes(CliqzLanguage.DOMAIN_THRESHOLD + 1);
            // add 'locale' hash
            CliqzLanguage.currentState[ll][0] = CliqzLanguage.LOCALE_HASH;
          }

          CliqzLanguage.cleanCurrentState();
          CliqzLanguage.saveCurrentState();

          CliqzUtils.log(CliqzLanguage.stateToQueryString(), CliqzLanguage.LOG_KEY);
        },
        unload: function unload() {
          if (this.removeHashId != null) {
            CliqzUtils.clearInterval(this.removeHashId);
            this.removeHashId = null;
          }
        },
        updateTicker: function updateTicker() {
          var lastUpdate = 0;
          if (CliqzUtils.hasPref('lastUpdate', 'extensions.cliqz-lang.')) {
            try {
              lastUpdate = parseInt(CliqzUtils.getPref('lastUpdate', 0, 'extensions.cliqz-lang.'));
            } catch (e) {
              lastUpdate = 0;
            }
          }
          var currentTime = Date.now();
          if (currentTime > this.cron + lastUpdate) {
            this.removeHash();
            CliqzUtils.setPref('lastUpdate', String(currentTime), 'extensions.cliqz-lang.');
          }
        },
        // create array of unique hashes
        createHashes: function createHashes(max_len) {
          let hashes = [];
          let i = 0;
          while (i < max_len) {
            // random hash value: [-256, 255]
            let r = Math.floor(Math.random() * 512) - 256;
            if (hashes.indexOf(r) == -1) {
              hashes.push(r);
              i += 1;
            }
          }
          return hashes;
        },
        // add locale, this is the function hook that will be called for every page load that
        // stays more than 5 seconds active
        addLocale: function addLocale(url, localeStr) {

          var locale = CliqzLanguage.normalizeLocale(localeStr);

          if (locale == '' || locale == undefined || locale == null || locale.length != 2) return;
          if (url == '' || url == undefined || url == null) return;

          // extract domain from url, hash it and update the value
          var url_hash = CliqzLanguage.hashCode(CliqzUtils.cleanUrlProtocol(url, true).split('/')[0]) % 256;

          if (CliqzLanguage.currentState[locale] == null || CliqzLanguage.currentState[locale].indexOf(url_hash) == -1) {
            if (CliqzLanguage.currentState[locale] == null) CliqzLanguage.currentState[locale] = [];
            CliqzLanguage.currentState[locale].push(url_hash);
            CliqzUtils.log('Saving: ' + locale + ' ' + url_hash, CliqzLanguage.LOG_KEY + " for url " + url);
            CliqzLanguage.saveCurrentState();
          }
        },
        // do random delete of hash with prob 0.05 (5%)
        removeHash: function removeHash() {
          let changed = false;
          for (let lang in CliqzLanguage.currentState) {
            if (CliqzLanguage.currentState[lang].length > CliqzLanguage.DOMAIN_THRESHOLD + 1) {
              let prob = Math.random();
              if (prob <= 0.05) {
                let ind = Math.floor(Math.random() * CliqzLanguage.currentState[lang].length);
                if (CliqzLanguage.currentState[lang][ind] != CliqzLanguage.LOCALE_HASH) {
                  if (!changed) changed = !changed;
                  CliqzUtils.log("Removing hash " + CliqzLanguage.currentState[lang][ind] + " for the language " + lang);
                  CliqzLanguage.currentState[lang].splice(ind, 1);
                }
              }
            }
          }
          if (changed) CliqzLanguage.saveCurrentState();
        },
        // returns hash of the string
        hashCode: function hashCode(s) {
          return s.split("").reduce(function (a, b) {
            a = (a << 5) - a + b.charCodeAt(0);return a & a;
          }, 0);
        },
        // removes the country from the locale, for instance, de-de => de, en-US => en
        normalizeLocale: function normalizeLocale(str) {
          if (str) return str.split(/-|_/)[0].trim().toLowerCase();else return str;
        },
        // the function that decided which languages the person understands
        state: function state(distribution) {
          distribution = typeof distribution !== 'undefined' ? distribution : false;
          var lang_vec = [];
          for (var lang in CliqzLanguage.currentState) {
            var len = Object.keys(CliqzLanguage.currentState[lang]).length;
            if (len > CliqzLanguage.DOMAIN_THRESHOLD) {
              lang_vec.push([lang, 1.0 / len]);
            }
          }

          lang_vec = lang_vec.sort(function (a, b) {
            return a[1] - b[1];
          });
          // returns full distribution if asked for it
          if (distribution) {
            return lang_vec;
          }

          // returns only lang names
          var lang_vec_clean = [];
          for (let index in lang_vec) {
            lang_vec_clean.push(lang_vec[index][0]);
          }

          return lang_vec_clean;
        },
        // remove doubled values, normalize languages
        cleanCurrentState: function cleanCurrentState() {
          var keys = Object.keys(CliqzLanguage.currentState);
          var cleanState = {};
          for (let i = 0; i < keys.length; i++) {
            var nkey = CliqzLanguage.normalizeLocale(keys[i]);
            cleanState[nkey] = cleanState[nkey] || [];

            for (let j = 0; j < CliqzLanguage.currentState[keys[i]].length; j++) {
              var value = CliqzLanguage.currentState[keys[i]][j];
              if (cleanState[nkey].indexOf(value) == -1) cleanState[nkey].push(value);
            }
          }
          if (cleanState != CliqzLanguage.currentState) {
            CliqzLanguage.currentState = cleanState;
            CliqzLanguage.saveCurrentState();
          }
        },
        // returns query string with popular languages
        stateToQueryString: function stateToQueryString() {
          return '&lang=' + encodeURIComponent(CliqzLanguage.state().join(','));
        },
        // Save the current state to preferences,
        saveCurrentState: function saveCurrentState() {
          CliqzUtils.log("Going to save languages: " + JSON.stringify(CliqzLanguage.currentState), CliqzLanguage.LOG_KEY);
          CliqzUtils.setPref('data', JSON.stringify(CliqzLanguage.currentState || {}), 'extensions.cliqz-lang.');
        }
      };

      /* global crypto */

      /* eslint-disable no-bitwise */

      // Cryptographically secure Math.random replacement
      //
      //  Doing the same as Firefox Math.random does, but with a crypto secure 64 bit number instead.
      //  The equivalent in C++ is: double(uint64val & 0x1FFFFFFFFFFFFF) / (1 << 53);
      //  WARNING: In tests (Linux), considerably slower than Math.random (5-10 times)
      function random() {
        const values = crypto.getRandomValues(new Uint32Array(2));
        return (Math.pow(2, 32) * (values[0] & 0x1FFFFF) + values[1]) / Math.pow(2, 53);
      }

      function randomInt() {
        return Math.floor(random() * Number.MAX_SAFE_INTEGER);
      }

      var platform = {
        isMobile: false,
        isFirefox: true,
        isChromium: false,
        platformName: 'firefox'
      };

      const appInfo = Components.classes['@mozilla.org/xre/app-info;1'];
      const versionChecker = Components.classes['@mozilla.org/xpcom/version-comparator;1'].getService(Components.interfaces.nsIVersionComparator);

      function isPlatformAtLeastInVersion(minVersion) {
        const hostVersion = appInfo.getService(Components.interfaces.nsIXULAppInfo).version;
        return versionChecker.compare(hostVersion, minVersion) >= 0;
      }

      const OS$1 = appInfo.getService(Components.interfaces.nsIXULRuntime).OS.toLowerCase();
      const OS_VERSION = Services.sysinfo.getProperty('version');

      function isCliqzAtLeastInVersion(minVersion) {
        const cliqzVersion = prefs.get('distribution.version', '', '');
        return versionChecker.compare(cliqzVersion, minVersion) >= 0;
      }

      function notImplemented() {
        throw new Error('Not implemented');
      }

      const isFirefox = platform.isFirefox;
      const isMobile = platform.isMobile;
      const isChromium = platform.isChromium;

      const isCliqzBrowser = config.settings.channel === '40';

      function isWindows() {
        return OS$1 && OS$1.indexOf('win') === 0;
      }

      function isMac() {
        return OS$1 && OS$1.indexOf('darwin') === 0;
      }

      function isLinux() {
        return OS$1 && OS$1.indexOf('linux') === 0;
      }

      function mapWindows(callback) {
        const enumerator = Services.wm.getEnumerator('navigator:browser');
        const results = [];
        while (enumerator.hasMoreElements()) {
          try {
            const win = enumerator.getNext();
            results.push(callback(win));
          } catch (e) {
            // Nothing
          }
        }
        return results;
      }

      class Window {
        constructor(window$$1) {
          this.window = window$$1;
        }

        get id() {
          const util = this.window.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindowUtils);
          return util.outerWindowID;
        }

        static findById(windowId) {
          const windows = mapWindows(w => new Window(w));
          return windows.find(w => w.id === windowId);
        }

        static findByTabId(tabId) {
          const windows = mapWindows(w => new Window(w));
          return windows.find(w =>
          // In some cases `w.window.gBrowser.selectedBrowser` is undefined.
          w.window.gBrowser.selectedBrowser !== undefined && w.window.gBrowser.selectedBrowser.outerWindowID === tabId);
        }
      }

      function forEachWindow(callback) {
        mapWindows(callback);
      }

      function isTabURL(url) {
        const wm = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator);
        const browserEnumerator = wm.getEnumerator('navigator:browser');

        while (browserEnumerator.hasMoreElements()) {
          const browserWin = browserEnumerator.getNext();
          const tabbrowser = browserWin.gBrowser;

          const numTabs = tabbrowser.browsers.length;
          for (let index = 0; index < numTabs; index += 1) {
            const currentBrowser = tabbrowser.getBrowserAtIndex(index);
            if (currentBrowser) {
              const tabURL = currentBrowser.currentURI.spec;
              if (url === tabURL || url === tabURL.split('#')[0]) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function getBrowserMajorVersion() {
        const appInfo = Components.classes['@mozilla.org/xre/app-info;1'].getService(Components.interfaces.nsIXULAppInfo);
        return parseInt(appInfo.version.split('.')[0], 10);
      }

      /** Returns true if the give windowID represents an open browser tab's windowID.
       */
      function isWindowActive(windowID) {
        const wm = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator);
        const browserEnumerator = wm.getEnumerator('navigator:browser');

        // the windowID should be an integer
        const numId = Number(windowID);
        if (numId <= 0) {
          return false;
        }

        while (browserEnumerator.hasMoreElements()) {
          const browserWin = browserEnumerator.getNext();
          const tabbrowser = browserWin.gBrowser;

          // check if tab is open in this window
          const win = tabbrowser.getBrowserForOuterWindowID(numId);

          // check for http URI.
          if (win !== undefined) {
            return win.currentURI && (win.currentURI.schemeIs('http') || win.currentURI.schemeIs('https'));
          }
        }

        return false;
      }

      function checkIsWindowActive(windowID) {
        return Promise.resolve(isWindowActive(windowID));
      }

      const windowObservers = new Map();
      function addWindowObserver(callback) {
        const cb = (win, topic) => {
          callback(win, topic === 'domwindowopened' ? 'opened' : 'closed');
        };
        windowObservers.set(callback, cb);
        Services.ww.registerNotification(cb);
      }

      function removeWindowObserver(callback) {
        const cb = windowObservers.get(callback);
        if (cb) {
          Services.ww.unregisterNotification(cb);
        }
      }

      const sessionRestoreObservers = new Set();
      function addSessionRestoreObserver(callback) {
        sessionRestoreObservers.add(callback);
        Services.obs.addObserver(callback, 'sessionstore-windows-restored', false);
      }

      function removeSessionRestoreObserver(callback) {
        if (sessionRestoreObservers.has(callback)) {
          sessionRestoreObservers.delete(callback);
          Services.obs.removeObserver(callback, 'sessionstore-windows-restored', false);
        }
      }

      function reportError(e) {
        Components.utils.reportError(e);
      }

      function mustLoadWindow(win) {
        return win.location.href === 'chrome://browser/content/browser.xul';
      }

      function setInstallDatePref(date) {
        // for legacy users who have not set install date on installation
        if (!prefs.get('install_date')) {
          prefs.set('install_date', date);
        }
      }

      function setOurOwnPrefs() {
        if (prefs.has('unifiedcomplete', 'browser.urlbar.') && prefs.get('unifiedcomplete', false)) {
          prefs.set('unifiedcomplete', true); // backup
          prefs.set('unifiedcomplete', false, 'browser.urlbar.');
        }

        // disable FF search hints from FF55 (and maybe above)
        prefs.set('timesBeforeHidingSuggestionsHint', 0, 'browser.urlbar.');
        prefs.set('userMadeSearchSuggestionsChoice', true, 'browser.urlbar.');

        if (prefs.get('suggest.searches', false, 'browser.urlbar.')) {
          prefs.set('backup.browser.urlbar.suggest.searches', true);
          prefs.set('suggest.searches', false, 'browser.urlbar.');
        }

        if (prefs.get('suggest.enabled', false, 'browser.urlbar.')) {
          prefs.set('backup.browser.urlbar.suggest.enabled', true);
          prefs.set('suggest.enabled', false, 'browser.urlbar.');
        }

        // freshtab is optOut since 2.20.3 for new users
        // we migrate the old ones
        if (prefs.has('freshTabState')) {
          prefs.set('freshtab.state', prefs.get('freshTabState'));
          prefs.clear('freshTabState');
        }

        // use a more suggestive name for human web opt out
        if (prefs.has('dnt')) {
          prefs.set('humanWebOptOut', prefs.get('dnt'));
          prefs.clear('dnt');
        }

        // Firefox merges search resuls with results from previous search by default
        // (INSERTMETHOD.MERGE_RELATED at UnifiedComplete.js).
        // It break Cliq's search in different ways, so we change it to INSERTMETHOD.APPEND
        const insertMethod = prefs.get('insertMethod', -1, 'browser.urlbar.');
        if (insertMethod === -1 || insertMethod > 0) {
          // change it to INSERTMETHOD.APPEND
          prefs.set('insertMethod', 0, 'browser.urlbar.');
          prefs.set('backup.browser.urlbar.insertMethod', insertMethod);
        }
      }

      /** Reset changed prefs on uninstall */
      function resetOriginalPrefs() {
        if (prefs.get('unifiedcomplete', false)) {
          prefs.set('unifiedcomplete', true, 'browser.urlbar.');
          prefs.set('unifiedcomplete', false);
        }

        if (prefs.has('backup.browser.urlbar.suggest.searches')) {
          prefs.clear('backup.browser.urlbar.suggest.searches');
          prefs.clear('suggest.searches', 'browser.urlbar.');
        }

        if (prefs.has('backup.browser.urlbar.suggest.searches')) {
          prefs.clear('backup.browser.urlbar.suggest.searches');
          prefs.clear('suggest.searches', 'browser.urlbar.');
        }

        if (prefs.has('backup.browser.urlbar.insertMethod')) {
          const insertMethod = prefs.get('backup.browser.urlbar.insertMethod', -1);
          if (insertMethod === -1) {
            prefs.clear('insertMethod', 'browser.urlbar.');
          } else {
            prefs.set('insertMethod', insertMethod, 'browser.urlbar.');
          }
          prefs.clear('backup.browser.urlbar.insertMethod');
        }
      }

      function getThemeStyle() {
        const selectedThemeID = prefs.get('lightweightThemes.selectedThemeID', '', '');
        return selectedThemeID === 'firefox-compact-dark@mozilla.org' ? 'dark' : 'light';
      }

      let branch; // cliqz specific prefs
      let branchLightweightThemes; // theme specific prefs

      const observer = {
        observe: (subject, topic, data) => {
          CliqzEvents.pub('prefchange', data);
        }
      };

      const observerLightweightThemes = {
        observe: (subject, topic, data) => {
          if (data === 'selectedThemeID') {
            CliqzEvents.pub('hostthemechange', getThemeStyle());
          }
        }
      };

      function enableChangeEvents$1() {
        if (!branch) {
          const prefService = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefService);
          branch = prefService.getBranch('extensions.cliqz.');
          if (!('addObserver' in branch)) {
            branch.QueryInterface(Components.interfaces.nsIPrefBranch2);
          }
          branch.addObserver('', observer, false);
        }

        if (!branchLightweightThemes) {
          const prefService = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefService);
          branchLightweightThemes = prefService.getBranch('lightweightThemes.');
          if (!('addObserver' in branchLightweightThemes)) {
            branchLightweightThemes.QueryInterface(Components.interfaces.nsIPrefBranch2);
          }
          // using a very specific observer for performance reasons
          branchLightweightThemes.addObserver('', observerLightweightThemes, false);
        }
      }

      function disableChangeEvents$1() {
        if (branch) {
          branch.removeObserver('', observer);
          branch = null;
        }

        if (branchLightweightThemes) {
          branchLightweightThemes.removeObserver('', observerLightweightThemes);
          branchLightweightThemes = null;
        }
      }

      function getLang() {
        return prefs.get('general.useragent.locale', 'en', '');
      }

      // resolve only on Idle Callback if available
      function resolveOnIdleCallback(win, resolve, to) {
        if (win.requestIdleCallback) {
          win.requestIdleCallback(() => {
            resolve(win);
          }, { timeout: to });
        } else {
          resolve(win);
        }
      }

      function waitWindowReady(win) {
        return new Promise(resolve => {
          if (!win.document || win.document.readyState !== 'complete') {
            win.addEventListener('load', function loader() {
              win.removeEventListener('load', loader, false);
              resolveOnIdleCallback(win, resolve, 1000);
            }, false);
          } else {
            resolveOnIdleCallback(win, resolve, 1000);
          }
        });
      }

      function getActiveTab(w) {
        let window$$1 = w;
        if (!w) {
          const wm = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator);
          window$$1 = wm.getMostRecentWindow('navigator:browser');
          if (!window$$1) {
            return Promise.reject('No open window available');
          }
        }
        return new Promise((resolve, reject) => {
          // Extract id of the current tab
          let tabId;
          let url;
          try {
            const gBrowser = window$$1.gBrowser;
            const selectedBrowser = gBrowser.selectedBrowser;
            tabId = selectedBrowser.outerWindowID;
            url = selectedBrowser.currentURI.spec;
          } catch (e) {
            reject(e);
          }

          resolve({
            id: tabId,
            url
          });
        });
      }

      function getCookies() {
        return Promise.reject('Not implemented');
      }

      function waitForAsync(fn) {
        let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

        if (depth <= 0) {
          return Promise.resolve('waitForAsync max depth');
        }

        return fn().then(value => {
          if (value) {
            return Promise.resolve();
          }
          return Promise.reject();
        }).catch(() => new Promise(resolve => {
          setTimeout(() => {
            resolve(waitForAsync(fn, depth - 1));
          }, 100);
        }));
      }

      function getCurrentgBrowser() {
        return Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator).getMostRecentWindow('navigator:browser').gBrowser;
      }

      const migrationObservers = new Map();
      function addMigrationObserver(callback) {
        const obs = {
          init() {
            Services.obs.addObserver(this, 'Migration:Ended', false);
            migrationObservers.set(callback, this);
          },

          uninit() {
            Services.obs.removeObserver(this, 'Migration:Ended');
            migrationObservers.delete(callback);
          },

          observe(subject, topic, data) {
            callback(subject, topic, data);
          }
        };
        obs.init();
      }

      function removeMigrationObserver(callback) {
        const obs = migrationObservers.get(callback);
        if (obs) {
          obs.uninit();
        }
      }

      var getLocaleObject = function (url) {
        // Warning - sync request
        return JSON.parse(httpHandler$1('GET', url, null, null, null, null, true).response);
      };

      const SUPPORTED_LANGS = ['de', 'en', 'fr'];

      var getSupportedLanguage = function (lang) {
        if (SUPPORTED_LANGS.indexOf(lang) !== -1) {
          return lang;
        }

        return 'en';
      };

      const getLanguageFromLocale = locale => locale.match(/([a-z]+)(?:[-_]([A-Z]+))?/)[1];

      const i18n = {
        locale: {},
        currLocale: '',
        LOCALE_PATH: `${config.baseURL}static/locale`
      };

      const getLocaleFile = locale => {
        const url = `${i18n.LOCALE_PATH}/${locale}/cliqz.json`;
        // Warning - sync request
        const localeObject = getLocaleObject(url, locale);
        i18n.currLocale = locale;
        i18n.locale.default = localeObject;
        i18n.locale[locale] = localeObject;
      };

      const setLang = locale => {
        const lang = getLanguageFromLocale(locale);
        const supportedLang = getSupportedLanguage(lang);

        i18n.PREFERRED_LANGUAGE = locale;
        getLocaleFile(supportedLang);
      };

      const loadTranslation = () => setLang(getLang());

      function getMessage(key) {
        let substitutions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        if (!key) {
          return '';
        }

        if (Object.keys(i18n.locale).length === 0) {
          loadTranslation();
        }

        const str = (i18n.locale[i18n.currLocale][key] || { message: key }).message || key;

        let subs = substitutions;

        if (!Array.isArray(substitutions)) {
          subs = [substitutions];
        }

        function replacer(matched, index, dollarSigns) {
          if (index) {
            const i = parseInt(index, 10) - 1;
            return i in subs ? subs[i] : '';
          }

          // For any series of contiguous `$`s, the first is dropped, and
          // the rest remain in the output string.
          return dollarSigns;
        }

        return str.replace(/\$(?:([1-9]\d*)|(\$+))/g, replacer);
      }

      var _slicedToArray$2 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      let _provider = null;

      function getProvider() {
        if (!_provider) {
          _provider = (
          // history autocomplete provider is removed
          // https://hg.mozilla.org/mozilla-central/rev/44a989cf6c16
          Components.classes['@mozilla.org/autocomplete/search;1?name=history'] || Components.classes['@mozilla.org/autocomplete/search;1?name=unifiedcomplete']).getService(Components.interfaces.nsIAutoCompleteSearch);
        }
        return _provider;
      }

      /* eslint-disable */

      // callback called multiple times
      function getHistory(q, callback) {
        let isPrivate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        const provider = getProvider();
        let lastMatchCount = 0;
        let searchParams = ['enable-actions', 'prohibit-autofill'];
        if (isPrivate) {
          searchParams.push('disable-private-actions');
          searchParams.push('private-window');
        }

        provider.startSearch(q, searchParams.join(' '), null, {
          onSearchResult: function onSearchResult(ctx, result) {
            const res = [];
            // TODO: remove this check when we switch to a new mixer completely
            const isNewSearchMode = prefs.get('searchMode', 'autocomplete') !== 'autocomplete';
            for (let i = lastMatchCount; result && i < result.matchCount; i++) {
              let style = result.getStyleAt(i);
              if (result.getValueAt(i).indexOf('https://cliqz.com/search?q=') === 0) {
                continue;
              }

              if (style.includes('heuristic') || style.includes('searchengine')) {
                // filter out "heuristic" and "searchengine" results
                continue;
              }

              if (style.indexOf('switchtab') !== -1) {
                try {
                  var _utils$cleanMozillaAc = CliqzUtils.cleanMozillaActions(result.getValueAt(i)),
                      _utils$cleanMozillaAc2 = _slicedToArray$2(_utils$cleanMozillaAc, 2);

                  let mozAction = _utils$cleanMozillaAc2[0],
                      cleanURL = _utils$cleanMozillaAc2[1];

                  let label;

                  // ignore freshtab, history and cliqz search
                  if (cleanURL.indexOf('chrome://cliqz') === 0 || cleanURL.indexOf('resource://cliqz') === 0 || cleanURL.indexOf('https://cliqz.com/search?q=') === 0) {
                    continue;
                  }

                  res.push({
                    style: style,
                    value: cleanURL,
                    image: result.getImageAt(i),
                    comment: result.getCommentAt(i),
                    label: label || cleanURL
                  });
                } catch (e) {
                  console$1.log('history result error', e);
                }
              } else {
                res.push({
                  style: style,
                  value: result.getValueAt(i),
                  image: result.getImageAt(i),
                  comment: result.getCommentAt(i),
                  label: result.getLabelAt(i)
                });
              }
            }
            callback({
              query: q,
              results: res,
              ready: result.searchResult != result.RESULT_NOMATCH_ONGOING && result.searchResult != result.RESULT_SUCCESS_ONGOING
            });

            if (isNewSearchMode) {
              lastMatchCount = result.matchCount;
            }
          }
        });
      }

      var VERTICAL_ENCODINGS = {
        'people': 'p',
        'news': 'n',
        'video': 'v',
        'hq': 'h',
        'bm': 'm',
        'reciperd': 'r',
        'game': 'g',
        'movie': 'o'
      };

      var BRANDS_DATABASE = { domains: Object.create(null), palette: ["999"] };

      var CliqzUtils = {
        environment: CLIQZEnvironment,
        RESULTS_PROVIDER: CLIQZEnvironment.RESULTS_PROVIDER,
        RICH_HEADER: CLIQZEnvironment.RICH_HEADER,
        RESULTS_PROVIDER_LOG: 'https://api.cliqz.com/api/v1/logging?q=',
        RESULTS_PROVIDER_PING: 'https://api.cliqz.com/ping',
        SAFE_BROWSING: 'https://safe-browsing.cliqz.com',
        TUTORIAL_URL: 'https://cliqz.com/home/onboarding',
        UNINSTALL: 'https://cliqz.com/home/offboarding',
        FEEDBACK: 'https://cliqz.com/feedback/',
        get FEEDBACK_URL() {
          return `${this.FEEDBACK}${this.VERSION}-${config.settings.channel}`;
        },
        RESULTS_TIMEOUT: CLIQZEnvironment.RESULTS_TIMEOUT,

        BRANDS_DATABASE: BRANDS_DATABASE,

        //will be updated from the mixer config endpoint every time new logos are generated
        BRANDS_DATABASE_VERSION: 1515404421880,
        GEOLOC_WATCH_ID: null, // The ID of the geolocation watcher (function that updates cached geolocation on change)
        VERTICAL_TEMPLATES: {
          'n': 'news',
          'p': 'people',
          'v': 'video',
          'h': 'hq',
          'r': 'recipe',
          'g': 'cpgame_movie',
          'o': 'cpgame_movie'
        },
        hm: null,
        hw: null,
        mc: null,
        TEMPLATES_PATH: CLIQZEnvironment.TEMPLATES_PATH,
        TEMPLATES: CLIQZEnvironment.TEMPLATES,
        MESSAGE_TEMPLATES: CLIQZEnvironment.MESSAGE_TEMPLATES,
        PARTIALS: CLIQZEnvironment.PARTIALS,
        SKIN_PATH: CLIQZEnvironment.SKIN_PATH,
        RERANKERS: CLIQZEnvironment.RERANKERS,
        CLIQZ_ONBOARDING: CLIQZEnvironment.CLIQZ_ONBOARDING,
        CLIQZ_ONBOARDING_URL: CLIQZEnvironment.CLIQZ_ONBOARDING_URL,
        BROWSER_ONBOARDING_PREF: CLIQZEnvironment.BROWSER_ONBOARDING_PREF,
        telemetryHandlers: [CLIQZEnvironment.telemetry],

        init() {
          // cutting cyclic dependency
          CLIQZEnvironment.getLogoDetails = CliqzUtils.getLogoDetails.bind(CliqzUtils);
          CLIQZEnvironment.getDetailsFromUrl = CliqzUtils.getDetailsFromUrl.bind(CliqzUtils);
          CLIQZEnvironment.getLocalizedString = CliqzUtils.getLocalizedString.bind(CliqzUtils);
          CLIQZEnvironment.app = CliqzUtils.app;
          CliqzUtils.log('Initialized', 'CliqzUtils');

          CliqzUtils.tldExtractor = CLIQZEnvironment.tldExtractor || CliqzUtils.genericTldExtractor;
        },
        isNumber: function isNumber(n) {
          /*
          NOTE: this function can't recognize numbers in the form such as: "1.2B", but it can for "1e4". See specification for isFinite()
           */
          return !isNaN(parseFloat(n)) && isFinite(n);
        },

        //returns the type only if it is known
        getKnownType: function getKnownType(type) {
          return VERTICAL_ENCODINGS.hasOwnProperty(type) && type;
        },

        /**
         * Construct a uri from a url
         * @param {string}  aUrl - url
         * @param {string}  aOriginCharset - optional character set for the URI
         * @param {nsIURI}  aBaseURI - base URI for the spec
         */
        makeUri: CLIQZEnvironment.makeUri,

        setLogoDb: function setLogoDb(db) {
          let domains = Object.create(null);
          db.domains = Object.assign(domains, db.domains);
          BRANDS_DATABASE = CliqzUtils.BRANDS_DATABASE = db;
        },
        getLogoDetails: function getLogoDetails(urlDetails) {
          var base = urlDetails.name,
              baseCore = base.replace(/[-]/g, ""),
              check = function check(host, rule) {
            var address = host.lastIndexOf(base),
                parseddomain = host.substr(0, address) + "$" + host.substr(address + base.length);

            return parseddomain.indexOf(rule) != -1;
          },
              result = {},
              domains = BRANDS_DATABASE.domains,
              blackTxtColor = '2d2d2d';

          if (base.length == 0) return result;

          if (base == "IP") result = { text: "IP", backgroundColor: "9077e3" };else if (domains[base]) {
            for (var i = 0, imax = domains[base].length; i < imax; i++) {
              var rule = domains[base][i]; // r = rule, b = background-color, l = logo, t = text, c = color

              if (check(urlDetails.host, rule.r)) {
                result = {
                  backgroundColor: rule.b ? rule.b : null,
                  backgroundImage: rule.l ? "url(https://cdn.cliqz.com/brands-database/database/" + this.BRANDS_DATABASE_VERSION + "/logos/" + base + "/" + rule.r + ".svg)" : "",
                  text: rule.t,
                  color: rule.c ? "" : "#fff",
                  brandTxtColor: rule.b ? rule.b : blackTxtColor
                };

                break;
              }
            }
          }
          result.text = result.text || `${baseCore[0] || ''}${baseCore[1] || ''}`.toLowerCase();
          result.backgroundColor = result.backgroundColor || BRANDS_DATABASE.palette[base.split("").reduce(function (a, b) {
            return a + b.charCodeAt(0);
          }, 0) % BRANDS_DATABASE.palette.length];
          result.brandTxtColor = result.brandTxtColor || blackTxtColor;
          var colorID = BRANDS_DATABASE.palette.indexOf(result.backgroundColor),
              buttonClass = BRANDS_DATABASE.buttons && colorID != -1 && BRANDS_DATABASE.buttons[colorID] ? BRANDS_DATABASE.buttons[colorID] : 10;

          result.buttonsClass = "cliqz-brands-button-" + buttonClass;
          result.style = "background-color: #" + result.backgroundColor + ";color:" + (result.color || '#fff') + ";";

          if (result.backgroundImage) result.style += "background-image:" + result.backgroundImage + "; text-indent: -10em;";

          return result;
        },
        httpHandler: function httpHandler() {
          var errorHandler = arguments[3]; // see httpGet or httpPost arguments
          try {
            return httpHandler$1.apply(undefined, arguments);
          } catch (e) {
            if (errorHandler) {
              errorHandler(e);
            } else {
              CliqzUtils.log(e, "httpHandler failed");
            }
          }
        },
        httpGet: function httpGet(url, callback, onerror, timeout, _, sync) {
          return CliqzUtils.httpHandler('GET', url, callback, onerror, timeout, _, sync);
        },
        httpPost: function httpPost(url, callback, data, onerror, timeout) {
          return CliqzUtils.httpHandler('POST', url, callback, onerror, timeout, data);
        },
        httpPut: function httpPut(url, callback, data, onerror, timeout) {
          return CliqzUtils.httpHandler('PUT', url, callback, onerror, timeout, data);
        },
        getLocalStorage(url) {
          return new Storage(url);
        },
        /**
         * Loads a resource URL from the xpi.
         *
         * Wraps httpGet in a try-catch clause. We need to do this, because when
         * trying to load a non-existing file from an xpi via xmlhttprequest, Firefox
         * throws a NS_ERROR_FILE_NOT_FOUND exception instead of calling the onerror
         * function.
         *
         * @see https://bugzilla.mozilla.org/show_bug.cgi?id=827243 (probably).
         */
        loadResource: function loadResource(url, callback, onerror) {
          try {
            return CliqzUtils.httpGet(url, callback, onerror, 3000);
          } catch (e) {
            CliqzUtils.log("Could not load resource " + url + " from the xpi", "CliqzUtils.httpHandler");
            onerror && onerror();
          }
        },
        openTabInWindow: CLIQZEnvironment.openTabInWindow,
        getPref: prefs.get,
        setPref: prefs.set,
        hasPref: prefs.has,
        clearPref: prefs.clear,
        log: function log(msg, key) {
          console$1.log(key, msg);
        },
        getDay: function getDay() {
          return Math.floor(new Date().getTime() / 86400000);
        },
        getServerDay: function getServerDay() {
          const serverDateStr = CliqzUtils.getPref('config_ts', null);
          if (serverDateStr) {
            try {
              const year = serverDateStr.substr(0, 4);
              const month = serverDateStr.substr(4, 2);
              const day = serverDateStr.substr(6, 2);
              const realDate = new Date(`${year}/${month}/${day}`);

              // we need to consider the timezone offset
              return Math.floor((realDate.getTime() - realDate.getTimezoneOffset() * 60 * 1000) / 86400000);
            } catch (e) {
              // fallback to getDay
            }
          }

          return CliqzUtils.getDay();
        },
        //creates a random 'len' long string from the input space
        rand: function rand(len, _space) {
          var ret = '',
              i,
              space = _space || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
              sLen = space.length;

          for (i = 0; i < len; i++) ret += space.charAt(Math.floor(random() * sLen));

          return ret;
        },
        hash: function hash(s) {
          return s.split('').reduce(function (a, b) {
            return (a << 4) - a + b.charCodeAt(0) & 0xEFFFFFF;
          }, 0);
        },
        cleanMozillaActions: cleanMozillaActions,
        cleanUrlProtocol: function cleanUrlProtocol(url, cleanWWW) {
          if (!url) return '';

          // removes protocol if it's http(s). See CLIQZIUM-218.
          const urlLowered = url.toLowerCase();
          if (urlLowered.startsWith('http://')) url = url.slice(7);
          if (urlLowered.startsWith('https://')) url = url.slice(8);

          // removes the www.
          if (cleanWWW && url.toLowerCase().startsWith('www.')) url = url.slice(4);

          return url;
        },
        genericTldExtractor: getPublicSuffix,
        getDetailsFromUrl: getDetailsFromUrl,
        stripTrailingSlash: stripTrailingSlash,
        isUrl: isUrl,
        // Checks if the given string is a valid IPv4 addres
        isIPv4: isIpv4Address,
        isIPv6: isIpv6Address,

        isLocalhost: isLocalhost,
        // checks if a value represents an url which is a seach engine
        isSearch: function isSearch(value) {
          if (CliqzUtils.isUrl(value)) {
            const url = this.cleanMozillaActions(value)[1];

            var _CliqzUtils$getDetail = CliqzUtils.getDetailsFromUrl(url);

            const name = _CliqzUtils$getDetail.name,
                  subdomains = _CliqzUtils$getDetail.subdomains,
                  path = _CliqzUtils$getDetail.path;
            // allow only 'www' and 'de' (for Yahoo) subdomains to exclude 'maps.google.com' etc.
            // and empty path only to exclude 'www.google.com/maps' etc.

            const firstSubdomain = subdomains.length ? subdomains[0] : '';
            return (!path || path.length === 1 && path[0] === '/') && ((name === 'google' || name === 'bing' || name === 'duckduckgo' || name === 'startpage') && (!firstSubdomain || firstSubdomain === 'www') || name === 'yahoo' && (!firstSubdomain || firstSubdomain === 'de'));
          }
          return false;
        },
        // checks if a string is a complete url
        isCompleteUrl: function isCompleteUrl(input) {
          var pattern = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
          if (!pattern.test(input)) {
            return false;
          } else {
            return true;
          }
        },
        // extract query term from search engine result page URLs
        extractQueryFromUrl: function extractQueryFromUrl(url) {
          // Google
          if (url.search(/http(s?):\/\/www\.google\..*\/.*q=.*/i) === 0) {
            url = url.substring(url.lastIndexOf('q=') + 2).split('&')[0];
            // Bing
          } else if (url.search(/http(s?):\/\/www\.bing\..*\/.*q=.*/i) === 0) {
            url = url.substring(url.indexOf('q=') + 2).split('&')[0];
            // Yahoo
          } else if (url.search(/http(s?):\/\/.*search\.yahoo\.com\/search.*p=.*/i) === 0) {
            url = url.substring(url.indexOf('p=') + 2).split('&')[0];
          } else {
            url = null;
          }
          var decoded = url ? decodeURIComponent(url.replace(/\+/g, ' ')) : null;
          if (decoded) return decoded;else return url;
        },
        // Remove clutter (http, www) from urls
        generalizeUrl: function generalizeUrl(url, skipCorrection) {
          if (!url) {
            return '';
          }
          var val = url.toLowerCase();
          var cleanParts = CliqzUtils.cleanUrlProtocol(val, false).split('/'),
              host = cleanParts[0],
              pathLength = 0,
              SYMBOLS = /,|\./g;
          if (!skipCorrection) {
            if (cleanParts.length > 1) {
              pathLength = ('/' + cleanParts.slice(1).join('/')).length;
            }
            if (host.indexOf('www') === 0 && host.length > 4) {
              // only fix symbols in host
              if (SYMBOLS.test(host[3]) && host[4] != ' ')
                // replace only issues in the host name, not ever in the path
                val = val.substr(0, val.length - pathLength).replace(SYMBOLS, '.') + (pathLength ? val.substr(-pathLength) : '');
            }
          }
          url = CliqzUtils.cleanUrlProtocol(val, true);
          return url[url.length - 1] == '/' ? url.slice(0, -1) : url;
        },
        // Remove clutter from urls that prevents pattern detection, e.g. checksum
        simplifyUrl: function simplifyUrl(url) {
          var q;
          // Google redirect urls
          if (url.search(/http(s?):\/\/www\.google\..*\/url\?.*url=.*/i) === 0) {
            // Return target URL instead
            url = url.substring(url.lastIndexOf('url=')).split('&')[0];
            url = url.substr(4);
            return decodeURIComponent(url);

            // Remove clutter from Google searches
          } else if (url.search(/http(s?):\/\/www\.google\..*\/.*q=.*/i) === 0) {
            q = url.substring(url.lastIndexOf('q=')).split('&')[0];
            if (q != 'q=') {
              // tbm defines category (images/news/...)
              var param = url.indexOf('#') != -1 ? url.substr(url.indexOf('#')) : url.substr(url.indexOf('?'));
              var tbm = param.indexOf('tbm=') != -1 ? '&' + param.substring(param.lastIndexOf('tbm=')).split('&')[0] : '';
              var page = param.indexOf('start=') != -1 ? '&' + param.substring(param.lastIndexOf('start=')).split('&')[0] : '';
              return 'https://www.google.com/search?' + q + tbm /*+ page*/;
            } else {
              return url;
            }
            // Bing
          } else if (url.search(/http(s?):\/\/www\.bing\..*\/.*q=.*/i) === 0) {
            q = url.substring(url.indexOf('q=')).split('&')[0];
            if (q != 'q=') {
              if (url.indexOf('search?') != -1) return url.substr(0, url.indexOf('search?')) + 'search?' + q;else return url.substr(0, url.indexOf('/?')) + '/?' + q;
            } else {
              return url;
            }
            // Yahoo redirect
          } else if (url.search(/http(s?):\/\/r.search\.yahoo\.com\/.*/i) === 0) {
            url = url.substring(url.lastIndexOf('/RU=')).split('/RK=')[0];
            url = url.substr(4);
            return decodeURIComponent(url);
            // Yahoo
          } else if (url.search(/http(s?):\/\/.*search\.yahoo\.com\/search.*p=.*/i) === 0) {
            var p = url.substring(url.indexOf('p=')).split('&')[0];
            if (p != 'p=' && url.indexOf(';') != -1) {
              return url.substr(0, url.indexOf(';')) + '?' + p;
            } else {
              return url;
            }
          } else {
            return url;
          }
        },

        // establishes the connection
        pingCliqzResults: function pingCliqzResults() {
          CliqzUtils.httpHandler('HEAD', CliqzUtils.RESULTS_PROVIDER_PING);
        },

        getResultsProviderQueryString: function getResultsProviderQueryString(q) {
          let numberResults = 5;
          if (CliqzUtils.getPref('languageDedup', false)) {
            numberResults = 7;
          }
          if (CliqzUtils.getPref('modules.context-search.enabled', false)) {
            numberResults = 10;
          }
          return encodeURIComponent(q) + CliqzUtils.encodeSessionParams() + CliqzLanguage.stateToQueryString() + CliqzUtils.encodeLocale() + CliqzUtils.encodePlatform() + CliqzUtils.encodeResultOrder() + CliqzUtils.encodeCountry() + CliqzUtils.encodeFilter() + CliqzUtils.encodeLocation(true) + // @TODO: remove true
          CliqzUtils.encodeResultCount(numberResults) + CliqzUtils.enncodeQuerySuggestionParam() + CliqzUtils.disableWikiDedup();
        },

        getRichHeaderQueryString: function getRichHeaderQueryString(q, loc) {
          let numberResults = 5;
          if (CliqzUtils.getPref('languageDedup', false)) {
            numberResults = 7;
          }
          if (CliqzUtils.getPref('modules.context-search.enabled', false)) {
            numberResults = 10;
          }
          return "&q=" + encodeURIComponent(q) + // @TODO: should start with &q=
          CliqzUtils.encodeSessionParams() + CliqzLanguage.stateToQueryString() + CliqzUtils.encodeLocale() + CliqzUtils.encodePlatform() + CliqzUtils.encodeResultOrder() + CliqzUtils.encodeCountry() + CliqzUtils.encodeFilter() + CliqzUtils.encodeLocation(true, loc && loc.latitude, loc && loc.longitude) + CliqzUtils.encodeResultCount(numberResults) + CliqzUtils.disableWikiDedup();
        },
        // used in testing only
        fetchFactory() {
          return fetchFactory();
        },

        getBackendResults: function getBackendResults(q) {
          const url = CliqzUtils.RESULTS_PROVIDER + CliqzUtils.getResultsProviderQueryString(q);
          const fetch$$1 = CliqzUtils.fetchFactory();
          const suggestionChoice = CliqzUtils.getPref('suggestionChoice', 0);
          const isOldMixer = CliqzUtils.getPref('searchMode', 'autocomplete') === 'autocomplete';
          const isPrivateMode = CliqzUtils.isPrivateMode();

          CliqzUtils._sessionSeq++;

          // if the user sees the results more than 500ms we consider that he starts a new query
          if (CliqzUtils._queryLastDraw && Date.now() > CliqzUtils._queryLastDraw + 500) {
            CliqzUtils._queryCount++;
          }
          CliqzUtils._queryLastDraw = 0; // reset last Draw - wait for the actual draw
          CliqzUtils._queryLastLength = q.length;

          const backendPromise = fetch$$1(url).then(res => res.json()).then(response => {
            // Logic for offer experiment
            if (prefs.get('myoffrz.experiments.001.position', 'first') === 'last') {
              const offerResults = response.results.filter(r => r.template === 'offer');
              const nonOfferResults = response.results.filter(r => r.template !== 'offer');

              response.results = [...nonOfferResults, ...offerResults];
            }

            if (response.results && (response.results.length > 0 || !config.settings.suggestions)) {

              if (suggestionChoice === 1 && !isPrivateMode) {
                if (response.suggestions && response.suggestions.length > 0) {
                  response.results = response.results.concat([{
                    url: 'https://cliqz.com/q=' + q,
                    template: 'inline-suggestion',
                    type: 'suggestion',
                    snippet: {
                      suggestions: response.suggestions.filter(r => r !== q),
                      source: 'Cliqz'
                    }
                  }]);
                }
              }

              return {
                response,
                query: q
              };
            } else if (config.settings.suggestions && suggestionChoice === 2) {
              return CliqzUtils.getSuggestions(q);
            } else {
              return {
                response: {
                  results: []
                },
                query: q
              };
            }
          });

          if (isOldMixer && suggestionChoice > 1 && !isPrivateMode) {
            return Promise.all([backendPromise, CliqzUtils.getSuggestions(q)]).then(values => {
              const searchResults = values[0].response.results || [];
              const googleSuggestions = values[1].response.results || [];

              return {
                query: q,
                response: {
                  results: searchResults.concat(googleSuggestions)
                }
              };
            });
          }

          return backendPromise;
        },

        historySearch: getHistory,

        getSuggestions: function getSuggestions(q) {
          const searchDataType = 'application/x-suggestions+json';
          const defaultEngine = CliqzUtils.getDefaultSearchEngine();
          const fetch$$1 = CliqzUtils.fetchFactory();
          const submissionUrl = defaultEngine.getSubmissionForQuery(q, searchDataType);

          if (submissionUrl) {
            return fetch$$1(submissionUrl).then(res => res.json()).then(response => {
              return {
                response: {
                  results: response[1].filter(r => r !== q).map(q => {
                    return {
                      url: defaultEngine.getSubmissionForQuery(q),
                      template: 'suggestion',
                      type: 'suggestion',
                      snippet: { suggestion: q }
                    };
                  })
                },
                query: response[0]
              };
            });
          } else {
            // there is no suggestion URL for the default search Engine
            return Promise.resolve({
              response: { results: [] },
              query: q
            });
          }
        },
        setDefaultIndexCountry: function setDefaultIndexCountry(country) {
          var supportedCountries = JSON.parse(CliqzUtils.getPref("config_backends", '["de"]'));
          if (supportedCountries.indexOf(country) !== -1) {
            // supported country
            CliqzUtils.setPref('backend_country', country);
          } else {
            // unsupported country - fallback to
            //    'de' for german speaking users
            //    'en' for everybody else
            if (CliqzUtils.currLocale === 'de') {
              CliqzUtils.setPref('backend_country', 'de');
            } else {
              CliqzUtils.setPref('backend_country', 'us');
            }
          }
        },
        encodePlatform: function encodePlatform() {
          return '&platform=' + (isMobile ? '1' : '0');
        },
        encodeLocale: function encodeLocale() {
          return '&locale=' + CliqzUtils.PREFERRED_LANGUAGE || '';
        },
        encodeCountry: function encodeCountry() {
          return '&country=' + CliqzUtils.getPref('backend_country', 'de');
        },
        disableWikiDedup: function disableWikiDedup() {
          // disable wikipedia deduplication on the backend side
          var doDedup = CliqzUtils.getPref("languageDedup", false);
          if (doDedup) return '&ddl=0';else return "";
        },
        getAdultContentFilterState: function getAdultContentFilterState() {
          var data = {
            'conservative': 3,
            'moderate': 0,
            'liberal': 1
          },
              pref = CliqzUtils.getPref('adultContentFilter', 'moderate');
          return data[pref];
        },
        encodeFilter: function encodeFilter() {
          return '&adult=' + CliqzUtils.getAdultContentFilterState();
        },
        encodeResultCount: function encodeResultCount(count) {
          count = count || 5;
          return '&count=' + count;
        },
        enncodeQuerySuggestionParam: function enncodeQuerySuggestionParam() {
          const suggestionsEnabled = CliqzUtils.getPref("suggestionsEnabled", false) || CliqzUtils.getPref("suggestionChoice", 0) === 1;

          return `&suggest=${suggestionsEnabled ? 1 : 0}`;
        },
        encodeResultType: function encodeResultType(type) {
          if (type.indexOf('action') !== -1) return ['T'];else if (type.indexOf('cliqz-results') == 0) return CliqzUtils.encodeCliqzResultType(type);else if (type.indexOf('cliqz-pattern') == 0) return ['C'];else if (type === 'cliqz-extra') return ['X'];else if (type === 'cliqz-series') return ['S'];else if (type === 'cliqz-suggestion') return ['Z'];else if (type.indexOf('bookmark') == 0 || type.indexOf('tag') == 0) return ['B'].concat(CliqzUtils.encodeCliqzResultType(type));else if (type.indexOf('favicon') == 0 || type.indexOf('history') == 0) return ['H'].concat(CliqzUtils.encodeCliqzResultType(type));

          // cliqz type = "cliqz-custom sources-X"
          else if (type.indexOf('cliqz-custom') == 0) return type.substr(21);

          return type; //should never happen
        },
        //eg types: [ "H", "m" ], [ "H|instant", "X|11" ]
        isPrivateResultType: function isPrivateResultType() {
          let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          if (type.length === 0) {
            return false;
          }

          var onlyType = type[0].split('|')[0];
          var hasCluster = type.some(function (a) {
            return a.split('|')[0] === 'C';
          });

          if (hasCluster) {
            // we want to be extra carefull and do not send back any cluster information
            return true;
          }

          return 'HBTCS'.indexOf(onlyType) != -1 && type.length == 1;
        },
        // cliqz type = "cliqz-results sources-XXXXX" or "favicon sources-XXXXX" if combined with history
        encodeCliqzResultType: function encodeCliqzResultType(type) {
          var pos = type.indexOf('sources-');
          if (pos != -1) return CliqzUtils.encodeSources(type.substr(pos + 8));else return [];
        },
        // random ID generated at each urlbar focus
        _searchSession: '',
        // number of sequences in each session
        _sessionSeq: 0,
        _queryLastLength: null,
        _queryLastDraw: null,
        // number of queries in search session
        _queryCount: null,
        setSearchSession: function setSearchSession(rand) {
          CliqzUtils._searchSession = rand;
          CliqzUtils._sessionSeq = 0;
          CliqzUtils._queryCount = 0;
          CliqzUtils._queryLastLength = 0;
          CliqzUtils._queryLastDraw = 0;
        },
        encodeSessionParams: function encodeSessionParams() {
          if (CliqzUtils._searchSession.length) {
            return '&s=' + encodeURIComponent(CliqzUtils._searchSession) + '&n=' + CliqzUtils._sessionSeq + '&qc=' + CliqzUtils._queryCount;
          } else return '';
        },

        encodeLocation: function encodeLocation(specifySource, lat, lng) {
          // default geolocation 'yes' for funnelCake - 'ask' for everything else
          let locationPref = CliqzUtils.getPref('share_location', config.settings.geolocation || 'ask');
          if (locationPref === 'showOnce') {
            locationPref = 'ask';
          }
          let qs = `&loc_pref=${locationPref}`;

          if (CliqzUtils.USER_LAT && CliqzUtils.USER_LNG || lat && lng) {
            qs += ['&loc=', lat || CliqzUtils.USER_LAT, ',', lng || CliqzUtils.USER_LNG, specifySource ? ',U' : ''].join('');
          }

          return qs;
        },
        encodeSources: function encodeSources(sources) {
          return sources.toLowerCase().split(', ').map(function (s) {
            if (s.indexOf('cache') == 0) // to catch 'cache-*' for specific countries
              return 'd';else return VERTICAL_ENCODINGS[s] || s;
          });
        },
        /**
         * @deprecated - use isPrivateMode instead
         * @todo - add deprecation logging in 1.23
         */
        isPrivate: CLIQZEnvironment.isPrivate,
        /**
         * @deprecated - use isPrivateMode instead
         * @todo - add deprecation logging in 1.23
         */
        isOnPrivateTab: CLIQZEnvironment.isOnPrivateTab,
        isPrivateMode(win) {
          if (!win) {
            win = CliqzUtils.getWindow();
          }
          return CliqzUtils.isPrivate(win) || CliqzUtils.isOnPrivateTab(win);
        },
        telemetry: function telemetry() {
          const args = arguments;
          CliqzUtils.telemetryHandlers.forEach(handler => handler.apply(null, args));
        },
        resultTelemetry: function resultTelemetry(query, queryAutocompleted, resultIndex, resultUrl, resultOrder, extra) {
          if (CliqzUtils.isPrivateMode()) {
            return;
          }

          CliqzUtils.setResultOrder(resultOrder);
          CliqzEvents.pub("human-web:sanitize-result-telemetry", { type: 'extension-result-telemetry',
            q: query,
            s: CliqzUtils.encodeSessionParams(),
            msg: {
              i: resultIndex,
              o: CliqzUtils.encodeResultOrder(),
              u: resultUrl ? resultUrl : '',
              a: queryAutocompleted,
              e: extra
            },
            endpoint: CliqzUtils.RESULTS_PROVIDER_LOG,
            method: "GET"
          });
          CliqzUtils.setResultOrder('');
        },
        sendUserFeedback(data) {
          data._type = 'user_feedback';
          // Params: method, url, resolve, reject, timeout, data
          httpHandler$1('POST', CLIQZEnvironment.LOG, null, null, 10000, JSON.stringify(data));
        },
        _resultOrder: '',
        setResultOrder: function setResultOrder(resultOrder) {
          CliqzUtils._resultOrder = resultOrder;
        },
        encodeResultOrder: function encodeResultOrder() {
          return CliqzUtils._resultOrder && CliqzUtils._resultOrder.length ? '&o=' + encodeURIComponent(JSON.stringify(CliqzUtils._resultOrder)) : '';
        },
        setInterval: CLIQZEnvironment.setInterval,
        setTimeout: CLIQZEnvironment.setTimeout,
        clearTimeout: CLIQZEnvironment.clearTimeout,
        clearInterval: CLIQZEnvironment.clearTimeout,
        Promise: CLIQZEnvironment.Promise,

        /* i18n -- start */
        // TODO: all those should be remove and used from i18n directly
        get locale() {
          return i18n.locale;
        },
        get currLocale() {
          return i18n.currLocale;
        },
        get PREFERRED_LANGUAGE() {
          return i18n.PREFERRED_LANGUAGE;
        },
        get LOCALE_PATH() {
          return i18n.LOCALE_PATH;
        },
        getLanguageFromLocale: getLanguageFromLocale,
        getLocalizedString: getMessage,
        // gets all the elements with the class 'cliqz-locale' and adds
        // the localized string - key attribute - as content
        localizeDoc: function localizeDoc(doc) {
          var locale = doc.getElementsByClassName('cliqz-locale');
          for (var i = 0; i < locale.length; i++) {
            var el = locale[i];
            el.textContent = getMessage(el.getAttribute('key'));
          }
        },
        /* i18n -- end */
        /* platform -- start */
        isWindows,
        isLinux,
        isMac,
        /* platform -- end */
        getWindow: CLIQZEnvironment.getWindow,
        getWindowID: CLIQZEnvironment.getWindowID,
        /**
         * Bind functions contexts to a specified object.
         * @param {Object} from - An object, whose function properties will be processed.
         * @param {Object} to - An object, which will be the context (this) of processed functions.
         */
        bindObjectFunctions: function bindObjectFunctions(from, to) {
          for (var funcName in from) {
            var func = from[funcName];
            if (!from.hasOwnProperty(funcName)) continue;
            // Can't compare with prototype of object from a different module.
            if (typeof func != "function") continue;
            from[funcName] = func.bind(to);
          }
        },
        tryDecodeURIComponent: tryDecodeURIComponent,
        tryDecodeURI: tryDecodeURI,
        tryEncodeURIComponent: tryEncodeURIComponent,
        tryEncodeURI: tryEncodeURI,
        parseQueryString: function parseQueryString(qstr) {
          var query = {};
          var a = (qstr || '').split('&');
          for (var i in a) {
            var b = a[i].split('=');
            query[CliqzUtils.tryDecodeURIComponent(b[0])] = CliqzUtils.tryDecodeURIComponent(b[1]);
          }

          return query;
        },
        roundToDecimal: function roundToDecimal(number, digits) {
          var multiplier = Math.pow(10, digits);
          return Math.round(number * multiplier) / multiplier;
        },
        getAdultFilterState: function getAdultFilterState() {
          var data = {
            'conservative': {
              name: CliqzUtils.getLocalizedString('always'),
              selected: false
            },
            'moderate': {
              name: CliqzUtils.getLocalizedString('always_ask'),
              selected: false
            },
            'liberal': {
              name: CliqzUtils.getLocalizedString('never'),
              selected: false
            }
          };
          let state = CliqzUtils.getPref('adultContentFilter', 'moderate');
          if (state === 'showOnce') {
            state = 'moderate';
          }
          data[state].selected = true;

          return data;
        },
        getLocationPermState() {
          var data = {
            'yes': {
              name: CliqzUtils.getLocalizedString('always'),
              selected: false
            },
            'ask': {
              name: CliqzUtils.getLocalizedString('always_ask'),
              selected: false
            },
            'no': {
              name: CliqzUtils.getLocalizedString('never'),
              selected: false
            }
          };
          var currentState = CliqzUtils.getPref('share_location', config.settings.geolocation || 'ask');
          if (currentState === 'showOnce') {
            currentState = 'ask';
          }

          // default geolocation 'yes' for funnelCake - 'ask' for everything else
          data[currentState].selected = true;

          return data;
        },

        // Returns result elements selecatble and navigatable from keyboard.
        // |container| search context, usually it's `CLIQZ.UI.gCliqzBox`.
        extractSelectableElements(container) {
          return Array.prototype.slice.call(container.querySelectorAll('[arrow]')).filter(function (el) {
            // dont consider hidden elements
            if (el.offsetParent == null) return false;

            if (!el.getAttribute('arrow-if-visible')) return true;

            // check if the element is visible
            //
            // for now this check is enough but we might be forced to switch to a
            // more generic approach - maybe using document.elementFromPoint(x, y)
            if (el.offsetLeft + el.offsetWidth > el.parentElement.offsetWidth) return false;
            return true;
          });
        },

        getNoResults: CLIQZEnvironment.getNoResults,
        getParameterByName: function getParameterByName(name, location) {
          name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
          var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
              results = regex.exec(location.search);
          return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        },
        search: CLIQZEnvironment.search,
        distance: function distance(lon1, lat1) {
          let lon2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CliqzUtils.USER_LNG;
          let lat2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CliqzUtils.USER_LAT;

          /** Converts numeric degrees to radians */
          function degreesToRad(degree) {
            return degree * Math.PI / 180;
          }

          var R = 6371; // Radius of the earth in km
          if (!lon2 || !lon1 || !lat2 || !lat1) {
            return -1;
          }
          var dLat = degreesToRad(lat2 - lat1); // Javascript functions in radians
          var dLon = degreesToRad(lon2 - lon1);
          var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(degreesToRad(lat1)) * Math.cos(degreesToRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
          var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          var d = R * c; // Distance in km
          return d;
        },
        getDefaultSearchEngine: CLIQZEnvironment.getDefaultSearchEngine,
        copyResult: CLIQZEnvironment.copyResult,
        openPopup: CLIQZEnvironment.openPopup,
        getAllCliqzPrefs: CLIQZEnvironment.getAllCliqzPrefs,
        isDefaultBrowser: CLIQZEnvironment.isDefaultBrowser,
        setDefaultSearchEngine: CLIQZEnvironment.setDefaultSearchEngine,
        isUnknownTemplate: CLIQZEnvironment.isUnknownTemplate,
        getEngineByName: CLIQZEnvironment.getEngineByName,
        addEngineWithDetails: CLIQZEnvironment.addEngineWithDetails,
        restoreHiddenSearchEngines: CLIQZEnvironment.restoreHiddenSearchEngines,
        removeEngine: CLIQZEnvironment.removeEngine,
        getEngineByAlias: CLIQZEnvironment.getEngineByAlias,
        getSearchEngines: CLIQZEnvironment.getSearchEngines,
        updateAlias: CLIQZEnvironment.updateAlias,
        openLink: CLIQZEnvironment.openLink,
        getCliqzPrefs() {
          function filterer(entry) {
            // avoid privay leaking prefs ('backup').
            // avoid irrelevant deep prefs (something.otherthing.x.y)
            // avoid prefs sending domains.
            // allow 'enabled' prefs
            return entry.indexOf('.') == -1 && entry.indexOf('backup') == -1 && entry.indexOf('attrackSourceDomainWhitelist') == -1 || entry.indexOf('.enabled') != -1;
          }

          let cliqzPrefs = {};
          let cliqzPrefsKeys = CliqzUtils.getAllCliqzPrefs().filter(filterer);

          for (let i = 0; i < cliqzPrefsKeys.length; i++) {
            cliqzPrefs[cliqzPrefsKeys[i]] = prefs.get(cliqzPrefsKeys[i]);
          }

          return cliqzPrefs;
        },
        promiseHttpHandler: promiseHttpHandler,
        registerResultProvider: function registerResultProvider(o) {
          CLIQZEnvironment.CliqzResultProviders = o.ResultProviders;
          CLIQZEnvironment.Result = o.Result;
        },
        lastRenderedResults: [],
        lastRenderedURLs: [],
        lastSelection: -1,
        onRenderComplete: function onRenderComplete(query, box) {
          if (!CLIQZEnvironment.onRenderComplete) return;

          CliqzUtils.lastRenderedResults = this.extractSelectableElements(box).filter(function (node) {
            return !!(node.getAttribute("url") || node.getAttribute("href"));
          });
          CliqzUtils.lastRenderedURLs = CliqzUtils.lastRenderedResults.map(function (node) {
            return node.getAttribute("url") || node.getAttribute("href");
          });

          CLIQZEnvironment.onRenderComplete(query, CliqzUtils.lastRenderedURLs);
        },
        fetchAndStoreConfig() {
          return Promise.resolve();
        },
        onSelectionChange: function onSelectionChange(element) {
          if (!element) return;

          var current = CliqzUtils.lastRenderedResults.indexOf(element);
          if (current == -1) {
            current = CliqzUtils.lastRenderedURLs.indexOf(element.getAttribute("url"));
          }

          if (CliqzUtils.lastSelection == current) return;
          CliqzUtils.lastSelection = current;

          if (!CLIQZEnvironment.onResultSelectionChange) return;
          CLIQZEnvironment.onResultSelectionChange(current);
        }
      };

      /* eslint-disable */
      /*
       Copyright (c) 2013, Nick Fitzgerald
      
        All rights reserved.
      
        Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
            Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      
            Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      */
      // https://developer.chrome.com/extensions/content_scripts#match-patterns-globs
      // source: https://github.com/fitzgen/glob-to-regexp

      /* eslint-enable */

      /* eslint-disable */
      function getWindowId(window) {
        return window.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindowUtils).outerWindowID;
      }
      /* eslint-enable */

      const CHROME_MSG_SOURCE = 'cliqz-content-script';

      var _extends$1 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const PROCESS_SCRIPT_URL = `${config.baseURL}platform/process-script.bundle.js`;
      const FRAME_SCRIPT_URL = `${config.baseURL}core/frameScript.js`;

      class ProcessScriptManager {
        constructor(dispatcher) {
          this.dispatchMessage = dispatcher;
          this.timestamp = Date.now();
        }

        get ppmm() {
          return Components.classes['@mozilla.org/parentprocessmessagemanager;1'].getService(Components.interfaces.nsIProcessScriptLoader);
        }

        get gmm() {
          return Components.classes['@mozilla.org/globalmessagemanager;1'].getService(Components.interfaces.nsIMessageListenerManager);
        }

        get processScriptUrl() {
          return `${PROCESS_SCRIPT_URL}?t=${this.timestamp}`;
        }

        get frameScriptUrl() {
          return `${FRAME_SCRIPT_URL}?t=${this.timestamp}`;
        }

        init() {
          // on extension update or downgrade there might be a race condition
          // and we might end up having no process script
          CliqzUtils.setTimeout(this.ppmm.loadProcessScript.bind(this.ppmm, this.processScriptUrl, true), 0);
          CliqzUtils.setTimeout(this.gmm.loadFrameScript.bind(this.gmm, this.frameScriptUrl, true), 0);

          this.addMessageListener('cliqz', this.dispatchMessage);
        }

        unload() {
          this.removeMessageListener('cliqz', this.dispatchMessage);
          this.broadcast('cliqz:core', {
            action: 'unload'
          });
          this.broadcast('cliqz:process-script', {
            action: 'unload'
          });
          this.ppmm.removeDelayedProcessScript(this.processScriptUrl);
          this.gmm.removeDelayedFrameScript(this.frameScriptUrl);
        }

        broadcast(channel, msg) {
          /* eslint-disable no-param-reassign */
          if (typeof msg === 'object') {
            msg = _extends$1({}, msg, {
              source: CHROME_MSG_SOURCE
            });
          }

          this.ppmm.broadcastAsyncMessage(channel, msg);
          this.gmm.broadcastAsyncMessage(channel, msg);
        }

        addMessageListener(channel, cb) {
          this.ppmm.addMessageListener(channel, cb);
          this.gmm.addMessageListener(channel, cb);
        }

        removeMessageListener(channel, cb) {
          this.ppmm.removeMessageListener(channel, cb);
          this.gmm.removeMessageListener(channel, cb);
        }
      }

      // source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
      function completeAssign(target) {
        for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          sources[_key - 1] = arguments[_key];
        }

        sources.forEach(source => {
          let descriptors = Object.keys(source).reduce((descriptors, key) => {
            descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
            return descriptors;
          }, {});
          // by default, Object.assign copies enumerable Symbols too
          if (typeof Symbol !== 'undefined') {
            Object.getOwnPropertySymbols(source).forEach(sym => {
              let descriptor = Object.getOwnPropertyDescriptor(source, sym);
              if (descriptor.enumerable) {
                descriptors[sym] = descriptor;
              }
            });
          }
          Object.defineProperties(target, descriptors);
        });
        return target;
      }

      var background = function (originalBackground) {
        const background = completeAssign({}, originalBackground);
        const bgInit = background.init;
        const bgUnload = background.unload;
        const bgEvents = background.events;

        // bind actions to background object
        Object.keys(background.actions || {}).forEach(action => {
          background.actions[action] = background.actions[action].bind(background);
        });

        background.init = function init() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          const promise = Promise.resolve(bgInit.apply(background, args));

          Object.keys(bgEvents || {}).forEach(event => {
            bgEvents[event] = bgEvents[event].bind(background);
            CliqzEvents.sub(event, bgEvents[event]);
          });
          return promise;
        };

        background.unload = function unload() {
          Object.keys(bgEvents || {}).forEach(event => {
            CliqzEvents.un_sub(event, bgEvents[event]);
          });

          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          bgUnload.apply(background, args);
        };

        return background;
      };

      class ResourceManager {
        constructor() {
          this.loaders = [];
          this.initialised = false;
        }

        init() {
          const loadPromises = this.loaders.map(e => this._startLoader(e.loader, e.callback));
          this.initialised = true;
          return Promise.all(loadPromises);
        }

        unload() {
          this.loaders.forEach(e => {
            e.loader.stop();
          });
          this.initialised = false;
        }

        addResourceLoader(resourceLoader, callback) {
          this.loaders.push({
            loader: resourceLoader,
            callback
          });
          if (this.initialised) {
            // extension is already running, we can load this resource straight away
            this._startLoader(resourceLoader, callback);
          }
        }

        _startLoader(resourceLoader, callback) {
          resourceLoader.onUpdate(callback);
          return resourceLoader.load().then(callback);
        }
      }

      const manager = new ResourceManager();

      let app;

      class ModuleMissingError extends Error {
        constructor(moduleName) {
          super(`module '${moduleName}' is missing`);
          this.name = 'ModuleMissingError';
        }
      }

      class ModuleDisabledError extends Error {
        constructor(moduleName) {
          super(`module '${moduleName}' is disabled`);
          this.name = 'ModuleDisabledError';
        }
      }

      /**
       * Given the promise resulting from a call to `action`, ignore errors resulting
       * from a disabled module. This can be especially useful during extension
       * restart when modules are stopped in arbitrary order and some actions might
       * fail.
       */
      function ifModuleEnabled(promise) {
        return promise.catch(err => {
          if (err.name === ModuleDisabledError.name) {
            console$1.debug('Ignoring disabled module exception while calling action,' + ' the following exception can be safely ignored. This log' + ' is only printed in "debug" mode.', err);
            return Promise.resolve();
          }

          // Re-emit the same error if the cause is not `ModuleDisabledError`
          return Promise.reject(err);
        });
      }

      class ModuleWrapper {
        constructor(moduleName) {
          this.moduleName = moduleName;
        }

        get module() {
          return app && app.modules[this.moduleName];
        }

        isWindowReady(window) {
          return this.isReady().then(() => this.module.getWindowLoadingPromise(window));
        }

        isReady() {
          if (!this.module) {
            return Promise.reject(new ModuleMissingError(this.moduleName));
          }

          if (this.module.isDisabled) {
            return Promise.reject(new ModuleDisabledError(this.moduleName));
          }

          return this.module.isReady();
        }

        isEnabled() {
          return !!(this.module && !this.module.isDisabled);
        }

        action(actionName) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return this.isReady().then(() => this.module.background.actions[actionName](...args));
        }

        windowAction(window, actionName) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          return this.isWindowReady(window).then(() => {
            const windowModule = this.module.getWindowModule(window);
            const action = windowModule.actions[actionName];
            return Promise.resolve(action(...args));
          });
        }
      }

      var inject = {
        /**
         * Gets a module wrapper.
         * @param {string} -  moduleName Name of the module to be injected
         */
        module(moduleName) {
          return new ModuleWrapper(moduleName);
        }
      };

      function setGlobal(cliqzApp) {
        app = cliqzApp;
      }

      function queryCliqz(query) {
        const urlBar = CliqzUtils.getWindow().document.getElementById('urlbar');

        urlBar.mInputField.setUserInput('');
        urlBar.focus();
        urlBar.mInputField.focus();
        urlBar.mInputField.setUserInput(query);
      }

      function openLink$1(url) {
        const window = CliqzUtils.getWindow();
        CliqzUtils.openLink(window, url, true);
      }

      function openTab() {}

      function getOpenTabs() {}

      function getReminders() {}

      // not available in older FF versions

      /* global OS */

      try {
        Components.utils.import('resource://gre/modules/osfile.jsm');
      } catch (e) {
        // Nothing
      }

      function getFullPath(filePath) {
        const path = Array.isArray(filePath) ? filePath : [filePath];
        return OS.Path.join(OS.Constants.Path.profileDir, ...path);
      }

      function encodeText(text) {
        return new TextEncoder().encode(text);
      }

      function decodeText(array) {
        return new TextDecoder().decode(array);
      }

      function readFile(filePath) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        let isText = _ref.isText;

        return OS.File.read(getFullPath(filePath)).then(data => isText ? decodeText(data) : data);
      }

      function writeFile(filePath, data) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        let isText = _ref2.isText;

        return OS.File.writeAtomic(getFullPath(filePath), isText ? encodeText(data) : data);
      }

      // Not atomic truncating write


      function mkdir(dirPath) {
        return OS.File.makeDir(getFullPath(dirPath), { ignoreExisting: true });
      }

      function fileExists(path) {
        return OS.File.exists(getFullPath(path));
      }

      // Opens given path file for appending, and resolves to file descriptor object,
      // which can be used as input for writeStringFile and close functions


      // Writes to open file


      // Closes open file

      function _toArray(arr) {
        return Array.isArray(arr) ? arr : Array.from(arr);
      }

      function makeDirRecursive(path) {
        let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        var _path = _toArray(path);

        const first = _path[0],
              rest = _path.slice(1);

        if (!first) {
          return Promise.resolve();
        }

        return mkdir(from.concat(first)).then(() => makeDirRecursive(rest, from.concat(first)));
      }

      class Storage$1 {
        constructor(filePath) {
          this.filePath = filePath;
        }

        load() {
          return readFile(this.filePath);
        }

        save(data) {
          const dirPath = this.filePath.slice(0, -1);
          return makeDirRecursive(dirPath).then(() => {
            try {
              // If TextEncoder is not available just use `data`
              return new TextEncoder().encode(data);
            } catch (e) {
              return data;
            }
          }).then(encoded => writeFile(this.filePath, encoded));
        }
      }

      /* eslint-disable no-bitwise */
      /* eslint-disable no-param-reassign */
      /* eslint-disable no-plusplus */
      /* eslint-disable no-sparse-arrays */

      function toByteArray(data) {
        if (data.buffer) {
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        }
        return new Uint8Array(data);
      }

      function _toString(data) {
        const CHUNK_SIZE = 32767;
        const c = [];
        const len = data.length;
        for (let i = 0; i < len; i += CHUNK_SIZE) {
          c.push(String.fromCharCode.apply(null, data.subarray(i, i + CHUNK_SIZE)));
        }
        return c.join('');
      }

      function _fromString(data) {
        const res = new Uint8Array(data.length);
        const len = data.length;
        for (let i = 0; i < len; i += 1) {
          res[i] = data.charCodeAt(i);
        }
        return res;
      }

      /* Encodes a Uint8Array as a base64 string */
      function toBase64Fast(data) {
        return btoa(_toString(toByteArray(data)));
      }

      /* toBase64 without using btoa */
      function toBase64Slow(data) {
        data = toByteArray(data);
        const modtable = [0, 2, 1];
        const enctable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        const inlength = data.byteLength;
        const outlength = 4 * Math.floor((inlength + 2) / 3);

        const encdata = new Array(outlength);

        for (let i = 0, j = 0; i < inlength;) {
          const octa = i < inlength ? data[i++] : 0;
          const octb = i < inlength ? data[i++] : 0;
          const octc = i < inlength ? data[i++] : 0;

          const triple = (octa << 0x10) + (octb << 0x08) + octc;

          encdata[j++] = enctable[triple >> 3 * 6 & 0x3F];
          encdata[j++] = enctable[triple >> 2 * 6 & 0x3F];
          encdata[j++] = enctable[triple >> 1 * 6 & 0x3F];
          encdata[j++] = enctable[triple >> 0 * 6 & 0x3F];
        }

        for (let i = 0; i < modtable[inlength % 3]; i++) {
          encdata[outlength - 1 - i] = '=';
        }

        return encdata.join('');
      }

      // http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html
      function _toUTF8(s) {
        return _fromString(unescape(encodeURIComponent(s)));
      }

      function _fromUTF8(s) {
        return decodeURIComponent(escape(_toString(s)));
      }

      /* Returns a string given a Uint8Array UTF-8 encoding */
      const decoder = TextDecoder ? new TextDecoder() : { decode: _fromUTF8 };
      function fromUTF8(bytes) {
        return decoder.decode(toByteArray(bytes));
      }

      /* Returns a Uint8Array UTF-8 encoding of the given string */
      const encoder = TextEncoder ? new TextEncoder() : { encode: _toUTF8 };
      const toBase64 = typeof btoa !== 'undefined' ? toBase64Fast : toBase64Slow;

      var lazyLoader = (bundle, exportedSymbol) => {
        const url = `${config.baseURL}vendor/${bundle}`;
        let lib = null;

        const load = () => {
          if (lib === null) {
            // in case we load in chrome:// pages, the lib may be loaded on a window
            if (typeof window$1 !== 'undefined') {
              if (window$1[exportedSymbol]) {
                lib = window$1[exportedSymbol];
                return;
              }
            }

            const target = {
              window: safeGlobal
            };

            Services.scriptloader.loadSubScriptWithOptions(url, {
              target,
              ignoreCache: true
            });

            if (target[exportedSymbol] !== undefined) {
              lib = target[exportedSymbol];
            } else {
              lib = target.window[exportedSymbol];
            }
          }
        };

        /* eslint-disable func-names, prefer-arrow-callback, new-cap */
        return new Proxy(function () {}, {
          /**
           * Intercept construction on the proxy.
           */
          construct: (target, argumentsList) => {
            load();
            if (lib) {
              return new lib(...argumentsList);
            }
            return null;
          },

          /**
           * Intercept call on the proxy
           */
          apply: (target, thisArg, argumentsList) => {
            load();
            if (lib) {
              return lib.apply(thisArg, argumentsList);
            }
            return null;
          },

          get: (target, prop) => {
            load();
            if (lib) {
              return lib[prop];
            }
            return null;
          },

          set: (target, key, prop) => {
            load();
            if (lib) {
              lib[key] = prop;
              return true;
            }
            return false;
          }
        });
        /* eslint-enable func-names, prefer-arrow-callback, new-cap */
      };

      const zlibProxy = lazyLoader('pako.min.js', 'pako');

      function inflate() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return zlibProxy.inflate.call(zlibProxy, ...args);
      }

      function deflate() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return zlibProxy.deflate.call(zlibProxy, ...args);
      }

      // Common durations
      const ONE_SECOND = 1000;
      const ONE_MINUTE = 60 * ONE_SECOND;
      const ONE_HOUR = 60 * ONE_MINUTE;

      function get$1(url) {
        return fetch(url).then(response => response.text());
      }

      /* Abstract away the pattern `onUpdate` trigger list of
       * callbacks. This pattern is used a lot, so it looks worth
       * it to create a base class to handle it.
       */
      class UpdateCallbackHandler {
        constructor() {
          this.callbacks = [];
        }

        onUpdate(callback) {
          this.callbacks.push(callback);
        }

        triggerCallbacks(args) {
          return Promise.all(this.callbacks.map(cb => cb(args)));
        }
      }

      /* A resource is responsible for handling a remote resource persisted on
       * disk. It will be persisted on disk upon each update from remote. It is
       * also able to parse JSON automatically if `dataType` is 'json'.
       */
      class Resource {

        constructor(name) {
          let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          this.name = typeof name === 'string' ? [name] : name;
          this.remoteURL = options.remoteURL;
          this.dataType = options.dataType || 'json';
          this.filePath = ['cliqz', ...this.name];
          this.chromeURL = options.chromeURL || `${config.baseURL}${this.name.join('/')}`;
          this.storage = new Storage$1(this.filePath);
          this.remoteOnly = options.remoteOnly || false;
          this.compress = options.compress || isChromium ? true : false;
        }

        /**
         * Loads the resource. Load either a cached version of the file available in
         * the profile, or at the chrome URL (if provided) or from remote.
         *
         * @returns a Promise resolving to the resource. This Promise can fail on
         * error (if the remote resource cannot be fetched, or if the parsing
         * fails, for example), thus **you should should add a _catch_** to this
         * promise to handle errors properly.
         */
        load() {
          return this.storage.load().then(data => this.decompressData(data)).then(data => {
            try {
              // data might be a plain string in web extension case
              // for react native the TextDecoder.decode returns an empty string
              return fromUTF8(data) || data;
            } catch (e) {
              return data;
            }
          }).then(data => this.parseData(data)).catch(() => {
            if (this.remoteOnly) {
              return Promise.reject('Should update only from remote');
            } else {
              return this.updateFromURL(this.chromeURL);
            }
          }).catch(() => this.updateFromRemote());
        }

        /**
         * Tries to update the resource from the `remoteURL`.
         *
         * @returns a Promise resolving to the updated resource. Similarly
         * to the `load` method, the promise can fail, and thus you should
         * had a **catch** close to your promise to handle any exception.
         */
        updateFromRemote() {
          if (this.remoteURL === undefined) {
            return Promise.reject('updateFromRemote: remoteURL is undefined');
          }
          return this.updateFromURL(this.remoteURL);
        }

        /* *****************************************************************
         * Private API
         ******************************************************************/

        updateFromURL(url) {
          if (url) {
            return get$1(url).then(this.persist.bind(this));
          }

          return Promise.reject('updateFromURL: url is undefined');
        }

        compressData(data) {
          if (this.compress) {
            return deflate(data, { to: 'string' });
          } else {
            return data;
          }
        }

        decompressData(data) {
          if (this.compress) {
            try {
              return inflate(data, { to: 'string' });
            } catch (e) {
              return data;
            }
          } else {
            return data;
          }
        }

        persist(data) {
          return this.parseData(data).then(parsed => {
            const saveData = this.compressData(data);
            return this.storage.save(saveData).catch(e => console$1.error('resource-loader error on persist: ', e)).then(() => parsed);
          });
        }

        parseData(data) {
          if (this.dataType === 'json') {
            try {
              const parsed = JSON.parse(data);
              return Promise.resolve(parsed);
            } catch (e) {
              return Promise.reject(`parseData: failed with exception ${e} ${data}`);
            }
          }

          return Promise.resolve(data);
        }
      }

      class ResourceLoader extends UpdateCallbackHandler {

        constructor(resourceName) {
          let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          super();

          this.resource = new Resource(resourceName, options);
          this.cron = options.cron || ONE_HOUR;
          this.updateInterval = options.updateInterval || 10 * ONE_MINUTE;
          this.intervalTimer = CliqzUtils.setInterval(this.updateFromRemote.bind(this), this.updateInterval);
        }

        /**
         * Loads the resource hold by `this.resource`. This can return
         * a failed promise. Please read `Resource.load` doc string for
         * further information.
         */
        load() {
          return this.resource.load();
        }

        /**
         * Updates the resource from remote (maximum one time per `cron`
         * time frame).
         *
         * @returns a Promise which never fails, since this update will be
         * triggered by `setInterval` and thus you cannot catch. If the update
         * fails, then the callback won't be called.
         */
        updateFromRemote() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref$force = _ref.force;

          let force = _ref$force === undefined ? false : _ref$force;

          const pref = `resource-loader.lastUpdates.${this.resource.name.join('/')}`;
          const lastUpdate = Number(CliqzUtils.getPref(pref, 0));
          const currentTime = Date.now();

          if (force || currentTime > this.cron + lastUpdate) {
            return this.resource.updateFromRemote().then(data => {
              CliqzUtils.setPref(pref, String(Date.now()));
              return data;
            }).then(this.triggerCallbacks.bind(this)).catch(() => undefined);
          }
          return Promise.resolve();
        }

        stop() {
          CliqzUtils.clearInterval(this.intervalTimer);
        }
      }

      function getBrandsDBUrl(version) {
        return `https://cdn.cliqz.com/brands-database/database/${version}/data/database.json`;
      }

      var loadLogoDb = function () {
        const config = prefs.get('config_logoVersion');
        const dev = prefs.get('brands-database-version');
        let version = CliqzUtils.BRANDS_DATABASE_VERSION; // default fallback value

        if (dev) {
          version = dev;
        } else if (config) {
          version = config;
        }

        // use the proper database version for generating logo paths
        //
        CliqzUtils.BRANDS_DATABASE_VERSION = version;
        const remoteURL = getBrandsDBUrl(version);

        const loader = new ResourceLoader(['core', 'logo-database.json'], {
          remoteURL,
          cron: 24 * 60 * 60 * 1000
        });
        return loader.load();
      };

      var providesServices = {
        logos: () => loadLogoDb().then(CliqzUtils.setLogoDb),

        // IP driven configuration
        'cliqz-config': () => {
          const update = () => fetch(config.settings.CONFIG_PROVIDER).then(r => r.json()).then(config$$1 => {
            Object.keys(config$$1).forEach(k => {
              let val = config$$1[k];

              if (typeof val === 'object') {
                val = JSON.stringify(config$$1[k]);
              }

              prefs.set(`config_${k}`, val);
            });

            // we only set the prefered backend once at first start
            if (prefs.get('backend_country', '') === '') {
              // we fallback to german results if we did not decode the location
              CliqzUtils.setDefaultIndexCountry(prefs.get('config_location', 'de'));
            }

            CliqzEvents.pub('cliqz-config:update');
          }).catch(e => console$1.log('cliqz-config update failed', e));

          return update().then(() => CliqzUtils.setInterval(update, 1000 * 60 * 60));
        }
      };

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var lastRequestId = 0;
      var callbacks = {};

      /**
       * @module core
       * @namespace core
       * @class Background
       */
      var core = background({

        providesServices,

        init(settings, app) {
          this.settings = settings;
          this.utils = CliqzUtils;
          this.app = app;

          CliqzUtils.CliqzLanguage = CliqzLanguage;
          this.dispatchMessage = this.dispatchMessage.bind(this);

          CliqzUtils.bindObjectFunctions(this.actions, this);

          this.mm = new ProcessScriptManager(this.dispatchMessage);
          this.mm.init();

          manager.init();
        },

        unload() {
          this.mm.unload();
          manager.unload();
        },

        dispatchMessage(msg) {
          if (typeof msg.data.requestId === 'number') {
            if (msg.data.requestId in callbacks) {
              this.handleResponse(msg);
            }
          } else {
            this.handleRequest(msg);
          }
        },

        handleRequest(msg) {
          const payload = msg.data.payload;
          const sender = msg.data.sender;
          // TODO: remove this check. messages without a payload should never be sent
          if (!payload) {
            return;
          }
          const action = payload.action,
                moduleName = payload.module,
                args = payload.args,
                requestId = payload.requestId,
                windowId = msg.data.windowId;

          const origin = msg.data.origin;

          const module = this.app.modules[moduleName];
          if (!module) {
            console$1.error('Process Script', `${moduleName}/${action}`, 'Module not available');
            return;
          }

          if (module.isDisabled) {
            console$1.log('Process Script', `${moduleName}/${action}`, 'Module is disabled');
            return this.mm.broadcast(`window-${windowId}`, {
              origin,
              response: { moduleDisabled: true },
              action,
              module: moduleName,
              requestId,
              windowId
            });
          }

          // inject the required module, then call the requested action
          inject.module(moduleName).action(action, ...[...(args || []), sender]).then(response => {
            this.mm.broadcast(`window-${windowId}`, {
              origin,
              response,
              action,
              module: moduleName,
              requestId,
              windowId
            });
          }).catch(console$1.error.bind(null, 'Process Script', `${moduleName}/${action}`));
        },

        handleResponse(msg) {
          callbacks[msg.data.requestId].apply(null, [msg.data.payload]);
        },

        getWindowStatusFromModules(win) {
          return Object.keys(this.app.modules).map(module => {
            const windowModule = this.app.modules[module].getWindowModule(win);
            const backgroundModule = this.app.modules[module].backgroundModule;

            if (windowModule && windowModule.status) {
              return windowModule.status();
            } else if (backgroundModule && backgroundModule.status) {
              return backgroundModule.status();
            }
            return null;
          });
        },

        events: {
          'core:tab_select': function onTabSelect(_ref) {
            let url = _ref.url,
                isPrivate = _ref.isPrivate;

            CliqzEvents.pub('core.location_change', url, isPrivate);
          },
          'content:location-change': function onLocationChange(_ref2) {
            let url = _ref2.url,
                isPrivate = _ref2.isPrivate;

            CliqzEvents.pub('core.location_change', url, isPrivate);
          }
        },

        actions: {
          notifyProcessInit(processId) {
            CliqzEvents.pub('process:init', processId);
          },
          notifyLocationChange(msg) {
            const windowWrapper = Window.findByTabId(msg.domWindowId);
            const locationChangeMesssage = _extends({}, msg, {
              windowId: windowWrapper ? windowWrapper.id : null,
              tabId: msg.windowTreeInformation.tabId
            });

            CliqzEvents.pub('content:location-change', locationChangeMesssage);
          },
          notifyStateChange() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            const ev = args[0];

            // TODO: design proper property list for the event
            CliqzEvents.pub('content:state-change', {
              url: ev.urlSpec,
              originalUrl: ev.originalUrl,
              triggeringUrl: ev.triggeringUrl,
              windowTreeInformation: ev.windowTreeInformation
            });

            // DEPRECATED - use content:state-change instead
            CliqzEvents.pub('core.tab_state_change', ...args);
          },
          recordMouseDown() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            CliqzEvents.pub('core:mouse-down', ...args);
          },
          /**
          * @method actions.recordKeyPress
          */
          recordKeyPress() {
            CliqzEvents.pub('core:key-press', ...arguments);
          },
          /**
          * @method actions.recordMouseMove
          */
          recordMouseMove() {
            CliqzEvents.pub('core:mouse-move', ...arguments);
          },
          /**
          * @method actions.recordScroll
          */
          recordScroll() {
            CliqzEvents.pub('core:scroll', ...arguments);
          },
          /**
          * @method actions.recordCopy
          */
          recordCopy() {
            CliqzEvents.pub('core:copy', ...arguments);
          },
          /**
           * publish an event using events.pub
           * @param  {String}    evtChannel channel name
           * @param  {...[objects]} args       arguments to sent
           */
          publishEvent(evtChannel) {
            for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }

            CliqzEvents.pub(evtChannel, ...args);
          },
          restart() {
            return this.app.extensionRestart();
          },
          status() {
            const appModules = this.app.modules;
            const modules = config.modules.reduce((hash, moduleName) => {
              const module = appModules[moduleName];
              const windowWrappers = mapWindows(window => new Window(window));
              const windows = windowWrappers.reduce((hash, win) => {
                hash[win.id] = {
                  loadingTime: module.getLoadingTime(win.window)
                };
                return hash;
              }, Object.create(null));

              hash[moduleName] = {
                name: module.name,
                isEnabled: module.isEnabled,
                loadingTime: module.loadingTime,
                windows
              };
              return hash;
            }, Object.create(null));

            return {
              modules
            };
          },
          broadcast(target, payload) {
            this.mm.broadcast(target, payload);
          },
          broadcastMessageToWindow(payload, windowId, module) {
            this.mm.broadcast(`window-${windowId}`, {
              payload,
              module,
              windowId
            });
          },
          broadcastMessage(url, message) {
            this.mm.broadcast('cliqz:core', {
              action: 'postMessage',
              url,
              args: [JSON.stringify(message)]
            });
          },
          getWindowStatus(win) {
            return Promise.all(this.getWindowStatusFromModules(win)).then(allStatus => {
              var result = {};

              allStatus.forEach((status, moduleIdx) => {
                result[config.modules[moduleIdx]] = status || null;
              });

              return result;
            });
          },
          sendTelemetry(msg) {
            CliqzUtils.telemetry(msg);
            return Promise.resolve();
          },

          refreshPopup() {
            let query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

            if (query.trim() !== '') {
              return this.actions.queryCliqz(query);
            }
            const doc = CliqzUtils.getWindow().document;
            const urlBar = doc.getElementById('urlbar');
            const dropmarker = doc.getAnonymousElementByAttribute(urlBar, 'anonid', 'historydropmarker');
            setTimeout(() => {
              dropmarker.click();
            }, 0);
          },

          queryCliqz(query) {
            queryCliqz(query);
          },

          openLink(url) {
            openLink$1(url);
          },

          openTab(tabId) {
            openTab(tabId);
          },

          getOpenTabs() {
            return getOpenTabs();
          },

          getReminders(domain) {
            return getReminders(domain);
          },

          closePopup() {
            var popup = CliqzUtils.getWindow().CLIQZ.Core.popup;

            popup.hidePopup();
          },

          setUrlbar(value) {
            let urlBar = CliqzUtils.getWindow().document.getElementById('urlbar');
            urlBar.mInputField.value = value;
          },
          recordLang(url, lang) {
            CliqzEvents.pub('content:dom-ready', url);
            if (lang) {
              CliqzLanguage.addLocale(url, lang);
            }
            return Promise.resolve();
          },
          recordMeta(url, meta) {
            CliqzEvents.pub('core:url-meta', url, meta);
          },
          openFeedbackPage() {
            const window = CliqzUtils.getWindow();
            const tab = CliqzUtils.openLink(window, CliqzUtils.FEEDBACK_URL, true);
            window.gBrowser.selectedTab = tab;
          },
          enableModule(moduleName) {
            return this.app.enableModule(moduleName);
          },
          disableModule(moduleName) {
            this.app.disableModule(moduleName);
          },
          resizeWindow(width, height) {
            CliqzUtils.getWindow().resizeTo(width, height);
          },
          queryHTML(url, selector, attribute) {
            const requestId = lastRequestId++,
                  documents = [];

            this.mm.broadcast('cliqz:core', {
              action: 'queryHTML',
              url,
              args: [selector, attribute],
              requestId
            });

            return new Promise((resolve, reject) => {
              callbacks[requestId] = function (attributeValues) {
                delete callbacks[requestId];
                resolve(attributeValues);
              };

              CliqzUtils.setTimeout(function () {
                delete callbacks[requestId];
                reject(new Error('queryHTML timeout'));
              }, 1000);
            });
          },

          getHTML(url) {
            let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

            const requestId = lastRequestId++,
                  documents = [];

            this.mm.broadcast('cliqz:core', {
              action: 'getHTML',
              url,
              args: [],
              requestId
            });

            callbacks[requestId] = function (doc) {
              documents.push(doc);
            };

            return new Promise(resolve => {
              CliqzUtils.setTimeout(function () {
                delete callbacks[requestId];
                resolve(documents);
              }, timeout);
            });
          },

          getCookie(url) {
            return getCookies(url).catch(() => {
              const requestId = lastRequestId++;

              this.mm.broadcast('cliqz:core', {
                action: 'getCookie',
                url,
                args: [],
                requestId
              });

              return new Promise((resolve, reject) => {
                callbacks[requestId] = function (attributeValues) {
                  delete callbacks[requestId];
                  resolve(attributeValues);
                };

                CliqzUtils.setTimeout(function () {
                  delete callbacks[requestId];
                  reject(new Error('getCookie timeout'));
                }, 1000);
              });
            });
          }
        }
      });

      Components.utils.import('resource://gre/modules/PlacesUtils.jsm');

      var _slicedToArray$3 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /*
       * This module provides misc functions related to the FF history database.
       */

      const Cc$2 = Components.classes;
      const Ci$4 = Components.interfaces;

      var bookmarkService = Cc$2["@mozilla.org/browser/nav-bookmarks-service;1"].getService(Ci$4.nsINavBookmarksService);

      var CliqzHistoryManager = {
        init: function init() {},
        unload: function unload() {},
        getStats: function getStats(callback) {
          let historysize = 0;
          let daysVisited = {};
          let visitedDomainOn = {};
          let visitedSubDomain = {};
          let today = CliqzUtils.getDay();
          let history = today;

          this.PlacesInterestsStorage._execute('SELECT count(*) cnt, MIN(v.visit_date) first ' + 'FROM moz_historyvisits v ' + 'JOIN moz_places h ' + 'ON h.id = v.place_id ' + 'WHERE h.hidden = 0 AND h.visit_count > 0 ', ['cnt', 'first'], function (result) {
            try {
              history = Math.floor(result.first / 86400000000);
              historysize = result.cnt;
            } catch (ex) {}
          }).then(function () {
            if (CliqzUtils) {
              callback({
                size: historysize,
                days: CliqzUtils.getDay() - history
              });
            }
          });
        },
        // Extract earliest and latest entry of Firefox history
        historyTimeFrame: function historyTimeFrame(callback) {
          var history = [];
          var min, max;
          this.PlacesInterestsStorage._execute('SELECT min(last_visit_date) as min_date, max(last_visit_date) as max_date FROM moz_places', ['min_date', 'max_date'], function (result) {
            try {
              min = parseInt(result.min_date / 1000);
              max = parseInt(result.max_date / 1000);
            } catch (ex) {}
          }).then(function () {
            callback(min, max);
          });
        },
        // moz_inputhistory records queries-to-URL mappings to adapt history
        // results to a user's query behavior; moz_inputhistory would be automatically
        // updated by Firefox's Places system if the dropdown was not overidden--
        // thus, we have to update moz_inputhistory manually whenever the user
        // selects a page from history or autocomplete
        updateInputHistory: function updateInputHistory(input, url) {
          if (url.indexOf('://') == -1) url = 'http://' + url;

          // copied from http://mxr.mozilla.org/mozilla-central/source/toolkit/components/places/nsNavHistory.cpp#4525
          var sql = 'INSERT OR REPLACE INTO moz_inputhistory ' + 'SELECT h.id, IFNULL(i.input, :input_text), IFNULL(i.use_count, 0) * .9 + 1 ' + 'FROM moz_places h ' + 'LEFT JOIN moz_inputhistory i ON i.place_id = h.id AND i.input = :input_text ' + 'WHERE url = :page_url ';
          CliqzUtils.setTimeout(function () {
            CliqzHistoryManager.PlacesInterestsStorage._execute(sql,
            // no results for INSERT
            [], function (results) {}, {
              input_text: input,
              page_url: url
            }).then(function () {
              // utils.log('updated moz_inputhistory', 'CLIQZ.HISTORY_MANAGER');
            });
          },
          // wait a bit before updating moz_inputhistory; otherwise, the URL might
          // not exist in moz_places yet and above SQL statement would not insert anything
          5000);
        },
        // Update the title of a page in the FF history database
        updatePageTitle: function updatePageTitle(url, title) {
          if (url.indexOf('://') == -1) url = 'http://' + url;

          var sql = 'UPDATE moz_places ' + 'SET title = :title ' + 'WHERE url = :page_url ';

          CliqzHistoryManager.PlacesInterestsStorage._execute(sql,
          // no results for UPDATE
          [], function (results) {}, {
            title: title,
            page_url: url
          }).then(function () {});
        },
        getPageTitle: function getPageTitle(url) {
          var hs = CliqzHistoryManager.getHistoryService();
          var uri = CliqzHistoryManager.makeURI(url);
          if (hs && uri) {
            return hs.getPageTitle(uri);
          } else {
            return undefined;
          }
        },
        historyService: null,
        ioService: null,
        getHistoryService: function getHistoryService() {
          if (!CliqzHistoryManager.historyService) {
            try {
              CliqzHistoryManager.historyService = Components.classes['@mozilla.org/browser/nav-history-service;1'].getService(Ci$4.nsINavHistoryService);
            } catch (e) {
              CliqzUtils.log('unable to get history service: ' + e);
            }
          }
          return CliqzHistoryManager.historyService;
        },
        getIoService: function getIoService() {
          if (!CliqzHistoryManager.ioService) {
            try {
              CliqzHistoryManager.ioService = Components.classes['@mozilla.org/network/io-service;1'].getService(Ci$4.nsIIOService);
            } catch (e) {
              CliqzUtils.log('unable to get IO service: ' + e);
            }
          }
          return CliqzHistoryManager.ioService;
        },
        makeURI: function makeURI(url) {
          var ios = CliqzHistoryManager.getIoService();
          if (ios) {
            return ios.newURI(url, null, null);
          }
          return false;
        },
        PlacesInterestsStorage: {
          _execute: function PIS__execute(sql, columns, onRow, parameters) {
            var conn = PlacesUtils.history.QueryInterface(Ci$4.nsPIPlacesDatabase).DBConnection,
                statement = conn.createAsyncStatement(sql),
                onThen,

            //called after the async operation is finalized
            promiseMock = {
              then: function then(func) {
                onThen = func;
              }
            };
            if (parameters) {
              for (var key in parameters) {
                statement.params[key] = parameters[key];
              }
            }
            statement.executeAsync({
              handleCompletion: function handleCompletion(reason) {
                onThen();
              },

              handleError: function handleError(error) {},

              handleResult: function handleResult(resultSet) {
                let row;
                while (row = resultSet.getNextRow()) {
                  // Read out the desired columns from the row into an object
                  let result;
                  if (columns != null) {
                    // For just a single column, make the result that column
                    if (columns.length == 1) {
                      result = row.getResultByName(columns[0]);
                    }
                    // For multiple columns, put as values on an object
                    else {
                        result = {};
                        for (var i = 0; i < columns.length; i++) {
                          var column = columns[i];
                          result[column] = row.getResultByName(column);
                        }
                      }
                  }
                  //pass the result to the onRow handler
                  onRow(result);
                }
              }
            });
            return promiseMock;
          }
        },
        removeFromHistory: function removeFromHistory(url) {
          try {
            PlacesUtils.history.remove(url);
          } catch (e) {
            CliqzUtils.log(e.message, 'Error removing entry from history');
          }
        },
        removeFromBookmarks: function removeFromBookmarks(url) {
          try {
            const uri = CliqzHistoryManager.makeURI(url);

            var _PlacesUtils$getBookm = PlacesUtils.getBookmarksForURI(uri),
                _PlacesUtils$getBookm2 = _slicedToArray$3(_PlacesUtils$getBookm, 1);

            const itemId = _PlacesUtils$getBookm2[0];

            if (itemId) {
              bookmarkService.removeItem(itemId);
            }
          } catch (e) {
            CliqzUtils.log(e.message, "Error removing entry from bookmarks");
          }
        },
        isBookmarked: function isBookmarked(url) {
          const uri = CliqzHistoryManager.makeURI(url);
          if (bookmarkService.isBookmarked) {
            return Promise.resolve(bookmarkService.isBookmarked(uri));
          } else {
            // isBookmarked is obsolete since Firefox 57
            return PlacesUtils.bookmarks.fetch({ url: url }).then(res => {
              return res !== null;
            });
          }
        }
      };

      /*
       * This module implements a mechanism which enables/disables AB tests
       *
       */

      var timer = null;
      var ONE_HOUR$1 = 60 * 60 * 1000;

      function log$2(msg) {
        CliqzUtils.log(msg, "CliqzABTests.jsm");
      }

      var CliqzABTests = {
        PREF: 'ABTests',
        PREF_OVERRIDE: 'ABTestsOverride',
        URL: 'https://stats.cliqz.com/abtests/check?session=',
        // Accessors to list of tests this user is current in
        getCurrent: function getCurrent() {
          if (CliqzUtils.hasPref(CliqzABTests.PREF)) return JSON.parse(CliqzUtils.getPref(CliqzABTests.PREF));
          return undefined;
        },
        setCurrent: function setCurrent(tests) {
          CliqzUtils.setPref(CliqzABTests.PREF, JSON.stringify(tests));
        },

        // Accessors to list of tests in override list
        getOverride: function getOverride() {
          if (CliqzUtils.hasPref(CliqzABTests.PREF_OVERRIDE)) {
            var ABtests = JSON.parse(CliqzUtils.getPref(CliqzABTests.PREF_OVERRIDE));
            return ABtests;
          }
          return undefined;
        },
        setOverride: function setOverride(tests) {
          if (tests) CliqzUtils.setPref(CliqzABTests.PREF_OVERRIDE, JSON.stringify(tests));else CliqzUtils.clearPref(CliqzABTests.PREF_OVERRIDE);
        },

        // Check for newest list of AB tests from server
        check: function check() {
          log$2('AB checking');
          // clear the last timer
          CliqzUtils.clearTimeout(timer);
          // set a new timer to be triggered after 1 hour
          timer = CliqzUtils.setTimeout(CliqzABTests.check, ONE_HOUR$1);

          CliqzABTests.retrieve(function (response) {
            try {
              var prevABtests = {};
              if (CliqzUtils.hasPref(CliqzABTests.PREF)) prevABtests = JSON.parse(CliqzUtils.getPref(CliqzABTests.PREF));

              var respABtests = JSON.parse(response.responseText);

              // Override the backend response - for local testing
              var overrideABtests = CliqzABTests.getOverride();
              if (overrideABtests) respABtests = overrideABtests;

              var newABtests = {};

              var changes = false; // any changes?

              // find old AB tests to leave
              for (var o in prevABtests) {
                if (!respABtests[o]) {
                  if (CliqzABTests.leave(o)) changes = true;
                } else {
                  // keep this old test in the list of current tests
                  newABtests[o] = prevABtests[o];
                }
              }

              // find new AB tests to enter
              for (var n in respABtests) {
                if (!prevABtests[n]) {
                  if (CliqzABTests.enter(n, respABtests[n])) {
                    changes = true;
                    newABtests[n] = respABtests[n];
                  }
                }
              }

              if (changes) {
                CliqzUtils.setPref(CliqzABTests.PREF, JSON.stringify(newABtests));
              }
            } catch (e) {
              log$2('retrieve error: ' + e.message);
            }
          });
        },
        retrieve: function retrieve(callback) {
          var url = CliqzABTests.URL + encodeURIComponent(CliqzUtils.getPref('session', ''));

          var onerror = function onerror() {
            log$2("failed to retrieve AB test data");
          };

          CliqzUtils.httpGet(url, callback, onerror, 15000);
        },
        enter: function enter(abtest, payload) {
          // Add new AB tests here.
          // It is safe to remove them as soon as the test is over.
          var rule_executed = true;
          switch (abtest) {
            case "1028_A":
              CliqzUtils.setPref("humanWeb", false);
              break;
            case "1028_B":
              CliqzUtils.setPref("humanWeb", true);
              break;
            case "1032_A":
              CliqzUtils.setPref("spellCorrMessage", false);
              break;
            case "1032_B":
              CliqzUtils.setPref("spellCorrMessage", true);
              break;
            case "1036_B":
              CliqzUtils.setPref("extended_onboarding_same_result", true);
              break;
            case "1045_A":
              break;
            case "1045_B":
              CliqzUtils.setPref("antiTrackTest", true);
              break;
            case "1046_B":
              CliqzUtils.setPref("attrackBlockCookieTracking", true);
              break;
            case "1047_B":
              CliqzUtils.setPref("attrackRemoveQueryStringTracking", true);
              break;
            case "1048_B":
              CliqzUtils.setPref("attrackAlterPostdataTracking", true);
              break;
            case "1049_B":
              CliqzUtils.setPref("attrackCanvasFingerprintTracking", true);
              break;
            case "1050_B":
              CliqzUtils.setPref("attrackRefererTracking", true);
              break;
            case "1051_B":
              CliqzUtils.setPref("antiTrackTest", true);
              break;
            case "1052_A":
              CliqzUtils.setPref("attrackBlockCookieTracking", false);
              break;
            case "1052_B":
              CliqzUtils.setPref("attrackBlockCookieTracking", true);
              break;
            case "1053_A":
              CliqzUtils.setPref("attrackRemoveQueryStringTracking", false);
              break;
            case "1053_B":
              CliqzUtils.setPref("attrackRemoveQueryStringTracking", true);
              break;
            case "1057_A":
              CliqzUtils.setPref("trackerTxt", false);
              break;
            case "1057_B":
              CliqzUtils.setPref("trackerTxt", true);
              break;
            case "1059_A":
              CliqzUtils.setPref("attrack.local_tracking", false);
              break;
            case "1059_B":
              CliqzUtils.setPref("attrack.local_tracking", true);
              break;
            case "1060_A":
              CliqzUtils.setPref("attrackBloomFilter", false);
              break;
            case "1060_B":
              CliqzUtils.setPref("attrackBloomFilter", true);
              break;
            case "1061_A":
              CliqzUtils.setPref("attrackUI", false);
              break;
            case "1061_B":
              CliqzUtils.setPref("attrackUI", true);
              break;
            case "1063_A":
              CliqzUtils.setPref("double-enter2", false);
              break;
            case "1063_B":
              CliqzUtils.setPref("double-enter2", true);
              break;
            case "1064_A":
              CliqzUtils.setPref("attrackDefaultAction", "same");
              break;
            case "1064_B":
              CliqzUtils.setPref("attrackDefaultAction", "placeholder");
              break;
            case "1064_C":
              CliqzUtils.setPref("attrackDefaultAction", "block");
              break;
            case "1064_D":
              CliqzUtils.setPref("attrackDefaultAction", "empty");
              break;
            case "1064_E":
              CliqzUtils.setPref("attrackDefaultAction", "replace");
              break;
            case "1065_A":
              CliqzUtils.setPref("freshTabNewsEmail", false);
              break;
            case "1065_B":
              CliqzUtils.setPref("freshTabNewsEmail", true);
              break;
            case "1066_A":
              CliqzUtils.setPref("proxyNetwork", false);
              break;
            case "1066_B":
              CliqzUtils.setPref("proxyNetwork", true);
              break;
            case "1069_A":
              CliqzUtils.setPref("grOfferSwitchFlag", false);
              break;
            case "1069_B":
              CliqzUtils.setPref("grOfferSwitchFlag", true);
              break;
            case "1070_A":
              CliqzUtils.setPref("cliqz-anti-phishing", false);
              CliqzUtils.setPref("cliqz-anti-phishing-enabled", false);
              break;
            case "1070_B":
              CliqzUtils.setPref("cliqz-anti-phishing", true);
              CliqzUtils.setPref("cliqz-anti-phishing-enabled", true);
              break;
            case "1071_A":
              CliqzUtils.setPref("browser.privatebrowsing.apt", false, '');
              break;
            case "1071_B":
              CliqzUtils.setPref("browser.privatebrowsing.apt", true, '');
              break;
            case "1074_A":
              CliqzUtils.setPref("cliqz-adb-abtest", false);
              break;
            case "1074_B":
              CliqzUtils.setPref("cliqz-adb-abtest", true);
              break;
            case "1077_A":
              CliqzUtils.setPref("languageDedup", false);
              break;
            case "1077_B":
              CliqzUtils.setPref("languageDedup", true);
              break;
            case "1078_A":
              CliqzUtils.setPref("telemetryNoSession", false);
              break;
            case "1078_B":
              CliqzUtils.setPref("telemetryNoSession", true);
              break;
            case "1080_A":
              CliqzUtils.setPref("freshtabNewBrand", false);
              break;
            case "1080_B":
              CliqzUtils.setPref("freshtabNewBrand", true);
              break;
            case "1081_A":
              CliqzUtils.setPref("attrackLogBreakage", false);
              break;
            case "1081_B":
              CliqzUtils.setPref("attrackLogBreakage", true);
              break;
            case "1084_B":
              CliqzUtils.setPref("attrackOverrideUserAgent", true);
              break;
            case "1085_A":
              CliqzUtils.setPref('extOnboardShareLocation', false);
              break;
            case "1085_B":
              CliqzUtils.setPref('extOnboardShareLocation', true);
              break;
            case "1086_A":
              CliqzUtils.setPref("checkLogos", '1');
              break;
            case "1086_B":
              CliqzUtils.setPref("checkLogos", '0');
              break;
            case "1087_A":
              CliqzUtils.setPref('modules.context-search.enabled', false);
              break;
            case "1087_B":
              CliqzUtils.setPref('modules.context-search.enabled', true);
              break;
            case "1088_A":
              CliqzUtils.setPref('offers2FeatureEnabled', false);
              break;
            case "1088_B":
              CliqzUtils.setPref('offers2FeatureEnabled', true);
              break;
            case "1092_A":
              CliqzUtils.setPref("extOnboardVideoDownloader", false);
              break;
            case "1092_B":
              CliqzUtils.setPref("extOnboardVideoDownloader", true);
              break;
            case "1094_A":
              CliqzUtils.setPref("ff-experiment", false);
              break;
            case "1094_B":
              CliqzUtils.setPref("ff-experiment", true);
              break;
            case "1096_A":
              CliqzUtils.setPref("extOnboardCliqzConnect", false);
              break;
            case "1096_B":
              CliqzUtils.setPref("extOnboardCliqzConnect", true);
              break;
            case "1097_A":
              CliqzUtils.setPref("dropdownAdCampaignPosition", 'top');
              break;
            case "1097_B":
              CliqzUtils.setPref("dropdownAdCampaignPosition", 'bottom');
              break;
            case "1098_A":
              // ADB turned OFF
              if (CliqzUtils.getPref("cliqz-adb-onboarding-ab", false) === true) {
                // turn ADB back OFF only if it was set ON by this test
                CliqzUtils.clearPref("cliqz-adb-onboarding-ab");
                CliqzUtils.clearPref("cliqz-adb-onboarding-message");
                CliqzUtils.setPref("cliqz-adb", 0);
              }
              break;
            case "1098_B":
              // ADB turned ON
              if (CliqzUtils.getPref("cliqz-adb", 0) === 1) {
                // ADB already turned ON by the user so leave this test
                CliqzABTests.disable("1098_B");
              } else {
                CliqzUtils.setPref("cliqz-adb-onboarding-ab", true);
                CliqzUtils.setPref("cliqz-adb", 1);
              }
              break;
            case "1098_C":
              // ADB turned ON + message
              if (CliqzUtils.getPref("cliqz-adb", 0) === 1) {
                // ADB already turned ON by the user so leave this test
                CliqzABTests.disable("1098_C");
              } else {
                CliqzUtils.setPref("cliqz-adb-onboarding-ab", true);
                CliqzUtils.setPref("cliqz-adb", 1);
                CliqzUtils.setPref("cliqz-adb-onboarding-message", true);
              }
              break;
            case "1099_A":
              CliqzUtils.setPref("attrackCookieTrustReferers", false);
              break;
            case "1099_B":
              CliqzUtils.setPref("attrackCookieTrustReferers", true);
              break;
            case "1101_A":
              CliqzUtils.setPref("modules.history.enabled", false);
              break;
            case "1101_B":
              CliqzUtils.setPref("modules.history.enabled", true);
              break;
            case "1102_A":
              CliqzUtils.setPref("modules.antitracking-blocker.enabled", false);
              break;
            case "1102_B":
              CliqzUtils.setPref("antitrackingBlocklist", "default");
              CliqzUtils.setPref("modules.antitracking-blocker.enabled", true);
              break;
            case "1102_C":
              CliqzUtils.setPref("antitrackingBlocklist", "cliqz");
              CliqzUtils.setPref("modules.antitracking-blocker.enabled", true);
              break;
            case "1102_D":
              CliqzUtils.setPref("antitrackingBlocklist", "ghostery");
              CliqzUtils.setPref("modules.antitracking-blocker.enabled", true);
              break;
            case "1103_A":
              CliqzUtils.setPref("offersDropdownAdPosition", 'top');
              break;
            case "1103_B":
              CliqzUtils.setPref("offersDropdownAdPosition", 'bottom');
              break;
            case "1103_C":
              CliqzUtils.setPref("offersDropdownAdPosition", 'right');
              break;
            case "1105_A":
              CliqzUtils.setPref('offersBrowserPanelEnableSwitch', false);
              break;
            case "1105_B":
              CliqzUtils.setPref('offersBrowserPanelEnableSwitch', true);
              break;
            case "1106_A":
              CliqzUtils.setPref("greenads", 'green');
              break;
            case "1106_B":
              CliqzUtils.setPref("greenads", 'collect');
              break;
            case "1106_C":
              CliqzUtils.setPref("greenads", 'disabled');
              break;
            case "1107_A":
              CliqzUtils.setPref("MarketAnalysisEnabled", false);
              break;
            case "1107_B":
              CliqzUtils.setPref("MarketAnalysisEnabled", true);
              break;
            case "1108_A":
              CliqzUtils.setPref("extOnboardNewSearchUI", false);
              break;
            case "1108_B":
              CliqzUtils.setPref("extOnboardNewSearchUI", true);
              break;
            case "1109_A":
              CliqzUtils.setPref("offersDropdownSwitch", false);
              break;
            case "1109_B":
              CliqzUtils.setPref("offersDropdownSwitch", true);
              break;
            case "1110_A":
              CliqzUtils.setPref("cliqzTabOffersNotification", false);
              break;
            case "1110_B":
              CliqzUtils.setPref("cliqzTabOffersNotification", true);
              break;
            case "1111_A":
              CliqzUtils.setPref("modules.history-analyzer.enabled", false);
              break;
            case "1111_B":
              CliqzUtils.setPref("modules.history-analyzer.enabled", true);
              break;
            case "1112_A":
              CliqzUtils.setPref("experiment_svm", false);
              break;
            case "1112_B":
              CliqzUtils.setPref("experiment_svm", true);
              break;
            default:
              rule_executed = false;
          }
          if (rule_executed) {
            var action = {
              type: 'abtest',
              action: 'enter',
              name: abtest
            };
            CliqzUtils.telemetry(action);

            return true;
          } else {
            return false;
          }
        },
        leave: function leave(abtest, disable) {
          // Restore defaults after an AB test is finished.
          // DO NOT remove test cleanup code too quickly, a user
          // might not start the browser for a long time and
          // get stuck in a test if we remove cases too early.
          var rule_executed = true;
          switch (abtest) {
            case "1024_B":
              CliqzUtils.clearPref("categoryAssessment");
              break;
            case "1028_A":
            case "1028_B":
              CliqzUtils.clearPref("humanWeb");
              break;
            case "1032_A":
            case "1032_B":
              CliqzUtils.clearPref("spellCorrMessage");
              break;
            case "1036_A":
            case "1036_B":
              CliqzUtils.clearPref("extended_onboarding_same_result");
              CliqzUtils.clearPref("extended_onboarding");
              break;
            case "1045_A":
            case "1045_B":
              CliqzUtils.clearPref("antiTrackTest");
              break;
            case "1046_A":
            case "1047_A":
            case "1048_A":
            case "1049_A":
            case "1050_A":
              break;
            case "1046_B":
              CliqzUtils.clearPref("attrackBlockCookieTracking");
              break;
            case "1047_B":
              CliqzUtils.clearPref("attrackRemoveQueryStringTracking");
              break;
            case "1048_B":
              CliqzUtils.clearPref("attrackAlterPostdataTracking");
              break;
            case "1049_B":
              CliqzUtils.clearPref("attrackCanvasFingerprintTracking");
              break;
            case "1050_B":
              CliqzUtils.clearPref("attrackRefererTracking");
              break;
            case "1051_B":
              CliqzUtils.clearPref("antiTrackTest");
              break;
            case "1052_B":
              CliqzUtils.clearPref("attrackBlockCookieTracking");
              break;
            case "1053_B":
              CliqzUtils.clearPref("attrackRemoveQueryStringTracking");
              break;
            case "1055_A":
            case "1055_B":
              CliqzUtils.clearPref("unblockEnabled");
              break;
            case "1056_A":
            case "1056_B":
              CliqzUtils.clearPref("freshTabAB");
              break;
            case "1057_B":
              CliqzUtils.clearPref("trackerTxt");
              break;
            case "1058_A":
            case "1058_B":
              CliqzUtils.clearPref("unblockMode");
              break;
            case "1059_A":
            case "1059_B":
              CliqzUtils.clearPref("attrack.local_tracking");
              break;
            case "1060_A":
            case "1060_B":
              CliqzUtils.clearPref("attrackBloomFilter");
              break;
            case "1061_A":
            case "1061_B":
              CliqzUtils.clearPref("attrackUI");
              break;
            case "1063_A":
            case "1063_B":
              CliqzUtils.clearPref("double-enter2");
              break;
            case "1064_A":
            case "1064_B":
            case "1064_C":
            case "1064_D":
            case "1064_E":
              CliqzUtils.clearPref("attrackDefaultAction");
              break;
            case "1066_A":
            case "1066_B":
              CliqzUtils.clearPref("proxyNetwork");
              break;
            case "1065_A":
            case "1065_B":
              CliqzUtils.clearPref("freshTabNewsEmail");
              break;
            case "1068_A":
            case "1068_B":
              CliqzUtils.clearPref("languageDedup");
              break;
            case "1069_A":
            case "1069_B":
              CliqzUtils.clearPref("grOfferSwitchFlag");
              break;
            case "1070_A":
            case "1070_B":
              CliqzUtils.clearPref('cliqz-anti-phishing');
              CliqzUtils.clearPref('cliqz-anti-phishing-enabled');
              break;
            case "1071_A":
            case "1071_B":
              CliqzUtils.clearPref('browser.privatebrowsing.apt', '');
              break;
            case "1072_A":
            case "1072_B":
              CliqzUtils.clearPref('grFeatureEnabled');
              break;
            case "1074_A":
            case "1074_B":
              CliqzUtils.clearPref('cliqz-adb-abtest');
              break;
            case "1075_A":
            case "1075_B":
              CliqzUtils.clearPref('freshtabFeedback');
              break;
            case "1076_A":
            case "1076_B":
              CliqzUtils.clearPref('history.timeouts');
              break;
            case "1077_A":
            case "1077_B":
              CliqzUtils.clearPref("languageDedup");
              break;
            case "1078_A":
            case "1078_B":
              CliqzUtils.clearPref("telemetryNoSession");
              break;
            case "1079_A":
            case "1079_B":
              CliqzUtils.clearPref("controlCenter");
              break;
            case "1080_A":
            case "1080_B":
              CliqzUtils.clearPref("freshtabNewBrand");
              break;
            case "1081_A":
            case "1081_B":
              CliqzUtils.clearPref("attrackLogBreakage");
              break;
            case "1082_A":
            case "1082_B":
              CliqzUtils.clearPref("experimentalCookieDroppingDetection");
              break;
            case "1084_B":
              CliqzUtils.clearPref("attrackOverrideUserAgent");
              break;
            case "1085_A":
            case "1085_B":
              CliqzUtils.clearPref("extOnboardShareLocation");
              break;
            case "1086_A":
            case "1086_B":
              CliqzUtils.clearPref("checkLogos");
              break;
            case "1087_B":
              CliqzUtils.setPref('modules.context-search.enabled', false);
              break;
            case "1088_A":
            case "1088_B":
              CliqzUtils.clearPref('offers2FeatureEnabled');
              break;
            case "1091_A":
              CliqzUtils.clearPref('dropDownStyle');
              break;
            case "1092_A":
            case "1092_B":
              CliqzUtils.clearPref('extOnboardVideoDownloader');
              break;
            case "1093_A":
            case "1093_B":
              CliqzUtils.clearPref('extOnboardCliqzGhostery');
              break;
            case "1094_A":
            case "1094_B":
              CliqzUtils.clearPref('ff-experiment');
              break;
            case "1095_A":
            case "1095_B":
              CliqzUtils.clearPref('connect');
              break;
            case "1096_A":
            case "1096_B":
              CliqzUtils.clearPref('extOnboardCliqzConnect');
              break;
            case "1097_A":
            case "1097_B":
              CliqzUtils.clearPref('dropdownAdCampaignPosition');
              break;
            case "1098_A":
            case "1098_B":
            case "1098_C":
              if (CliqzUtils.getPref("cliqz-adb-onboarding-ab", false) === true) {
                // turn ADB back OFF only if it was set ON by this test
                CliqzUtils.setPref("cliqz-adb", 0);
              }
              CliqzUtils.clearPref("cliqz-adb-onboarding-ab");
              CliqzUtils.clearPref("cliqz-adb-onboarding-message");
              break;
            case "1099_A":
            case "1099_B":
              CliqzUtils.clearPref("attrackCookieTrustReferers");
              break;
            case "1100_A":
            case "1100_B":
              CliqzUtils.clearPref("offersHubEnableSwitch");
              break;
            case "1101_A":
            case "1101_B":
              CliqzUtils.clearPref("modules.history.enabled");
              break;
            case "1102_A":
            case "1102_B":
            case "1102_C":
            case "1102_D":
              CliqzUtils.setPref("modules.antitracking-blocker.enabled", false);
              CliqzUtils.clearPref("antitrackingBlocklist");
              break;
            case "1103_A":
            case "1103_B":
            case "1103_C":
              CliqzUtils.clearPref("offersDropdownAdPosition");
              break;
            case "1104_A":
            case "1104_B":
            case "1104_C":
              CliqzUtils.clearPref("offersHubTrigger");
              break;
            case "1105_A":
            case "1105_B":
              CliqzUtils.clearPref('offersBrowserPanelEnableSwitch');
              break;
            case "1106_A":
            case "1106_B":
            case "1106_C":
              CliqzUtils.clearPref("greenads");
              break;
            case "1107_A":
            case "1107_B":
              CliqzUtils.clearPref("MarketAnalysisEnabled");
              break;
            case "1108_A":
            case "1108_B":
              CliqzUtils.clearPref("extOnboardNewSearchUI");
              break;
            case "1109_A":
            case "1109_B":
              CliqzUtils.clearPref("offersDropdownSwitch");
              break;
            case "1110_A":
            case "1110_B":
              CliqzUtils.clearPref("cliqzTabOffersNotification");
              break;
            case "1111_A":
            case "1111_B":
              CliqzUtils.setPref("modules.history-analyzer.enabled", false);
              break;
            case "1112_A":
            case "1112_B":
              CliqzUtils.clearPref("experiment_svm");
              break;
            default:
              rule_executed = false;
          }
          if (rule_executed) {
            var action = {
              type: 'abtest',
              action: 'leave',
              name: abtest,
              disable: disable
            };
            CliqzUtils.telemetry(action);
            return true;
          } else {
            return false;
          }
        },
        disable: function disable(abtest) {
          // Disable an AB test but do not remove it from list of active AB tests,
          // this is intended to be used by the extension itself when it experiences
          // an error associated with this AB test.
          if (CliqzUtils.hasPref(CliqzABTests.PREF)) {
            var curABtests = JSON.parse(CliqzUtils.getPref(CliqzABTests.PREF));

            if (curABtests[abtest] && CliqzABTests.leave(abtest, true)) {
              // mark as disabled and save back to preferences
              curABtests[abtest].disabled = true;
              CliqzUtils.setPref(CliqzABTests.PREF, JSON.stringify(curABtests));
            }
          }
        }
      };

      class Win {

        constructor(settings) {
          this.window = settings.window;
          this.actions = {
            addClassToWindow: this.addClassToWindow.bind(this),
            removeClassFromWindow: this.removeClassFromWindow.bind(this)
          };
        }

        init() {
          // expose globals
          this.window.CLIQZEnvironment = CliqzUtils.environment;
          this.window.CliqzUtils = CliqzUtils;
          this.window.CliqzEvents = CliqzEvents;
          this.window.CliqzABTests = CliqzABTests;
          this.window.CliqzHistoryManager = CliqzHistoryManager;
        }

        unload() {
          delete this.window.CLIQZEnvironment;
          delete this.window.CliqzUtils;
          delete this.window.CliqzEvents;
          delete this.window.CliqzABTests;
          delete this.window.CliqzHistoryManager;
        }

        addClassToWindow() {
          var args = [].slice.call(arguments);
          var mainWindow = this.window.document.getElementById('main-window');
          args.forEach(function (aClass) {
            mainWindow.classList.add(aClass);
          });
        }

        removeClassFromWindow() {
          var args = [].slice.call(arguments);
          var mainWindow = this.window.document.getElementById('main-window');
          args.forEach(function (aClass) {
            mainWindow.classList.remove(aClass);
          });
        }
      }

      var coreModule = {
        Background: core,
        Window: Win
      };

      var Background = background({
        init() {
          let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.settings = settings;
          CliqzUtils.bindObjectFunctions(this.actions, this);

          // load translations
          CliqzUtils.getLocalizedString('test');

          CliqzUtils.init();

          this.checkSession();
          if (isFirefox) {
            CliqzLanguage.init();
            CliqzHistoryManager.init();
          }

          if (!isMobile) {
            this.report = CliqzUtils.setTimeout(this.reportStartupTime.bind(this), 1000 * 60);
          }

          this.supportInfo = CliqzUtils.setTimeout(() => {
            this.actions.setSupportInfo();
            if (config.settings.channel == 40) {
              this.browserDetection();
            }
          }, 30 * 1000);
        },

        unload() {
          CliqzUtils.clearTimeout(this.report);
          CliqzUtils.clearTimeout(this.supportInfo);
          if (isFirefox) {
            CliqzLanguage.unload();
            CliqzHistoryManager.unload();
          }
        },

        reportStartupTime() {
          inject.module('core').action('status').then(status => {
            CliqzUtils.telemetry({
              type: 'startup',
              modules: status.modules
            });
          });
        },

        checkSession() {
          if (!prefs.has('session')) {
            const session = [CliqzUtils.rand(18), CliqzUtils.rand(6, '0123456789'), '|', CliqzUtils.getServerDay(), '|', config.settings.channel || 'NONE'].join('');

            prefs.set('session', session);
            prefs.set('install_date', session.split('|')[1]);
            prefs.set('new_session', true);

            if (!prefs.has('freshtab.state')) {
              // freshtab is opt-out since 2.20.3
              prefs.set('freshtab.state', true);
            }
          } else {
            prefs.set('new_session', false);
          }
        },

        browserDetection() {
          var pref = 'detection',
              sites = ["https://www.ghostery.com", "https://ghostery.com"];

          // make sure we only do it once
          if (CliqzUtils.getPref(pref, false) !== true) {
            CliqzUtils.setPref(pref, true);

            sites.forEach(function (url) {
              var ls = new Storage(url);
              if (ls) ls.setItem("cliqz", true);
            });
          }
        },

        actions: {
          setSupportInfo(status) {

            const version = this.settings.version;
            const host = prefs.get('distribution.id', '', '');
            const hostVersion = prefs.get('distribution.version', '', '');
            const info = JSON.stringify({
              version,
              host,
              hostVersion,
              country: CliqzUtils.getPref('config_location', ''),
              status: status || 'active'
            });

            try {
              ['http://cliqz.com', 'https://cliqz.com'].forEach(url => {
                const ls = new Storage(url);
                ls.setItem('extension-info', info);
              });
            } catch (e) {
              console.log('Error setting localstorage', e);
            }
          }
        }

      });

      /**
      * @namespace theme
      */
      class Win$1 {
        /**
        * @class Theme
        * @constructor
        */

        constructor(settings) {
          this.window = settings.window;
        }

        /**
        * @method init
        */
        init() {
          // Do not wait for AB to load
          if (!isMobile) {
            CliqzABTests.check();
          }
        }

        unload() {}
      }

      var coreCliqzModule = {
        Background,
        Window: Win$1
      };

      var _extends$2 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      class OfferResult {
        constructor(rawResult) {
          this.rawResult = rawResult;
        }

        get _extra() {
          return this.rawResult.data.extra || {};
        }

        get isAd() {
          return this._extra.is_ad;
        }

        get isInjected() {
          const offerData = this._extra.offers_data || {};
          return offerData.is_injected;
        }

        get isOffer() {
          return this.isAd || this.isInjected;
        }

        get isHistory() {
          const kind = this.rawResult.data.kind || [''];
          return kind.some(k => k === 'H');
        }

        get shouldCountStats() {
          return this.isOffer && !this.isHistory;
        }

        get offerId() {
          const offerData = this._extra.offers_data.data || {};
          const campaignId = this.isAd ? '001' : '002';
          const prefName = `myoffrz.experiments.${campaignId}`;
          const style = CliqzUtils.getPref(`${prefName}.style`, 'plain');
          const position = CliqzUtils.getPref(`${prefName}.position`, 'first');

          if (this.isAd) {
            return `${offerData.offer_id}_${campaignId}_${style}_${position}`;
          }

          return `${offerData.offer_id}_${campaignId}_${style}`;
        }

        get offerData() {
          const data = Object.assign({}, _extends$2({}, this.rawResult.data.extra.offers_data.data, {
            offer_id: this.offerId
          }));
          return data;
        }
      }

      /**
        @namespace dropdown
        @module dropdown
        @class Background
       */
      var Background$1 = background({
        history: inject.module('history'),
        offers: inject.module('offers-v2'),

        requiresServices: ['logos'],

        /**
          @method init
          @param settings
        */
        init() {
          this.offerSignalSent = new WeakMap();
        },

        unload() {},

        getSessionCount() /* query */{
          return 0; // this.history.action('getSessionCount', query);
        },

        beforeBrowserShutdown() {},

        sendOfferShownSignals(offerResult) {
          const offer = {
            origin: 'dropdown',
            data: offerResult.offerData
          };
          return this.offers.action('createExternalOffer', offer).then(() => {
            if (this.offerSignalSent.get(this.currentResults)) {
              return Promise.resolve();
            }
            this.offerSignalSent.set(this.currentResults, true);
            CliqzEvents.pub('offers-recv-ch', {
              origin: 'dropdown',
              type: 'offer-action-signal',
              data: {
                offer_id: offerResult.offerId,
                action_id: 'offer_dsp_session'
              }
            });
            CliqzEvents.pub('offers-recv-ch', {
              origin: 'dropdown',
              type: 'offer-action-signal',
              data: {
                offer_id: offerResult.offerId,
                action_id: 'offer_shown'
              }
            });
            return Promise.resolve();
          }).catch(console$1.error);
        },

        get inOffersAB() {
          return CliqzUtils.getPref('offers2UserEnabled', true) && CliqzUtils.getPref('offersDropdownSwitch', false);
        },

        events: {
          'ui:click-on-url': function onClick(_ref) {
            let rawResult = _ref.rawResult;

            if (!this.inOffersAB) {
              return;
            }

            let showsPromise;

            // report shows if the query of currentResults matches
            if (this.currentResults && rawResult.text === this.currentResults[0].text) {
              const offersCreationPromises = this.currentResults.map(r => new OfferResult(r)).filter(r => r.shouldCountStats).map(this.sendOfferShownSignals.bind(this));
              showsPromise = Promise.all(offersCreationPromises);
            } else {
              showsPromise = Promise.resolve();
            }

            const offerResult = new OfferResult(rawResult);

            if (!offerResult.shouldCountStats) {
              return;
            }

            showsPromise.then(() => {
              CliqzEvents.pub('offers-recv-ch', {
                origin: 'dropdown',
                type: 'offer-action-signal',
                data: {
                  offer_id: offerResult.offerId,
                  action_id: 'offer_ca_action'
                }
              });
            }, console$1.error);
          },

          'core:urlbar_blur': function onBlur() {
            if (!this.inOffersAB || !this.currentResults || this.offerSignalSent.get(this.currentResults)) {
              return;
            }
            this.currentResults.map(r => new OfferResult(r)).filter(r => r.shouldCountStats).map(this.sendOfferShownSignals.bind(this));
          },

          'ui:results': function onResults(rawResults) {
            if (!this.inOffersAB) {
              return;
            }
            this.currentResults = rawResults;
            this.offerSignalSent.set(this.currentResults, false);
          }
        },

        actions: {}
      });

      Components.utils.import('resource://gre/modules/Services.jsm');

      function setSearchEngine(engine) {
        Services.search.currentEngine = engine;
      }

      var _slicedToArray$5 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      function log$3(msg) {}
      // utils.log('search-engines', msg);


      // Filters out results with value: "moz-action:searchengine,{"engineName":"Google","input":"awz","searchQuery":"awz"}"
      // that are returned from the unifiedcomplete history provider that is the only provider from Firefox 49.0 on
      function isSearchEngineResult(resultValue) {
        var _utils$cleanMozillaAc = CliqzUtils.cleanMozillaActions(resultValue),
            _utils$cleanMozillaAc2 = _slicedToArray$5(_utils$cleanMozillaAc, 1);

        const action = _utils$cleanMozillaAc2[0];

        return action === 'searchengine';
      }

      // check if a result should be kept in final result list
      function isValidUrl(url) {
        const urlparts = CliqzUtils.getDetailsFromUrl(url);
        // Google Filters
        if (urlparts.name.toLowerCase() == "google" && urlparts.subdomains.length > 0 && urlparts.subdomains[0].toLowerCase() == "www" && (urlparts.extra.indexOf("/search") != -1 || // "/search?" for regular SERPS and ".*/search/.*" for maps
        urlparts.extra.indexOf("/url?") == 0 || // www.google.*/url? - for redirects
        urlparts.extra.indexOf("q=") != -1)) {
          // for instant search results
          log$3("Discarding result page from history: " + url);
          return false;
        }
        // Bing Filters
        // Filter all like:
        //    www.bing.com/search?
        if (urlparts.name.toLowerCase() == "bing" && urlparts.extra.indexOf("q=") != -1) {
          log$3("Discarding result page from history: " + url);
          return false;
        }
        // Yahoo filters
        // Filter all like:
        //   search.yahoo.com/search
        //   *.search.yahooo.com/search - for international 'de.search.yahoo.com'
        //   r.search.yahoo.com - for redirects 'r.search.yahoo.com'
        if (urlparts.name.toLowerCase() == "yahoo" && (urlparts.subdomains.length == 1 && urlparts.subdomains[0].toLowerCase() == "search" && urlparts.path.indexOf("/search") == 0 || urlparts.subdomains.length == 2 && urlparts.subdomains[1].toLowerCase() == "search" && urlparts.path.indexOf("/search") == 0 || urlparts.subdomains.length == 2 && urlparts.subdomains[0].toLowerCase() == "r" && urlparts.subdomains[1].toLowerCase() == "search")) {
          log$3("Discarding result page from history: " + url);
          return false;
        }

        // Ignore bitly redirections
        if (url.search(/http(s?):\/\/bit\.ly\/.*/i) === 0) {
          log$3("Discarding result page from history: " + url);
          return false;
        }

        // Ignore Twitter redirections
        if (url.search(/http(s?):\/\/t\.co\/.*/i) === 0) {
          log$3("Discarding result page from history: " + url);
          return false;
        }

        return true;
      }

      /*
       * This module acts as a result factory
       *
       */

      //utils.log(msg, 'Result.jsm');


      // returns the super type of a result - type to be consider for UI creation
      function getSuperType(result) {
        if (result.type == 'bm' && result.snippet && result.template) {
          // backwards compatibility (most generic type, requires only url)
          return CliqzUtils.getKnownType(result.template.toLowerCase()) || 'bm';
        }
        return null;
      }

      function combineSources(internal, cliqz) {
        // do not add extra sources to end of EZs
        if (internal == "cliqz-extra") return internal;

        var cliqz_sources = cliqz.substr(cliqz.indexOf('sources-'));
        return internal + " " + cliqz_sources;
      }

      var Result = {
        CLIQZR: 'cliqz-results',
        CLIQZC: 'cliqz-custom',
        CLIQZE: 'cliqz-extra',
        CLIQZCLUSTER: 'cliqz-cluster',
        CLIQZSERIES: 'cliqz-series',
        RULES: {
          'video': [{ 'domain': 'youtube.com', 'ogtypes': ['video', 'youtube'] }, { 'domain': 'vimeo.com', 'ogtypes': ['video'] }, { 'domain': 'myvideo.de', 'ogtypes': ['video.tv_show', 'video.episode', 'video.other'] }, { 'domain': 'dailymotion.com', 'ogtypes': ['video'] }, { 'vertical': 'video' }],
          'poster': [{ 'domain': 'imdb.com', 'ogtypes': ['video.tv_show', 'tv_show', 'movie', 'video.movie', 'game', 'video.episode', 'actor', 'public_figure'] }],
          'person': [{ 'domain': 'xing.com', 'ogtypes': ['profile'] }, { 'vertical': 'people' }],
          'hq': [{ 'vertical': 'hq' }],
          'news': [{ 'vertical': 'news' }],
          'shopping': [{ 'vertical': 'shopping' }]
        },
        generic: function generic(style, value, image, comment, label, query, data, subtype) {
          //try to show host name if no title (comment) is provided
          if (style.indexOf(Result.CLIQZC) === -1 // is not a custom search
          && (!comment || value == comment) // no comment(page title) or comment is exactly the url
          && CliqzUtils.isCompleteUrl(value)) {
            // looks like an url
            var host = CliqzUtils.getDetailsFromUrl(value).name;
            if (host && host.length > 0) {
              comment = host[0].toUpperCase() + host.slice(1);
            }
          }
          if (!comment) {
            comment = value;
          }

          data = data || {};
          data.kind = [CliqzUtils.encodeResultType(style) + (subtype ? '|' + JSON.stringify(subtype) : '')];
          var item = {
            style: style,
            val: value,
            comment: comment,
            label: label || value,
            query: query,
            data: data,
            image: image
          };
          return item;
        },
        cliqz: function cliqz(result, q) {
          var resStyle;
          result.snippet = result.snippet || {};
          if (!result.type) {
            result.type = 'bm'; // result.type will not be set if RH is down
          }
          if (result.snippet.desc) {
            // description will be called desc if RH is down
            result.snippet.description = result.snippet.desc;
          }
          if (result.type == 'bm') {
            resStyle = Result.CLIQZR + ' sources-' + CliqzUtils.encodeSources(getSuperType(result) || result.type).join('');
          } else if (result.type == 'rh') {
            resStyle = Result.CLIQZE;
          } else if (result.type == 'suggestion') {
            resStyle = 'cliqz-suggestion';
          }
          Object.assign(result.snippet, {
            subType: result.subType,
            trigger_urls: result.trigger,
            ts: result.ts,
            template: result.template || 'generic'
          });

          return Result.generic(resStyle || '', //style
          result.url, //value
          result.image, //image -> favico
          result.snippet.title, null, //label
          q, //query
          result.snippet, //data
          result.subType);
        },
        // Combine two results into a new result
        combine: function combine(first, second) {
          var ret = Result.clone(first);
          ret.image = ret.image || second.image;
          ret.style = combineSources(ret.style, second.style);
          ret.data.kind = (ret.data.kind || []).concat(second.data.kind || []);

          // copy over description, title and url list, if needed
          if (second.data.description && !ret.data.description) ret.data.description = second.data.description;
          if (second.data.title && !ret.data.title) // title
            ret.data.title = second.data.title;
          if (second.data.urls && !ret.data.urls) // history url list
            ret.data.urls = second.data.urls.map(item => {
              item.favicon = item.favicon || ret.image;
              return item;
            });
          if (second.data.deepResults && !ret.data.deepResults) ret.data.deepResults = second.data.deepResults;
          if (second.data.extra && !ret.data.extra) ret.data.extra = second.data.extra;
          if (ret.data.template !== 'pattern-h2' && second.data.template != 'generic') ret.data.template = second.data.template;

          return ret;
        },
        // not really cloning the object !!!
        clone: function clone(entry) {
          var ret = Result.generic(entry.style, entry.val, entry.image, entry.comment, entry.label, entry.query, null);
          ret.data = JSON.parse(JSON.stringify(entry.data)); // nasty way of cloning an object
          if (entry.autocompleted) ret.autocompleted = true;
          return ret;
        },
        getOgImage: function getOgImage(og) {
          if (og && og.image) {
            var image = { src: og.image };

            if (og.duration && parseInt(og.duration)) {
              var parsedDuration = Result.tryGetImageDuration(og.duration);
              if (parsedDuration) image.duration = parsedDuration;
            }

            return image;
          }
        },
        getVerticalImage: function getVerticalImage(imageData, richData) {
          if (imageData == undefined || imageData.src == undefined) return;

          var image = {
            src: imageData.src
          };

          if (imageData.width) image.width = imageData.width;
          if (imageData.height) image.height = imageData.height;
          if (imageData.ratio) image.ratio = imageData.ratio;

          // add duration from rich data
          if (richData && richData.duration) {
            var parsedDuration = Result.tryGetImageDuration(richData.duration);
            if (parsedDuration) image.duration = parsedDuration;
          }

          return image;
        },
        tryGetImageDuration: function tryGetImageDuration(duration) {
          try {
            var totalSeconds = parseInt(duration),
                min = Math.floor(totalSeconds / 60),
                seconds = totalSeconds % 60;
            return min + ':' + (seconds < 10 ? '0' + seconds : seconds);
          } catch (e) {}

          return undefined;
        }
      };

      var _slicedToArray$4 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var FF_DEF_FAVICON = 'chrome://mozapps/skin/places/defaultFavicon.png';
      var Q_DEF_FAVICON = CliqzUtils.SKIN_PATH + 'defaultFavicon.png';

      var CliqzHistoryCluster = {
        historyCallback: null,
        latencies: [],

        // Generate result json from patterns
        _generateResult: function _generateResult(patterns, query, cluster, baseUrl) {
          if (!patterns) {
            patterns = [];
          }
          return {
            query: query,
            cluster: cluster,
            top_domain: baseUrl || CliqzHistoryCluster._maxDomainShare(patterns)[0],
            results: patterns,
            filteredResults: function filteredResults() {
              var self = this;
              return this.results.filter(function (r) {
                return r.title && CliqzUtils.getDetailsFromUrl(r.url).name == CliqzUtils.getDetailsFromUrl(self.top_domain).name;
              });
            }
          };
        },
        // This method is triggered when the Firefox history has finished loading
        addFirefoxHistory: function addFirefoxHistory(history) {
          var query = history.query;
          var res;

          // Extract results
          var patterns = [];
          for (var i = 0; i < history.results.length; i++) {
            var parts = CliqzUtils.cleanMozillaActions(history.results[i].value);
            var url = parts[1],
                title = history.results[i].comment;

            if (isSearchEngineResult(history.results[i].value)) {
              continue;
            }

            if (!title) {
              title = CliqzUtils.generalizeUrl(url);
            }

            if (title.length > 0 && url.length > 0 && isValidUrl(url)) {
              patterns.push({
                url: url,
                title: title,
                favicon: history.results[i].image,
                style: history.results[i].style,
                _genUrl: CliqzUtils.generalizeUrl(url, true)
              });
            }
          }
          // Process patterns
          res = CliqzHistoryCluster._preparePatterns(patterns, query);
          CliqzHistoryCluster.historyCallback(res);
        },
        _simplePreparePatterns: function _simplePreparePatterns(patterns, query) {
          var baseUrl,
              favicon,
              orig_query = query;

          query = CliqzUtils.cleanUrlProtocol(query, true).trim();

          // Filter patterns that don't match search
          //patterns = CliqzHistoryCluster._filterPatterns(patterns, query.toLowerCase());
          //var share = CliqzHistoryCluster._maxDomainShare(patterns);

          // Remove patterns with same url or title
          //patterns = CliqzHistoryCluster._removeDuplicates(patterns);

          // Move base domain to top
          //var adjustedResults = CliqzHistoryCluster._adjustBaseDomain(patterns, query);
          //patterns = adjustedResults[0];
          //baseUrl = adjustedResults[1];
          //favicon = adjustedResults[2];
          //var https = adjustedResults[3];
          var res = CliqzHistoryCluster._generateResult(patterns, orig_query, false, baseUrl);

          res.cluster = false;

          res.results = CliqzHistoryCluster._removeDuplicates(res.results);
          return res;
        },

        // Process patterns
        _preparePatterns: function _preparePatterns(patterns, query) {
          var baseUrl,
              favicon,
              orig_query = query;

          query = CliqzUtils.cleanUrlProtocol(query, true).trim();

          // Filter patterns that don't match search
          patterns = CliqzHistoryCluster._filterPatterns(patterns, query.toLowerCase());
          var share = CliqzHistoryCluster._maxDomainShare(patterns);

          // Remove patterns with same url or title
          patterns = CliqzHistoryCluster._removeDuplicates(patterns);

          // Move base domain to top
          var adjustedResults = CliqzHistoryCluster._adjustBaseDomain(patterns, query);
          patterns = adjustedResults[0];
          baseUrl = adjustedResults[1];
          favicon = adjustedResults[2];
          var https = adjustedResults[3];
          var res = CliqzHistoryCluster._generateResult(patterns, orig_query, false, baseUrl);

          // Add base domain if above threshold
          var fRes = res.filteredResults();
          var genQ = CliqzUtils.generalizeUrl(query);
          if (share[1] > 0.5 && fRes.length > 2 && !(CliqzUtils.generalizeUrl(patterns[0].url).indexOf(genQ) !== 0 && share[1] < 0.8)) {
            // Check if base domain changed due to filtering
            var tmpBaseUrl = CliqzHistoryCluster._adjustBaseDomain(fRes, query)[1];
            baseUrl = tmpBaseUrl;
            CliqzHistoryCluster._addBaseDomain(patterns, baseUrl, favicon, https);
            res.cluster = true;
            // Threshold not reached or clustering not enabled -> no domain clustering
          } else {
            // Disable domain filtering
            res.filteredResults = function () {
              return this.results;
            };
          }

          // Remove automatically added patterns if they don't match query
          if (patterns && patterns.length > 0 && patterns[0].autoAdd && CliqzUtils.generalizeUrl(patterns[0].url).indexOf(genQ) !== 0) {
            patterns.shift();
            res.cluster = false;
          }

          res.results = CliqzHistoryCluster._removeDuplicates(res.results);
          return res;
        },

        // find the best (https) common protocol for urls from patterns for the same domain
        // if no https urls is found 'http' will be used
        _findBestCommonProtocol(baseDomain, patterns) {
          return patterns.find(pattern => {
            const details = CliqzUtils.getDetailsFromUrl(pattern.url);
            return baseDomain === details.domain && details.scheme === 'https';
          }) && 'https' || 'http';
        },

        // Calculates the _weighted_ share of the most common domain in given patterns
        _maxDomainShare: function _maxDomainShare(patterns) {
          var patternCount = patterns.length;
          // boost the first X domain entries (i.e., within boostRange)
          var boostRange = 3;
          // weight for the first X entries, all other entries have weight of 1;
          // this makes the first X entries as important as the remaining (N - X) entries
          var boostFactor = (patternCount - boostRange) / (1 * boostRange);

          // make sure the first results do not become less important, which happens if
          // if there are only very few patterns (i.e, patternCount < boostRange * 2)
          boostFactor = Math.max(1, boostFactor);

          var domains = new Map();
          var index = 0;

          for (var key in patterns) {
            var url = patterns[key].url,
                domainName;

            // only consider http(s) urls for patterns
            if (url.indexOf('http://') === 0 || url.indexOf('https://') === 0) {
              domainName = CliqzUtils.getDetailsFromUrl(url).domain;
            }

            // assign a higher weight to this domain entry if it is one of the first N entries
            var weightedCount = index < boostRange ? boostFactor : 1;
            var prevValue = domains.get(domainName) || 0;
            domains.set(domainName, prevValue + weightedCount);
            index++;
          }
          var max = 0.0,
              cnt = 0.0;
          var mainDomain = null;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = domains.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _ref = _step.value;

              var _ref2 = _slicedToArray$4(_ref, 2);

              var domain = _ref2[0];
              var value = _ref2[1];

              cnt += value;
              if (value > max && domain) {
                max = value;
                mainDomain = domain;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return [mainDomain, max / cnt];
        },
        _filterPatterns: function _filterPatterns(patterns, full_query) {
          var queries = full_query.trim().split(' ');
          var newPatterns = [];
          for (var key in patterns) {
            var match = true;
            // Check all queries for matches
            for (var wordKey in queries) {
              var titleUrlMatch = false;
              if (patterns[key].url.indexOf(queries[wordKey]) != -1 || (patterns[key].title || '').toLowerCase().indexOf(queries[wordKey]) != -1) {
                titleUrlMatch = true;
              }
              var queryMatch = false;
              for (var qkey in patterns[key].query) {
                var q = patterns[key].query[qkey];
                if (q.indexOf(queries[wordKey]) != -1) {
                  queryMatch = true;
                  break;
                }
              }
              if (!queryMatch && !titleUrlMatch) {
                match = false;
                break;
              }
            }
            if (match) newPatterns.push(patterns[key]);
          }
          return newPatterns;
        },
        // Deduplicate URLs and titles
        _removeDuplicates: function _removeDuplicates(patterns) {
          var newPatterns;
          newPatterns = CliqzHistoryCluster._removeDuplicatesByKey(patterns, '_genUrl');
          newPatterns = CliqzHistoryCluster._removeDuplicatesByKey(newPatterns, 'title');
          return newPatterns;
        },
        // Deduplicate entries by value of key, with a preference for https and proper titles
        _removeDuplicatesByKey: function _removeDuplicatesByKey(patterns, key) {
          var reorg = {};
          var order = [];

          var value;

          // Pass 1: group similar entries by key
          for (var i = 0; i < patterns.length; i++) {
            value = patterns[i][key];
            if (!reorg.hasOwnProperty(value)) {
              order.push(value);
              reorg[value] = [];
            }
            reorg[value].push(patterns[i]);
          }

          // Pass 2: take the best entry from each group
          // and add to newPatterns in original order.
          var newPatterns = [];
          for (i = 0; i < order.length; i++) {
            value = order[i];

            if (reorg[value].length == 1) {
              newPatterns.push(reorg[value][0]);
              continue;
            }

            // Separate http and https links
            var https = [],
                http = [];
            for (var j = 0; j < reorg[value].length; j++) {
              if (reorg[value][j].url.indexOf('https://') === 0) {
                https.push(reorg[value][j]);
              } else {
                http.push(reorg[value][j]);
              }
            }

            // if any https links, proceed with them only
            var candidates;
            if (https.length > 0) candidates = https;else candidates = http;

            // Pick the one with a "real" title.
            // Some history entries will have a title the same as the URL,
            // don't use these if possible.
            var found = false;
            for (var x = 0; x < candidates.length; x++) {
              if (!(candidates[x].title == candidates[x]._genUrl || candidates[x].title == 'www.' + candidates[x]._genUrl || candidates[x].title == candidates[x].url)) {
                newPatterns.push(candidates[x]);
                found = true;
                break;
              }
            }
            if (!found) newPatterns.push(candidates[0]);
          }

          return newPatterns;
        },
        // Search all patterns for matching substring (should be domain)
        _findCommonDomain: function _findCommonDomain(patterns) {
          if (patterns.length < 2) {
            return null;
          }
          var scores = {};

          for (var key in patterns) {
            var url1 = patterns[key]._genUrl;
            scores[url1] = true;
            for (var key2 in patterns) {
              var url2 = patterns[key2]._genUrl;
              if (key != key2 && url2.indexOf(url1) == -1) {
                scores[url1] = false;
              }
            }
          }

          // Return match with most occurences
          for (var scorekey in scores) {
            if (scores[scorekey] === true) {
              return scorekey;
            }
          }
          return null;
        },
        // Move base domain to top
        _adjustBaseDomain: function _adjustBaseDomain(patterns, query) {
          if (patterns.length === 0) {
            return [];
          }
          var basePattern = null,
              baseUrl = null,
              favicon = null,
              commonDomain = CliqzHistoryCluster._findCommonDomain(patterns);

          // Check for url matching query
          query = CliqzUtils.generalizeUrl(query, true);
          if (query) {
            for (let key in patterns) {
              var url = patterns[key].url;
              if (url.indexOf(query) === 0) {
                baseUrl = url;
                favicon = patterns[key].favicon;
                break;
              }
            }
          }

          // if none found, use the first entry
          if (!baseUrl) {
            baseUrl = patterns[0]._genUrl;
            favicon = patterns[0].favicon;
          }

          baseUrl = commonDomain || baseUrl.split('/')[0];

          // find if there is an entry matching the base URL.
          var pUrl;
          for (var i = 0; i < patterns.length; i++) {
            pUrl = patterns[i]._genUrl;
            if (baseUrl == pUrl) {
              basePattern = patterns[i];
              break;
            }
          }
          var https = false;
          var newPatterns = [];
          if (basePattern) {
            // found a history entry representing the base pattern,
            // use at the first entry in newPatterns
            basePattern.base = true;
            patterns[0].debug = 'Replaced by base domain';
            newPatterns.push(basePattern);
          } else {
            CliqzUtils.log('Using a base url that did not exist in history list.', 'CliqzHistoryCluster');

            for (let key in patterns) {
              // if any pattern uses an https domain, try to use that for
              // base domain too.
              pUrl = patterns[key].url;
              if (pUrl.indexOf('https://') === 0) {
                https = true;
                break;
              }

              // Add https if required
              if (https) {
                // ...but only if there is a history entry with title
                if (CliqzHistoryManager.getPageTitle('https://' + baseUrl)) {
                  CliqzUtils.log('found https base URL with title', 'CliqzHistoryCluster');
                  // keep https as true
                } else {
                  CliqzUtils.log('no https base URL with title, do not change original base URL', 'CliqzHistoryCluster');
                  https = false;
                }
              }
            }
          }

          for (let key in patterns) {
            // keep everything else except for base, it is already there
            if (patterns[key] != basePattern) newPatterns.push(patterns[key]);
          }
          return [newPatterns, baseUrl, favicon, https];
        },
        // Add base domain of given result to top of patterns, if necessary
        _addBaseDomain: function _addBaseDomain(patterns, baseUrl, favicon, https) {
          baseUrl = CliqzUtils.generalizeUrl(baseUrl, true);
          // Add base domain entry if there is not one already
          if (patterns && patterns.length > 0 && !patterns[0].base) {
            var title = CliqzUtils.getDetailsFromUrl(baseUrl).domain;
            if (!title) {
              CliqzUtils.log('Failed to add base domain because there is no title: ' + baseUrl, 'CliqzHistoryCluster');
              return;
            }

            CliqzUtils.log('Adding base domain to history cluster: ' + baseUrl, 'CliqzHistoryCluster');

            var urldetails = CliqzUtils.getDetailsFromUrl(baseUrl);
            // Add protocol if it is missing
            if (!urldetails.scheme) {
              baseUrl = this._findBestCommonProtocol(urldetails.domain, patterns) + '://' + baseUrl;
            }
            // Add trailing slash if not there
            if (urldetails.path === '') baseUrl = baseUrl + '/';

            patterns.unshift({
              title: title.charAt(0).toUpperCase() + title.split('.')[0].slice(1),
              url: baseUrl,
              favicon: favicon,
              autoAdd: true
            });
          }
        },
        // Autocomplete an urlbar value with the given patterns
        autocompleteTerm: function autocompleteTerm(urlbar, pattern, loose) {
          var MAX_AUTOCOMPLETE_LENGTH = 80; // max length of autocomplete portion

          function matchQuery(queries) {
            var query = '';
            for (var key in queries) {
              var q = queries[key].toLowerCase();
              if (q.indexOf(input) === 0 && q.length > query.length) {
                query = q;
              }
            }
            return query;
          }
          if (urlbar == 'www.' || urlbar == 'http://' || urlbar.substr(urlbar.indexOf('://') + 3) == 'www.' || urlbar === '') return {};

          var url = CliqzUtils.simplifyUrl(pattern.url);
          url = CliqzUtils.generalizeUrl(url, true);
          var input = CliqzUtils.generalizeUrl(urlbar);
          if (urlbar[urlbar.length - 1] == '/') input += '/';

          var autocomplete = false,
              highlight = false,
              selectionStart = 0,
              urlbarCompleted = '';
          var queryMatch = matchQuery(pattern.query);

          // Url
          if (url.indexOf(input) === 0 && url != input && url.length - input.length <= MAX_AUTOCOMPLETE_LENGTH) {
            autocomplete = true;
            highlight = true;
            urlbarCompleted = urlbar + url.substring(url.indexOf(input) + input.length);
          }

          if (autocomplete) {
            selectionStart = urlbar.toLowerCase().lastIndexOf(input) + input.length;
          }

          // Adjust url to user protocol
          if (urlbar.indexOf('://') != -1) {
            var prot_user = urlbar.substr(0, urlbar.indexOf('://') + 3);
            var prot_auto = pattern.url.substr(0, pattern.url.indexOf('://') + 3);
            pattern.url = pattern.url.replace(prot_auto, prot_user);
          }

          return {
            url: url,
            full_url: pattern.url,
            autocomplete: autocomplete,
            urlbar: urlbarCompleted,
            selectionStart: selectionStart,
            highlight: highlight
          };
        },

        // Attach a list of URLs to a cluster result
        _attachURLs: function _attachURLs(result, urls, with_favicon) {
          result.data.urls = [];

          for (var i = 0; i < urls.length; i++) {
            var domain = CliqzUtils.generalizeUrl(urls[i].url, true).split('/')[0],
                url = urls[i].url;

            if (url[url.length - 1] == '/') url = url.substring(0, url.length - 1);

            var favicon = with_favicon && (urls[i].favicon == FF_DEF_FAVICON ? Q_DEF_FAVICON : urls[i].favicon),
                cleanUrl = CliqzUtils.cleanUrlProtocol(CliqzUtils.simplifyUrl(url), true);

            var item = {
              href: urls[i].url,
              link: cleanUrl,
              domain: cleanUrl.split('/')[0],
              title: urls[i].title,
              extra: 'history-' + i,
              favicon: favicon,
              kind: ['H'],
              style: urls[i].style
            };
            // logo is only necessary for 3-up mini-history view, this can be removed if that is retired
            if (urls[i].url && urls[i].url.toLowerCase().startsWith("http")) item.logo = CliqzUtils.getLogoDetails(CliqzUtils.getDetailsFromUrl(urls[i].url));

            if (urls[i].hasOwnProperty('xtra_c')) {
              item['xtra_c'] = urls[i]['xtra_c'];
              item['class-col-cluster'] = 'cqz-col-12';
              //item['class-col-query'] = 'cqz-col-0';
            }

            if (urls[i].hasOwnProperty('xtra_q')) {
              item['xtra_q'] = urls[i]['xtra_q'];
              item['class-col-cluster'] = 'cqz-col-8';
              item['class-col-query'] = 'cqz-col-4';
            }

            result.data.urls.push(item);

            if (result.data.urls.length > 9 && result.data.template == 'pattern-h1' || result.data.urls.length > 4 && result.data.template == 'pattern-h2' || result.data.urls.length > 2 && result.data.template == 'pattern-h3') {
              break;
            }
          }
        },
        // Creates one (or potentially more) instant results based on history
        createInstantResult: function createInstantResult(res, searchString, callback, customResults) {
          var instant_results = [];
          var results = res.filteredResults();

          if (results.length === 0 && !res.urls) {
            // no results, so do nothing
          } else if (res.urls) {
            // Rule-based clustering has already been performed, just take the entry as it is
            var instant = Result.generic('cliqz-pattern', res.url, res.urls[0].favicon, res.title, null, searchString, res);
            instant.data.debug = '(history rules cluster)!';

            instant.data.template = 'pattern-h2';
            instant.data.cluster = true; // a history cluster based on a destination bet
            instant_results.push(instant);
          } else if (searchString.trim().length === 0 && customResults === null) {
            // special case for user request of top sites from history
            var instant = Result.generic('cliqz-pattern', '', null, '', null, searchString);
            instant.data.title = CliqzUtils.getLocalizedString('history_results_cluster');
            instant.data.url = results[0].url;
            instant.data.debug = '(history top sites)!';
            instant.data.template = 'pattern-h1';
            instant.data.generic = true;

            this._attachURLs(instant, results);

            instant_results.push(instant);
          } else if (res.cluster) {
            // domain-based cluster
            var instant = Result.generic('cliqz-pattern', results[0].url, results[0].favicon, results[0].title, null, searchString);
            var title = results[0].title;
            if (!title) {
              title = results[0].url;
              CliqzUtils.log('No title, assigning ' + title, 'CliqzHistoryCluster');
            }
            instant.data.localSource = results[0].style;
            instant.data.title = title;
            instant.data.url = results[0].url;
            instant.data.debug = '(history domain cluster)!';
            instant.data.template = 'pattern-h2';
            instant.data.autoAdd = results[0].autoAdd;
            instant.data.cluster = true; // a history cluster based on a destination bet

            // first entry is used as the main URL of this cluster, remove from remaining result list
            results.shift();

            CliqzHistoryCluster._attachURLs(instant, results);

            instant_results.push(instant);
          } else if (results.length < 3) {
            for (var i = 0; i < results.length; i++) {
              var instant = Result.generic('favicon', results[i].url, results[i].favicon, results[i].title, null, searchString);
              instant.data.title = instant.comment;
              instant.data.debug = '(history generic)!';
              instant.data.kind = ['H'];
              instant.data.localSource = results[i].style;
              instant_results.push(instant);
            }
          } else {
            // 3-up combined generic history entry
            var instant = Result.generic('cliqz-pattern', '', null, '', null, searchString);
            instant.data.title = instant.comment;
            instant.data.debug = '(history generic)!';
            instant.data.template = 'pattern-h3';
            instant.data.generic = true;

            this._attachURLs(instant, results, true);
            instant_results.push(instant);
          }

          callback(instant_results, 'cliqz-prod');
        },
        // Creates one (or potentially more) instant results based on history
        simpleCreateInstantResult: function simpleCreateInstantResult(res, cont, searchString, callback) {
          var instant_results = [];
          //var results = res.filteredResults();
          var results = res.results;
          var promises = [];

          if (results.length === 0 && !res.urls) {
            // no results, so do nothing

          } else {
            // generic history
            var simple_generic = CliqzUtils.getPref('simpleHistory', false);
            //var simple_generic = true;

            // 3-up combined generic history entry
            var instant = Result.generic('cliqz-pattern', '', null, '', null, searchString);
            instant.data.title = instant.comment;
            instant.data.debug = '(history generic)!';

            //
            // There is so many levels of abstraction here that is impossible to follow,
            // 5 function to be able to printout something, stack overflow :-/
            //
            instant.data.template = 'pattern-hm';
            //instant.data.template = 'pattern-h3';

            instant.data.generic = true;

            instant.data.cont = cont;

            this._attachURLs(instant, results, true);

            instant_results.push(instant);
          }

          if (typeof Promise === 'undefined') {
            // Firefox versions < 29
            callback(instant_results, 'hm');
          } else {
            Promise.all(promises).then(function (data) {
              callback(instant_results, 'hm');
            });
          }
        },
        // Removes a given url from the instant.data.url list
        removeUrlFromResult: function removeUrlFromResult(urlList, _url) {
          var url = CliqzUtils.generalizeUrl(_url);
          for (var key in urlList) {
            var r_url = CliqzUtils.generalizeUrl(urlList[key].href);
            if (r_url == url) {
              urlList.splice(key, 1);
              return;
            }
          }
        }
      };

      var math = lazyLoader('math.min.js', 'math');

      /*
       * This module handles various calculations
       *
       */

      // REF:
      //      http://mathjs.org/docs/index.html
      //      http://stackoverflow.com/questions/26603795/variable-name-and-restrict-operators-in-math-js
      //      http://jsbin.com/duduru/1/edit?html,output


      function getEqualOperator(val, localizedStr) {
        const valStr = val.toString().replace(',', '').replace('.', '');
        const normLocalizedStr = localizedStr.replace(',', '').replace('.', '');
        return valStr === normLocalizedStr ? '=' : '\u2248';
      }

      function NumberException(number) {
        return {
          name: 'NumberException',
          message: `Invalid number: ${number}`
        };
      }

      function replaceAll(string, search, replacement) {
        return string.split(search).join(replacement);
      }

      const CliqzCalculator = {
        CALCULATOR_RES: 0,
        UNIT_RES: '',
        IS_UNIT_CONVERTER: false,
        BASE_UNIT_CONVERTER: '',
        CLEANED_QUERY: '',
        FLOAT_DEC: [100000, 100, 1],
        FLOAT_DEC_THRESHOLD: [99, 99999],
        ACCEPT_ERROR: 1e-8,
        UNIT_CONVERSION_DATA: { // http://en.wikipedia.org/wiki/Conversion_of_units
          // http://www.convert-me.com/en/convert/length/
          LOCALIZE_KEYS: { 'de-DE': 'names_de', 'en-US': 'names_en', default: 'names_de' },
          types: ['length', 'mass'],
          length: {
            base: 'm',
            units: [{ val: 4828, names: ['lea', 'leuge', 'league', 'leagues'] }, { val: 0.3048006096012192, // this is US foot, there're IDIAN, CLA, BEN,...
              names: ['ft', 'foot', 'feet', 'fu\xDF'],
              names_en: { s: 'foot', p: 'feet' },
              names_de: { s: 'fu\xDF', p: 'fu\xDF' } }, { val: 0.0254, names: ['in', 'inch', 'inches', 'zoll'] }, { val: 1000, names: ['km', 'kilometer', 'kilometre', 'kilometres', 'kilometers'] }, { val: 1, names: ['m', 'meter', 'metre', 'metres', 'meters'] }, { val: 0.1, names: ['dm', 'decimeter', 'decimetre', 'decimeters', 'decimetres', 'dezimeter'] }, { val: 0.01, names: ['cm', 'centimeter', 'centimetre', 'centimetres', 'centimeters', 'zentimeter'] }, { val: 0.001, names: ['mm', 'millimeter', 'millimetre', 'millimetres', 'millimeters'] }, { val: 1e-6, names: ['micron', 'micrometer', 'micrometre', 'micrometres', 'micrometers', 'mikrometer'] }, { val: 1e-9, names: ['nm', 'nanometre', 'nanometre', 'nanometer', 'nanometers'] }, { val: 10000, names: ['mil'] }, // this is Sweden and Norway unit
            { val: 1609.344,
              names: ['mil.', 'mi.', 'mile', 'miles', 'meile', 'meilen'],
              names_en: { s: 'mile', p: 'miles' },
              names_de: { s: 'meile', p: 'meilen' } }, { val: 201.168, names: ['furlong', 'furlongs'] }, { val: 0.9144, names: ['yd', 'yard', 'yards'] }, { val: 2.54 * 1e-5, names: ['thou'] }, { val: 1.8288, names: ['fm', 'fathom', 'fathoms', 'faden', 'f\xE4den'] }, { val: 5.0292, names: ['rd', 'rod', 'rods', 'rute', 'ruten'] }, { val: 0.1016, names: ['hand', 'hands', 'handbreit'] }, { val: 0.2286, names: ['span', 'spans', 'spanne', 'spannen'] }, { val: 5556, names: ['naut.leag', 'nautical league', 'naut.leags', 'nautical league'] }, { val: 1852, names: ['naut.mil', 'naut.mils', 'nautical mile', 'nautical miles', 'naut.meile', 'naut.meilen', 'nautische meile', 'nautische meilen'] }, { val: 1852.216, names: ['sm', 'Seemeile'] }, { val: 185.2, names: ['cbl', 'cable length', "cable'slength", 'Kabel', 'Kabellnge'] }]
          },
          mass: {
            base: 'g',
            units: [{ val: 102, names: ['kN', 'kn', 'kilonewton', 'kilonewtons'] }, { val: 1e9, names: ['kt', 'kilotonne', 'kilotonnes', 'kilotonnen'] }, { val: 1e6, names: ['t', 'tonne', 'tonnes', 'tonnen', 'metric ton', 'metric tons'] }, { val: 1e6, names: ['Mg', 'megagram', 'megagrams'] }, { val: 1000, names: ['kg', 'kilogram', 'kilograms', 'kilogramme', 'kilogrammes', 'kilogramm', 'kilogramms'] }, { val: 100, names: ['hg', 'hectogram', 'hectograms', 'hectogramme', 'hectogrammes', 'hectogramm', 'hectogramms'] }, { val: 10, names: ['dag', 'decagram', 'decagrams', 'decagramme', 'decagrammes', 'decagramm', 'decagramms'] }, { val: 1, names: ['g', 'gram', 'grams', 'gramme', 'grammes', 'gramm', 'gramms'] }, { val: 0.1, names: ['dg', 'decigram', 'decigrams', 'decigramme', 'decigrammes', 'decigramm', 'decigramms'] }, { val: 0.01, names: ['cg', 'centigram', 'centigrams', 'centigramme', 'centigrammes', 'centigramm', 'centigramms'] }, { val: 0.001, names: ['mg', 'milligram', 'milligrams', 'milligramme', 'milligrammes', 'milligramm', 'milligramms'] }, { val: 0.000001, names: ['mcg', 'microgram', 'micrograms', 'microgramme', 'microgrammes', 'microgramm', 'microgramms'] }, { val: 453.59237, names: ['lb', 'lbs', 'pound', 'pounds', 'pound-mass', 'pfund'] }, { val: 28.349523125, names: ['oz', 'ozs', 'ounce', 'ounces', 'unze', 'unzen'] }, { val: 1.7718452, names: ['dr', 'dram', 'drams'] }, { val: 0.06479891, names: ['gr', 'grain', 'grains', 'Gran'] }]
          }
        },
        init() {
          this.thousandsSeparator = CliqzUtils.getLocalizedString('calculator-thousands-separator');
          this.decimalSeparator = CliqzUtils.getLocalizedString('calculator-decimal-separator');
        },
        shortenNumber() {
          // shorten numbers when needed
          try {
            let num;

            num = this.CALCULATOR_RES.toLocaleString(CliqzUtils.getLocalizedString('locale_lang_code'), { maximumFractionDigits: 6 });
            num = replaceAll(num, this.thousandsSeparator, ' '); // Use spaces as thousands separators

            return this.IS_UNIT_CONVERTER ? [num, this.UNIT_RES].join(' ') : num.toString();
          } catch (err) {
            console$1.error(err);
          }
          return this.CALCULATOR_RES;
        },
        isValidThousandsSeparator(number, separator) {
          // More than one thousands separator, it should be thousands separator
          const parts = number.split(separator);
          if (parts.length === 1) {
            return true; // There is no thousands separator
          }
          // Invalid thousands separator
          if (parts[0].length > 3) {
            return false; // Invalid thousands separator
          }
          // Invalid thousands separator
          for (let i = 1; i < parts.length; i += 1) {
            if (parts[i].length !== 3) {
              // Invalid thousands separator
              return false;
            }
          }

          if (parts[0] === '0') {
            return false;
          }
          return true;
        },
        standardize(number) {
          let firstPart = ''; // Part before the first decimal separator
          let secondPart = ''; // Part after the first decimal separator
          // If there is (one or more) decimal separator
          if (number.indexOf(this.decimalSeparator) > -1) {
            secondPart = number.substring(number.indexOf(this.decimalSeparator) + 1);
            // If there are more than two decimal separators, there should be no thousands separator
            if (secondPart.indexOf(this.decimalSeparator) > -1 && number.indexOf(this.thousandsSeparator) > -1) {
              throw NumberException(number);
            }
            // Thousands separator should come before decimal separator
            if (secondPart.indexOf(this.thousandsSeparator) > -1) {
              throw NumberException(number);
            }
            firstPart = number.substring(0, number.indexOf(this.decimalSeparator));
            // Only one decimal separator => it's decimal separator
            if (secondPart.indexOf(this.decimalSeparator) === -1) {
              // First part contains thousands separator
              if (firstPart.indexOf(this.thousandsSeparator) > -1) {
                if (!this.isValidThousandsSeparator(firstPart, this.thousandsSeparator)) {
                  throw NumberException(number);
                }
                firstPart = replaceAll(firstPart, this.thousandsSeparator, '');
              }
              // Always use '.' as decimal separator for mathjs
              return `${firstPart}.${secondPart}`;
            }
            // There are more than one decimal separators => could be thousands separator
            if (!this.isValidThousandsSeparator(number, this.decimalSeparator)) {
              throw NumberException(number);
            }
            // *** Decimal separator becomes thousands separator
            return replaceAll(number, this.decimalSeparator, '');
          }
          // If there is no decimal separator
          const parts = number.split(this.thousandsSeparator);
          // There is only one thousands separator => could be decimal separator
          if (parts.length === 2) {
            if (parts[0].length > 3 || parts[1].length !== 3 || parts[0] === '0') {
              // *** Thousands separator becomes decimal separator
              return replaceAll(number, this.thousandsSeparator, '.');
            }
          }
          if (!this.isValidThousandsSeparator(number, this.thousandsSeparator)) {
            throw NumberException(number);
          }
          // All tests passed
          return replaceAll(number, this.thousandsSeparator, '');
        },
        clean(query) {
          let q = query;
          // Don't trigger calculator yet if the query is just a number
          if (!isNaN(q)) {
            return '';
          }
          try {
            // Replace all ' x ' with '*' for multiply triggering
            q = q.replace(/ x /g, '*');
            // Remove all spaces
            q = q.replace(/ /g, '');
            const operators = ['+', '-', '*', '/', '^', '='];
            // Remove the last operator
            while (operators.indexOf(q[q.length - 1]) > -1) {
              q = q.substr(0, q.length - 1);
            }
            let finalQuery = '';
            let lastPosition = 0;
            // Construct a query with cleaned numbers and operators
            // And standardize them independently
            for (let i = 0; i < q.length; i += 1) {
              if (operators.indexOf(q[i]) > -1) {
                const element = q.slice(lastPosition, i);
                if (element) {
                  finalQuery += this.standardize(element);
                }
                lastPosition = i + 1;
                finalQuery += q[i];
              }
              // Last number
              if (i === q.length - 1 && lastPosition < i + 1) {
                const element = q.slice(lastPosition, i + 1);
                finalQuery += this.standardize(element);
              }
            }

            // Check if the query is just a number again
            if (!isNaN(finalQuery)) {
              return '';
            }

            return finalQuery;
          } catch (e) {
            return '';
          }
        },

        calculate(q) {
          if (this.CALCULATOR_RES === null || this.CALCULATOR_RES === q) {
            return null;
          }
          const expandedExpression = this.IS_UNIT_CONVERTER ? this.CLEANED_QUERY : replaceAll(math.parse(this.clean(q)).toString(), '.', this.decimalSeparator);

          this.CALCULATOR_RES = this.shortenNumber();

          return Result.cliqz({
            url: '',
            q,
            type: 'rh',
            subType: { type: 'calculator' },
            template: 'calculator',
            snippet: {
              title: this.CALCULATOR_RES,
              extra: {
                expression: expandedExpression,
                answer: this.CALCULATOR_RES,
                is_calculus: true,
                // TODO: support_copy_ans should be platform specific
                support_copy_ans: true
              }
            }
          });
        },

        find_unit_in_data(unit_) {
          const self = this;
          const unit = unit_.toLowerCase();
          let unitFound = null;

          self.UNIT_CONVERSION_DATA.types.some(type => self.UNIT_CONVERSION_DATA[type].units.some(item => {
            if (item.names.indexOf(unit) > -1 || item.names.indexOf(unit_) > -1) {
              unitFound = [type, true, item];
              return true;
            }
            return false;
          }));
          return unitFound || ['', false, null];
        },

        selectUnitTerms(unitData, val) {
          /*
           *   + based on the value and the language preference,
           *     select unit name in suitable language and form (singular/plural)
           */
          const BROWSER_LANG = CliqzUtils.getLocalizedString('locale_lang_code');
          const nounType = val === 1 ? 's' : 'p';
          const nameInfo = unitData[CliqzCalculator.UNIT_CONVERSION_DATA.LOCALIZE_KEYS[BROWSER_LANG]] || unitData[CliqzCalculator.UNIT_CONVERSION_DATA.LOCALIZE_KEYS.default] || unitData.names;
          const name = nameInfo[nounType];

          return name || unitData.names['0'] || '';
        },

        isConverterSearch(q) {
          // --- Process query to recognize a unit-conversion query
          // ACCEPTED query types:
          //    1. a to b, e.g. cm to mm
          let tmp = q.trim();
          let unit1;
          let idx;
          let num;
          let unit1Info;
          // Note: don't use regex match in replace function, e.g. tmp.replace(/ zu | in | im /g, ' to ')
          tmp = q.replace(' zu ', ' to ');
          tmp = tmp.replace(' im ', ' to ');
          tmp = tmp.replace(' in ', ' to ');
          tmp = tmp.replace(' into ', ' to '); // this needs to be at the end
          const paramList = tmp.trim().split(' to ');

          if (paramList.length !== 2) {
            return false;
          }
          const unit2 = this.find_unit_in_data(paramList[1].trim());
          if (unit2[1]) {
            unit1 = `${paramList[0].replace(' ', '')} `;
            idx = 0;
            while (unit1[idx] === ',' || unit1[idx] === '.' || unit1[idx] >= '0' && unit1[idx] <= '9') {
              idx += 1;
            }
            if (idx === 0) {
              num = 1;
            } else {
              let numRaw = unit1.slice(0, idx);
              try {
                numRaw = this.standardize(numRaw);
              } catch (e) {
                return false;
              }
              num = Number(numRaw);
              if (isNaN(num)) {
                return false;
              }
            }

            unit1 = unit1.slice(idx, unit1.length).trim();
            unit1Info = this.find_unit_in_data(unit1);
            if (!unit1Info[1] || unit1Info[0] !== unit2[0]) {
              return false;
            } // if not unit of the same type, e.g. 1km to g should not return result

            this.IS_UNIT_CONVERTER = true;
            const cvRaw = unit1Info[2].val / unit2[2].val;
            const cv = cvRaw.toLocaleString(CliqzUtils.getLocalizedString('locale_lang_code'));
            this.CALCULATOR_RES = num * cvRaw;
            this.UNIT_RES = CliqzCalculator.selectUnitTerms(unit2[2], this.CALCULATOR_RES);
            this.BASE_UNIT_CONVERTER = ['1', CliqzCalculator.selectUnitTerms(unit1Info[2], 1), getEqualOperator(cvRaw, cv), cv, CliqzCalculator.selectUnitTerms(unit2[2], this.CALCULATOR_RES, cvRaw)].join(' ');
            num = num.toLocaleString(CliqzUtils.getLocalizedString('locale_lang_code'));
            num = replaceAll(num, this.thousandsSeparator, ' '); // Use spaces as thousands separators
            this.CLEANED_QUERY = [num, unit1].join(' ');

            return true;
          }
          return false;
        },

        isCalculatorSearch(q) {
          // filter out:
          // + too short query (avoid answering e, pi)
          // + automatically convert queries like '10cm
          if (this.isConverterSearch(q)) {
            return true;
          }
          const tmp = this.clean(q);
          // Don't trigger if query contains no operator
          if (tmp.length <= 2 || tmp.length > 150 || !/\+|-|\*|\/|\^/.test(tmp)) {
            return false;
          }

          try {
            this.CALCULATOR_RES = math.eval(tmp);

            if (typeof this.CALCULATOR_RES === 'number') {
              this.IS_UNIT_CONVERTER = false;
              return true;
            }
          } catch (err) {
            return false;
          }
          return false;
        }
      };

      /*
       * This module handles the search engines present in the browser
       * and provides a series of custom results
       *
       */

      // INIT_KEY ('newProvidersAdded') was used only as a boolean but now we have multiple states
      // state 1 -> Google images & Google maps
      // state 2 -> YouTube engine is added
      // state 3 -> Aliases (shortcuts) are updated:
      //  - to first 2 letters for default engines
      //  - to key property for NonDefaultProviders
      // state 4 -> Ecosia engine is added

      var INIT_KEY = 'newProvidersAdded';
      var LOG_KEY = 'NonDefaultProviders.jsm';
      var KEY = '#';
      var CUSTOM = {
        '#fee': {
          url: 'https://cliqz.com/support/'
        },
        '#team': {
          url: 'https://cliqz.com/team/'
        },
        '#cliqz': {
          url: 'https://cliqz.com/'
        },
        '#join': {
          url: 'https://cliqz.com/jobs/'
        }
      };
      var ENGINE_CODES = ['google images', 'google maps', 'google', 'yahoo', 'bing', 'wikipedia', 'amazon', 'ebay', 'leo', 'youtube', 'ecosia'];

      // REFS:
      // http://stenevang.wordpress.com/2013/02/22/google-search-url-request-parameters/
      // https://developers.google.com/custom-search/docs/xml_results#hlsp

      const SEARCH_ENGINE_ALIAS = {
        YouTube: '#yt',
        'Google Images': '#gi',
        'Google Maps': '#gm'
      };

      class CliqzResultProviders {
        constructor() {
          console$1.log('CliqzResultProviders initialized', LOG_KEY);
          this.manageProviders();
          CliqzCalculator.init();
        }
        manageProviders() {
          if (CliqzUtils.getPref('restoredDefaultSearchEnginesOnce', false) == false && CliqzUtils.restoreHiddenSearchEngines) {
            CliqzUtils.restoreHiddenSearchEngines();
            CliqzUtils.setPref('restoredDefaultSearchEnginesOnce', true);
          }

          var newProviderAdded = this.addCustomProviders();

          if (newProviderAdded) {
            this.updateEngineAliases();
          }
        }
        addCustomProviders() {
          var providersAddedState,
              maxState = -1,
              newProviderIsAdded = false;

          if (typeof CliqzUtils.getPref(INIT_KEY) === "boolean") {
            providersAddedState = 1;
          } else {
            providersAddedState = CliqzUtils.getPref(INIT_KEY, 0);
          }

          const lang = CliqzUtils.getLanguageFromLocale(CliqzUtils.getPref('general.useragent.locale', 'en', ''));

          // we only add non default search providers for the languages we support
          (NonDefaultProviders[lang] || []).forEach(function (extern) {
            try {
              if (providersAddedState < extern.state) {
                maxState = extern.state > maxState ? extern.state : maxState;
                const existedEngine = CliqzUtils.getEngineByName(extern.name);
                if (!existedEngine) {
                  console$1.log('Added ' + extern.name, LOG_KEY);
                  CliqzUtils.addEngineWithDetails(extern);
                } else {
                  // Keep the current alias just in case user has changed it
                  if (!extern.overrideAlias && existedEngine.alias) {
                    extern.key = existedEngine.alias;
                  }
                  CliqzUtils.removeEngine(extern.name);
                  console$1.log('Updated ' + extern.name, LOG_KEY);
                  CliqzUtils.addEngineWithDetails(extern);
                }
              }
            } catch (e) {
              console$1.log(e, 'err' + LOG_KEY);
            }
          });

          if (maxState > 0) {
            CliqzUtils.setPref(INIT_KEY, maxState);
            newProviderIsAdded = true;
          }

          return newProviderIsAdded;
        }
        updateEngineAliases() {
          this.getSearchEngines().forEach(function (engine) {
            var alias = engine.alias;
            if (!alias) {
              alias = this.createShortcut(engine.name);
            }
            this.updateAlias(engine.name, alias);
          }.bind(this));
        }
        updateAlias(name, newAlias) {
          CliqzUtils.updateAlias(name, newAlias);
          console$1.log("Alias of engine  " + name + " was updated to " + newAlias, LOG_KEY);
        }
        getCustomResults(q) {
          var results = null;
          var customQuery = this.customizeQuery(q);

          if (customQuery) {
            results = [Result.generic(Result.CLIQZC + ' sources-' + customQuery.code, customQuery.queryURI, q, customQuery.updatedQ, customQuery.queryURI, null, {
              extra: {
                q: customQuery.updatedQ,
                engine: customQuery.engineName
              },
              template: 'custom'
            })];
            q = customQuery.updatedQ;
          } else if (CliqzCalculator.isCalculatorSearch(q)) {
            var calcRes = CliqzCalculator.calculate(q);
            if (calcRes != null) {
              results = [calcRes];
            }
          }
          return [q, results];
        }
        getEngineCode(engineName) {
          for (var c in ENGINE_CODES) {
            if (engineName.toLowerCase().indexOf(ENGINE_CODES[c]) != -1) {
              return +c + 1;
            }
          }
          // unknown engine
          return 0;
        }
        setCurrentSearchEngine(engine) {
          const searchEngine = this.getEngineByName(engine);
          setSearchEngine(searchEngine);
        }
        // called for each query
        customizeQuery(q) {
          if (CUSTOM[q.trim()] && CUSTOM[q.trim()].url) {
            return {
              updatedQ: q,
              engineName: 'Cliqz',
              queryURI: CUSTOM[q.trim()].url,
              code: '#'
            };
          }
          //a prefix has min 3 chars
          if (q.length < 4) return false;

          var components = q.split(' ');

          if (components.length < 2) return false;

          var start = components[0],
              end = components[components.length - 1],
              engineName,
              uq;

          if (this.getEngineByAlias(start)) {
            engineName = this.getEngineByAlias(start).name;
            uq = q.substring(start.length + 1);
          } else if (this.getEngineByAlias(end)) {
            engineName = this.getEngineByAlias(end).name;
            uq = q.substring(0, q.length - end.length - 1);
          }

          if (engineName) {
            return {
              updatedQ: uq,
              engineName: engineName,
              queryURI: this.getSubmissionByEngineName(engineName, uq),
              code: this.getEngineCode(engineName)
            };
          } else {
            return null;
          }
        }
        getEngineByName(engine) {
          return CliqzUtils.getEngineByName(engine);
        }
        getEngineByAlias(alias) {
          return CliqzUtils.getEngineByAlias(alias);
        }
        getSubmissionByEngineName(name, query) {
          var engine = this.getSearchEngines().find(engine => engine.name === name);
          if (engine) {
            return engine.getSubmissionForQuery(query);
          }
        }
        // create a unique shortcut -> first 2 lowercased letters
        createShortcut(name) {
          if (SEARCH_ENGINE_ALIAS[name]) {
            return SEARCH_ENGINE_ALIAS[name];
          }

          return KEY + name.substring(0, 2).toLowerCase();
        }
        getSearchEngines() {
          return CliqzUtils.getSearchEngines().map(function (e) {
            e.code = this.getEngineCode(e.name);
            return e;
          }.bind(this));
        }
      }

      // TODO: create language/location aware customization
      var NonDefaultProviders = {
        'de': [{
          key: "#gi",
          url: "https://www.google.de/search?tbm=isch&q={searchTerms}&hl=de",
          name: "Google Images",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5QjI3QkY3REM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5QjI3QkY3RUM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdCQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjdDQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Wi2PvQAABaNJREFUWMPtV0uMFFUUPa+qunt+PcBAT/f8+DiJGhfOxkRg8BOM0ZWy0GBQoxsTo8YdK9euWJOw0rjxG0QEo25cQJgBFiABkQHmF5jpQWaanu5pmJnues9776uqrgJky0IKKtX1qt67955z7nk1yhiDh3k4eMjHowQeegLemTNn+PohiXEvna7W2tB/sDjtqcH3msVq+Grv6SWwfDVfg3ftPC3vRvNja/G79EzRmE/3+2j0gEfjryuF/YwGL3j/nrBPzP2GHzzwoGM/v+65rvOGQ0eYpe9r1E1dquXDb22FhoKq1WjMpxEVS6ZZuSAhqARo/Vc+JkH/Z97Y5StaEQQ8R2sfbW1tKOS7YWhM0xtrj/8Bp3wLpR07oVNpCuJLciagJJPJoJWSTKdSlJvB6modtdptOmuo+z4cpWIY3nP43sxsUQe1CF++35DJW554HKm5InKHv4W7tISVXDfKzwxDLVXhU6UZCti1voshxM35ecxcv07jPrrWdSFf6Ibr5FGcu4FyefE+gSNKjee4TpCaEVA44xv/3ET/xo1ws52oPjWEVGkByz0DUKsrEry9vQ35XA4X/rqII0d/weTkJFW+KvRkMmkUCj14aeeLGB7ehjZCZ6ZYjEFgYmgYeERYM68AWsWPCQntepjd84EoW/hdWUFrSwbdFPznI0fx/Q8HQfJBS0sLWok6RzmyaJECfvHlV7j49yW8/967WL/SJWikvEQ424ZGR3KKMhNh0Q/qSRJGQ54r4pOiIdedw7Fjx/H1N9+hszMLz0uJLjk4a4lPjwKxLkZHT4mm3t7zFqanr8m6KaLOb/hNJVJnyj/LSNDfGol+JnUK9B3t7aiUKzj44yGioR2um5KAruPK1XFUkIRNZs2aTpwYGcHVq+PYvGkAExMT0i2MWlitI0ahw1aylUs6Fgp5K2yrbEc7zv55DvPzJaTTaSgKGFbOi3LgZhKUGAmUg4yePEW6yMvaly9fkeJ4LhftSEBjg9ge1pZzk+xxCUYLTk1NwfVcG4yDUzFhQNtxNqHwYMhnZ2apu6hDutbhVrmM8YlJQZqTdnQEtZZAgn9gn3FLZaL5ukQt6XK1jg2oYtzb4DZwOMZB7iwvo9GoI0UFuCTsSqWC8ckpScpjfhPdyV6ggqoDQSLwfKEhmxVmFJKVNxFQ0RxrcEYEyWJtNKyJufSbCxkbu8IIGCRPRE4XPznbBp2bt2xmohIw23RiwSNEQEEb6O/rFdTKlUVY3zFCX71ehxMPEoqumQCiKyNQrVQxNPQ0chtyMtkGUff4nIr5ClOwdeuzmF9YwOJihe7dyAeFolD9JhCb9rnlQg3oGApAeXGROiGLXbtewwqZkhUnomrFxGLIVKtVDG/fhifJ1s+eOx88R8IVvZAvk9isQkQQdQLfNOo+OVoRO8hiGY3Dh48QEg1ywkykB36fx1bJtrny3bvfxPkLFzFFRpROp4DEXkpOmNijTGBAGrEPCG3HYbmtVGu4dn0Wr77yMgYHH8Ovv/1OrTktATln9ofengKef+E5SnQ7aLfFyMnT4o5oWktEtcfbJ2IZsU0ODPSLifBvE5pScOXNqkxclkolCfTpJx9hYaEkHHPCa9etpb1ig2jk2PETtB+MiX+wQSV3QouD11PIR6RxF/BOV+jOS8s0PSDcPG0JrlipK7xyoIH+PnR0dAgFrJNLl8YwMzuH2u078p0g1KAp9CYARnmDg4Mqrl6GPAyeCBxHQlux9ff1EbfTGBk9bW0XlkJeiPuet+ZQT1GDBav6thVdomD1EI28Q4OOXcAaSjNw0IqRSJr3mnp8E303cGsVi3PScoFtIZb3Xd9iRrqMqNRE4eesjJ9ouY9pfC/9dmV5c1cCYeBARaEu2M/5G7Kvt0c+SFgH0U4X03vUUXaecpXr9/b17OvMdhxQj/42/N8n8C+AMxJgeLQzoQAAAABJRU5ErkJggg==",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#gm",
          url: "https://www.google.de/maps?q={searchTerms}",
          name: "Google Maps",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OUZEQTFEMkM5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OUZEQTFEM0M5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdGQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjgwQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+UK0L7QAAB3lJREFUWMOtlXtQU2cah09n9q/dmZ3Z2ZlOd8Z6adWgVFvd2R2sUJJoQoBIMTMoIpcqCcUdXWtbrbuibmt11XV3tlOrVbmEiIi3AoEEAwih4gVvRSyFXBF07BpuOYFcICG//c6BQHKgip3+8ZszyTnzPc/7fu93DrXkmy3UsvocipefSYUVZk0781RZ1JI8BWVMSqSeJkgoW0YyZYzl/9oUL1xnihMWGeMEN42xggemuBVXTO+K9ptWCxebZasocp/qSBBTfoWCAkBRv4xADPUkRSY2SvjNBIpJkfCZ65BplfgoEfvtLyawlAiYicDjuJXphli+d0o4R4Q8pycCv4Mia0ygdAv1dsNuRuAlsvC0wyOZU5RNncleveyxiO/hwsxj4f5vIBJWqeiCN2vjS6zA4pJNYYsubP4mrFB+M0ylmHZ4JK8XZV07mxlv6xJFh0CscUK0xgnwIJaBCYmIkNMJIrc+RswKLFTJG3jKTISp5ON5XfkeZhek4zVy5alC7wXy2hkFxF+mo43AzJKJxS3kt1q0HPv/tBj7l4ZDJfwjvo/nh3aDeT5eWMwKkMX6AovOK9zIgqPOf4TV5f+A4OIOVmY++Z8rMPNsFrL2JePxyonqraTSq5J38Pe3wpETzsPuN8LwyUIelPylsEiF3O0wBAR6mAXnEkj46SycuqdBX38fRgaHMGB34GKrHm+e2cTKcQU+zkkKEeiIF+KSIAI7CXTvogVscsLDcDhiEdqkfJhCBbrHBXhMS0mlRS01gMuLguYqZOr+jWN3ynH8rpoFzi/MnCSw6dO1oR0g7W+MjUTOm6PgPW8swCcLeDgeucRvDu4Aec4gjrKMC8wpyEBC+V54B9344vYlvJKbjBl5qZiVnw7mHlM9dxbmkBmQ/jeNrSpkBkgXSsV/xmdLF2IPEflPxFv+JonAZwkaRIMoCtYN6yrGBV7NT8XOhlx4HE7Elu7Cy6fW4mP9CbQ9saKpsxXXOlqwXvtPdj4CAvNPy7GAXC+nSNAp4o8vbhqTaJZGo0kahfZ4gZ8ZzJCjuDISj7I3ZowLzMxPw1+vHIXfOYRU7UH8/mQSNlw+wm6JzngL8ACba78EIxoQYOAziskg7l3r71oZ7Z/8HhCCqdo01bsglm80x0T+ZlxgrnIDIkq24knPU9zu/AER57biD7nr2Lm4RIaQttvJidjOnoiAwNxCMjcqhbfkRmqfbYtopF3Ax3PfhAw8Jho/pifLerM3UiGnYBZpb3bNF3A5BvG/XhvqzHdhffqIdGUY+66dZu8Hw+coFd7zN9b34Mc1Xk+DDEYpWVz8HAEC75SKzo18uI3CrpxQAVaCDJ1M/RkutNbjXlc7tIab7FYwgxgYQhZeyFRO4J1JXljWAE+SYT8ZB6Mg6pnfgfaY6M6+dWtewfvvU365fLIAk9kExswEsy3M0DGV88b2fBQu9569PgH3MwIPZRg0ZLoeZKUMmVZETgk3id/B1SOHlHUlZ6lvi8+wmVIgEO6xY+CzlXJv8bXUHjwMglsT4Taku/T1Jfaq08Uj7QlimGJCvw3mFW/jzrbNqKipza+srqYqdTo2zxSYDFd4ixh4cOWWRLiMcle9TmUvU+ugrqnB9X17CXD5xLEklbclSnD5XAkqL+sKtFotFci0BOYR+Cylwqdq5MDNUvge7UGv7ZH7Sl2jvbysDBVaLTTl5WhNlhFw1Fj1y3H9092snEajeTEBFl6g8Cm5cEsCfF27yPHsxgD5ZvT09Ljq6+tZCXVNLRoP7GPBphhSvSwOVRcvoqKq6sUEGPhMpdxX0JjaGwLvSMCQdavH6bB5aYcbNG3H4OAgK1FXV2cvrahA1YXzpO2xsJAP060d26CurkZlZeX0BVg4qTzvKmfgHibC3pbh3prb2nvu+lCfz0N7HTRNJOhgCbpUo8V3f1EQgWW4cuJrqHW66QsE4Lmj8OFguMOQ4f7gVEt/1OfDEB2kfWW3HL1EwseVqGlstH+7ZxcMq8Sj7SezMS0BBv5qgWLk5FXOnrPwdPcHuS19/APDfum/aEgO0YyEt3wKCZuddjad+tpxf827qGTgGs3zBcbgvhMN7J4Pc+Ef5t5n4fEEHggjISYS6tujEvSYxIDLhX6rxdN07KizjMwEA3+mQKDy4/q0Xm7bBwxp7o/ymgncGwIPlog5RHsruRJOJ5729ztra2vpMnI6flJgfqG8d0aBwn+sgYUPwToBHzSmerbn3ftJOEdiWHPH0TsSJMFuh83GSpST98OUAgTefVSf5mDhQZU7janu7fnPhwcSM9YJ7d3QTgRJjKjVaiWRoAJhBb7Sp5kI3BdcOYF7duTfnTacK1F1b0qJEb1e/5WOfAOqyfeACSuAjqTuicpXw2lK8ewsuNMXvf/F4MESksP0sO47R1/ITAwMoL+/P5+IUN3d3WxGBSxrG/xm5g0nY+D+vylvO0nl+DnwcYmDNGIP06hudgx63aMCTJxOp8Lj8VCBjApYU8LIFqhdppQfdqtutEQf8D0ki3SRdP7sHKE7SSe6iIS57j79vcdJG8g2fO73+3/FQIPzfycNFDLjoYgtAAAAAElFTkSuQmCC",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#yt",
          url: "https://www.youtube.com/results?search_query={searchTerms}&gl=DE&hl=de",
          name: "YouTube",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgNkQkIDZGiCA2RzAgNkcwIDZH/CA2R/wgNkf8IDZH/CA2R/wgNkf8IDZH/CA2R2AgNkcwIDZHMCA2RhAgNkQYIDpWHCA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpWHCQ6ZzAkOmf8JDpn/CQ6Z/wkOmf8JDpb/BQhc/wgMgf8JDpn/CQ6Z/wkOmf8JDpn/CQ6Z/wkOmf8JDpn/CQ6ZzAkOnuoJDp7/CQ6e/wkOnv8JDp7/Exed/8jIy/9RU4j/Bwp0/wkOm/8JDp7/CQ6e/wkOnv8JDp7/CQ6e/wkOnuoJD6T8CQ+k/wkPpP8JD6T/CQ+k/xUbo//V1dX/1dXV/4yNrP8QFG//CA6Y/wkPpP8JD6T/CQ+k/wkPpP8JD6T8CQ+q/wkPqv8JD6r/CQ+q/wkPqv8WG6n/3d3d/93d3f/d3d3/v7/M/y0wjv8JD6r/CQ+q/wkPqv8JD6r/CQ+q/woQr/8KEK//ChCv/woQr/8KEK//Fx2v/+fn5//n5+f/5+fn/+jo6P+YmtP/ChCv/woQr/8KEK//ChCv/woQr/8KELX8ChC1/woQtf8KELX/ChC1/xgdtf/x8fH/8fHx//Ly8v+bndv/Ehi3/woQtf8KELX/ChC1/woQtf8KELX8ChG76goRu/8KEbv/ChG7/woRu/8YH77/+fn5/+/v9/9fY9H/ChG7/woRu/8KEbv/ChG7/woRu/8KEbv/ChG76goRwMwKEcD/ChHA/woRwP8KEcD/EBfB/6Ol5/8tM8n/ChHA/woRwP8KEcD/ChHA/woRwP8KEcD/ChHA/woRwMwLEcSHCxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcSHCxLICQsSyKULEsjMCxLI+QsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI0gsSyMwLEsiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAD//wAA//8AAA==',
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#ec",
          url: "https://www.ecosia.org/search?q={searchTerms}&ref=cliqz",
          name: "Ecosia",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAACMuAAAjLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8qzQBuaw3UrmsN6u5rDfruaw37bmsN+25rDfSuaw3fLmsNyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2rTokrLFGurqsNv+5rDf/uaw3/7msN/+5rDf/uaw3/7urNP/AqS7suqw2aAAAAAAAAAAAAAAAAAAAAAC/qjApkbpn4mvJlf/EqCr/uaw3/7msN/+5rDf/uaw3/7urNP+rsUj/ib5x/7qsNv+9qzKBAAAAAAAAAAC5rDcLwKkvzom9cf813Nb/lrlh/8KoLP+5rDf/uaw3/7msN//BqS3/eMSF/yXj6v+BwHv/lbli/7atO1IAAAAAuaw3bsCqL/+Rumb/K+Di/z3ZzP+dtln/vqox/7msN/+5rDf/waku/23Ikv8s4OH/ONvS/5m4Xv+7qzXZuaw3CbmsN9DBqS7/hL93/zDe3f8v393/RdbD/7OuPv+7qzX/uqw2/8WoKf99wn//Lt/e/y/e3f99wn//v6ow/7msN0+7qzT7s64+/0bWwf8y3tn/L97d/03TuP+usET/vKoz/7isOP+vr0P/XM6n/zDe3P813Nb/L97d/5O6Zf/EpymOu6s0/7OuPv8+2cv/J+Hn/1HStP+0rjz/vasy/76qMP9zxYr/NtzV/zTd1/823NX/NtzV/zLd2f9I1b//mbheqsGpLf+gtVX/bseR/3fEhv+wr0L/vaoy/7msN/+/qjD/Wc+q/yvg4/813Nb/Md7b/zfc1P833NT/Mt7a/zbc1aqHvnT6bMiT/522WP+wr0L/vqox/7msN/+5rDf/vaoy/6C1VP8/2cr/N9zT/2vJlf9hzKD/NtzU/zbc1f813NaONdzWz3HGjv9ky53/prNN/8SoKv+8qzT/uaw3/7msOP/EqCr/ecOE/0HYx/9V0K//N9vT/zXc1v823NX/NtzVTjXc120w3tz/Lt/e/0zUu/+Fv3X/rrBF/7msN/+7qzX/vaoy/6qxSf9G1sH/L9/d/zPd2P8x3tv/L9/e2C/f3Qk23NUKNtzVzDbc1v823NX/OdvQ/0nVvv+xr0H/ta07/7+qL/+7qzT/r69D/2LMoP823NX/VNGx/2TLnVEAAAAAAAAAADbc1Sc03dfgQNnJ/2bKm/862tD/pLRP/1vOqf9S0rP/ib1x/8CpL/+4rDj/qLJM/7qsNn4AAAAAAAAAAAAAAAAAAAAAM93YI0vUvLtux5H/VdGw/3DHj/9Zz6r/Xc2m/3rDgv+5rDf/u6s1672rM2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyaYjUburNaytsUbZuK056cGpLuS/qjDGuaw3gLmsNx4AAAAAAAAAAAAAAAAAAAAA+D8AAOAPAADAAwAAgAMAAIABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAACAAQAAgAMAAMAHAADgDwAA+B8AAA==',
          method: 'GET',
          overrideAlias: false,
          state: 4
        }, {
          key: "#st",
          url: "https://www.startpage.com/do/dsearch?query={searchTerms}&cat=web&pl=opensearch&language=deutsch",
          name: "Start Page",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAe9QTFRF0d3z0t701eD01eH11eP31eL21uH01+L11+H11eH02eP22Nzs16ux1oiG14iF16er2Nbm09/zr8PlydfvtMbml7DbmbLcucvo1+H02eP13OP02Y6L12FU2pOR2pWU2G9l2omEzNXsc5XNhaLTjKjXm7PdiabVb5LLqL7i3OX239fi2F1O3Kiq4O//4O384N/s4NDYz9nvcZTMoLfe3OX14un33eb2ytfu4+Pu23Zs2WZZ3qio4crR4+Pv5e/80t3xdZbOw9Hr5u355Ov45ez4rsLj6O/75tfe35CK2mZZ2VpK2mxg47q81eDydpfOxdPs6u/66O756O763+f2e5vQpbvg7PH77fX+7PL86+bu6M7S4ImA211O1szZdpnQydbt7/P77PH67vL72uPzdJbNs8bl7+vx6srM7urw8fj/8fv/6szN2ldG2MPMc5fPqb7g8vb87vL6qb7hdZbN1+Hy8eLl33Rn3nNm5aGa5qSe3W1f4oJ23t/rdpjOiqbVla7ZqL3gkq3YcZPMtcfl8/b8+Pr+9OTl6qym5I6D67Cq9uzt4+v3eJnOytftyNXrorjdpbrfztru9fj8+Pr9+vv++/3/+/7//P3/5ev2093v/////Pz+/Pz/+/z+/f3//v7/6O73eZnO1d/w+Pr88PT5zmljmAAAAAFiS0dEmpjfZxIAAAAJcEhZcwAACxMAAAsTAQCanBgAAABsSURBVBgZXcHbCoJAAEXRs/VQKaLzYv//fz0IEVloTF6QZlpL/0A5s1CMJRGiircv5BzIOZD4DL1bEtPQuiXV40DOgcO9Y+GOQ2DlAIgfdxAFPBpgOo2utYKKV6mzas/aVLerZi0K7cbmqc0Xo4UVg4tdcLcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMDctMTVUMTA6NDg6NTgrMDI6MDB+HgtZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTA3LTE1VDEwOjQ4OjU4KzAyOjAwD0Oz5QAAABF0RVh0ZXhpZjpDb2xvclNwYWNlADEPmwJJAAAAEnRFWHRleGlmOkNvbXByZXNzaW9uADaY0ectAAAAIXRFWHRleGlmOkRhdGVUaW1lADIwMTQ6MDc6MTQgMTE6Mzg6MjfrLWLNAAAAGHRFWHRleGlmOkV4aWZJbWFnZUxlbmd0aAAyNjBOcW3eAAAAF3RFWHRleGlmOkV4aWZJbWFnZVdpZHRoADI2MNPu6MwAAAATdEVYdGV4aWY6RXhpZk9mZnNldAAxNjjFzWc/AAAAHnRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdAAzMDawHZ2iAAAAJXRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aAA3Njc3u8Y0mAAAAC10RVh0ZXhpZjpTb2Z0d2FyZQBBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoOzZ19QAAAA10RVh0cmRmOkJhZwAgICAgIFuLzEsAAAASdEVYdHhtcE1NOkRlcml2ZWRGcm9tAJeoJAgAAAAASUVORK5CYII=',
          method: 'GET',
          overrideAlias: false,
          state: 6
        }],
        'en': [{
          key: "#gi",
          url: "https://www.google.com/search?tbm=isch&q={searchTerms}",
          name: "Google Images",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5QjI3QkY3REM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5QjI3QkY3RUM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdCQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjdDQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Wi2PvQAABaNJREFUWMPtV0uMFFUUPa+qunt+PcBAT/f8+DiJGhfOxkRg8BOM0ZWy0GBQoxsTo8YdK9euWJOw0rjxG0QEo25cQJgBFiABkQHmF5jpQWaanu5pmJnues9776uqrgJky0IKKtX1qt67955z7nk1yhiDh3k4eMjHowQeegLemTNn+PohiXEvna7W2tB/sDjtqcH3msVq+Grv6SWwfDVfg3ftPC3vRvNja/G79EzRmE/3+2j0gEfjryuF/YwGL3j/nrBPzP2GHzzwoGM/v+65rvOGQ0eYpe9r1E1dquXDb22FhoKq1WjMpxEVS6ZZuSAhqARo/Vc+JkH/Z97Y5StaEQQ8R2sfbW1tKOS7YWhM0xtrj/8Bp3wLpR07oVNpCuJLciagJJPJoJWSTKdSlJvB6modtdptOmuo+z4cpWIY3nP43sxsUQe1CF++35DJW554HKm5InKHv4W7tISVXDfKzwxDLVXhU6UZCti1voshxM35ecxcv07jPrrWdSFf6Ibr5FGcu4FyefE+gSNKjee4TpCaEVA44xv/3ET/xo1ws52oPjWEVGkByz0DUKsrEry9vQ35XA4X/rqII0d/weTkJFW+KvRkMmkUCj14aeeLGB7ehjZCZ6ZYjEFgYmgYeERYM68AWsWPCQntepjd84EoW/hdWUFrSwbdFPznI0fx/Q8HQfJBS0sLWok6RzmyaJECfvHlV7j49yW8/967WL/SJWikvEQ424ZGR3KKMhNh0Q/qSRJGQ54r4pOiIdedw7Fjx/H1N9+hszMLz0uJLjk4a4lPjwKxLkZHT4mm3t7zFqanr8m6KaLOb/hNJVJnyj/LSNDfGol+JnUK9B3t7aiUKzj44yGioR2um5KAruPK1XFUkIRNZs2aTpwYGcHVq+PYvGkAExMT0i2MWlitI0ahw1aylUs6Fgp5K2yrbEc7zv55DvPzJaTTaSgKGFbOi3LgZhKUGAmUg4yePEW6yMvaly9fkeJ4LhftSEBjg9ge1pZzk+xxCUYLTk1NwfVcG4yDUzFhQNtxNqHwYMhnZ2apu6hDutbhVrmM8YlJQZqTdnQEtZZAgn9gn3FLZaL5ukQt6XK1jg2oYtzb4DZwOMZB7iwvo9GoI0UFuCTsSqWC8ckpScpjfhPdyV6ggqoDQSLwfKEhmxVmFJKVNxFQ0RxrcEYEyWJtNKyJufSbCxkbu8IIGCRPRE4XPznbBp2bt2xmohIw23RiwSNEQEEb6O/rFdTKlUVY3zFCX71ehxMPEoqumQCiKyNQrVQxNPQ0chtyMtkGUff4nIr5ClOwdeuzmF9YwOJihe7dyAeFolD9JhCb9rnlQg3oGApAeXGROiGLXbtewwqZkhUnomrFxGLIVKtVDG/fhifJ1s+eOx88R8IVvZAvk9isQkQQdQLfNOo+OVoRO8hiGY3Dh48QEg1ywkykB36fx1bJtrny3bvfxPkLFzFFRpROp4DEXkpOmNijTGBAGrEPCG3HYbmtVGu4dn0Wr77yMgYHH8Ovv/1OrTktATln9ofengKef+E5SnQ7aLfFyMnT4o5oWktEtcfbJ2IZsU0ODPSLifBvE5pScOXNqkxclkolCfTpJx9hYaEkHHPCa9etpb1ig2jk2PETtB+MiX+wQSV3QouD11PIR6RxF/BOV+jOS8s0PSDcPG0JrlipK7xyoIH+PnR0dAgFrJNLl8YwMzuH2u078p0g1KAp9CYARnmDg4Mqrl6GPAyeCBxHQlux9ff1EbfTGBk9bW0XlkJeiPuet+ZQT1GDBav6thVdomD1EI28Q4OOXcAaSjNw0IqRSJr3mnp8E303cGsVi3PScoFtIZb3Xd9iRrqMqNRE4eesjJ9ouY9pfC/9dmV5c1cCYeBARaEu2M/5G7Kvt0c+SFgH0U4X03vUUXaecpXr9/b17OvMdhxQj/42/N8n8C+AMxJgeLQzoQAAAABJRU5ErkJggg==",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#gm",
          url: "https://www.google.com/maps?q={searchTerms}",
          name: "Google Maps",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OUZEQTFEMkM5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OUZEQTFEM0M5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdGQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjgwQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+UK0L7QAAB3lJREFUWMOtlXtQU2cah09n9q/dmZ3Z2ZlOd8Z6adWgVFvd2R2sUJJoQoBIMTMoIpcqCcUdXWtbrbuibmt11XV3tlOrVbmEiIi3AoEEAwih4gVvRSyFXBF07BpuOYFcICG//c6BQHKgip3+8ZszyTnzPc/7fu93DrXkmy3UsvocipefSYUVZk0781RZ1JI8BWVMSqSeJkgoW0YyZYzl/9oUL1xnihMWGeMEN42xggemuBVXTO+K9ptWCxebZasocp/qSBBTfoWCAkBRv4xADPUkRSY2SvjNBIpJkfCZ65BplfgoEfvtLyawlAiYicDjuJXphli+d0o4R4Q8pycCv4Mia0ygdAv1dsNuRuAlsvC0wyOZU5RNncleveyxiO/hwsxj4f5vIBJWqeiCN2vjS6zA4pJNYYsubP4mrFB+M0ylmHZ4JK8XZV07mxlv6xJFh0CscUK0xgnwIJaBCYmIkNMJIrc+RswKLFTJG3jKTISp5ON5XfkeZhek4zVy5alC7wXy2hkFxF+mo43AzJKJxS3kt1q0HPv/tBj7l4ZDJfwjvo/nh3aDeT5eWMwKkMX6AovOK9zIgqPOf4TV5f+A4OIOVmY++Z8rMPNsFrL2JePxyonqraTSq5J38Pe3wpETzsPuN8LwyUIelPylsEiF3O0wBAR6mAXnEkj46SycuqdBX38fRgaHMGB34GKrHm+e2cTKcQU+zkkKEeiIF+KSIAI7CXTvogVscsLDcDhiEdqkfJhCBbrHBXhMS0mlRS01gMuLguYqZOr+jWN3ynH8rpoFzi/MnCSw6dO1oR0g7W+MjUTOm6PgPW8swCcLeDgeucRvDu4Aec4gjrKMC8wpyEBC+V54B9344vYlvJKbjBl5qZiVnw7mHlM9dxbmkBmQ/jeNrSpkBkgXSsV/xmdLF2IPEflPxFv+JonAZwkaRIMoCtYN6yrGBV7NT8XOhlx4HE7Elu7Cy6fW4mP9CbQ9saKpsxXXOlqwXvtPdj4CAvNPy7GAXC+nSNAp4o8vbhqTaJZGo0kahfZ4gZ8ZzJCjuDISj7I3ZowLzMxPw1+vHIXfOYRU7UH8/mQSNlw+wm6JzngL8ACba78EIxoQYOAziskg7l3r71oZ7Z/8HhCCqdo01bsglm80x0T+ZlxgrnIDIkq24knPU9zu/AER57biD7nr2Lm4RIaQttvJidjOnoiAwNxCMjcqhbfkRmqfbYtopF3Ax3PfhAw8Jho/pifLerM3UiGnYBZpb3bNF3A5BvG/XhvqzHdhffqIdGUY+66dZu8Hw+coFd7zN9b34Mc1Xk+DDEYpWVz8HAEC75SKzo18uI3CrpxQAVaCDJ1M/RkutNbjXlc7tIab7FYwgxgYQhZeyFRO4J1JXljWAE+SYT8ZB6Mg6pnfgfaY6M6+dWtewfvvU365fLIAk9kExswEsy3M0DGV88b2fBQu9569PgH3MwIPZRg0ZLoeZKUMmVZETgk3id/B1SOHlHUlZ6lvi8+wmVIgEO6xY+CzlXJv8bXUHjwMglsT4Taku/T1Jfaq08Uj7QlimGJCvw3mFW/jzrbNqKipza+srqYqdTo2zxSYDFd4ixh4cOWWRLiMcle9TmUvU+ugrqnB9X17CXD5xLEklbclSnD5XAkqL+sKtFotFci0BOYR+Cylwqdq5MDNUvge7UGv7ZH7Sl2jvbysDBVaLTTl5WhNlhFw1Fj1y3H9092snEajeTEBFl6g8Cm5cEsCfF27yPHsxgD5ZvT09Ljq6+tZCXVNLRoP7GPBphhSvSwOVRcvoqKq6sUEGPhMpdxX0JjaGwLvSMCQdavH6bB5aYcbNG3H4OAgK1FXV2cvrahA1YXzpO2xsJAP060d26CurkZlZeX0BVg4qTzvKmfgHibC3pbh3prb2nvu+lCfz0N7HTRNJOhgCbpUo8V3f1EQgWW4cuJrqHW66QsE4Lmj8OFguMOQ4f7gVEt/1OfDEB2kfWW3HL1EwseVqGlstH+7ZxcMq8Sj7SezMS0BBv5qgWLk5FXOnrPwdPcHuS19/APDfum/aEgO0YyEt3wKCZuddjad+tpxf827qGTgGs3zBcbgvhMN7J4Pc+Ef5t5n4fEEHggjISYS6tujEvSYxIDLhX6rxdN07KizjMwEA3+mQKDy4/q0Xm7bBwxp7o/ymgncGwIPlog5RHsruRJOJ5729ztra2vpMnI6flJgfqG8d0aBwn+sgYUPwToBHzSmerbn3ftJOEdiWHPH0TsSJMFuh83GSpST98OUAgTefVSf5mDhQZU7janu7fnPhwcSM9YJ7d3QTgRJjKjVaiWRoAJhBb7Sp5kI3BdcOYF7duTfnTacK1F1b0qJEb1e/5WOfAOqyfeACSuAjqTuicpXw2lK8ewsuNMXvf/F4MESksP0sO47R1/ITAwMoL+/P5+IUN3d3WxGBSxrG/xm5g0nY+D+vylvO0nl+DnwcYmDNGIP06hudgx63aMCTJxOp8Lj8VCBjApYU8LIFqhdppQfdqtutEQf8D0ki3SRdP7sHKE7SSe6iIS57j79vcdJG8g2fO73+3/FQIPzfycNFDLjoYgtAAAAAElFTkSuQmCC",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#yt",
          url: "https://www.youtube.com/results?search_query={searchTerms}&amp;page={startPage?}&amp;utm_source=opensearch",
          name: "YouTube",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgNkQkIDZGiCA2RzAgNkcwIDZH/CA2R/wgNkf8IDZH/CA2R/wgNkf8IDZH/CA2R2AgNkcwIDZHMCA2RhAgNkQYIDpWHCA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpWHCQ6ZzAkOmf8JDpn/CQ6Z/wkOmf8JDpb/BQhc/wgMgf8JDpn/CQ6Z/wkOmf8JDpn/CQ6Z/wkOmf8JDpn/CQ6ZzAkOnuoJDp7/CQ6e/wkOnv8JDp7/Exed/8jIy/9RU4j/Bwp0/wkOm/8JDp7/CQ6e/wkOnv8JDp7/CQ6e/wkOnuoJD6T8CQ+k/wkPpP8JD6T/CQ+k/xUbo//V1dX/1dXV/4yNrP8QFG//CA6Y/wkPpP8JD6T/CQ+k/wkPpP8JD6T8CQ+q/wkPqv8JD6r/CQ+q/wkPqv8WG6n/3d3d/93d3f/d3d3/v7/M/y0wjv8JD6r/CQ+q/wkPqv8JD6r/CQ+q/woQr/8KEK//ChCv/woQr/8KEK//Fx2v/+fn5//n5+f/5+fn/+jo6P+YmtP/ChCv/woQr/8KEK//ChCv/woQr/8KELX8ChC1/woQtf8KELX/ChC1/xgdtf/x8fH/8fHx//Ly8v+bndv/Ehi3/woQtf8KELX/ChC1/woQtf8KELX8ChG76goRu/8KEbv/ChG7/woRu/8YH77/+fn5/+/v9/9fY9H/ChG7/woRu/8KEbv/ChG7/woRu/8KEbv/ChG76goRwMwKEcD/ChHA/woRwP8KEcD/EBfB/6Ol5/8tM8n/ChHA/woRwP8KEcD/ChHA/woRwP8KEcD/ChHA/woRwMwLEcSHCxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcSHCxLICQsSyKULEsjMCxLI+QsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI0gsSyMwLEsiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAD//wAA//8AAA==',
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#ec",
          url: "https://www.ecosia.org/search?q={searchTerms}&ref=cliqz",
          name: "Ecosia",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAACMuAAAjLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8qzQBuaw3UrmsN6u5rDfruaw37bmsN+25rDfSuaw3fLmsNyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2rTokrLFGurqsNv+5rDf/uaw3/7msN/+5rDf/uaw3/7urNP/AqS7suqw2aAAAAAAAAAAAAAAAAAAAAAC/qjApkbpn4mvJlf/EqCr/uaw3/7msN/+5rDf/uaw3/7urNP+rsUj/ib5x/7qsNv+9qzKBAAAAAAAAAAC5rDcLwKkvzom9cf813Nb/lrlh/8KoLP+5rDf/uaw3/7msN//BqS3/eMSF/yXj6v+BwHv/lbli/7atO1IAAAAAuaw3bsCqL/+Rumb/K+Di/z3ZzP+dtln/vqox/7msN/+5rDf/waku/23Ikv8s4OH/ONvS/5m4Xv+7qzXZuaw3CbmsN9DBqS7/hL93/zDe3f8v393/RdbD/7OuPv+7qzX/uqw2/8WoKf99wn//Lt/e/y/e3f99wn//v6ow/7msN0+7qzT7s64+/0bWwf8y3tn/L97d/03TuP+usET/vKoz/7isOP+vr0P/XM6n/zDe3P813Nb/L97d/5O6Zf/EpymOu6s0/7OuPv8+2cv/J+Hn/1HStP+0rjz/vasy/76qMP9zxYr/NtzV/zTd1/823NX/NtzV/zLd2f9I1b//mbheqsGpLf+gtVX/bseR/3fEhv+wr0L/vaoy/7msN/+/qjD/Wc+q/yvg4/813Nb/Md7b/zfc1P833NT/Mt7a/zbc1aqHvnT6bMiT/522WP+wr0L/vqox/7msN/+5rDf/vaoy/6C1VP8/2cr/N9zT/2vJlf9hzKD/NtzU/zbc1f813NaONdzWz3HGjv9ky53/prNN/8SoKv+8qzT/uaw3/7msOP/EqCr/ecOE/0HYx/9V0K//N9vT/zXc1v823NX/NtzVTjXc120w3tz/Lt/e/0zUu/+Fv3X/rrBF/7msN/+7qzX/vaoy/6qxSf9G1sH/L9/d/zPd2P8x3tv/L9/e2C/f3Qk23NUKNtzVzDbc1v823NX/OdvQ/0nVvv+xr0H/ta07/7+qL/+7qzT/r69D/2LMoP823NX/VNGx/2TLnVEAAAAAAAAAADbc1Sc03dfgQNnJ/2bKm/862tD/pLRP/1vOqf9S0rP/ib1x/8CpL/+4rDj/qLJM/7qsNn4AAAAAAAAAAAAAAAAAAAAAM93YI0vUvLtux5H/VdGw/3DHj/9Zz6r/Xc2m/3rDgv+5rDf/u6s1672rM2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyaYjUburNaytsUbZuK056cGpLuS/qjDGuaw3gLmsNx4AAAAAAAAAAAAAAAAAAAAA+D8AAOAPAADAAwAAgAMAAIABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAACAAQAAgAMAAMAHAADgDwAA+B8AAA==',
          method: 'GET',
          overrideAlias: false,
          state: 1
        }, {
          key: "#st",
          url: "https://www.startpage.com/do/dsearch?query={searchTerms}&cat=web&pl=opensearch&language=english",
          name: "Start Page",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAe9QTFRF0d3z0t701eD01eH11eP31eL21uH01+L11+H11eH02eP22Nzs16ux1oiG14iF16er2Nbm09/zr8PlydfvtMbml7DbmbLcucvo1+H02eP13OP02Y6L12FU2pOR2pWU2G9l2omEzNXsc5XNhaLTjKjXm7PdiabVb5LLqL7i3OX239fi2F1O3Kiq4O//4O384N/s4NDYz9nvcZTMoLfe3OX14un33eb2ytfu4+Pu23Zs2WZZ3qio4crR4+Pv5e/80t3xdZbOw9Hr5u355Ov45ez4rsLj6O/75tfe35CK2mZZ2VpK2mxg47q81eDydpfOxdPs6u/66O756O763+f2e5vQpbvg7PH77fX+7PL86+bu6M7S4ImA211O1szZdpnQydbt7/P77PH67vL72uPzdJbNs8bl7+vx6srM7urw8fj/8fv/6szN2ldG2MPMc5fPqb7g8vb87vL6qb7hdZbN1+Hy8eLl33Rn3nNm5aGa5qSe3W1f4oJ23t/rdpjOiqbVla7ZqL3gkq3YcZPMtcfl8/b8+Pr+9OTl6qym5I6D67Cq9uzt4+v3eJnOytftyNXrorjdpbrfztru9fj8+Pr9+vv++/3/+/7//P3/5ev2093v/////Pz+/Pz/+/z+/f3//v7/6O73eZnO1d/w+Pr88PT5zmljmAAAAAFiS0dEmpjfZxIAAAAJcEhZcwAACxMAAAsTAQCanBgAAABsSURBVBgZXcHbCoJAAEXRs/VQKaLzYv//fz0IEVloTF6QZlpL/0A5s1CMJRGiircv5BzIOZD4DL1bEtPQuiXV40DOgcO9Y+GOQ2DlAIgfdxAFPBpgOo2utYKKV6mzas/aVLerZi0K7cbmqc0Xo4UVg4tdcLcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMDctMTVUMTA6NDg6NTgrMDI6MDB+HgtZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTA3LTE1VDEwOjQ4OjU4KzAyOjAwD0Oz5QAAABF0RVh0ZXhpZjpDb2xvclNwYWNlADEPmwJJAAAAEnRFWHRleGlmOkNvbXByZXNzaW9uADaY0ectAAAAIXRFWHRleGlmOkRhdGVUaW1lADIwMTQ6MDc6MTQgMTE6Mzg6MjfrLWLNAAAAGHRFWHRleGlmOkV4aWZJbWFnZUxlbmd0aAAyNjBOcW3eAAAAF3RFWHRleGlmOkV4aWZJbWFnZVdpZHRoADI2MNPu6MwAAAATdEVYdGV4aWY6RXhpZk9mZnNldAAxNjjFzWc/AAAAHnRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdAAzMDawHZ2iAAAAJXRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aAA3Njc3u8Y0mAAAAC10RVh0ZXhpZjpTb2Z0d2FyZQBBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoOzZ19QAAAA10RVh0cmRmOkJhZwAgICAgIFuLzEsAAAASdEVYdHhtcE1NOkRlcml2ZWRGcm9tAJeoJAgAAAAASUVORK5CYII=',
          method: 'GET',
          overrideAlias: false,
          state: 6
        }],
        'fr': [{
          key: "#gi",
          url: "https://www.google.fr/search?tbm=isch&q={searchTerms}",
          name: "Google Images",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5QjI3QkY3REM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5QjI3QkY3RUM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdCQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjdDQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Wi2PvQAABaNJREFUWMPtV0uMFFUUPa+qunt+PcBAT/f8+DiJGhfOxkRg8BOM0ZWy0GBQoxsTo8YdK9euWJOw0rjxG0QEo25cQJgBFiABkQHmF5jpQWaanu5pmJnues9776uqrgJky0IKKtX1qt67955z7nk1yhiDh3k4eMjHowQeegLemTNn+PohiXEvna7W2tB/sDjtqcH3msVq+Grv6SWwfDVfg3ftPC3vRvNja/G79EzRmE/3+2j0gEfjryuF/YwGL3j/nrBPzP2GHzzwoGM/v+65rvOGQ0eYpe9r1E1dquXDb22FhoKq1WjMpxEVS6ZZuSAhqARo/Vc+JkH/Z97Y5StaEQQ8R2sfbW1tKOS7YWhM0xtrj/8Bp3wLpR07oVNpCuJLciagJJPJoJWSTKdSlJvB6modtdptOmuo+z4cpWIY3nP43sxsUQe1CF++35DJW554HKm5InKHv4W7tISVXDfKzwxDLVXhU6UZCti1voshxM35ecxcv07jPrrWdSFf6Ibr5FGcu4FyefE+gSNKjee4TpCaEVA44xv/3ET/xo1ws52oPjWEVGkByz0DUKsrEry9vQ35XA4X/rqII0d/weTkJFW+KvRkMmkUCj14aeeLGB7ehjZCZ6ZYjEFgYmgYeERYM68AWsWPCQntepjd84EoW/hdWUFrSwbdFPznI0fx/Q8HQfJBS0sLWok6RzmyaJECfvHlV7j49yW8/967WL/SJWikvEQ424ZGR3KKMhNh0Q/qSRJGQ54r4pOiIdedw7Fjx/H1N9+hszMLz0uJLjk4a4lPjwKxLkZHT4mm3t7zFqanr8m6KaLOb/hNJVJnyj/LSNDfGol+JnUK9B3t7aiUKzj44yGioR2um5KAruPK1XFUkIRNZs2aTpwYGcHVq+PYvGkAExMT0i2MWlitI0ahw1aylUs6Fgp5K2yrbEc7zv55DvPzJaTTaSgKGFbOi3LgZhKUGAmUg4yePEW6yMvaly9fkeJ4LhftSEBjg9ge1pZzk+xxCUYLTk1NwfVcG4yDUzFhQNtxNqHwYMhnZ2apu6hDutbhVrmM8YlJQZqTdnQEtZZAgn9gn3FLZaL5ukQt6XK1jg2oYtzb4DZwOMZB7iwvo9GoI0UFuCTsSqWC8ckpScpjfhPdyV6ggqoDQSLwfKEhmxVmFJKVNxFQ0RxrcEYEyWJtNKyJufSbCxkbu8IIGCRPRE4XPznbBp2bt2xmohIw23RiwSNEQEEb6O/rFdTKlUVY3zFCX71ehxMPEoqumQCiKyNQrVQxNPQ0chtyMtkGUff4nIr5ClOwdeuzmF9YwOJihe7dyAeFolD9JhCb9rnlQg3oGApAeXGROiGLXbtewwqZkhUnomrFxGLIVKtVDG/fhifJ1s+eOx88R8IVvZAvk9isQkQQdQLfNOo+OVoRO8hiGY3Dh48QEg1ywkykB36fx1bJtrny3bvfxPkLFzFFRpROp4DEXkpOmNijTGBAGrEPCG3HYbmtVGu4dn0Wr77yMgYHH8Ovv/1OrTktATln9ofengKef+E5SnQ7aLfFyMnT4o5oWktEtcfbJ2IZsU0ODPSLifBvE5pScOXNqkxclkolCfTpJx9hYaEkHHPCa9etpb1ig2jk2PETtB+MiX+wQSV3QouD11PIR6RxF/BOV+jOS8s0PSDcPG0JrlipK7xyoIH+PnR0dAgFrJNLl8YwMzuH2u078p0g1KAp9CYARnmDg4Mqrl6GPAyeCBxHQlux9ff1EbfTGBk9bW0XlkJeiPuet+ZQT1GDBav6thVdomD1EI28Q4OOXcAaSjNw0IqRSJr3mnp8E303cGsVi3PScoFtIZb3Xd9iRrqMqNRE4eesjJ9ouY9pfC/9dmV5c1cCYeBARaEu2M/5G7Kvt0c+SFgH0U4X03vUUXaecpXr9/b17OvMdhxQj/42/N8n8C+AMxJgeLQzoQAAAABJRU5ErkJggg==",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#gm",
          url: "https://www.google.fr/maps?q={searchTerms}",
          name: "Google Maps",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OUZEQTFEMkM5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OUZEQTFEM0M5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdGQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjgwQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+UK0L7QAAB3lJREFUWMOtlXtQU2cah09n9q/dmZ3Z2ZlOd8Z6adWgVFvd2R2sUJJoQoBIMTMoIpcqCcUdXWtbrbuibmt11XV3tlOrVbmEiIi3AoEEAwih4gVvRSyFXBF07BpuOYFcICG//c6BQHKgip3+8ZszyTnzPc/7fu93DrXkmy3UsvocipefSYUVZk0781RZ1JI8BWVMSqSeJkgoW0YyZYzl/9oUL1xnihMWGeMEN42xggemuBVXTO+K9ptWCxebZasocp/qSBBTfoWCAkBRv4xADPUkRSY2SvjNBIpJkfCZ65BplfgoEfvtLyawlAiYicDjuJXphli+d0o4R4Q8pycCv4Mia0ygdAv1dsNuRuAlsvC0wyOZU5RNncleveyxiO/hwsxj4f5vIBJWqeiCN2vjS6zA4pJNYYsubP4mrFB+M0ylmHZ4JK8XZV07mxlv6xJFh0CscUK0xgnwIJaBCYmIkNMJIrc+RswKLFTJG3jKTISp5ON5XfkeZhek4zVy5alC7wXy2hkFxF+mo43AzJKJxS3kt1q0HPv/tBj7l4ZDJfwjvo/nh3aDeT5eWMwKkMX6AovOK9zIgqPOf4TV5f+A4OIOVmY++Z8rMPNsFrL2JePxyonqraTSq5J38Pe3wpETzsPuN8LwyUIelPylsEiF3O0wBAR6mAXnEkj46SycuqdBX38fRgaHMGB34GKrHm+e2cTKcQU+zkkKEeiIF+KSIAI7CXTvogVscsLDcDhiEdqkfJhCBbrHBXhMS0mlRS01gMuLguYqZOr+jWN3ynH8rpoFzi/MnCSw6dO1oR0g7W+MjUTOm6PgPW8swCcLeDgeucRvDu4Aec4gjrKMC8wpyEBC+V54B9344vYlvJKbjBl5qZiVnw7mHlM9dxbmkBmQ/jeNrSpkBkgXSsV/xmdLF2IPEflPxFv+JonAZwkaRIMoCtYN6yrGBV7NT8XOhlx4HE7Elu7Cy6fW4mP9CbQ9saKpsxXXOlqwXvtPdj4CAvNPy7GAXC+nSNAp4o8vbhqTaJZGo0kahfZ4gZ8ZzJCjuDISj7I3ZowLzMxPw1+vHIXfOYRU7UH8/mQSNlw+wm6JzngL8ACba78EIxoQYOAziskg7l3r71oZ7Z/8HhCCqdo01bsglm80x0T+ZlxgrnIDIkq24knPU9zu/AER57biD7nr2Lm4RIaQttvJidjOnoiAwNxCMjcqhbfkRmqfbYtopF3Ax3PfhAw8Jho/pifLerM3UiGnYBZpb3bNF3A5BvG/XhvqzHdhffqIdGUY+66dZu8Hw+coFd7zN9b34Mc1Xk+DDEYpWVz8HAEC75SKzo18uI3CrpxQAVaCDJ1M/RkutNbjXlc7tIab7FYwgxgYQhZeyFRO4J1JXljWAE+SYT8ZB6Mg6pnfgfaY6M6+dWtewfvvU365fLIAk9kExswEsy3M0DGV88b2fBQu9569PgH3MwIPZRg0ZLoeZKUMmVZETgk3id/B1SOHlHUlZ6lvi8+wmVIgEO6xY+CzlXJv8bXUHjwMglsT4Taku/T1Jfaq08Uj7QlimGJCvw3mFW/jzrbNqKipza+srqYqdTo2zxSYDFd4ixh4cOWWRLiMcle9TmUvU+ugrqnB9X17CXD5xLEklbclSnD5XAkqL+sKtFotFci0BOYR+Cylwqdq5MDNUvge7UGv7ZH7Sl2jvbysDBVaLTTl5WhNlhFw1Fj1y3H9092snEajeTEBFl6g8Cm5cEsCfF27yPHsxgD5ZvT09Ljq6+tZCXVNLRoP7GPBphhSvSwOVRcvoqKq6sUEGPhMpdxX0JjaGwLvSMCQdavH6bB5aYcbNG3H4OAgK1FXV2cvrahA1YXzpO2xsJAP060d26CurkZlZeX0BVg4qTzvKmfgHibC3pbh3prb2nvu+lCfz0N7HTRNJOhgCbpUo8V3f1EQgWW4cuJrqHW66QsE4Lmj8OFguMOQ4f7gVEt/1OfDEB2kfWW3HL1EwseVqGlstH+7ZxcMq8Sj7SezMS0BBv5qgWLk5FXOnrPwdPcHuS19/APDfum/aEgO0YyEt3wKCZuddjad+tpxf827qGTgGs3zBcbgvhMN7J4Pc+Ef5t5n4fEEHggjISYS6tujEvSYxIDLhX6rxdN07KizjMwEA3+mQKDy4/q0Xm7bBwxp7o/ymgncGwIPlog5RHsruRJOJ5729ztra2vpMnI6flJgfqG8d0aBwn+sgYUPwToBHzSmerbn3ftJOEdiWHPH0TsSJMFuh83GSpST98OUAgTefVSf5mDhQZU7janu7fnPhwcSM9YJ7d3QTgRJjKjVaiWRoAJhBb7Sp5kI3BdcOYF7duTfnTacK1F1b0qJEb1e/5WOfAOqyfeACSuAjqTuicpXw2lK8ewsuNMXvf/F4MESksP0sO47R1/ITAwMoL+/P5+IUN3d3WxGBSxrG/xm5g0nY+D+vylvO0nl+DnwcYmDNGIP06hudgx63aMCTJxOp8Lj8VCBjApYU8LIFqhdppQfdqtutEQf8D0ki3SRdP7sHKE7SSe6iIS57j79vcdJG8g2fO73+3/FQIPzfycNFDLjoYgtAAAAAElFTkSuQmCC",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#yt",
          url: "https://www.youtube.com/results?search_query={searchTerms}&gl=FR&hl=fr",
          name: "YouTube",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgNkQkIDZGiCA2RzAgNkcwIDZH/CA2R/wgNkf8IDZH/CA2R/wgNkf8IDZH/CA2R2AgNkcwIDZHMCA2RhAgNkQYIDpWHCA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpWHCQ6ZzAkOmf8JDpn/CQ6Z/wkOmf8JDpb/BQhc/wgMgf8JDpn/CQ6Z/wkOmf8JDpn/CQ6Z/wkOmf8JDpn/CQ6ZzAkOnuoJDp7/CQ6e/wkOnv8JDp7/Exed/8jIy/9RU4j/Bwp0/wkOm/8JDp7/CQ6e/wkOnv8JDp7/CQ6e/wkOnuoJD6T8CQ+k/wkPpP8JD6T/CQ+k/xUbo//V1dX/1dXV/4yNrP8QFG//CA6Y/wkPpP8JD6T/CQ+k/wkPpP8JD6T8CQ+q/wkPqv8JD6r/CQ+q/wkPqv8WG6n/3d3d/93d3f/d3d3/v7/M/y0wjv8JD6r/CQ+q/wkPqv8JD6r/CQ+q/woQr/8KEK//ChCv/woQr/8KEK//Fx2v/+fn5//n5+f/5+fn/+jo6P+YmtP/ChCv/woQr/8KEK//ChCv/woQr/8KELX8ChC1/woQtf8KELX/ChC1/xgdtf/x8fH/8fHx//Ly8v+bndv/Ehi3/woQtf8KELX/ChC1/woQtf8KELX8ChG76goRu/8KEbv/ChG7/woRu/8YH77/+fn5/+/v9/9fY9H/ChG7/woRu/8KEbv/ChG7/woRu/8KEbv/ChG76goRwMwKEcD/ChHA/woRwP8KEcD/EBfB/6Ol5/8tM8n/ChHA/woRwP8KEcD/ChHA/woRwP8KEcD/ChHA/woRwMwLEcSHCxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcSHCxLICQsSyKULEsjMCxLI+QsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI0gsSyMwLEsiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAD//wAA//8AAA==',
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#ec",
          url: "https://www.ecosia.org/search?q={searchTerms}&ref=cliqz",
          name: "Ecosia",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAACMuAAAjLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8qzQBuaw3UrmsN6u5rDfruaw37bmsN+25rDfSuaw3fLmsNyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2rTokrLFGurqsNv+5rDf/uaw3/7msN/+5rDf/uaw3/7urNP/AqS7suqw2aAAAAAAAAAAAAAAAAAAAAAC/qjApkbpn4mvJlf/EqCr/uaw3/7msN/+5rDf/uaw3/7urNP+rsUj/ib5x/7qsNv+9qzKBAAAAAAAAAAC5rDcLwKkvzom9cf813Nb/lrlh/8KoLP+5rDf/uaw3/7msN//BqS3/eMSF/yXj6v+BwHv/lbli/7atO1IAAAAAuaw3bsCqL/+Rumb/K+Di/z3ZzP+dtln/vqox/7msN/+5rDf/waku/23Ikv8s4OH/ONvS/5m4Xv+7qzXZuaw3CbmsN9DBqS7/hL93/zDe3f8v393/RdbD/7OuPv+7qzX/uqw2/8WoKf99wn//Lt/e/y/e3f99wn//v6ow/7msN0+7qzT7s64+/0bWwf8y3tn/L97d/03TuP+usET/vKoz/7isOP+vr0P/XM6n/zDe3P813Nb/L97d/5O6Zf/EpymOu6s0/7OuPv8+2cv/J+Hn/1HStP+0rjz/vasy/76qMP9zxYr/NtzV/zTd1/823NX/NtzV/zLd2f9I1b//mbheqsGpLf+gtVX/bseR/3fEhv+wr0L/vaoy/7msN/+/qjD/Wc+q/yvg4/813Nb/Md7b/zfc1P833NT/Mt7a/zbc1aqHvnT6bMiT/522WP+wr0L/vqox/7msN/+5rDf/vaoy/6C1VP8/2cr/N9zT/2vJlf9hzKD/NtzU/zbc1f813NaONdzWz3HGjv9ky53/prNN/8SoKv+8qzT/uaw3/7msOP/EqCr/ecOE/0HYx/9V0K//N9vT/zXc1v823NX/NtzVTjXc120w3tz/Lt/e/0zUu/+Fv3X/rrBF/7msN/+7qzX/vaoy/6qxSf9G1sH/L9/d/zPd2P8x3tv/L9/e2C/f3Qk23NUKNtzVzDbc1v823NX/OdvQ/0nVvv+xr0H/ta07/7+qL/+7qzT/r69D/2LMoP823NX/VNGx/2TLnVEAAAAAAAAAADbc1Sc03dfgQNnJ/2bKm/862tD/pLRP/1vOqf9S0rP/ib1x/8CpL/+4rDj/qLJM/7qsNn4AAAAAAAAAAAAAAAAAAAAAM93YI0vUvLtux5H/VdGw/3DHj/9Zz6r/Xc2m/3rDgv+5rDf/u6s1672rM2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyaYjUburNaytsUbZuK056cGpLuS/qjDGuaw3gLmsNx4AAAAAAAAAAAAAAAAAAAAA+D8AAOAPAADAAwAAgAMAAIABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAACAAQAAgAMAAMAHAADgDwAA+B8AAA==',
          method: 'GET',
          overrideAlias: false,
          state: 1
        }, {
          key: "#st",
          url: "https://www.startpage.com/do/dsearch?query={searchTerms}&cat=web&pl=opensearch&language=francais",
          name: "Start Page",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAe9QTFRF0d3z0t701eD01eH11eP31eL21uH01+L11+H11eH02eP22Nzs16ux1oiG14iF16er2Nbm09/zr8PlydfvtMbml7DbmbLcucvo1+H02eP13OP02Y6L12FU2pOR2pWU2G9l2omEzNXsc5XNhaLTjKjXm7PdiabVb5LLqL7i3OX239fi2F1O3Kiq4O//4O384N/s4NDYz9nvcZTMoLfe3OX14un33eb2ytfu4+Pu23Zs2WZZ3qio4crR4+Pv5e/80t3xdZbOw9Hr5u355Ov45ez4rsLj6O/75tfe35CK2mZZ2VpK2mxg47q81eDydpfOxdPs6u/66O756O763+f2e5vQpbvg7PH77fX+7PL86+bu6M7S4ImA211O1szZdpnQydbt7/P77PH67vL72uPzdJbNs8bl7+vx6srM7urw8fj/8fv/6szN2ldG2MPMc5fPqb7g8vb87vL6qb7hdZbN1+Hy8eLl33Rn3nNm5aGa5qSe3W1f4oJ23t/rdpjOiqbVla7ZqL3gkq3YcZPMtcfl8/b8+Pr+9OTl6qym5I6D67Cq9uzt4+v3eJnOytftyNXrorjdpbrfztru9fj8+Pr9+vv++/3/+/7//P3/5ev2093v/////Pz+/Pz/+/z+/f3//v7/6O73eZnO1d/w+Pr88PT5zmljmAAAAAFiS0dEmpjfZxIAAAAJcEhZcwAACxMAAAsTAQCanBgAAABsSURBVBgZXcHbCoJAAEXRs/VQKaLzYv//fz0IEVloTF6QZlpL/0A5s1CMJRGiircv5BzIOZD4DL1bEtPQuiXV40DOgcO9Y+GOQ2DlAIgfdxAFPBpgOo2utYKKV6mzas/aVLerZi0K7cbmqc0Xo4UVg4tdcLcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMDctMTVUMTA6NDg6NTgrMDI6MDB+HgtZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTA3LTE1VDEwOjQ4OjU4KzAyOjAwD0Oz5QAAABF0RVh0ZXhpZjpDb2xvclNwYWNlADEPmwJJAAAAEnRFWHRleGlmOkNvbXByZXNzaW9uADaY0ectAAAAIXRFWHRleGlmOkRhdGVUaW1lADIwMTQ6MDc6MTQgMTE6Mzg6MjfrLWLNAAAAGHRFWHRleGlmOkV4aWZJbWFnZUxlbmd0aAAyNjBOcW3eAAAAF3RFWHRleGlmOkV4aWZJbWFnZVdpZHRoADI2MNPu6MwAAAATdEVYdGV4aWY6RXhpZk9mZnNldAAxNjjFzWc/AAAAHnRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdAAzMDawHZ2iAAAAJXRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aAA3Njc3u8Y0mAAAAC10RVh0ZXhpZjpTb2Z0d2FyZQBBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoOzZ19QAAAA10RVh0cmRmOkJhZwAgICAgIFuLzEsAAAASdEVYdHhtcE1NOkRlcml2ZWRGcm9tAJeoJAgAAAAASUVORK5CYII=',
          method: 'GET',
          overrideAlias: false,
          state: 6
        }, {
          key: "#qw",
          url: "https://www.qwant.com/?q={searchTerms}",
          name: "Qwant",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAKdlJREFUeNrtnXmUXFd54H/33vde7VW9t9RSa7ElLBnj3diGgAljdgiBAMEnYGaGMENyDgkkkBC2MOfMJCHDQDLkECDbJGGJ4ZATcAhgHGyzxCzGm7C8SrJ2ufeu9a33zh/vdXf1vrfUUn065XZXV72qd9/vfdv97neFMeYMkKMlLVm+1CygCGRaY9GSFYiSQNQah5asUCLZGoOWrEZaALWkBVBLWgC1pAVQS1oAtaQlLYBaspFiXVinq4EGhhqYEKhhGAAziuEMEAIRmNMY6sn9JRB0gOgCfAR5oAchOoE+hFAYMkAGQaoF0PkrLsacxnAYY54C8wyGBlAB6mDGMWjAAGWa86uGDMLkMEQIHBAFMDkEJYQoEpmL0ezEkjtRouuCAkgYYypA/vw7tVoMjHkcwwGMOQqUMWYUqK3dAAKNyKEadSBFO0q048hLcNSzseVulGgH1PnKT/W8AsiERzDRIYw6jJEHQQxg9FiiYcza332AEIZx36EaKZSY+gwpSkjRhi0vIq2uwZZ7seXO883tPA8AMg2M91OM90OMexfajIJywbHAtkFZYDkgJBidvMesHUDAsO/gajkNoGmvExkkJdLqKhx1OSl1OUp0twA6u+DU0LWvYtx7MMFB0COAxkw6ywKkwCgbbAssG+wUwrJByhiiVYIkhCHQkrHAJjRiSbpFiAy22EFKXUPWejGW3NECaGMDqTKmdhumcQc6eBxMY0odJC4wItEyAowR8e9SgLIwSoKykbYDTgqEmtJMy82BCEM9tCiHFmbqKyxRFJbsxZHPIWe/Bkc+qwXQupuq2u2Y6j9iwkNAgJlpT5oBSn6aiV8mnjMGIwClQKrYxNmpGCgpl4WBBMqhRSW05jVfSwOxRFpdR95+A7bctZn8pE0AkPEw7r2Y8mfBfxBjwknnY0UAQQwQzceIzZ2QFiKVQlgOCCvWWpMX08zyfwwwHtjUZzjQqwEpZ72anP1ylOhtAbRKcsB/HFP5AqZ6GyQXyDR5r2sGkJh5HIFQKvaZpA2WjRAy1ljJSyQQGBgLLPxIIcXaRXmW3E7BfjMZ9QsIkW0BtHw/pwa1f0WXPwPhibkBWUeA4ufM5AcI20IqB2nZCGWBdJBS4oaC8dBBG7MeWQIy1gvJ22/CkXuX7WFduAAFhzHjn4Hqv2Ca7+oNBAgRu0MisVMagzbxIzA2tdDGNwqcPCqdwxYgMAgEkTGsJUuW2ErefgNZ62aEyLQAWlAaP8SMfAyCR6df6HUGSMjY3ZFJwBaaeCIjMuAFUAuh5kM9AC8w+H6AJx1kezupdIqckhQcRc6SSARSCoyBaM3UkiRrvZSi8xaU6GkBNNvdCaDyFczYX0A0OAXDOgGEjJcTiASYwMSwBBG4UQxLxYvBCSIIdfz3SMdRnJRAsYjOpImiCInEloKUJSg5FjnbIiUFlpQIQaK9VjdENhE5tR9lv4u0uuScAejsT6YaH4b/HCp/w3otEBGJSZqI0oMI3AACDV4ItSB+VPwYIA3oxAUSJtFQgKVigHQmS5ROIQElJcZAYAy+r6kFGikCCrai6FhkLElKxYBpE8O0HJYUmpTwcU2KR4IRjvj/ytUZh7327nOCoLOrgcJxzPGPI8J/ArspMbxCDSSaTJKYSNQIQRiCH4IfxT/rAdQ8qEXghjEwSNAy/kzBlHaa7txrjGURtbWBZYHWM+NGSMCbiBlTSpKzLQq2ImNJ0io2c/G8v5l8/czjKDSOiDAGTpoOHol2czDaiWccCjLitbkXc4Wz7wI2YcEI+tAHMQPfQnYqRFZMDeQSABIiudhiMvKehCrS4AfgeuCFgkYQ+zKNINYwZmISy0outgCTaKdovmDHGBCCKJ/HZLNLmgoxgDGGyIASkLEUeTsGKmcpHBVPqUwAF5kEHEKkMAzoNg5GO3lE72RU57FFhEWEwOAIm1dkX8C1qcsuQICCUfST78OM/DsYkGmB6FTxRTRzAGRiDSGSBIxIcntRPFtBFIHvg+cJXD8GJYhiiPwohkKo5Lgq1jgmOZYm+V3GH6PlbI0QwwImnSIqFhN6l+fUxIDE4b6jJGklyFoWxZQip1TixAssImra4mC0kwPRLk7rDqSANN6cx/1PmRt4Uea5F5APFIyin/z9GJ5Ec2jXoKKm9C5ToAg5lQw2UaxdTJAAUxd4XmyWJpzdMIRQgFHxdbYssMR0SCCGasLkTAA574yYMWBZRLlc7Ejp5c+dCcBK1GWkNeORoeJHjHqStJQUHEmHA8flTn6i93EkaCdAkRUeCj0VDMyQ7zZ+jC0snp+++qwQtLEA6Qb60Icxw9+ZdXsa10BBIOwEGAM6gsiNf4YB+G788DyItCAyMTQTcJBMbSkVayctJswISTQ0ZQJl7NLEmiixIUIl30XMgEdKdDYbl4dovephkELgiPhD/EjjhppGZBhvhNwdwrFMJ70ZRTqqJ19NLKDZDHfW76UkC1zm7D2PATIR+tCfYJ75xmzvVIBuRMi8RVSHyIPIB9+D0IfAj82UNrHmiHQMi1HJnGji/BpiaHRSzSGYC4jEV9JT+Z8JkyaaYDNNAJl0Gp3JrAk8s6ctRDIEhtBIjo4PcHDsYdr791Cy03hRsHgsQsTttbuQSC51Lj4/ATLHPwen/rHJE56hgRpQPxYDE/qJqTKxTzJRqSwSWIQCLQwGMQmHScAQZsqpbg7qDCCT4008p5lyZUQClbTSKKuAY/cgUES4VNMVlLCIJkpH1kGkEKSUJGspTowM89OTcEPfHrJOijAKFw3968bla7XvkpVpdlnbzi+AzOA3MU//XzAzlHHTVIKoKHRFEqb0pMNsktyNmNAsctK6Tfosk36MmMv5nXLIhUnM3IRLY2dJZ/aSyV5KNn8pllVCqQJCKKTMYKkCCIkxAR5lhJBExiXQZerhCerBCSrBU1SDQ6sfH+LaIl8LQmPjKJsTlWHuOw1Xb72YnJ0i1IvnyOqmwe21u3lz/pV0q/bzBKDx+zFP/GHszMwIyTFT/ysHbJxIEOb05HWXid8yYY6ESaKmZvBmmChjppxuMUPZ2XY3xY4XU2x/IenMLpTKY1ltSLnwHFNu1gXXRLpOaGp40Qhl/1EGGz9kzH+YUK+sYN/GMK4V45FECokjLE5VhhECruzdTd7JLAmigWiYb9d/wOtyN5OTmU0OUOMo+qk/Am9wFjjTEoBVBVWJJUFEoNV8Wc+pJKFp1i5MZY0nfZrk77bTTa50HW09v0wmvx9lFRcFZvGISmLJPBZ50qqXkrOfrdmX4usRBhv3cqZ+J7XgCKGpLz/UbzJpUihOVUYAwZW9u5YM0ePBEf7De4CXZJ63iQGK6phjfw3jP5uRqp2hhaRBjFgQCKQCp65olKJYszSZpmZ/RsxhskRzlhpJKrODXOcLKPX8Eunss5Bqfe9GS+axZJ4dhe1sy72KEe8BTte+yaj/EH40uqxwv3kORiE5WRlCGMPlvbvJO2miJZTg/rDxAL2qi8udZ21OgMzgdzCnbpvtmIgZ/klNQlXF5iwC5QooxaURoullMgnLZ8zDYISYdjw7vY1c90sp9byGVH4/QmzsmqwJ7dSTeQFd6RsY8e7jZPV2htwfERl3Qe0jMEjMtHtNCIElFCcqwxgBV/TupmCnCReBKCLi7sZP2Kq66FYdmwyg2lOYo5+JY/FJaMT0bJ0ALIMcs8ETk96x5QosVxKkzCxnWDQT1TzJbgCVptD9IkrbbiHbdv1UdvAsihQ2XekbaXMu55nGdzlR/Rpl/7FkBeyMCyEMDaMY0xZgplU4CgS2sjhVHkEAV/ReRN5JES6SVhiMRrjXfYhXZF+ALaxNApD2MMf+H5QfnWG6zIySCoNwVax9NBPL0FGexG4IgowGLeJK1qaE4EQSED017WCltlDa9Q4KfW9Yd1O1MvOWY1vuNbSnruB49V84Wf36LP9IYXC1pK7VbFM28RolOVkZwQBX9l5EwU4TmIV9op95j9BvbeGq1P71uUnW3nR9D3P889Mdl2aQTKKFpIFxGZuwGYk+y5XIMK6lYYbvY2ZMOWTab6T3ik9T6n/rOQlPs2StHVzS9lvsa/8d0qpnxtCIyVprMcfQTWgiJSSnKqM8+MxhaqGHrRbWARrNT7wDjOvKJgDIG8Ic/su5oWl+KMCXULFnT38LsBsKyxdoMW01zqTlikN3RaH/Vnqu+BSp4mVsJunLvZIruv6YwgwHV7B45bMQAiUEJ8vD/OzMIeqBh7MIRCfCM/zMO8jaFtuuA0Bm8N+hfP/c0EzLmhlETcXhO3MU3gQC253D907yPlJlaNv7O3Ts+zDSKrIZpeTs55quT9Cdef7khQiMwDNiXhPWDJElFSfKQ9x36inqgU/acqZp7Jlyv3eQ0+HgOQyQP4w5/Om5oZlwnpM5KkKgHIfuc30DgcGuK6xQYGTT9AQgVIa2/R+muPu/sdnFUR1c1vERtuV+CVtqGhrGIguNTAzawhDZwuJ4eZCfnHqCWuDGEM2Xz9UVHvQfm1z8fc4BZE58GapHp0CZ6fM0Oc94MgZoIjs4R5gvGxLlm+kpI5GhtP9DZLe/kfNFbFngso7305W9BYRAKhfbaqAsDylDhEhqFyer4KYQkVLgKItj4wP85OTj1HyPzAIQPeAdZDAaOQcB8oYwR/5htsZp1kRNE1iiYiECOb+eFiAjsBsWwkypn/z+PyDT/ybOR9laeBdb06/BrfcQeBnCIIU2CiE1yvJwUjUsu4FSfhNYAiUUKeXw9NgQPzrxBNXAI205c7ihAtf4POAdOPfCeHP8K9A4Pf0GmZk+NnHehxDEeOI8W3r+dKwBuyoRbfHURv7i3yS78xbOV5HC4cU9b2frAz/gxyMnaMtUsZw6lu1i2XUcp57A5MY/lY+UDTASyyiEEhwrn4JTcEPfJeRsh3oQIKUmJTSODJEYHgx+znOjq+lQxXMEoKiBOfPt2dDMgGHy14oNDQli8XS89AW2qxB7Xkn2We/ifJe8XeJvXvBCbr79HobKYwg0QhgQBqlClOXjOFWkFWDbdWzHRVk+0mpgWSEZp8Hp+tPcP1jjuX376cqkcMOI8SDFKbfAaJhmyM9SDJ7hN7vOEYDMmTuh+tTCUxYTvo8WULbjLTosvahxlZEgrZ6N9ewPxc0OLgDZUyrwmZuu5L/eczdVPyll1YpQW0RBGr9RmCpBEBrL9lFWA8vysBwfQ4OHBss0xsfZvmUvw7Qz4DmMBhnKYQptJMNejVvaQ9qVdQ5ooGe+C36VWbGnmSPBUbMQDTXbcZ5PVBb7+t9HOJ1cSPLy/u28Y/8+/uzAw8mQhpOD2+xMGyAMHMIghTe5jk2BcHlgqM5Brwfd0YOOIoTRcY240AyFDe6ujPK6ttV3SVudEz3+KGbs4fmThjM8OVFR4AtQSwBISLjurYht13Mhyvsuv4Jru7uZeWcKYRBCI2SEnOMhVBAXv4U5/IZBEeIojSM1jtAooQlMxL+MrU1OaFUAmYG7oXZs4aThRKFOQyFqaulNJrY8B676NS5Uyds2H77qGjrT6aVcCRBmCq4EFCvykTqaswzrUbfOQbd2FgEKqzB8P0TB/HNezc5zzQLXWpr2SRXhilsg086FLC/q6+PVO3eusLOLwWg9u/tIImcCj2+MD59FgMqPY8Z/PkWKNtNzP5MhvEF4ClG3lu777LgR9txMS+Dtz9rHjlQWlpNBFnF3EO2HCGMQc8xxBMbwcKOKZ/TZAciM/hzc4abK9kT1mKaHjlUrroS6jCOxxSTTDpe8HKx0ix7gis5OXr1lGzKCBSe75hI/xGgz7/sOew0ebdTPAkDah+H74gVccznPzaG7L+afNJ1Ltl0Nu17QIqdJXr93LzusFMvqEWNAB9GC7zkdeDzUqJwFgNyhWAPNF3E1eWzCU9Cwl6aC7SzsflFL+8yQ67Zt4WV9/XFPmqUqIUHcTSQM5x17V2sONGrojQbIVA+DPz6/4zxRgahFvLN4tETt074L9r6kRcxcDvWufjrCpLnREsZSTNT6hhHzNbE2wONujVO+t8EaaPQRCCrzm66JtVm+hLo1M5Uxv/RfH2uhlsySG7b3cUVXN1T9JfbhSuqAJwCa5wKcCDzOhP4GAzT2SFwwP1/eJw2kBMK1EIG1NHjsLOx/zTlRDH8uSkcmzY07tuF4Bhr+4lcu6SahPR9jzLzXoBJFHPLqGwiQDjDlQ9PBmagBcog7DYUGTgoYsyDF0sL39l3QtqNFygLy4t076MikEdUAvChphL6Qr6ExkVnQ/WzoiCfcxgYCVD8NQX2qUCwinlErJlryKIivg/i8QDySrE1OL8GE7b4JpN2iZAG5rLuL3kIOtEFU/KlC8fksmAEThICeMxc0ce+fCNwV54OWN5mqfUz1KPjlGByVgBMAT4N4CMRDBk4mi3QdDbaE3Ylm8hYIxrZfN9kJviVzi2Mprtnay4Ezgxg/QlR8TDE1T7e02Acy4eIO09Oey1gY0ms766yBgjqMPgneOBSAHIhjIO8A+fcG8R0DpxMfqI24pdgJDT83MGpiEzfXjeDkWuZrCaKE4Nq+LaTsZC1dNUC4UdyzeK4rqzU6jKaaSc4XE0Uh7sZoIBf8U5ALECeBAwbxAPBMolkcIEP8haPEF3KI4TkAXAL0iLg6IWyCqffZYGdahCxBrtzSQ8qycMMobnhVcRFOBqNU0nmrGaK4G5cJIoSaX1d4WnMm8NnppNcZID+AEyOIbxnEAeBEAoGdHKl56XFkwEtOKCWgauCgARfYLmKw/OS1PZe2kodLlO3FAjnbZtz1Yi3jRXGD61J6evNPMxWJEYbJRZpbXKMZWmEovzwTVg4R3xlG3JHAk0o0jtUUxjeH9H7SwFAlr3WBxw0cboraAHLd8baULVn8ggnB7vYS05JrtSBufj2HmTI6wkQ6XlQ4jxkLTKyB1h8gN4ARL4Y5y8KbEU9sOhHqKbCcBKyndAxSkNwYHbs5R3ejOefEVpKL29tmmSlR8eOkoWouPhMIrdHhwn0WfWMYDIMNAOjkMfAqS39XZGItZGYYTQUcT0xaFXDyLTKWKEIICqkZ2lpK8CNE1YtN1kR+SIg4iRhGC6biJJCWcgMAqlXiBs1LO9PYTLlJvYeYA6JBA8dzELTM15KdVinZms/N1vZCQDVE1IKm5+KbOA7l588ZhcYwuCEmTKql16RI4rvBi6aZ60n/SCWPRgq01SJjGaF8f7E493gbA9WkPb+IQ3ejNSbUTLXsmi0GOBl4K1r0vL4TT4Z4LyW9gJ80vSKtJaujKzZX1aRPsowBwg/iFb6LXCrOOYBEkx80n/5s+c7LlgUbJEgRbxZSD5L2xxITaXQULQiJXOGFWH+AQsAzLVDWMpRfbDCNQFR8hBdOaaFIz3sNDGbFXTuWB9Byt3CUokkDzQdZq3xjubJYg81J/7Pix+MPSev/2eBECTxKrOwOX6b3apYHUbMJm4gKZr498OM9BlqyxMyI4XSlurQo2IviLa1yISaK4vhHTOyaGF+INDYlmWO/07EiI7E8gIolSKVW4EjrOKko5wCoUY63D2zJ0gDSmoFafWk3rzHIug81D6N1vPt00r4qIxyKMkeHyFGSObbbhQ3QQFv6IL/MpN9ERtrXkFGzCZLAWLlFxlIdaGMYabhLdyFCoOyiGz6qXZAVDu2iQIfMkRIpLBSRifBNtAEA2Q6kljnpKScAMvH0x+yQAoaOTbWlb8kiGshwZGx86fevpQjqLpnxkC197XRYeVLGRiEI0QSEpKWg09qITLRtQ0fX8h3pUMdmbC5AIuDwiXgXuZYsKl4U8dTwErdOSPoGR66krVGkT3aQlSkMBp9o0g+yhaDDUhsAkGVD+wra5k/Oic0wXwpoAE8cBtdt0bEEOTpephGGS4AnXtLsjxpy6S46+rciLEmgQ8yMPRAdIShtiAZyHOjujTciXZYfJOLaIF9P/0QJVAU89POlz7FdwGKAh84M4EfRIlonbkBlajZRVVLs7aTQ2z65zfgsvSDYIA2UycLO3VAorcAPSh6yaZOLINFA5QoceqpFyBIc6AfODODNV+ecdGE3oYR6mqACTi5N5+4+bMdGzwNeTknSYiMy0akUXLwXisXla6Bgwg9KbiUbqIu4KhHg+99PKudaMp/4YcSDZwbmzhlP5Nl8C2oOJpBEOqDY20ZHf2+8ZC+aO4e307HIq42ayujuhcIKGjQGTY70BEQuU2WtP/1py4wtIo8MDnGqXJkbHsA0bEzdAW0RRQFKSbp2bcPJpubVPhLY4ljYYqMAchzY1r/8XBAJLJFJ9soQ0JwPO34cTp5oUbKAfPPJI4y63ixnGSNicFwLtMBIjY40ufYSHTu2IBBxp445GElJwTZn5cupVuZ6X/qcGKTlQuRHcXmHnZiuRtPfajX4xjeWP992gUjZ87n3xKnpe4QJIJKYmgN+AoFMCsgMdO3eSqaUJ1rANUhLwVbH2mCAnnPlysyYH8UaSBIvMmwuwzUGfvADGBtr0TKH3HXkGAcHh6bDEyhMPQWhnNbk3USGTCFP564+lGURLdDRo9e26LY2WgPt2AWltpWF8lpDKKDG1OYrE/L003DPPS1a5gjf73r6GGPN5suzMHV7VuscYwxaa9r7u8l1ltALaB8B7MvYdNsbDVB7J1xy6QpGIinv8IgBYgZArgvfuaOVlZ4hPz5xmu8cPpoEHyJ2ll07WXE6I9SPNFbaoeuibaSyacJgfoBsIeh3rFWVaq0MIMeBa2+A9DJWk040PAp07PvMlwt76CG4++4WNU3y1YOPc7JcgUhgGg4E8/dcivyA9r5uij0dC8ID0GFJdqVX19Bi5dVc+y+DjmVOa0gBDQMVmLYdYbOMjcG//VtraiORn51+htufPBT7O7XE35lPwUcaaVl07NhCupAj8hcGaEfKZu9ZA2j3xXDJs5fu/1gSI6BxbIz6keE4GTbf/MtPfgx3fPuCh0cbw98+cIDTQz7GdeJdhhfQ8IHrU9zSQXv/lripwgJiCcH+jI2zygqIlQOUL8DV1y0ezksBUhB5IZVTo4wcG2H85CBBrTp/+UalAp//AgwPX9AAffvJo3zjwDHwrKmO//PBFmmkknT0byHXll8UoE5Lck1u9f0IVleQfMMvwNbt8/s8SUcId6zGyNODVIaryZ0VURkYRLseqHkigMceg7/72ws37+P6/Om/P8Do2FJm3iF0fbIdRbp39UESiS1oQNI2ezL2WQZo37PhiqvmOKoEqYjcWOuMHh0icP3Jba0l4NbrVAYHIYri18++peCrX4Xvfe+CgyfUmo986yfcf2xoSUV2JopXvbRv6ybf1UYULW6+bsyn12RJzuqP8aKXTJW5CpFoHYM7VmX46ADlocqkQhIzFFRtdJT66AKJw0oFPvF/4MyZCwqgv/rRQf7hvseWthRKQOgHZPI5ui/uBynQ4cLap89RPK+wNu10Vg/QjS+EZ+2PfR0V+zrlUyOMHhvCd4N5P2BiPrUyOEhQq81vyp56Cv7kjyEILgh4vvPEcf74zp8RLbUrvTagNfnedoq9nUljxIXf8vxChoKS5whA+Ty85FVgDN5YjdGjQ5SHqhizcPeXiQ8Pg4DyM8+gfX9+iO68Ez796fMengdPDvG7X/sh4+5SG1jE2kelbHr37MBKOYR+uKDmykjBi0tr1w1ubTB81S9Tz3QyenwEt+GhWPpCVAl4tTqVgYGFC+v/6nPwhS+c1/Dc+sU7OTq6jL0rjMFoQ76znfbtvbFWX8T/eWVbjn7HOscAau/AvPmtRJFmJbMqAqiPjOKOji7c+/h//ync9k/nJTxv+9Iy4SH2dYSSdF3URyqfIXQ9xAJ9fvJK8sr2td0JYM3WFWfe8lbsHSvvtGqA8sAAYa0+vykLQ/jYx+DLXz5v4Pnukyd425fu5OmR5WieEKI6xi9TbHPo3rkVIdWi0dfL27L0Oda5CZDs7ib/wQ+u+P0CCPyA8pkBtB/MD5Hvw59+DD732U0Pzxfvf4Jf//JdC8CTdHM3AWgPojoickGm0E4fuvgcsnuvJ9tVwLj1BfsMdNuKl5aya97jQhhjKsRtwFctplJh5LWvxb/rrlVpokJnJ4W+rVMb180nr30tvO/3oK1t08Hz8bse4JPfe4iqFzC5yYiZsWuNMSAUWG1ouw3sAsbKg8xiZA4t0tg7imzfE7DTHsaSEMwz3fGW7gJv6Sqs9WlU1xQgAPf22xl7wxswK6xvNoCUkrZtfaTb2uL6oYXk6qvgDz4A+y/dFOCMNjw++I17+dL9j6FN0jFDyDiZagTIFNgdMTBWCaNyIFMYmQKVAmHFo6Q1GE3UmYZ+h62pOnsK46RlRGCmZ90uyTh8cFs7PbY69wEynkflfe+j9qlPrfgYGnAch7b+fuxcZnYD7ZnIbemi/usfJvXqm1D5c7ff4k+Pneaj3/opPzg6iBFJo0grh7E7wW7H2AWQGRBW/Heh4odJdrNp1lAT/1uyiPpzRErQaXlc0lamZLmESLQRpKXgPVvbuKm4Lo3c1x4ggPDAAUZvuYXwkUdWBVGmUKCtfztSqQU0kUZj8VT6jYjrr2XLrZdTuH77OQVOEBm+/OAAf/jd+zjjZxF2G1oVwcqDdGINZFT8UzAHMPNIZCBnwc4cJiPxfSg5IXsK43SnGxjgpW15fqO3tOpZ9/kAWpfuTtZll5F///vjtfSrcKrdSoXawOAijRdchrmEqluifM8Rjrz33zjxJ/dQve/kOQOQMTBcS1MObkDlriHM78Wke0HlQNjJ2UZg/Hg/WhMmEJklRB4aQo1QkFJQCSweGWvnaK3ArrTNa9sL6wUPAOqjH/3oB5jqGb9GrrnA2rcPU60S3HvvigECCF0XZTvYuewcG8iGaLKc4EZcOpAEaDek9vNnqPz4ON6xcVTewe7MxvmRs9T8QwrBZVtTlCzJA4c8TKDR0mCkRphVNBmdeGu7DVkFYexKRUYw5qdwJFydV+xIq/U6dX99AAKEUlj79hEeOEB05MiKITLGELoN7EwGlU43mTIB1BnkSobZnzwztU9EVPGpHxyg/MOjVO8/hfFCrGIaYUmEvbHbSgkBjiW4cpsio+D+Jz2kb+JW2pZY/cFzFmStyVGRArQRnGnY3D2usaTg8pzAEpsIIABZKqH27MG/4w5MubxiiHSk0X5AKp9HWFbiG3iElDjFc3HpRBHO6V/rmo/39CiV/zjKyDefoH7gDCbUyJRKdvMzCCkQcv3Vk5KCK7fZZB3Bw8cCdF2jQtAKtBRz1cgvHrJCDFDemqbIpAAjBOVQ8d0Rgavh+hI4a+u0+OviRM+Uxpe+xPg73oGp1VYc2gPkOzsp9m2NsdIjDPFcjvKLGCSS5a2rl2mLVH+JzLO6SO1sx9laINVfQqYtREohEy1ldWRRxdSaj8k3Dnr83tcrlOsGI8HNSLyMJEpAXsouoZikB3dXCvozU7sDzCPv3Aa/vxN61k5dVDcEIIDapz5F5b3vXVV+SAhBaetWsj15TORwRL+EIS5B4SNYu0adKp9ClVIIJel9+zV0/cpl6zIm33rU431frzJa1wgDkSVoZBV+KtZGi4JkEoiKDuzIgiMW3dH5FZ3wib2wY23Kgaob1mM39653kXv3u1eXHjCG6sAAVAaoyIsYYzegEURr+l2jqod/sox3bIyovH5r1F6+P8XHX5unKxcvOFCBIT8eki9H2H5MjpEsuC8qmqnmXUu4mt8cht9+Au5bo7aUG9qkOf+Rj5C59dYVaR9FvDWZDEPGBg3DZh+RVUCxfoVmwpLr7hu9bF+KP399ge1tCpMko9MNTb4ckq1qZBg/Z+QCoxNGU6t8l2D67hiB33gc7h3fZACJXI7SX/wFmTe/eenmhHgLVgkE5Bihl0frN3Cm0oOtQpQSbPY2+Dftcfjsm4rs7FAgIFIgNWRrEcXxiFTDIHXsaM8+1cTv8aPZS8UXkIM1eMdj8LXBVeb8NnqwRKFA6XOfA2No3HbbvJrZSqDxkZTpYZweRtlHlR68MEP61CBFt0Guo4CyFDrS8d5Ym1Su2Gbxl28s8htfKXN0JJr0gaxAky9r/JSgkZNEtkSLGLBpKsA3y9JCAEca8K4nYrfp9d2bBKBJiD77WVCKxhe/OE0dJlOF1GinSi9l+hljDx5FTPJ1LRqEXoOR03Xcap1iTzvpfAajF1/Oci7L5X0Wn31Tkf/+5SmIjIgdacczWGGElzZ4aUVkCcREYlUTZ6RXIMMBvPMxGPbhHdtWEHCsZx5oQYjSaVIvexnG9wnuvRcLCJCMspsBLuMU13GG66iwHU0KgUbhIvGTFR7xref7Hn7VxWiDnXFQllozTSSkoHjjDnJXbt2wcekpSG7YZfPEQMTJcT2lkhOtYwcaK4zPL7TjRZsiMpCScTSmFtZApil4m3h4Gu4YBltBwYLepdPgn9Wd3kQ+T/HjH0dt28ahD3yJEXc7NbbhUUISIYiwCBGTOZ7p/o5AIhEEQcDYmSHcWoNiVxupQgZhmCqX2GTy7C0Wf/mmIu/+5wrfPzyV9ojNmsDyDdkgwvINflYSCBE3c5/YMlszaQLncxFsK95eTKl4hbml4O+GYUsGLs+d4yZsVoj/nvfQ1XUDJz50L+GxM1jUE0w0s1eUzRyM+J/BUK9U8Rsexc4Suc4iyrbiHYs3oW/UW5D82esL/PY/V/jB4em5MyPjTr7pRoQTGFwFblqgERMbFSJE4hJYMRyWSH6qZAWWnFx1jpSxAnt3D9y8zL5h58xek31vvZHM3j4eff/tDN9zqOleWaI2Q6BQRGHA2MAwbs2l2F0ilc8gpURHelNC9MnXFXjv1yrc89QMiJJ9UmVkyDQ0jhKYIES1WVgabJlAwlSViBTTixpM8h9j4JZ2eGvnOR7GLybtN+zk6s+/hYvecxNWfmXTBxIFBtxqleHjA4yfGSUKQpRlITbhXhxbi5I/e12BX7li7tSxEYASWJWQYjmgswjFLGRtSNmxX6MScIyJa/MmHlrHBQ6vKMFv9myCPNBSJL29jf1/9Gqu+OtfpXjlthUdQyARKMIwpDw0yvDRQRrjNYSSSCU3nV/UnZf8z1flufW6eaoKbUHkG/yTLroez/JHJm47EJkYkvkWrF6Xg/dugaw8TwCCeKKz71ev4tqv/Gcu/t0XrUIbxbA06jWGjj/D2MkhoiBMJko3lzYqpATvvznHW65NzxlaSUcSDoZ4x3z0Ek/vkjR8qA96V9Gk45zebzK3p4t9/+tVXPf1X6fnFftXtB3UhJOto4jxoTEGj5ymPlZFKrHpTFoxLfjAS/L81guzs9df2gLtRoTHXYy7+E6i2xz4g62wZ5WFBuf8hqUyZdH1i3u45ra3cc1tt9J2bT9ymY2xxeQ/8F2PkeMDDJ8YJPCCs1qpuFKI3n1TlvffnGNmXZywJeFQQDTkLxgetSl4d29svlZ9fTbLwFmFFH1vvJLnfe9dXPn3v0b7jbtQWWcFIEmM1tRGxhk+eobaSAWjDVLKTaORHEvwzudn+fPXF2nLNOXFbEE0HhIc9+MMyBxX1xHwX7rgZcW1+S5nLRO9YuJtRfGyrfS/7blkdrSj/RDthkRVbxnO8ZRZa1RqREGI7dgo25qmjc5GJnrJZyDgkh6LXR2KB06GlF0zGZYZ32BtcZBFSXOdnQBu6YR39sSbBayB+BabVIQl6X/bdfS/7TpGvn+YM1//OcPfO0T1sQGiqodZUn+dOAVZHyvj113yXW3kSvk4AblJ5tReeWmK7W2K999e4eFTIcISRKMBwWkf1ZWZNrn68lIMT2oNFe2GVSRuhNSPDDPywyOUHzzJ8PcPUz8yQjjeQPuLF5xpIkCQLeYpdpVI5dJgK/p++3n03HrVOX/uR4Yj/se3qtz5uI/xNdZWh9wLS8iCxDTgqhx8Ygf0rK3KqJ5XADVL4+golUefofzwKUZ/9DS1JwYJyy7+UI2oMXcRWrwptsG2bApdJbLtRfp/9wX0vv2aTXHOFdfwkW9W+cp9DYyA3E1tOBc57DLwye2wN73mH1m1OE8ls7OdzM52el6+D+2FBKMN6k+PMH7/CWqHhiaBCkbrhDUf3QgIK3H5qhaaaq1KpARabJ4pkEJa8MnXFSilBX/9vRrBIZfuPpuP7hbrAU8c3HABiExZpLYUSG0p0H7Dzml/c0+M4Q/V8IdruKfKk86zMQaUoHDV9k13vh99RZ68BV97LOAdHYZrs+sXXV4QAC0k6W0lUluLaD9Ce7OXBqk16KV8NuT1V2XI5xTXl9Y3NXHe+kAt2RCpytYYtGRV7kFrCFrSAqglLYBa0gKoJS2AWtKSFkAt2WCAVGsYWrJCURZQhjXuj9KSC0Vq/x+9AVPqoS4hzAAAAABJRU5ErkJggg==',
          method: 'GET',
          overrideAlias: false,
          state: 1
        }, {
          key: "#mi",
          url: "https://millionshort.com/search?country=fr-FR&keywords={searchTerms}",
          name: "Million Short",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHIAAAByCAYAAACP3YV9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUY2QUMwQjY1NDA0MTFFNTlBOTU5NDM2MDE3NDY5QTUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QUY2QUMwQjc1NDA0MTFFNTlBOTU5NDM2MDE3NDY5QTUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBRjZBQzBCNDU0MDQxMUU1OUE5NTk0MzYwMTc0NjlBNSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBRjZBQzBCNTU0MDQxMUU1OUE5NTk0MzYwMTc0NjlBNSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pq7y15AAAAk0SURBVHja7F09axxHGN5dH7hyrEKBEBFimRQOhOhSxJWDzzhg5EZSEdJFUm+Q9Qss/QL7wL2kpAhJCsmNUxnJxJVTRGcIcWWrcRESwoVAIAbfZp9dDVrNvTP79c7cSbwP3EnoY2fmfeb9nI8L4zgOBCcfoRApRAqESIEQKRAiTzWR1t/ef9NJ3u8kr46IaqToJ69ucOvMWnUi77+ZT963RYZjhc2EzGXqF5HlnzZEbmOHpUTBlsoTmZnUCZHbWGKuika2RV5ji4kqRIo2njBEIgIhUiBECoRIgRApRAqESIEQKRAihUiBECkQIgVCpECIFCIFQqRAiBQIkUKkQIgUCJECIVKIFAiRAiFSIEQKhEghUiBECoRIQQm0TtNgOlPZSfr+f3Gw/6cQeWIwcTYI5qfDYPFSmJCY/01G6ObzOFh/GgcH//jpz4Vz2WSamQyC9uTR9Qz913Hw+FUQ7Lxw15eWS+1YmUm+vhumAgcwiK1EuGtPm18Jc3smDO58evRsCksJwSB69UmckupyMq0k/WlPmv4K/QiCu1fC4F4vTvsz9kRiMHevRJqGHM1YCH8uGfi1nUFiAus9f+N6ZBHasKA3rodpWzsveQW4djkh8GP7ZKImIMBNZsQ9sF++pEnUydierd40NGx3vjyJeYDMKgIvsjYvv4oKLYKNTOXPx4pIaBoIxMDKCyMjpixglmxkQNuWH8WJpmdfdW3H/yltaAL0Y3c+TMdsAtreS3zi+s+ZSacsz+KlMTOtmFnbs2YBY0Dwi3MXM1+Sx51Eg4t8lzKN+v8qmAKavVdxOrny/UJQVNc/g7jtm2ZroEx3tzccMa+ejYcsSaaR8XhoZGbqaBIxGGgHfCGEvfAwHvJREI5tZuO5EABFIp7/yXeDVPuoSBA/0ydJUXs2V4BJYSIRAcz0N1lfqLQHJINgvS9jYVpBIjSFAkwKhAytOPZzQhvyYTpFIiU8EIQJUpQrbj0v355tnLpm563N9NeDNHApCtxcp0ARJ4kYDLTQZL4owbffrkYihEb5wCbt2YI302RFPzCZfOWo7D7STuKgcUXFRiIIrJoPol91IkuMkQrG6o5Tj+TrpF5sGgkHTZGo/BVHWQxpCReJJq2sSyKeBV9Y55kzk837xaKRWe4Xkra/bHJPOfj9P44LkMpB65JYByYSVXpTV5NQ4TpOZOyfSBAAc6ebKAxq4WH5Cg0VaPRfH5lsSoAgsAmJF95qTiLaB4l1gahbl12PWSMLTSs6gPyJIrGqr7g6RUV+8WHZjV+AVcJ8VyQCyKGpcXsj0hZ4LPxYfalo/mI45CdUG5Q/airAKiUzVyQqjdTHxh3tRkXlKFPgUXVGUck4/ASCG13bld9tCqrvyP30KBzjdEUinq+Pb+u5x9UPDI6apXWXhKgiMX6mk1vV79otSlhItCuTrrBIBU4vPBH5/Y3w/Bcf0AO816vXiatT5fwXJgpXaN6ZMvsmFcBRJp1riSlbaB62CC6KCENExnGMa7Bvu4jcioBJwplmvH+OLpOZArisPjxgS9ZXiNWWLUdpVESQuMs9S6nwm2oDNVpO6OmOyt1gTnX/CfKWHw1YKy66a6IK+exEJiTiHnN8RMQE9yylwm/XQsTE0clC7oYIlbIOdaLwcQhyjhF5SCI0sc0tYLWnxQZoInfJSq+k5IM4yi9z53WUWd38zTGRGB9FIkcRvMiswvnXDaCqBlfUDoYmAZwtQtetAdrhDHIS5ZtPXrvJaw2K2EreQOKSq+hxxbK9Qmm8C5TZE8MZoR4fc0AEOawkLgVHn5TUSV7nW1SEylWkpmamblJdhOKUf/Thl1XKQVVyuEz35++F7WD4Q+faEWVquCIr2wYjVya1bKrDma8eM9+Xh9vu9vjy0h9uhNSH6zyOfv832HFR0UCjpl1yLk2qyT+6zFdtgR1XymHKffH8j74dHLTe2Rh0lBliDb8/DL2b1DL+0ZVfBJDauEo5qLq3Kmf++lewCB85oRG4D8tH+c4qswc7sH2b1KwIYF66UgN3Bb2uivY4xoq9Q5R1y+W+ffjIg3zbiHWS19+uUg6XJjVt++JoLAEErU8g7CpoGkzhuVTapOW+XRB5De4R7abf3zqz78Lh+zCpaRVpejSWgFrlWG94WCk7R1OY+64nnO21kreDQy10NjOVU3YpSBVgUWmH6+AKbXKvcuCZ1PYazcdvqs9dZj+xbNLG1Z9i9pytrFl1bQmookeTlCM7JmHeXnMox/385y2zEgnfSGkjZif3kbay5s21SaXyVkyauuM1ba/RSOwfusTACZGmctzqk4FzEqkqkmuTqlwJZ8ph2terFTAQy/SdEAlBUivy93p+zvNTkV33mYfgiliiq7vKYdrXq22v2aMC0silIKER3IvFJtNmmkQuQVVy6u6Qs23HLDOOyKU2gkTXAQ6EefczWgDOg6tpniCnaHd7GUSutBEz07VGACiLUQHWgxfuzTllVqsGObZzJlXq3pErbXRVz9S1kSoFurj4oYxGQvhVrICNxKrba1outBFC5N46YdJGqhTo48APVZgvG62mKxmz9KUZdfdINSKS2repkn/XQNumwny354NIKl+OS5FoOobRZKNbIyKpKg78oo9TvGjbdBx8VKeIi9Ks9GjizYg+Xthwt2LURCOWiGUbH+mGbdF6y9M5yjpuAJrogsRGGkluaXjmPuS3VZBcbgAu6/v08cOXIo4wXSKF/pa5TMIJkZRG+FjdUDBpY7fnj0RK8IhCu70jMzo3HVpvAYP14riXrzaRpg1GPrTRtGiNtn1qI05U6WuF6BsuDywCJn2do4msPhJCpHyjLyGaNlb5Mut5MurkqrBa1B1E3omk7gHg2NLQpH0IlctEVYHppisKiKZBIIc/ZCESJ5ryHcH3Pqo4+fYpgY4Cao3QZI1U3AACOY5fsPpIdB4dU9sdsWTj06QhQMBNHfBH6VG8p36qSDZ5YCLhla/26BPeNWoFO6MyZUpwuKCQ82ZFLoxyQsmnDJwSCJFCpECIFAiRAiFSiBQIkQIhUsBB5J6I5nQQuS+iGVs8KE9kdkBkXWQ2doCCbVbzkdkBSiFzfAB3t6CfwlIovpDm/hvc69IJtCvOBN5wEGSHWq3uLozjWER1CiBECpECIVIgRApo/C/AADk15AEMltEjAAAAAElFTkSuQmCC',
          method: 'GET',
          overrideAlias: false,
          state: 1
        }]
      };

      /*
       * This module implements the core functionality based on nsIAutoCompleteResult interface
       * http://mxr.mozilla.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompleteResult.idl
       */

      var CliqzAutocomplete = {
        LOG_KEY: 'CliqzAutocomplete',
        SCROLL_SIGNAL_MIN_TIME: 500,
        setup() {
          Object.assign(this, {
            lastPattern: null,
            lastSearch: '',
            lastResult: null,
            lastSuggestions: null,
            lastResultHeights: [],
            hasUserScrolledCurrentResults: false, // set to true whenever user scrolls, set to false when new results are shown
            lastResultsUpdateTime: null, // to measure how long a result has been shown for
            resultsOverflowHeight: 0, // to determine if scrolling is possible (i.e., overflow > 0px)
            afterQueryCount: 0,
            discardedResults: 0,
            isPopupOpen: false,
            lastPopupOpen: null,
            lastQueryTime: null,
            lastDisplayTime: null,
            lastFocusTime: null,
            highlightFirstElement: false,
            hm: null,
            currentAutoLoadURL: null
          });
        },
        getResultsOrder: function getResultsOrder(results) {
          return CliqzAutocomplete.prepareResultOrder(results);
        },
        // SOURCE: https://dxr.mozilla.org/mozilla-central/source/toolkit/components/autocomplete/nsIAutoCompleteResult.idl

        // a result is done once a new result comes in, or once the popup closes
        markResultsDone: function markResultsDone(newResultsUpdateTime) {
          // is there a result to be marked as done?
          if (CliqzAutocomplete.lastResultsUpdateTime) {
            var resultsDisplayTime = Date.now() - CliqzAutocomplete.lastResultsUpdateTime;
            this.sendResultsDoneSignal(resultsDisplayTime);
          }
          // start counting elapsed time anew
          CliqzAutocomplete.lastResultsUpdateTime = newResultsUpdateTime;
          CliqzAutocomplete.hasUserScrolledCurrentResults = false;
        },
        sendResultsDoneSignal: function sendResultsDoneSignal(resultsDisplayTime) {
          // reduced traffic: only consider telemetry data if result was shown long enough (e.g., 0.5s)
          if (resultsDisplayTime > CliqzAutocomplete.SCROLL_SIGNAL_MIN_TIME) {
            var action = {
              type: 'activity',
              action: 'results_done',
              has_user_scrolled: CliqzAutocomplete.hasUserScrolledCurrentResults,
              results_display_time: resultsDisplayTime,
              results_overflow_height: CliqzAutocomplete.resultsOverflowHeight,
              can_user_scroll: CliqzAutocomplete.resultsOverflowHeight > 0
            };
            CliqzUtils.telemetry(action);
          }
        },
        // returns array of result kinds, adding each result's
        // height in terms of occupied dropdown slots (1-3) as
        // parameter (e.g., ["C|{\"h\":1}"],["m|{\"h\":1}"])
        prepareResultOrder: function prepareResultOrder(results) {
          // heights is updated in UI's handleResults
          var heights = CliqzAutocomplete.lastResultHeights,
              resultOrder = [];

          if (results) {
            for (var i = 0; i < results.length; i++) {
              if (results[i].data == null || results[i].data.kind == null) {
                resultOrder.push('_'); //debug - it should not happen
                continue;
              }

              var kind = results[i].data.kind.slice(0),
                  tokens = kind && kind.length > 0 ? kind[0].split('|') : [],
                  params = tokens.length > 1 ? JSON.parse(tokens[1]) : {};

              params.h = i < heights.length ? heights[i] : 0;
              kind[0] = tokens[0] + '|' + JSON.stringify(params);
              resultOrder.push(kind);
            }
          }

          return resultOrder;
        }
      };

      function queryActiveTabs(window) {
        if (window.gBrowser === null) {
          return [];
        }

        const selectedBrowser = window.gBrowser.selectedBrowser;
        return Array.prototype.map.call(window.gBrowser.tabs, (tab, index) => ({
          index,
          url: tab.linkedBrowser.currentURI.spec,
          isCurrent: selectedBrowser === tab.linkedBrowser,
          isPinned: tab.pinned
        }));
      }

      function getTabsWithUrl(window, url) {
        return Array.prototype.filter.call(window.gBrowser.tabs, tab => tab.linkedBrowser.currentURI.spec === url && tab);
      }

      function closeTab$1(window, tab) {
        window.gBrowser.removeTab(tab);
      }

      function getCurrentTabId(window) {
        return window.gBrowser.selectedBrowser.outerWindowID;
      }

      var _extends$3 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      /* eslint no-use-before-define: ["error", { "classes": false }] */
      function getDeepResults(rawResult, type) {
        const deepResults = rawResult.data && rawResult.data.deepResults || [];
        const deepResultsOfType = deepResults.find(dr => dr.type === type) || {
          links: []
        };
        return deepResultsOfType.links || [];
      }

      class BaseResult {
        constructor(rawResult) {
          let allResultsFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          this.rawResult = _extends$3({ data: {} }, rawResult);
          this.actions = {};

          // throw if main result is duplicate
          // TODO: move deduplication to autocomplete module
          if (this.rawResult.url) {
            if (allResultsFlat.some(url => equals(url, this.url))) {
              throw new Error('duplicate');
            } else {
              allResultsFlat.push(this.url);
            }
          }

          // TODO: move deduplication to autocomplete module
          this.rawResult.data.deepResults = (this.rawResult.data.deepResults || []).map(deepResult => {
            const type = deepResult.type;
            const links = getDeepResults(this.rawResult, type).reduce((filtered, result) => {
              let resultUrl;
              // TODO: fix the data!!!
              if (type === 'images') {
                resultUrl = result.extra && result.extra.original_image || result.image;
              } else {
                resultUrl = result.url;
              }

              const isDuplicate = allResultsFlat.some(url => equals(url, resultUrl));
              if (isDuplicate) {
                return filtered;
              }
              allResultsFlat.push(resultUrl);
              return [...filtered, result];
            }, []);
            return {
              type,
              links
            };
          });
        }

        get template() {
          return 'generic';
        }

        get query() {
          return this.rawResult.text;
        }

        get cssClasses() {
          const classes = [];
          if (this.rawResult.isCluster) {
            classes.push('history-cluster');
          }
          return classes.join(' ');
        }

        get kind() {
          return this.rawResult.data.kind || [''];
        }

        get title() {
          return this.rawResult.title;
        }

        get logo() {
          const urlDetails = CliqzUtils.getDetailsFromUrl(this.rawResult.url);
          return CliqzUtils.getLogoDetails(urlDetails);
        }

        get localSource() {
          const data = this.rawResult.data || {};
          return data.localSource || this.rawResult.style || '';
        }

        get friendlyUrl() {
          const urlDetails = CliqzUtils.getDetailsFromUrl(this.rawResult.url);
          return urlDetails.friendly_url;
        }

        get isActionSwitchTab() {
          return this.localSource.indexOf('switchtab') !== -1;
        }

        get isBookmark() {
          return this.localSource.indexOf('bookmark') !== -1;
        }

        get isCliqzAction() {
          return this.rawResult.url && this.rawResult.url.indexOf('cliqz-actions') === 0;
        }

        get isAdult() {
          const data = this.rawResult.data || {};
          const extra = data.extra || {};
          return extra.adult;
        }

        get isCalculator() {
          const data = this.rawResult.data || {};
          return data.template === 'calculator';
        }

        get isCurrency() {
          const data = this.rawResult.data || {};
          return data.template === 'currency';
        }

        get isSuggestion() {
          const data = this.rawResult.data || {};
          return data.template === 'suggestion';
        }

        get icon() {
          let icon;

          if (this.isBookmark) {
            icon = 'bookmark';
          }

          if (this.isActionSwitchTab) {
            icon = 'switchtab';
          }

          return icon;
        }

        get url() {
          let url = this.rawResult.url;
          if (this.isAd && this.urlAd) {
            url = this.urlAd;
          }

          if (this.isActionSwitchTab) {
            return `moz-action:switchtab,${JSON.stringify({ url: encodeURI(url) })}`;
          }
          return url;
        }

        get rawUrl() {
          return this.rawResult.url;
        }

        get displayUrl() {
          return this.rawResult.url;
        }

        get description() {
          return this.rawResult.description || '';
        }

        get image() {
          return this.rawResult.image;
        }

        get source() {
          const urlDetails = CliqzUtils.getDetailsFromUrl(this.rawUrl);
          return urlDetails.domain;
        }

        get updated() {
          const data = this.rawResult.data || {};
          const extra = data.extra || {};
          return extra.last_updated_ago;
        }

        get isAd() {
          const data = this.rawResult.data || {};
          const extra = data.extra || {};
          return extra.is_ad && CliqzUtils.getPref('offersDropdownSwitch', false);
        }

        get urlAd() {
          const data = this.rawResult.data || {};
          const extra = data.extra || {};
          return extra.url_ad;
        }

        get selectableResults() {
          return [...(this.url ? [this] : [])];
        }

        get allResults() {
          return [...this.selectableResults];
        }

        isUrlMatch(href) {
          return equals(this.rawUrl, href) || equals(this.url, href);
        }

        findResultByUrl(href) {
          return this.allResults.find(r => r.isUrlMatch(href));
        }

        hasUrl(href) {
          return Boolean(this.findResultByUrl(href));
        }

        get isHistory() {
          return this.kind[0] === 'H';
        }

        get isDeletable() {
          return this.isHistory;
        }

        click(window, href, ev) {
          if (this.isUrlMatch(href)) {
            const newTab = ev.altKey || ev.metaKey || ev.ctrlKey || ev.button === 1;
            const action = ev.code === 'Enter' ? 'enter' : 'click';
            // TODO: need to handle 'go-to' button (right arrow in URL bar)
            const target = action === 'enter' ? 'urlbar' : 'results';

            CliqzEvents.pub('ui:click-on-url', {
              url: this.url,
              query: this.query,
              rawResult: this.rawResult,
              isNewTab: Boolean(newTab),
              isPrivateWindow: CliqzUtils.isPrivateMode(window),
              isPrivateResult: CliqzUtils.isPrivateResultType(this.kind),
              isFromAutocompletedURL: this.isAutocompleted && ev.constructor.name === 'KeyboardEvent',
              windowId: CliqzUtils.getWindowID(window),
              tabId: getCurrentTabId(window),
              action,
              target
            });

            // TODO: do not use global
            /* eslint-disable */
            window.CLIQZ.Core.urlbar.value = href;
            /* eslint-enable */
            // delegate to Firefox for full set of features like switch-to-tab
            // and all related telemetry probes
            window.CLIQZ.Core.urlbar.handleCommand(ev, newTab ? 'tab' : 'current');
          } else {
            this.findResultByUrl(href).click(window, href, ev);
          }
        }

        /*
         * Lifecycle hook
         */
        didRender() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          const allButThisResult = this.allResults.slice(1);
          allButThisResult.forEach(result => result.didRender(...args));
        }
      }

      class SupplementarySearchResult extends BaseResult {
        constructor(rawResult) {
          let allResultsFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          super(rawResult, allResultsFlat);
        }

        click(window, _, ev) {
          if (this.rawResult.data.source === 'Cliqz') {
            this.actions.query(this.suggestion);
          } else {
            // we need to delegate the search queries to Firefox to ensure
            // that their SAP probes are working as expected
            // https://firefox-source-docs.mozilla.org/browser/browser/BrowserUsageTelemetry.html#browserusagetelemetry
            // https://hg.mozilla.org/mozilla-central/file/tip/toolkit/components/telemetry/Histograms.json#l8032
            super.click(window, this.suggestion, ev);
          }
        }

        isUrlMatch(href) {
          // we need to override isUrlMatch as in some cases the value of
          // 'href' is the bare query and not a full url. Please see the comment
          // from click
          return href === this.suggestion || href === this.url;
        }

        get template() {
          return 'search';
        }

        get engines() {
          if (!this._engines) {
            this._engines = CliqzUtils.getSearchEngines();
          }

          return this._engines;
        }

        get defaultSearchEngine() {
          if (!this._defaultSearchEngine) {
            this._defaultSearchEngine = this.engines.find(se => se.default);
          }

          return this._defaultSearchEngine;
        }

        // it is not history but makes the background color to be light gray
        get isHistory() {
          // it appears as history if its a default search result or
          // as a regular result if its a suggestion
          return this.defaultSearchResult;
        }

        get isDeletable() {
          return false;
        }

        get kind() {
          const engine = this.getEngineByQuery();
          return [engine ? 'custom-search' : 'default-search'];
        }

        get icon() {
          return 'search';
        }

        get displayText() {
          const engine = this.getEngineByQuery();
          const query = this.suggestion || this.rawResult.text;

          if (engine && engine.alias) {
            return query.replace(engine.alias, '').trim();
          }

          return query;
        }

        get suggestion() {
          return this.rawResult.data.suggestion;
        }

        get query() {
          return this.suggestion;
        }

        get engine() {
          return this.rawResult.data.source || this.searchEngine.name;
        }

        get defaultSearchResult() {
          return !this.rawResult.url;
        }

        get searchEngine() {
          const engine = this.getEngineByQuery();

          if (engine) {
            return engine;
          }

          return this.defaultSearchEngine;
        }

        // returns undefined if no token go detected
        getEngineByQuery() {
          const token = this.rawResult.data.suggestion.split(' ')[0];
          const engines = this.engines;
          return engines.find(e => e.alias === token);
        }

        get url() {
          return this.rawUrl;
        }

        get rawUrl() {
          return this.searchEngine.getSubmissionForQuery(this.displayText);
        }

        get displayUrl() {
          return this.rawResult.data.suggestion;
        }
      }

      class NavigateToResult extends BaseResult {
        get template() {
          return 'navigate-to';
        }

        // it is not history but makes the background color to be light gray
        get isHistory() {
          return true;
        }

        get isDeletable() {
          return false;
        }

        get isActionSwitchTab() {
          return false;
        }

        get logo() {
          const query = this.rawResult.text;
          let url;
          if (isUrl(query)) {
            url = query;
          } else {
            url = `http://${query}`;
          }
          const urlDetails = CliqzUtils.getDetailsFromUrl(url);
          return CliqzUtils.getLogoDetails(urlDetails);
        }

        get kind() {
          return ['navigate-to'];
        }

        get url() {
          const query = this.rawResult.text;
          return `moz-action:visiturl,${JSON.stringify({ url: fixURL(query) })}`;
        }

        get rawUrl() {
          return this.rawResult.text;
        }

        get displayUrl() {
          return this.rawResult.text;
        }
      }

      function common(_ref) {
        let results = _ref.results,
            result = _ref.result,
            clickedResult = _ref.clickedResult,
            url = _ref.url;

        const now = Date.now();
        const signal = {
          type: 'activity',
          v: 3.0,
          result_order: results.kinds,
          query_length: results.query.length,
          current_position: results.indexOf(result),
          reaction_time: now - results.queriedAt,
          display_time: now - results.displayedAt,
          position_type: result.kind,
          local_source: clickedResult.localSource,
          search: CliqzUtils.isSearch(url)
        };

        if (clickedResult !== result) {
          signal.sub_result_type = clickedResult.constructor.name;
          signal.sub_result_index = result.allResults.filter(r => r instanceof clickedResult.constructor).findIndex(r => equals(r.url, url));
        }

        CliqzUtils.resultTelemetry(results.query, clickedResult.isAutocompleted || false, signal.current_position, CliqzUtils.isPrivateResultType(signal.position_type) ? '' : url, results.kinds);

        return signal;
      }

      function generateCommonStub(_ref2) {
        let query = _ref2.query;

        return {
          type: 'activity',
          v: 3.0,
          current_position: 0,
          display_time: null,
          local_source: '',
          query_length: query.length,
          reaction_time: null,
          result_order: []
        };
      }

      function enterSignal(_ref3) {
        let result = _ref3.result,
            results = _ref3.results,
            clickedResult = _ref3.clickedResult,
            query = _ref3.query,
            newTab = _ref3.newTab;

        const hasResults = result && clickedResult && results && results.query === query;

        if (hasResults && result.isCliqzAction) {
          return;
        }

        const commonParts = hasResults ? common({ results, result, clickedResult, url: clickedResult.url }) : generateCommonStub({ query });

        const enterSpecificParts = {
          action: 'result_enter',
          new_tab: newTab
        };

        if (hasResults) {
          if (result instanceof SupplementarySearchResult) {
            // TODO: use result.kind
            enterSpecificParts.position_type = ['inbar_query'];
          } else if (result instanceof NavigateToResult) {
            // TODO: use result.kind
            enterSpecificParts.position_type = ['inbar_url'];
          }
          if (result.isAutocompleted) {
            enterSpecificParts.position_type = ['inbar_url'];
            enterSpecificParts.source = commonParts.position_type;
            enterSpecificParts.autocompleted = true;
            enterSpecificParts.autocompleted_length = result.url.length;
          }
        } else {
          const isUrl$$1 = CliqzUtils.isUrl(query);
          enterSpecificParts.position_type = isUrl$$1 ? ['inbar_url'] : ['inbar_query'];
          enterSpecificParts.search = isUrl$$1 && CliqzUtils.isSearch(query);
        }

        const signal = Object.assign({}, commonParts, enterSpecificParts);

        CliqzUtils.telemetry(signal);
      }

      function clickSignal(_ref4) {
        let extra = _ref4.extra,
            coordinates = _ref4.coordinates,
            results = _ref4.results,
            result = _ref4.result,
            url = _ref4.url,
            newTab = _ref4.newTab;

        if (isCliqzAction(url)) {
          return;
        }

        const clickedResult = result.findResultByUrl(url);
        if (clickedResult) {
          const commonPart = common({ results, result, clickedResult, url });
          const signal = Object.assign({}, commonPart, {
            action: 'result_click',
            extra,
            mouse: coordinates,
            new_tab: newTab
          });

          CliqzUtils.telemetry(signal);
        }
      }

      function dropdownContextMenuSignal(_ref5) {
        var _ref5$action = _ref5.action;
        let action = _ref5$action === undefined ? 'click' : _ref5$action;
        var _ref5$context = _ref5.context;
        let context = _ref5$context === undefined ? 'dropdown' : _ref5$context,
            target = _ref5.target;

        const signal = {
          action,
          context,
          type: 'context_menu'
        };

        if (target) {
          signal.target = target;
        }

        CliqzUtils.telemetry(signal);
      }

      function removeFromHistorySignal(_ref6) {
        var _ref6$withBookmarks = _ref6.withBookmarks;
        let withBookmarks = _ref6$withBookmarks === undefined ? false : _ref6$withBookmarks;

        const signal = {
          type: 'activity',
          v: 3.0,
          action: withBookmarks ? 'remove_from_history_and_bookmarks' : 'remove_from_history'
        };

        CliqzUtils.telemetry(signal);
      }

      function copyToClipboard(text) {
        const gClipboardHelper = Components.classes['@mozilla.org/widget/clipboardhelper;1'].getService(Components.interfaces.nsIClipboardHelper);
        gClipboardHelper.copyString(text);
      }

      function reportClick(window, result) {
        CliqzEvents.pub('ui:click-on-url', {
          url: result.url,
          query: result.query,
          rawResult: result.rawResult,
          isPrivateWindow: CliqzUtils.isPrivate(window),
          isPrivateResult: CliqzUtils.isPrivateResultType(result.kind),
          isFromAutocompletedURL: false,
          windowId: CliqzUtils.getWindowID(window),
          action: 'click',
          target: 'context-menu'
        });
      }

      class ContextMenu {
        constructor(window, rootElement) {
          this.core = inject.module('core');
          this.window = window;
          this.rootElement = rootElement;
          this.inPrivateWindow = CliqzUtils.isPrivate(window);
          this.labels = this.getLocalizedStrings();
        }

        /**
         * Create context menu for given search result and show it
         * @public
         */
        show(result, _ref) {
          let x = _ref.x,
              y = _ref.y;

          const url = CliqzUtils.cleanMozillaActions(result.url)[1];

          CliqzHistoryManager.isBookmarked(url).then(isBookmarked => {
            const contextMenu = this.createMenu(result, url, isBookmarked);
            CliqzUtils.openPopup(contextMenu, {}, x, y);
            dropdownContextMenuSignal({ action: 'open' });
          });
        }

        getLocalizedStrings() {
          return {
            NEW_TAB: CliqzUtils.getLocalizedString('cMenuOpenInNewTab'),
            NEW_PRIVATE_TAB: CliqzUtils.getLocalizedString('cMenuOpenInNewPrivateTab', CliqzUtils.getLocalizedString('private')),
            NEW_FORGET_TAB: CliqzUtils.getLocalizedString('cMenuOpenInNewPrivateTab', CliqzUtils.getLocalizedString('forget')),
            NEW_WINDOW: CliqzUtils.getLocalizedString('cMenuOpenInNewWindow'),
            NEW_PRIVATE_WINDOW: CliqzUtils.getLocalizedString('cMenuOpenInPrivateWindow', CliqzUtils.getLocalizedString('private')),
            NEW_FORGET_WINDOW: CliqzUtils.getLocalizedString('cMenuOpenInPrivateWindow', CliqzUtils.getLocalizedString('forget')),
            COPY_URL: CliqzUtils.getLocalizedString('cMenuCopyLinkLocation'),
            REMOVE_FROM_HISTORY: CliqzUtils.getLocalizedString('cMenuRemoveFromHistory'),
            REMOVE_FROM_HISTORY_BOOKMARKS_AND_CLOSE: CliqzUtils.getLocalizedString('cMenuRemoveFromHistoryAndBookmarksAndCloseTab'),
            REMOVE_FROM_HISTORY_AND_BOOKMARKS: CliqzUtils.getLocalizedString('cMenuRemoveFromBookmarksAndHistory'),
            REMOVE_FROM_HISTORY_AND_CLOSE: CliqzUtils.getLocalizedString('cMenuRemoveFromHistoryAndCloseTab'),
            FEEDBACK: CliqzUtils.getLocalizedString('cMenuFeedback')
          };
        }

        createMenuItems(result, url, isBookmarked) {
          const labels = this.labels;
          const openedTabs = getTabsWithUrl(this.window, url);
          const isOpened = !!openedTabs.length;
          const isCliqzBrowser = config.settings.channel === '40';
          const PRIVATE_NAME = isCliqzBrowser ? 'FORGET' : 'PRIVATE';

          let REMOVE_ENTRY_LABEL = labels.REMOVE_FROM_HISTORY;
          if (isBookmarked && isOpened) {
            REMOVE_ENTRY_LABEL = labels.REMOVE_FROM_HISTORY_BOOKMARKS_AND_CLOSE;
          } else if (isBookmarked && !isOpened) {
            REMOVE_ENTRY_LABEL = labels.REMOVE_FROM_HISTORY_AND_BOOKMARKS;
          } else if (!isBookmarked && isOpened) {
            REMOVE_ENTRY_LABEL = labels.REMOVE_FROM_HISTORY_AND_CLOSE;
          }

          const menuItems = [{
            label: this.inPrivateWindow ? labels[`NEW_${PRIVATE_NAME}_TAB`] : labels.NEW_TAB,
            command: this.openNewTab.bind(this, url, result)
          }, ...(this.inPrivateWindow ? [] : [{
            label: labels.NEW_WINDOW,
            command: this.openNewWindow.bind(this, url, result)
          }]), {
            label: labels[`NEW_${PRIVATE_NAME}_WINDOW`],
            command: this.openInPrivateWindow.bind(this, url, result)
          }, {
            label: labels.COPY_URL,
            command: this.copyURL.bind(this, url)
          }, ...(result.isDeletable ? [{
            label: REMOVE_ENTRY_LABEL,
            command: this.removeEntry.bind(this, url, result, openedTabs)
          }] : []), {
            label: labels.FEEDBACK,
            command: this.openFeedback.bind(this, result.kind)
          }];

          return menuItems;
        }

        createMenu(result, url, isBookmarked) {
          const doc = this.window.document;
          const contextMenu = doc.createElement('menupopup');

          this.rootElement.appendChild(contextMenu);
          contextMenu.setAttribute('id', 'dropdownContextMenu');

          this.createMenuItems(result, url, isBookmarked).forEach(item => {
            const menuItem = doc.createElement('menuitem');
            menuItem.setAttribute('label', item.label);
            menuItem.addEventListener('command', item.command, false);
            menuItem.addEventListener('mouseup', e => e.stopPropagation(), false);
            contextMenu.appendChild(menuItem);
          });

          return contextMenu;
        }

        openNewWindow(url, result) {
          CliqzUtils.openLink(this.window, url, false, true);
          this.telemetry('open_new_window');
          reportClick(this.window, result);
        }

        openNewTab(url, result) {
          CliqzUtils.openLink(this.window, url, true);
          this.telemetry('open_new_tab');
          reportClick(this.window, result);
        }

        openInPrivateWindow(url, result) {
          CliqzUtils.openLink(this.window, url, false, false, true);
          this.telemetry('open_private_window');
          reportClick(this.window, result);
        }

        copyURL(url) {
          copyToClipboard(url);
        }

        removeEntry(url, _ref2) {
          let query = _ref2.query;
          let openedTabs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

          CliqzHistoryManager.removeFromHistory(url);
          if (CliqzHistoryManager.isBookmarked(url)) {
            CliqzHistoryManager.removeFromBookmarks(url);
            this.telemetry('remove_from_history_and_bookmarks');
          } else {
            this.telemetry('remove_from_history');
          }
          if (openedTabs.length) {
            openedTabs.forEach(tab => closeTab$1(this.window, tab));
          }
          this.core.action('refreshPopup', query);
        }

        openFeedback(kind) {
          CliqzUtils.openLink(this.window, `${CliqzUtils.FEEDBACK}?kind=${kind}`, true);
          this.telemetry('open_feedback');
        }

        telemetry(target) {
          dropdownContextMenuSignal({ target });
        }
      }

      class Dropdown {
        constructor(element, window, extensionID) {
          this.rootElement = element;
          this.window = window;
          this.extensionID = extensionID;
          this.onMouseUp = this.onMouseUp.bind(this);
          this.onMouseMove = this.onMouseMove.bind(this);
        }

        init() {
          this.rootElement.innerHTML = templates.main(this.extensionID);
          this.dropdownElement.addEventListener('mouseup', this.onMouseUp);
          this.dropdownElement.addEventListener('mousemove', this.onMouseMove);
          this.contextMenu = new ContextMenu(this.window, this.dropdownElement);
          this.dropdownElement.style.setProperty('--url-padding-start', '50px');
        }

        get dropdownElement() {
          return this.rootElement.querySelector('#cliqz-dropdown');
        }

        get selectedResult() {
          return this.results.get(this.selectedIndex);
        }

        nextResult() {
          if (this.selectedIndex === this.results.length - 1) {
            this.selectedIndex = 0;
          } else {
            this.selectedIndex += 1;
          }

          return this.updateSelection();
        }

        previousResult() {
          if (this.selectedIndex <= 0) {
            this.selectedIndex = this.results.length - 1;
          } else {
            this.selectedIndex -= 1;
          }

          return this.updateSelection();
        }

        clearSelection() {
          [...this.rootElement.querySelectorAll('a')].forEach(anchor => anchor.classList.remove('selected'));
        }

        selectResult(result) {
          const el = [...this.rootElement.querySelectorAll('a')].find(a => equals(a.dataset.url, result.url));
          if (!el) {
            return;
          }
          el.classList.add('selected');
        }

        updateSelection() {
          this.clearSelection();
          this.selectResult(this.selectedResult);
          return this.selectedResult;
        }

        renderResults(results) {
          this.selectedIndex = 0;
          this.results = results;

          // Render and insert templates
          const html = templates.results({ results: results.results });
          this.dropdownElement.innerHTML = html;
          this.dropdownElement.style.maxHeight = `${this.window.innerHeight - 140}px`;

          // Nofify results that have been rendered
          results.results.forEach(result => {
            if (!result.didRender) {
              return;
            }
            result.didRender(this.dropdownElement);
          });

          // prevent default behavior of anchor tags
          [...this.rootElement.querySelectorAll('a')].forEach(anchor => {
            anchor.setAttribute('onclick', 'return false;');
            anchor.setAttribute('onmousedown', 'return false;');
          });

          this.selectResult(this.results.firstResult);

          const historyResults = this.rootElement.querySelectorAll('.history');
          if (historyResults.length > 0) {
            historyResults[historyResults.length - 1].classList.add('last');
          }
        }

        onMouseUp(ev) {
          let targetElement = ev.originalTarget;

          if (targetElement.nodeType !== 1) {
            targetElement = targetElement.parentElement;
          }

          const resultElement = targetElement.closest('.result');

          if (!resultElement) {
            return;
          }

          const extraElement = targetElement.closest('[data-extra]');
          const extra = extraElement ? extraElement.dataset.extra : null;
          const href = resultElement.dataset.url;
          const coordinates = [ev.offsetX, ev.offsetY, this.rootElement.clientWidth, this.rootElement.clientHeight];
          const result = this.results.find(href);
          if (!result) {
            return;
          }

          if (ev.button === 2) {
            const subresult = isCliqzAction(href) ? result : result.findResultByUrl(href);
            this.contextMenu.show(subresult, { x: ev.screenX, y: ev.screenY });
          } else {
            result.click(this.window, href, ev);

            clickSignal({
              extra,
              coordinates,
              results: this.results,
              result,
              url: href,
              newTab: ev.altKey || ev.metaKey || ev.ctrlKey
            });
          }
        }

        onMouseMove(ev) {
          let targetElement = ev.originalTarget;

          if (targetElement.nodeType !== 1) {
            targetElement = targetElement.parentElement;
          }

          if (this.lastTarget === targetElement) {
            return;
          }

          this.lastTarget = targetElement;

          const now = Date.now();
          if (now - this.lastMouseMove < 10) {
            return;
          }
          this.lastMouseMove = now;

          // TODO: merge with onMouseUp handler
          const resultElement = targetElement.closest('.result');

          if (!resultElement) {
            this.clearSelection();
            return;
          }

          if (resultElement.classList.contains('non-selectable')) {
            return;
          }

          const href = resultElement.dataset.url;
          const resultIndex = this.results.selectableResults.findIndex(r => equals(r.url, href));

          if (resultIndex !== -1) {
            this.clearSelection();
            this.selectedIndex = resultIndex;
            this.updateSelection();
          } else {
            this.clearSelection();
          }
        }
      }

      class LocalInfoResult extends BaseResult {
        get mapImg() {
          return this.rawResult.mapImg;
        }
      }

      class TextResult extends BaseResult {
        get textType() {
          return this.rawResult.textType;
        }

        get displayText() {
          return this.rawResult.text;
        }

        click(window, href, ev) {
          this.actions.copyToClipboard(this.rawResult.text);
          const el = ev.target;
          el.classList.add('copied');
          setTimeout(() => {
            el.classList.remove('copied');
          }, 1000);
        }
      }

      class ShareLocationButton extends BaseResult {
        get elementId() {
          if (!this._elementId) {
            const id = Math.floor(Math.random() * 1000);
            this._elementId = `result-share-location-${id}`;
          }
          return this._elementId;
        }

        get displayUrl() {
          return this.rawResult.text;
        }

        get className() {
          return this.rawResult.className;
        }

        get elementClassName() {
          return this.rawResult.className;
        }

        didRender(dropdownElement) {
          super.didRender(dropdownElement); // TODO @mai do we need this?

          this.element = dropdownElement.querySelector(`#${this.elementId}`);
          this.spinner = dropdownElement.ownerDocument.createElement('div');
          this.spinner.className = 'spinner';
        }

        click(window, href) {
          this.element.appendChild(this.spinner);

          const action = JSON.parse(href.split('cliqz-actions,')[1]);
          const locationAssistant = this.actions.locationAssistant;
          const actionName = action.actionName;
          if (!locationAssistant.hasAction(actionName)) {
            return;
          }

          const signal = {
            type: 'results',
            action: 'click',
            view: 'local'
          };
          if (actionName === 'allowOnce') {
            signal.target = 'share_location_once';
            CliqzUtils.telemetry(signal);
          } else if (actionName === 'allow') {
            signal.target = 'share_location_always';
            CliqzUtils.telemetry(signal);
          }

          locationAssistant[actionName]().then(() => {
            this.rawResult.onButtonClick();
          }).catch(console$1.error);
        }
      }

      class LocalResult extends BaseResult {
        get extra() {
          return this.rawResult.extra || {};
        }

        get address() {
          const address = this.extra.address || '';

          if (!address) {
            return null;
          }

          const addressResult = new TextResult({
            url: `cliqz-actions,${JSON.stringify({ type: 'location', actionName: 'copyAddress' })}`,
            text: address,
            textType: 'local-address'
          });
          addressResult.actions = this.actions;

          return addressResult;
        }

        get phoneNumber() {
          const phone = this.extra.phonenumber || '';

          if (!phone) {
            return null;
          }

          const phoneResult = new TextResult({
            url: `cliqz-actions,${JSON.stringify({ type: 'location', actionName: 'copyPhoneNumber' })}`,
            text: phone,
            textType: 'local-phone'
          });
          phoneResult.actions = this.actions;

          return phoneResult;
        }

        get mapImg() {
          return this.extra.map_img || '';
        }

        get mapUrl() {
          return this.extra.mu || '';
        }

        get allResults() {
          return [this.mapResult, ...this.textResults];
        }

        get mapResult() {
          return new LocalInfoResult({
            url: this.mapUrl,
            title: 'show-map',
            text: this.rawResult.text,
            mapImg: this.mapImg
          });
        }

        get textResults() {
          if (!this._textResults) {
            this._textResults = [];
            if (this.address) {
              this._textResults.push(this.address);
            }

            if (this.phoneNumber) {
              this._textResults.push(this.phoneNumber);
            }
          }

          return this._textResults;
        }

        get distance() {
          if (this.extra.lat && this.extra.lon) {
            const distance = CliqzUtils.distance(this.extra.lon, this.extra.lat) * 1000;
            if (distance > -1) {
              return distance;
            }
          }

          if (this.extra.distance) {
            return this.extra.distance;
          }

          return null;
        }

        get ratingImg() {
          const rating = this.extra.rating;
          if (!rating) {
            return null;
          }

          const ratingStars = Math.max(0, Math.min(Math.round(rating), 5));
          return `https://cdn.cliqz.com/extension/EZ/richresult/stars${ratingStars}.svg`;
        }

        parseTime(timeStr) {
          // e.g. timeStr: 10.30
          const time = timeStr.split('.');
          return {
            hours: parseInt(time[0], 10) || 0,
            minutes: parseInt(time[1], 10) || 0
          };
        }

        get openingStatus() {
          const openingHours = this.extra.opening_hours;
          if (!openingHours) {
            return null;
          }

          const OPENING_COLORS = {
            open: '#A6A6A6',
            closed: '#E64C66',
            open_soon: '#A6A6A6',
            close_soon: '#E64C66'
          };

          let openStatus;
          const timeInfos = [];

          openingHours.filter(el => el.open && el.close).forEach(el => {
            if (openStatus && openStatus !== 'closed') {
              return;
            }

            timeInfos.push(`${el.open.time.replace('.', ':')}-${el.close.time.replace('.', ':')}`);

            const openTime = this.parseTime(el.open.time);
            const closeTime = this.parseTime(el.close.time);
            const t = new Date();
            const minutes = {
              opening: 60 * openTime.hours + openTime.minutes,
              closing: 60 * closeTime.hours + closeTime.minutes
            };

            const now = 60 * t.getHours() + t.getMinutes();

            openStatus = 'closed';

            if (minutes.opening < minutes.closing) {
              if (minutes.opening <= now && now <= minutes.closing - 60) {
                openStatus = 'open';
              }

              if (minutes.closing - 60 < now && now < minutes.closing) {
                openStatus = 'close_soon';
              }
            } else {
              if (minutes.opening <= now || minutes.closing - 60 >= now) {
                openStatus = 'open';
              }

              if (minutes.closing > now && now > minutes.closing - 60) {
                openStatus = 'close_soon';
              }
            }

            const difference = ((minutes.opening - now) % 1440 + 1440) % 1440;
            if (difference < 60) {
              openStatus = 'open_soon';
            }
          });

          if (openStatus) {
            return {
              color: OPENING_COLORS[openStatus],
              sttText: openStatus,
              timeInfo: timeInfos.join(', ')
            };
          }

          return null;
        }
      }

      class TextResult$1 extends BaseResult {
        click(window, href, ev) {
          this.actions.copyToClipboard(this.rawResult.title);
          const el = ev.target;
          el.classList.add('copied');

          const signal = {
            type: 'offrz',
            action: 'click',
            view: 'search',
            target: 'copy'
          };

          CliqzUtils.telemetry(signal);
        }
      }

      class OfferResult$1 extends BaseResult {
        get _offerData() {
          return this.rawResult.offerData;
        }

        get offerSource() {
          if (!this._offerData.is_injected) {
            return null;
          }

          return new BaseResult({
            url: this._offerData.url_ad,
            title: this._offerData.title,
            text: this.rawResult.text
          });
        }

        get thumbnail() {
          return this._offerData.thumbnail;
        }

        get showThumbnail() {
          return this.rawResult.showThumbnail;
        }

        get promoCode() {
          const result = new TextResult$1({
            url: `cliqz-actions,${JSON.stringify({ type: 'offer', actionName: 'copy' })}`,
            text: this.rawResult.text,
            title: this._offerData.promo_code
          });
          result.actions = this.actions;

          return result;
        }

        get allResults() {
          return [this.promoCode, ...(this.offerSource ? [this.offerSource] : [])];
        }
      }

      class OffersResult extends BaseResult {
        constructor(rawResult, allResultsFlat) {
          var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          let offers = _ref.offers;

          if (!offers.isEnabled) {
            throw new Error('ignore');
          }

          super(rawResult, allResultsFlat);

          this.style = offers.nonOrganicStyle;
        }

        get template() {
          return this.style === 'rich' ? 'offer' : 'generic';
        }

        get _extra() {
          return this.rawResult.data.extra || {};
        }

        get displayUrl() {
          return this.url;
        }

        get friendlyUrl() {
          const urlDetails = CliqzUtils.getDetailsFromUrl(this.url);
          return urlDetails.friendly_url;
        }

        get _offerData() {
          return this._extra.offers_data || {};
        }

        get offerResult() {
          if (this.style !== 'rich') {
            return null;
          }

          const result = new OfferResult$1({
            offerData: this._offerData,
            text: this.query
          });

          result.actions = this.actions;

          return result;
        }

        get allResults() {
          return [...super.selectableResults, ...(this.offerResult ? this.offerResult.allResults : [])];
        }
      }

      class NewsResult extends BaseResult {
        get logo() {
          if (this.rawResult.showLogo) {
            return super.logo;
          }

          return null;
        }

        get logoDetails() {
          if (this.thumbnail === '') {
            return super.logo;
          }

          return null;
        }

        get thumbnail() {
          return this.rawResult.thumbnail;
        }

        get tweetCount() {
          return this.rawResult.tweet_count;
        }

        get publishedAt() {
          return this.rawResult.creation_time;
        }

        get friendlyUrl() {
          return this.rawResult.domain;
        }
      }

      class VideoResult extends BaseResult {
        get videoViews() {
          return this.rawResult.views;
        }

        secondsToDuration(s) {
          if (!s) {
            return null;
          }

          const date = new Date(null);
          date.setSeconds(s);
          let result = date.toISOString().substr(11, 8);
          if (result.indexOf('00:') === 0) {
            result = result.substr(3, 5);
          }

          return result;
        }

        get duration() {
          return this.secondsToDuration(this.rawResult.duration);
        }

        get thumbnail() {
          return this.rawResult.thumbnail;
        }

        get logo() {
          return null;
        }
      }

      class ImageResult extends BaseResult {
        get thumbnail() {
          return this.rawResult.thumbnail;
        }
      }

      class InternalResult extends BaseResult {}

      class SocialResult extends BaseResult {}

      class AnchorResult extends BaseResult {}

      class GenericResult extends BaseResult {
        constructor(rawResult, allResultsFlat) {
          var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          let offers = _ref.offers;

          super(rawResult, allResultsFlat);
          this.internalResultsLimit = 4;

          if (offers) {
            this.offerStyle = offers.organicStyle;
            this.offerEnabled = offers.isEnabled;
          }
        }

        // cannot limit here - inheriting results may like to have filtering
        get internalResults() {
          if (this.isAskingForLocation) {
            // Hide these buttons when asking for location sharing
            return [];
          }
          const deepLinks = getDeepResults(this.rawResult, 'buttons');

          return deepLinks.map(_ref2 => {
            let url = _ref2.url,
                title = _ref2.title;
            return new InternalResult({
              url,
              title,
              text: this.query
            });
          });
        }

        get socialResults() {
          const deepLinks = getDeepResults(this.rawResult, 'social');

          return deepLinks.map(_ref3 => {
            let url = _ref3.url,
                image = _ref3.image;
            return new SocialResult({
              url,
              image,
              text: this.query
            });
          });
        }

        get imageResults() {
          const deepLinks = getDeepResults(this.rawResult, 'images');
          return deepLinks.map(_ref4 => {
            let image = _ref4.image,
                extra = _ref4.extra;
            return new ImageResult({
              url: extra && extra.original_image || image,
              thumbnail: image,
              text: this.query
            });
          });
        }

        get anchorResults() {
          const deepLinks = getDeepResults(this.rawResult, 'simple_links');
          return deepLinks.map(_ref5 => {
            let url = _ref5.url,
                title = _ref5.title;
            return new AnchorResult({
              url,
              title,
              text: this.query
            });
          });
        }

        get newsResults() {
          var _this = this;

          const deepLinks = getDeepResults(this.rawResult, 'news');
          return deepLinks.map(function () {
            var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            let url = _ref6.url,
                title = _ref6.title;
            var _ref6$extra = _ref6.extra;
            let extra = _ref6$extra === undefined ? {} : _ref6$extra;
            return new NewsResult({
              url,
              domain: extra.domain,
              title,
              thumbnail: extra.thumbnail,
              description: extra.description,
              creation_time: extra.creation_timestamp,
              tweet_count: extra.tweet_count,
              showLogo: _this.url && CliqzUtils.getDetailsFromUrl(_this.url).domain !== CliqzUtils.getDetailsFromUrl(url).domain,
              text: _this.query
            });
          });
        }

        get videoResults() {
          const deepLinks = getDeepResults(this.rawResult, 'videos');
          return deepLinks.map(_ref7 => {
            let url = _ref7.url,
                title = _ref7.title,
                extra = _ref7.extra;
            return new VideoResult({
              url,
              title,
              thumbnail: extra.thumbnail,
              duration: extra.duration,
              views: extra.views,
              text: this.query
            });
          });
        }

        /**
         * To be used with the `with` statement in the template
         */
        get shareLocationButtonsWrapper() {
          return {
            internalResults: this.shareLocationButtons,
            internalResultsLimit: 3,
            logo: null
          };
        }

        get isAskingForLocation() {
          const extra = this.rawResult.data.extra || {};
          return (extra.no_location || false) && this.actions.locationAssistant.isAskingForLocation;
        }

        get selectableResults() {
          return [...super.selectableResults, ...this.shareLocationButtons, ...this.newsResults.slice(0, 3), ...this.videoResults.slice(0, 3), ...this.internalResults.slice(0, this.internalResultsLimit)];
        }

        get allResults() {
          return [...super.allResults, ...this.socialResults, ...this.imageResults, ...this.anchorResults, ...(this.localResult ? [...this.localResult.allResults] : []), ...(this.offerResult ? [...this.offerResult.allResults] : [])];
        }

        get shareLocationButtons() {
          const locationAssistant = this.actions.locationAssistant;

          if (!this._shareLocationButtons) {
            this._shareLocationButtons = !this.isAskingForLocation ? [] : locationAssistant.actions.map(action => {
              let additionalClassName = '';
              if (action.actionName === 'allowOnce') {
                additionalClassName = 'location-allow-once';
              }

              const result = new ShareLocationButton({
                title: action.title,
                url: `cliqz-actions,${JSON.stringify({ type: 'location', actionName: action.actionName })}`,
                text: this.rawResult.text,
                className: additionalClassName,
                locationAssistant,
                onButtonClick: () => {
                  this.actions.getSnippet(this.query, this.rawResult).then(snippet => {
                    const newRawResult = Object.assign({}, this.rawResult);
                    newRawResult.data.extra = Object.assign({}, newRawResult.data.extra, snippet.extra);

                    const newResult = new this.constructor(newRawResult, [], {
                      offers: {
                        isEnabled: this.offerEnabled,
                        organicStyle: this.offerStyle
                      }
                    });
                    newResult.actions = this.actions;
                    this.actions.replaceResult(this, newResult);
                  }).catch(console$1.error);
                }
              });
              result.actions = this.actions;

              return result;
            });
          }
          return this._shareLocationButtons;
        }

        get localResult() {
          const extra = this.rawResult.data.extra || {};
          if (!extra.address && !extra.phonenummber) {
            return null;
          }

          const result = new LocalResult({
            extra,
            text: this.query
          });

          result.actions = this.actions;
          return result;
        }

        get offerResult() {
          const extra = this.rawResult.data.extra || {};
          const offerData = extra.offers_data || {};
          if (this.isAd || !offerData.is_injected || !this.offerEnabled) {
            return null;
          }

          const result = new OfferResult$1({
            offerData,
            showThumbnail: this.offerStyle === 'rich',
            text: this.query
          });

          result.actions = this.actions;
          return result;
        }
      }

      class CalculatorResult extends BaseResult {
        get template() {
          return 'calculator';
        }

        get displayUrl() {
          return this.rawResult.text;
        }

        get query() {
          return (this.rawResult.data.extra || {}).expression || this.rawResult.text;
        }

        get result() {
          return this.rawResult.title || (this.rawResult.data.extra || {}).answer;
        }

        get title() {
          return this.rawResult.title;
        }

        get url() {
          return `cliqz-actions,${JSON.stringify({ type: 'calculator', actionName: 'copy' })}`;
        }

        get allResults() {
          return [this];
        }

        get selectableResults() {
          return [];
        }

        didRender($dropdown) {
          this.$calculator = $dropdown.querySelector('.calculator');
          this.$tooltip = this.$calculator.querySelector('.tooltip');
        }

        click() {
          copyToClipboard(this.rawResult.title);
          this.$tooltip.innerText = CliqzUtils.getLocalizedString('Copied');
          setTimeout(() => {
            this.$tooltip.style.display = 'none';
          }, 1000);
        }
      }

      class TimeResult extends GenericResult {
        get template() {
          return 'time';
        }

        get extra() {
          return this.rawResult.data.extra || {};
        }

        get answer() {
          return this.extra.answer;
        }

        get location() {
          return this.extra.mapped_location;
        }

        get expression() {
          return this.extra.expression;
        }

        get timeZone() {
          return this.extra.line3;
        }

        get selectableResults() {
          return [];
        }
      }

      class CurrencyResult extends BaseResult {
        get template() {
          return 'currency';
        }

        get url() {
          return `cliqz-actions,${JSON.stringify({ type: 'currency', actionName: 'copy' })}`;
        }

        get toAmount() {
          return this.rawResult.data.extra.toAmount.main;
        }

        get fromAmount() {
          return this.rawResult.data.extra.fromAmount;
        }

        get toCurrency() {
          return this.rawResult.data.extra.toCurrency;
        }

        get toCurrencyName() {
          const extra = this.rawResult.data.extra;
          return extra.toCurrencyName || this.toCurrency;
        }

        // FIXME: symbols not displayed (encoding issue?)
        get toSymbol() {
          return this.rawResult.data.extra.toSymbol || this.rawResult.data.extra.toCurrency;
        }

        get fromCurrency() {
          return this.rawResult.data.extra.fromCurrency;
        }

        // FIXME: symbols not displayed (encoding issue?)
        get fromSymbol() {
          // API v2 uses 'formCurrency' instead of 'fromCurrency'
          return this.rawResult.data.extra.formCurrency || this.rawResult.data.extra.fromCurrency;
        }

        get multiplyer() {
          return this.rawResult.data.extra.multiplyer;
        }

        get conversionRate() {
          return this.rawResult.data.extra.mConversionRate;
        }

        get allResults() {
          return [this];
        }

        get selectableResults() {
          return [];
        }

        didRender($dropdown) {
          this.$currency = $dropdown.querySelector('.currency');
          this.$tooltip = this.$currency.querySelector('.tooltip');
        }

        updateTooltip(text) {
          this.$tooltip.innerText = text;
        }

        hideTooltip() {
          this.$tooltip.style.display = 'none';
        }

        click() {
          copyToClipboard(this.toAmount);
          this.$tooltip.innerText = CliqzUtils.getLocalizedString('Copied');
          setTimeout(() => {
            this.$tooltip.style.display = 'none';
          }, 1000);
        }

        get sourceWrapper() {
          return {
            url: this.rawUrl,
            source: this.source
          };
        }
      }

      class WeatherResult extends BaseResult {
        get template() {
          return 'weather';
        }

        get todayDate() {
          return this.rawResult.data.extra.todayWeekday;
        }

        get today() {
          const extra = this.rawResult.data.extra;
          return {
            date: extra.todayWeekday,
            icon: extra.todayIcon,
            minTemp: extra.todayMin,
            maxTemp: extra.todayMax
          };
        }

        get forecast() {
          return this.rawResult.data.extra.forecast;
        }

        get allResults() {
          return [this, ...this.selectableResults];
        }

        get selectableResults() {
          return [];
        }
      }

      class LottoButton extends BaseResult {
        get displayUrl() {
          return this.rawResult.text;
        }

        get elementId() {
          return this.rawResult.elementId;
        }

        click() {
          this.rawResult.onClick();
        }
      }

      class LottoResult extends GenericResult {
        get template() {
          return 'lotto';
        }

        get currentLottoType() {
          const extra = this.rawResult.data.extra || {};
          return extra.lotto_type || 'unknown';
        }

        get lottoList() {
          const extra = this.rawResult.data.extra || {};
          const key = Object.keys(extra.lotto_list)[0];
          return extra.lotto_list[key] || {};
        }

        get locale() {
          return 'de-DE'; // Force to show German only
        }

        get localeDate() {
          const options = { weekday: 'long', year: 'numeric', month: 'numeric', day: 'numeric' };
          const date = this.lottoList.date;
          if (date) {
            return new Date(date).toLocaleDateString(this.locale, options);
          }
          return '';
        }

        get lottoResults() {
          let results = [];

          switch (this.currentLottoType) {
            case '6aus49':
              results = this.get6aus49Results;
              break;
            case 'eurojackpot':
              results = this.getEurojackpotResults;
              break;
            case 'keno':
              results = this.getKenoResults;
              break;
            case 'glueckspirale':
              results = this.getGlueckspiraleResults;
              break;
            default:
              results = [];
          }
          return results;
        }

        get get6aus49Results() {
          const lotto = this.lottoList.lotto;
          const spiel77 = this.lottoList.spiel77;
          const super6 = this.lottoList.super6;

          return [{
            result: lotto.gewinnzahlen.concat(lotto.superzahl),
            classNames: 'circle highlight-last',
            description: 'lotto-superzahl'
          }, {
            result: ['Spiel77'].concat(spiel77.gewinnzahlen.split('')),
            classNames: 'normal bold-first'
          }, {
            result: ['Super6'].concat(super6.gewinnzahlen.split('')),
            classNames: 'normal bold-first'
          }];
        }

        get getEurojackpotResults() {
          const ej = this.lottoList.ej;

          return [{
            result: ej.gewinnzahlen,
            classNames: 'circle',
            description: 'lotto-5aus50'
          }, {
            result: ej.zwei_aus_acht,
            classNames: 'circle',
            description: 'lotto-2aus8'
          }];
        }

        get getKenoResults() {
          const keno = this.lottoList.keno;
          const plus5 = this.lottoList.plus5;

          return [{
            result: keno.gewinnzahlen.slice(0, 10)
          }, {
            result: keno.gewinnzahlen.slice(10, 20)
          }, {
            result: ['plus5'].concat(plus5.gewinnzahlen.split('')),
            classNames: 'normal bold-first'
          }];
        }

        getTableData(rawData) {
          const gs = rawData;
          const dataSet = [];
          const romanNumber = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
          const nKlasse = 7;

          for (let i = 0; i < nKlasse; i += 1) {
            const klasse = romanNumber[i];
            const currenRow = gs.gewinnzahlen[i];
            const gewinnzahlen = typeof currenRow === 'string' ? [currenRow] : currenRow;
            let monatlich = '';

            const currency = gs.waehrung === 'EUR' ? CliqzUtils.getLocalizedString('lotto-euro') : '';
            const rente = CliqzUtils.getLocalizedString('lotto-rente');

            const anzahl = parseFloat(gs.quoten[i].anzahl).toLocaleString(this.locale, { minimumFractionDigits: 1 }).concat('x');
            let quote = parseFloat(gs.quoten[i].quote).toLocaleString(this.locale, { minimumFractionDigits: 2 }).concat(currency);

            if (gs.quoten[i].text) {
              monatlich = gs.quoten[i].text.split(' ')[0];
              quote = [quote].concat(`(${monatlich}${currency} ${rente})`);
            }

            dataSet.push([klasse, gewinnzahlen, anzahl, quote]);
          }

          return dataSet;
        }

        get getGlueckspiraleResults() {
          const gs = this.lottoList.gs;

          const lottoResults = [{
            result: gs.gewinnzahlen[6][0].split(''),
            description: 'lotto-gewinnklasse7'
          }, {
            result: gs.gewinnzahlen[6][1].split(''),
            description: 'lotto-gewinnklasse7'
          }];

          if (this.showTable) {
            lottoResults.push({
              table: {
                data: this.getTableData(gs),
                columns: ['lotto-klasse', 'lotto-gewinnzahlen', 'lotto-gewinne', 'lotto-quoten']
              }
            });
          }
          return lottoResults;
        }

        get showExpandButton() {
          // Temporarily disable the 'expand' button
          return false; // return this.currentLottoType === 'glueckspirale';
        }

        get internalResults() {
          const buttons = [];
          if (this.showExpandButton && !this.showTable) {
            buttons.push(new LottoButton({
              title: 'lotto-expand',
              url: `cliqz-actions,${JSON.stringify({ type: 'lotto', actionName: 'expand' })}`,
              text: this.rawResult.text,
              elementId: 'lotto-expand-button',
              onClick: () => {
                this.showTable = true;
                this.actions.replaceResult(this, this);
              }
            }));
          }
          return [...buttons, ...super.internalResults];
        }
      }

      var _extends$4 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      class HistoryResult extends BaseResult {
        get isHistory() {
          return true;
        }
      }

      class HistoryCluster extends GenericResult {
        constructor(rawResult) {
          let allResultsFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          super(rawResult, allResultsFlat);
        }

        get isHistory() {
          return true;
        }

        get template() {
          return 'history';
        }

        get description() {
          return null;
        }

        get results() {
          if (!this.historyResults) {
            this.historyResults = this.rawResult.data.urls.map(rawResult => new HistoryResult(_extends$4({}, rawResult, {
              url: rawResult.href,
              bulletLogo: true,
              isCluster: true,
              text: this.rawResult.text
            })));
          }
          return this.historyResults;
        }

        get internalResults() {
          const resultUrls = this.results.map(r => r.url);
          return super.internalResults.filter(result => !resultUrls.some(url => equals(result.url, url)));
        }

        get selectableResults() {
          return [...(this.url ? [this] : []), ...this.newsResults, ...this.results, ...this.internalResults.slice(0, this.internalResultsLimit)];
        }

        get internalResultsLogo() {
          const internalResults = this.internalResults || [];
          return internalResults.length > 0 ? this.logo : null;
        }

        // only include news in history cluster for new mixer
        get newsResults() {
          if (prefs.get('searchMode', 'autocomplete') !== 'search') {
            return [];
          }
          return super.newsResults;
        }

        // only include lotto in history cluster for new mixer
        get lottoResults() {
          if (prefs.get('searchMode', 'autocomplete') !== 'search') {
            return [];
          }

          const lottoResult = new LottoResult(this.rawResult);
          return lottoResult.lottoResults;
        }
      }

      var _extends$5 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const sessionsUrl = query => [config.settings.HISTORY_URL, config.settings['modules.history.search-path'], encodeURIComponent(query)].join('');

      class SessionsResult extends BaseResult {
        constructor(rawResult) {
          super(_extends$5({}, rawResult, {
            url: sessionsUrl(rawResult.text)
          }));
        }

        get elementId() {
          return `result-sessions-${this.rawResult.text}`;
        }

        get template() {
          return 'sessions';
        }

        get displayUrl() {
          return this.rawResult.text;
        }

        get isHistory() {
          return true;
        }

        get isDeletable() {
          return false;
        }

        click(window, href, ev) {
          // Let Firefox handle the urlbar value
          super.click(window, this.rawResult.url, ev);
        }
      }

      class AdultAnswerResult extends BaseResult {
        get displayUrl() {
          return this.rawResult.text;
        }

        get className() {
          return this.rawResult.className;
        }

        click(window, href) {
          const action = JSON.parse(href.split('cliqz-actions,')[1]);
          const adultAssistant = this.actions.adultAssistant;
          const actionName = action.actionName;
          if (!adultAssistant.hasAction(actionName)) {
            return;
          }
          adultAssistant[actionName]().then(() => {
            this.rawResult.onButtonClick();
          });
        }
      }

      class AdultQuestionResult extends BaseResult {
        get template() {
          return 'adult-question';
        }

        get internalResults() {
          return this.actions.adultAssistant.actions.map(action => {
            let additionalClassName = '';

            if (action.actionName === 'allowOnce') {
              additionalClassName = 'adult-allow-once';
            }

            const result = new AdultAnswerResult({
              title: action.title,
              url: `cliqz-actions,${JSON.stringify({ type: 'adult', actionName: action.actionName })}`,
              text: this.rawResult.text,
              className: additionalClassName,
              onButtonClick: this.rawResult.onButtonClick
            });
            result.actions = this.actions;
            return result;
          });
        }

        get selectableResults() {
          return this.internalResults;
        }
      }

      class Suggestion extends BaseResult {
        get displayText() {
          return this.rawResult.displayText;
        }

        get displayUrl() {
          return this.displayText;
        }

        click() {
          this.rawResult.onClick();
        }
      }

      class SuggestionsResult extends GenericResult {
        constructor(rawResult) {
          let allResultsFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          super(rawResult, allResultsFlat);

          this.rawResult.data.suggestions = this.rawResult.data.suggestions.filter(s => {
            const url = `https://cliqz.com/search?q=${s}`;
            if (allResultsFlat.some(u => equals(u, url))) {
              return false;
            }
            allResultsFlat.push(url);
            return true;
          });

          this.suggestionsLimit = 3;
        }

        get template() {
          return 'suggestions';
        }

        // it is not history but makes the background color to be light gray
        get isHistory() {
          return false;
        }

        get isDeletable() {
          return false;
        }

        get suggestionResults() {
          return this.rawResult.data.suggestions.map(s => new Suggestion({
            url: `https://cliqz.com/search?q=${s}`,
            text: this.rawResult.text,
            displayText: s,
            onClick: () => {
              this.actions.updateTabQuery(s);
              this.actions.query(s);
            }
          }));
        }

        get suggestionAvailable() {
          return this.suggestionResults.length > 0;
        }

        get kind() {
          return ['inline-suggestion'];
        }

        get selectableResults() {
          return this.suggestionResults.slice(0, this.suggestionsLimit);
        }

        get icon() {
          return 'search';
        }

        get defaultSearchResult() {
          return this.rawResult.defaultSearchResult || false;
        }

        get url() {
          return '';
        }
      }

      const LIMIT = {
        ligaEZ1Game: {
          rowsLimit: 2,
          maxRowsLimit: 10
        },
        liveTicker: {
          rowsLimit: 2,
          maxRowsLimit: 10
        },
        ligaEZTable: {
          rowsLimit: 6,
          maxRowsLimit: 20
        },
        ligaEZGroup: {
          rowsLimit: 4,
          maxRowsLimit: 4
        }
      };

      class ExpandButton extends BaseResult {
        get displayUrl() {
          return this.rawResult.text;
        }

        get show() {
          return this.rawResult.show;
        }

        click() {
          this.rawResult.onClick();
        }
      }

      class LiveTickerResult extends BaseResult {
        get locale() {
          return CliqzUtils.getLocalizedString('locale_lang_code');
        }

        getTime(gameTime) {
          const options = {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          };

          const date = gameTime;

          if (date) {
            return new Date(Number(date) * 1000).toLocaleDateString(this.locale, options);
          }

          return '';
        }

        get host() {
          return this.rawResult.match.HOST;
        }

        get hostLogo() {
          return this.rawResult.match.hostLogo;
        }

        get scored() {
          return this.rawResult.match.scored || '- : -';
        }

        get guest() {
          return this.rawResult.match.GUESS;
        }

        get guestLogo() {
          return this.rawResult.match.guestLogo;
        }

        get gameTime() {
          return this.getTime(this.rawResult.match.gameUtcTimestamp);
        }

        get liveOn() {
          return this.rawResult.match.tvChannelLogo;
        }

        get isLive() {
          return this.rawResult.match.isLive;
        }

        get leagueLogo() {
          return this.rawResult.match.leagueLogo;
        }

        get leagueName() {
          return this.rawResult.match.leagueName;
        }
      }

      class LiveTickerRound extends GenericResult {
        get round() {
          return this.rawResult.round;
        }

        get isCurrent() {
          return this.rawResult.isCurrent;
        }

        get allResults() {
          return this.rawResult.week.matches.map(match => new LiveTickerResult({
            match,
            text: this.rawResult.text,
            url: match.live_url
          }));
        }
      }

      class TableItemResult extends BaseResult {
        get rank() {
          return this.rawResult.item.rank;
        }

        get logo() {
          return this.rawResult.item.logo;
        }

        get club() {
          return this.rawResult.item.club;
        }

        get played() {
          return this.rawResult.item.SP;
        }

        get won() {
          return this.rawResult.item.S;
        }

        get lost() {
          return this.rawResult.item.N;
        }

        get drawn() {
          return this.rawResult.item.U;
        }

        get goals() {
          return this.rawResult.item.goals;
        }

        get goalsDiff() {
          return this.rawResult.item.TD;
        }

        get points() {
          return this.rawResult.item.PKT;
        }

        get qualified() {
          return `${config.baseURL}dropdown/images/champions-league.png`;
        }
      }

      class TableResult extends BaseResult {
        get tableHeader() {
          const infoList = this.rawResult.infoList;

          return {
            rank: infoList.rank,
            club: infoList.club,
            played: infoList.SP,
            won: infoList.S,
            lost: infoList.N,
            drawn: infoList.U,
            goals: infoList.goals,
            goalsDiff: infoList.TD,
            points: infoList.PKT
          };
        }

        get tableData() {
          const results = this.rawResult.ranking.map(item => new TableItemResult({
            item
          }));

          return results;
        }

        get table() {
          return {
            header: this.tableHeader,
            data: this.tableData,
            rowsLimit: this.rawResult.itemsLimit
          };
        }
      }

      class TableGroup extends BaseResult {
        get groupName() {
          return this.rawResult.groupName;
        }

        get ligaEZTable() {
          return this.rawResult.ligaEZTable;
        }
      }

      class SoccerSubResult extends BaseResult {}

      class SoccerResult extends GenericResult {
        constructor(rawResult) {
          let allResultsFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          super(rawResult, allResultsFlat);

          // De-duplicate sub result from extra
          if (allResultsFlat.indexOf(rawResult.data.extra.url) >= 0) {
            delete this.rawResult.data.extra.url;
            delete this.rawResult.data.extra.title;
          } else {
            allResultsFlat.push(rawResult.data.extra.url);
          }

          this.internalResultsLimit = 4;
          this.newsResultsLimit = 2;
          this.itemsLimit = this.rowsLimit;
        }

        get rowsLimit() {
          return LIMIT[this.currentSubTemplate].rowsLimit;
        }

        get maxRowsLimit() {
          return LIMIT[this.currentSubTemplate].maxRowsLimit;
        }

        get template() {
          return 'soccer';
        }

        get currentSubTemplate() {
          return this.rawResult.data.template;
        }

        get currentPartial() {
          return `partials/soccer/${this.currentSubTemplate}`;
        }

        get extra() {
          return this.rawResult.data.extra || {};
        }

        get allResults() {
          return [...this.selectableResults, ...this.soccerResults, this.expandButton, this.poweredByResult];
        }

        get selectableResults() {
          return [...(this.url ? [this] : []), ...super.internalResults.slice(0, this.internalResultsLimit), ...(this.subResult ? [this.subResult] : []), ...super.newsResults.slice(0, this.newsResultsLimit)];
        }

        get soccerResults() {
          let results = [];

          switch (this.currentSubTemplate) {
            case 'ligaEZ1Game':
              results = this.ligaEZ1Game;
              break;
            case 'liveTicker':
              results = this.liveTicker.map(round => round.allResults).reduce((arr, el) => [...arr, ...el], []);
              break;
            case 'ligaEZTable':
            case 'ligaEZGroup':
              results = [];
              break;
            default:
              results = [];
          }

          return results;
        }

        get ligaEZ1Game() {
          const results = this.extra.matches.map(match => new LiveTickerResult({
            match,
            text: this.query,
            url: match.live_url
          }));

          return results;
        }

        get liveTicker() {
          const results = this.extra.weeks.map(week => new LiveTickerRound({
            round: week.round,
            isCurrent: week.isCurrent,
            week,
            text: this.query
          }));

          return results;
        }

        get ligaEZTable() {
          const result = new TableResult({
            ranking: this.extra.ranking,
            infoList: this.extra.info_list,
            itemsLimit: this.itemsLimit
          });

          return result.table;
        }

        get ligaEZGroup() {
          const results = this.extra.groups.map(item => new TableGroup({
            groupName: item.group,
            group: item,
            ligaEZTable: new TableResult({
              ranking: item.ranking,
              infoList: item.info_list,
              itemsLimit: this.itemsLimit
            }).table
          }));

          return results;
        }

        get subResult() {
          if (!this.extra.url || !this.extra.title) {
            return null;
          }

          return new SoccerSubResult({
            url: this.extra.url,
            title: this.extra.title,
            text: this.query
          });
        }

        get newsAvailable() {
          return super.newsResults.length > 0;
        }

        get numberOfNews() {
          if (super.newsResults.length >= this.newsResultsLimit) {
            return this.newsResultsLimit;
          }

          return super.newsResults.length;
        }

        get expandButton() {
          return new ExpandButton({
            title: 'soccer-expand-button',
            url: `cliqz-actions,${JSON.stringify({ type: 'soccer', actionName: 'expand' })}`,
            text: this.rawResult.text,
            show: this.itemsLimit < this.maxRowsLimit,
            onClick: () => {
              const signal = {
                type: 'results',
                action: 'click',
                view: 'SoccerEZ',
                target: 'show_more'
              };
              CliqzUtils.telemetry(signal);

              this.itemsLimit = this.maxRowsLimit;
              this.actions.replaceResult(this, this);
            }
          });
        }

        get poweredByResult() {
          return new BaseResult({
            url: 'http://www.kicker.de/',
            title: 'soccer-powered-by',
            text: this.query
          });
        }

        get groupTableHeader() {
          return this.extra.group_name;
        }

        didRender($dropdown) {
          super.didRender($dropdown);

          $dropdown.querySelectorAll('.soccer .dropdown-tab-label').forEach(label => {
            label.addEventListener('click', e => {
              e.preventDefault();
              e.stopPropagation();

              const input = $dropdown.querySelector(`#${e.target.getAttribute('for')}`);

              if (!input) {
                return;
              }

              input.checked = 'checked';

              const signal = {
                type: 'results',
                action: 'click',
                view: 'SoccerEZ',
                target: 'tab',
                index: e.target.getAttribute('for').substr(4)
              };
              CliqzUtils.telemetry(signal);
            });
          });
        }
      }

      class FlightResult extends BaseResult {
        get _extra() {
          return this.rawResult.data.extra || {};
        }

        get _flightDetails() {
          return this._extra.depart_arrive || {};
        }

        get template() {
          return 'flight';
        }

        get oldApi() {
          return this.rawResult.data.old_api;
        }

        get name() {
          return this._extra.flight_name;
        }

        get flightStatus() {
          return this._extra.flight_status;
        }

        get status() {
          return this._extra.status;
        }

        get statusColor() {
          return this._extra.status_color;
        }

        get statusDetail() {
          return this._extra.status_detail;
        }

        get planeIcon() {
          return this._extra.plane_icon;
        }

        get planePosition() {
          return this._extra.plane_position;
        }

        get showDepartureScheduledTime() {
          return this.departure.scheduledTime !== this.departure.actualTime;
        }

        get showArrivalScheduledTime() {
          return this.arrival.scheduledTime !== this.arrival.actualTime;
        }

        get earlyDeparture() {
          return this.departure.actualTime < this.departure.scheduledTime;
        }

        get lateDeparture() {
          return this.departure.actualTime > this.departure.scheduledTime;
        }

        get earlyArrival() {
          return this.arrival.actualTime < this.arrival.scheduledTime;
        }

        get lateArrival() {
          return this.arrival.actualTime > this.arrival.scheduledTime;
        }

        get departure() {
          const depart = this._flightDetails['0'];
          return {
            locationName: depart.location_name,
            locationShortcut: depart.location_short_name,
            timeColor: depart.time_color,
            scheduledTime: depart.scheduled_time,
            scheduledDate: depart.scheduled_date,
            actualTime: depart.estimate_actual_time,
            terminal: depart.terminal_full,
            gate: depart.gate_full
          };
        }

        get arrival() {
          const arrival = this._flightDetails['1'];
          return {
            locationName: arrival.location_name,
            locationShortcut: arrival.location_short_name,
            actualLocation: arrival.actual_location_short_name || '',
            timeColor: arrival.time_color,
            scheduledTime: arrival.scheduled_time,
            scheduledDate: arrival.scheduled_date,
            actualTime: arrival.estimate_actual_time,
            terminal: arrival.terminal_full,
            gate: arrival.gate_full
          };
        }

        get selectableResults() {
          return [];
        }

        get allResults() {
          return [...(this.url ? [this] : [])];
        }
      }

      var _extends$6 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      class ExpandButton$1 extends BaseResult {
        get displayUrl() {
          return this.rawResult.text;
        }

        get show() {
          return this.rawResult.show;
        }

        click() {
          this.rawResult.onClick();
        }
      }

      class MovieInfo extends BaseResult {
        get name() {
          return this.rawResult.name;
        }

        get nVote() {
          return this.rawResult.nVote;
        }
      }

      class ShowTimeInfo extends BaseResult {
        get displayTime() {
          return this.rawResult.showTime.start_at.substr(11, 5);
        }

        get is3D() {
          return this.rawResult.showTime.is_3d;
        }

        get movieLanguage() {
          return this.rawResult.showTime.language;
        }
      }

      class ShowTimeRow extends GenericResult {
        get resultType() {
          return this.rawResult.type;
        }

        get cinemaInfo() {
          if (this.resultType === 'movie') {
            return {
              name: this.rawResult.row.name,
              distance: this.rawResult.row.distance ? this.rawResult.row.distance : null,
              address: this.rawResult.row.address
            };
          }

          return null;
        }

        get movieInfo() {
          if (this.resultType === 'cinema') {
            return {
              title: this.rawResult.row.title || ''
            };
          }

          return null;
        }

        get showTimes() {
          return this.rawResult.row.showtimes.map(showTime => new ShowTimeInfo({
            showTime,
            url: showTime.booking_link
          }));
        }
      }

      class ShowTimeDate extends GenericResult {
        get showDate() {
          return this.rawResult.date;
        }

        get rows() {
          return this.rawResult.rows.map(row => new ShowTimeRow({
            row,
            type: this.rawResult.type
          }));
        }
      }

      class MovieCinemaResult extends GenericResult {
        constructor(rawResult) {
          let allResultsFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          super(rawResult, allResultsFlat);

          this.showTimesLimit = 2;
          this.maxRowsLimit = 5;
        }

        get template() {
          return 'movie-cinema';
        }

        get _extra() {
          return this.rawResult.data.extra || {};
        }

        get _apiData() {
          return this._extra.data || {};
        }

        get _movieData() {
          return this._apiData.movie || {};
        }

        get _cinemaData() {
          return this._apiData.cinema || {};
        }

        get _richData() {
          return this._extra.rich_data || {};
        }

        get imageUrl() {
          return this._movieData.poster_image_thumbnail || this._richData.image;
        }

        get ratingInfo() {
          const rating = this._richData.rating;

          if (!rating) {
            return null;
          }

          const img = rating.img;
          const score = rating.val;
          const scale = rating.scale;

          if (img && score && scale) {
            return {
              img,
              score: Math.round(score * 10) / 10,
              scale
            };
          }

          return null;
        }

        get reviewsInfo() {
          const rating = this._richData.rating || {};
          const nVote = rating.nVote;

          if (nVote) {
            return new MovieInfo({
              url: `${this.rawResult.url}/ratings`,
              nVote,
              title: 'cinema-movie-reviews'
            });
          }

          return null;
        }

        get directorInfo() {
          const director = this._richData.director || {};

          if (director.info) {
            return new MovieInfo({
              url: director.info.url,
              title: director.title,
              name: director.info.name
            });
          }

          return null;
        }

        get trailerInfo() {
          if (!this._richData.categories) {
            return null;
          }

          const trailerResult = this._richData.categories.find(result => result.title === 'Trailer');

          if (trailerResult) {
            return new MovieInfo({
              url: trailerResult.url,
              title: 'cinema-movie-trailer'
            });
          }

          return null;
        }

        get starsInfo() {
          const stars = this._movieData.cast;

          if (stars) {
            return stars.slice(0, 3).map(star => star.name);
          }

          return null;
        }

        get fullCastInfo() {
          return new MovieInfo({
            url: `${this.rawResult.url}/fullcredits`,
            title: 'cinema-movie-full-cast'
          });
        }

        get showTimesInfo() {
          const showDates = this._apiData.showdates;

          if (!showDates) {
            return [];
          }
          const results = showDates.map(date => new ShowTimeDate({
            date: date.date,
            rows: this.isMovieEZ ? date.cinema_list : date.movie_list,
            type: this.isMovieEZ ? 'movie' : 'cinema'
          }));

          return results;
        }

        get isShowtimesAvailable() {
          return this.showTimesInfo.length > 0;
        }

        get isMovieEZ() {
          return this.rawResult.data.template === 'movieEZ' || this.rawResult.data.template === 'movie';
        }

        get headerTitle() {
          if (this.isMovieEZ) {
            return this._movieData.title;
          }

          return this._cinemaData.name;
        }

        get cityName() {
          return this._apiData.city;
        }

        get localResult() {
          const cinemaInfo = this._cinemaData;
          if (cinemaInfo.mu && cinemaInfo.address) {
            const result = new LocalResult({
              extra: cinemaInfo,
              text: this.query
            });

            result.actions = this.actions;
            return result;
          }

          return null;
        }

        get shareLocationButtonsWrapper() {
          return _extends$6({}, super.shareLocationButtonsWrapper, {
            localePrefix: 'cinema'
          });
        }

        get showTimeResults() {
          const results = this.showTimesInfo.map(date => date.rows.map(row => row.showTimes)).reduce((arr, el) => [...arr, ...el], []).reduce((arr, el) => [...arr, ...el], []);

          return results;
        }

        get expandButton() {
          return new ExpandButton$1({
            title: 'cinema-expand-button',
            url: `cliqz-actions,${JSON.stringify({ type: 'cinema', actionName: 'expand' })}`,
            text: this.rawResult.text,
            show: this.showTimesLimit < this.maxRowsLimit,
            onClick: () => {
              const signal = {
                type: 'results',
                action: 'click',
                view: 'EntityMovie',
                target: 'show_more'
              };
              CliqzUtils.telemetry(signal);

              this.showTimesLimit = this.maxRowsLimit;
              this.actions.replaceResult(this, this);
            }
          });
        }

        get selectableResults() {
          if (this.isMovieEZ) {
            return [...(this.url ? [this] : []), ...this.shareLocationButtons];
          }

          return super.selectableResults;
        }

        get allResults() {
          return [...super.allResults, ...(this.directorInfo ? [this.directorInfo] : []), ...(this.trailerInfo ? [this.trailerInfo] : []), ...(this.reviewsInfo ? [this.reviewsInfo] : []), this.fullCastInfo, ...this.showTimeResults, this.expandButton];
        }

        didRender($dropdown) {
          super.didRender($dropdown);

          $dropdown.querySelectorAll('.movie-cinema .dropdown-tab-label').forEach(label => {
            label.addEventListener('click', e => {
              e.preventDefault();
              e.stopPropagation();
              const input = $dropdown.querySelector(`#${e.target.getAttribute('for')}`);

              if (!input) {
                return;
              }

              input.checked = 'checked';

              const signal = {
                type: 'results',
                action: 'click',
                view: 'EntityMovie',
                target: 'tab',
                index: e.target.getAttribute('for').substr(4)
              };
              CliqzUtils.telemetry(signal);
            });
          });
        }
      }

      class NewsStoryResult extends GenericResult {
        get template() {
          return 'news-story';
        }

        get _extra() {
          return this.rawResult.data.extra || {};
        }

        get _richData() {
          return this._extra.rich_data || {};
        }

        get selectableResults() {
          return [this.newsStoryResult];
        }

        get newsStoryResult() {
          return new NewsResult({
            url: this.url,
            domain: this._richData.source_name,
            title: this.title,
            thumbnail: this._extra.media,
            description: this.description,
            creation_time: this._richData.discovery_timestamp,
            showLogo: true,
            text: this.query
          });
        }
      }

      const OFFER_USER_ENABLED = 'offers2UserEnabled';
      const OFFER_DROPDOWN_ENABLED = 'offersDropdownSwitch';
      const NON_ORGANIC_OFFER_STYLE_PREF = 'myoffrz.experiments.001.style';
      const ORGANIC_OFFER_STYLE_PREF = 'myoffrz.experiments.002.style';

      const OFFER_STYLE_DEFAULT = 'plain';

      function isUserEnabled() {
        return prefs.get(OFFER_USER_ENABLED, true) && prefs.get(OFFER_DROPDOWN_ENABLED, false);
      }

      function getNonOrganicOfferStyle() {
        return prefs.get(NON_ORGANIC_OFFER_STYLE_PREF, OFFER_STYLE_DEFAULT);
      }

      function getOrganicOfferStyle() {
        return prefs.get(ORGANIC_OFFER_STYLE_PREF, OFFER_STYLE_DEFAULT);
      }

      class ResultFactory {
        static create(rawResult, allResultsFlat, configs) {
          let Constructor = GenericResult;
          if (['custom', 'noResult'].indexOf(rawResult.data.template) >= 0) {
            throw new Error('ignore');
          }

          if (rawResult.data.template === 'calculator') {
            if (rawResult.data.extra.ez_type) {
              if (rawResult.data.extra.ez_type === 'time') {
                Constructor = TimeResult;
              } else {
                throw new Error('ignore');
              }
            } else {
              Constructor = CalculatorResult;
            }
          }

          if (rawResult.data.template === 'currency') {
            Constructor = CurrencyResult;
          }

          if (rawResult.data.template === 'weatherEZ' || rawResult.data.template === 'weatherAlert') {
            Constructor = WeatherResult;
          }

          if (rawResult.data.template === 'lotto') {
            Constructor = LottoResult;
          }

          if (rawResult.data.template === 'offer') {
            Constructor = OffersResult;
          }

          if (rawResult.data.template === 'movieEZ' || rawResult.data.template === 'cinemaEZ' || rawResult.data.template === 'movie') {
            Constructor = MovieCinemaResult;
          }

          if (rawResult.data.template === 'suggestion') {
            Constructor = SupplementarySearchResult;
          }

          if (rawResult.data.template === 'inline-suggestion') {
            Constructor = SuggestionsResult;
          }

          if (rawResult.data.template === 'sessions') {
            Constructor = SessionsResult;
          }

          if (rawResult.data.template === 'ligaEZ1Game' || rawResult.data.template === 'ligaEZTable' || rawResult.data.template === 'ligaEZGroup' || rawResult.data.template === 'liveTicker') {
            Constructor = SoccerResult;
          }

          if (rawResult.data.template === 'news') {
            Constructor = NewsStoryResult;
          }

          if (rawResult.data.template === 'flight') {
            Constructor = FlightResult;
          }

          if (rawResult.data.urls) {
            Constructor = HistoryCluster;
          }

          if (rawResult.type === 'cliqz-pattern' && !rawResult.data.urls) {
            throw new Error('ignore');
          }

          if (rawResult.type === 'navigate-to') {
            Constructor = NavigateToResult;
          }

          if (rawResult.type === 'supplementary-search') {
            Constructor = SupplementarySearchResult;
          }

          return new Constructor(rawResult, allResultsFlat, configs);
        }

        static createAll(rawResults) {
          let actions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          const all = rawResults.reduce((_ref, rawResult) => {
            let resultList = _ref.resultList,
                allResultsFlat = _ref.allResultsFlat;

            try {
              const result = ResultFactory.create(rawResult, allResultsFlat, {
                offers: {
                  isEnabled: isUserEnabled(),
                  nonOrganicStyle: getNonOrganicOfferStyle(),
                  organicStyle: getOrganicOfferStyle()
                }
              });
              result.actions = actions;
              resultList.push(result);
            } catch (e) {
              if (['duplicate', 'ignore'].indexOf(e.message) >= 0) {
                // it is expected to have duplicates
              } else {
                throw e;
              }
            }

            return {
              resultList,
              allResultsFlat
            };
          }, { resultList: [], allResultsFlat: [] });

          return all.resultList;
        }
      }

      class Results {
        constructor() {
          var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          let query = _ref2.query,
              rawResults = _ref2.rawResults,
              queriedAt = _ref2.queriedAt,
              queryCliqz = _ref2.queryCliqz,
              adultAssistant = _ref2.adultAssistant,
              locationAssistant = _ref2.locationAssistant,
              rerender = _ref2.rerender,
              getSnippet = _ref2.getSnippet,
              copyToClipboard = _ref2.copyToClipboard,
              isNewSearchMode = _ref2.isNewSearchMode,
              updateTabQuery = _ref2.updateTabQuery;

          this.rerender = rerender;
          this.query = query;
          this.queriedAt = queriedAt;
          this.isNewSearchMode = isNewSearchMode;

          const actions = {
            locationAssistant,
            adultAssistant,
            replaceResult: this.replaceResult.bind(this),
            getSnippet,
            copyToClipboard,
            query: queryCliqz,
            updateTabQuery
          };
          this.results = ResultFactory.createAll(rawResults, actions);

          if (this.hasAdultResults) {
            if (adultAssistant.isBlockingAdult) {
              this.results = this.results.filter(result => !result.isAdult);
            }

            if (adultAssistant.isAskingForAdult) {
              this.addAdultQuestionResult({
                onButtonClick: queryCliqz.bind(null, this.query),
                adultAssistant
              }, actions);
            }
          }

          if (this.hasCalculatorResults || this.hasCurrencyResults) {
            // we should filter out suggestions if we have calculatpr or currency results
            this.results = this.results.filter(result => !result.isSuggestion);
          }

          if (config.settings.HISTORY_URL && !this.isNewSearchMode && this.hasHistory && this.query !== '') {
            this.addSessionsResult();
          }

          this.displayedAt = Date.now();
        }

        get selectableResults() {
          return this.results.reduce((all, result) => [...all, ...result.selectableResults], []);
        }

        get length() {
          return this.selectableResults.length;
        }

        get firstResult() {
          return this.get(0);
        }

        get lastResult() {
          return this.get(this.selectableResults.length - 1);
        }

        get(index) {
          return this.selectableResults[index];
        }

        find(href) {
          return this.results.find(result => {
            if (!result.hasUrl) {
              console$1.error('Result does not implement #hasUrl', result);
              return false;
            }
            return result.hasUrl(href);
          });
        }

        findSelectable(href) {
          return this.selectableResults.find(r => equals(r.rawUrl, href) || equals(r.url, href));
        }

        indexOf(result) {
          return this.results.findIndex(r => r === result);
        }

        get kinds() {
          return this.results.map(result => result.kind);
        }

        prepend(result) {
          this.results.unshift(result);
        }

        replaceResult(oldResult, newResult) {
          const index = this.indexOf(oldResult);
          this.results.splice(index, 1, newResult);
          this.rerender();
        }

        insertAt(result, index) {
          this.results = [...this.results.slice(0, index), result, ...this.results.slice(index)];
        }

        addSessionsResult() {
          const firstHistoryIndex = this.results.findIndex(r => r.isHistory);
          const firstNonHistoryIndex = firstHistoryIndex + this.results.slice(firstHistoryIndex).findIndex(r => !r.isHistory);
          const sessionResult = new SessionsResult({
            text: this.query
          });

          this.insertAt(sessionResult, firstNonHistoryIndex >= 0 ? firstNonHistoryIndex : this.results.length);
        }

        addAdultQuestionResult(_ref3) {
          let onButtonClick = _ref3.onButtonClick;
          let actions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          const result = new AdultQuestionResult({
            text: this.query,
            onButtonClick
          });
          result.actions = actions;
          this.prepend(result);
        }

        get hasHistory() {
          return this.results.some(r => r.isHistory);
        }

        get hasAdultResults() {
          return this.results.some(r => r.isAdult);
        }

        get hasCalculatorResults() {
          return this.results.some(r => r.isCalculator);
        }

        get hasCurrencyResults() {
          return this.results.some(r => r.isCurrency);
        }
      }

      class Popup {
        constructor(window) {
          this.window = window;
        }

        get element() {
          return this.urlbar.popup;
        }

        get urlbar() {
          // TODO: do not use global
          return this.window.gURLBar;
        }

        get query() {
          const ctrl = this.urlbar.controller;
          return ctrl.searchString.trim();
        }

        get urlbarValue() {
          return this.urlbar.value;
        }

        get urlbarVisibleValue() {
          return this.urlbar.mInputField.value;
        }

        get urlbarSelectionRange() {
          return {
            selectionStart: this.urlbar.selectionStart,
            selectionEnd: this.urlbar.selectionEnd
          };
        }

        get isNewSearchMode() {
          return prefs.get('searchMode', 'autocomplete') !== 'autocomplete';
        }

        setDropdownPadding() {
          const urlbarRect = this.urlbar.getBoundingClientRect();
          const extraPadding = 10;
          let actualPadding = extraPadding + Math.round(urlbarRect.left || urlbarRect.x || 0);

          // Reset padding when there is a big space on the left of the urlbar
          // or when the browser's window is too narrow
          if (actualPadding > 500 || this.window.innerWidth < 650) {
            actualPadding = 50;
          }
          const dropdown = this.element.querySelector('#cliqz-dropdown');
          dropdown.style.setProperty('--url-padding-start', `${actualPadding}px`);
        }

        open() {
          this.setDropdownPadding();

          if (!this.isNewSearchMode) {
            return;
          }
          const navBar = this.window.document.querySelector('#nav-bar');

          // without this ESC does not revert to the page url
          this.element.mInput = this.urlbar;

          this.element.width = this.window.innerWidth;

          this.element.openPopup(navBar, 'after_start', 0, 0, false, true);
        }

        close() {
          if (!this.isNewSearchMode) {
            return;
          }
          this.element.closePopup();
        }

        execBrowserCommandHandler() {
          const urlbar = this.element.mInput;
          urlbar.value = urlbar.mInputField.value;
          this.element.mInput.handleCommand(...arguments);
        }
      }

      const PREF = 'adultContentFilter';
      const STATE_ALLOW_ONCE = 'showOnce';
      const STATE_ALLOW = 'liberal';
      const STATE_BLOCK = 'conservative';
      const STATE_DEFAULT = 'moderate';

      const getPref$1 = prefs.get.bind(prefs, PREF, STATE_DEFAULT);
      const setPref$1 = prefs.set.bind(prefs, PREF);

      class AdultContentAssistant {
        constructor() {
          this.actions = [{
            title: 'show_once',
            actionName: 'allowOnce'
          }, {
            title: 'always',
            actionName: 'block'
          }, {
            title: 'never',
            actionName: 'allow'
          }];
        }

        get isBlockingAdult() {
          const filterSetting = getPref$1();
          return [STATE_BLOCK, STATE_DEFAULT].indexOf(filterSetting) !== -1;
        }

        get isAskingForAdult() {
          return getPref$1() === STATE_DEFAULT;
        }

        block() {
          setPref$1(STATE_BLOCK);
          return Promise.resolve();
        }

        allow() {
          setPref$1(STATE_ALLOW);
          return Promise.resolve();
        }

        allowOnce() {
          setPref$1(STATE_ALLOW_ONCE);
          return Promise.resolve();
        }

        clear() {
          setPref$1(STATE_DEFAULT);
          return Promise.resolve();
        }

        resetAllowOnce() {
          if (getPref$1() !== STATE_ALLOW_ONCE) {
            return;
          }
          this.clear();
        }

        hasAction(actionName) {
          return this.actions.map(a => a.actionName).indexOf(actionName) !== -1;
        }
      }

      const PREF$1 = 'share_location';
      const STATE_ALLOW_ONCE$1 = 'showOnce';
      const STATE_ALLOW$1 = 'yes';
      const STATE_BLOCK$1 = 'no';
      const STATE_ASK = 'ask';

      // geolocation 'yes' for funnelCake - 'ask' for everything else
      const STATE_DEFAULT$1 = config.settings.geolocation || STATE_ASK;

      const getPref$2 = prefs.get.bind(prefs, PREF$1, STATE_DEFAULT$1);
      const setPref$2 = prefs.set.bind(prefs, PREF$1);

      class LocationSharingAssistant {
        constructor(_ref) {
          let updateGeoLocation = _ref.updateGeoLocation,
              resetGeoLocation = _ref.resetGeoLocation;

          this.actions = [{
            title: 'show-location-and-contact',
            actionName: 'allowOnce'
          }, {
            title: 'always-show-location',
            actionName: 'allow'
          }];

          this.updateGeoLocation = updateGeoLocation;
          this.resetGeoLocation = resetGeoLocation;
        }

        get isAskingForLocation() {
          return getPref$2() === STATE_ASK;
        }

        block() {
          setPref$2(STATE_BLOCK$1);
          return Promise.resolve();
        }

        allow() {
          setPref$2(STATE_ALLOW$1);
          return this.updateGeoLocation();
        }

        allowOnce() {
          setPref$2(STATE_ALLOW_ONCE$1);
          return this.updateGeoLocation();
        }

        clear() {
          // clear is alwasy called from the "ask" state
          // so we should revert back to that
          setPref$2(STATE_ASK);
          this.resetGeoLocation();
          return Promise.resolve();
        }

        resetAllowOnce() {
          if (getPref$2() !== STATE_ALLOW_ONCE$1) {
            return;
          }
          this.clear();
        }

        hasAction(actionName) {
          return this.actions.map(a => a.actionName).indexOf(actionName) !== -1;
        }
      }

      class Ui {

        constructor(window, id, _ref) {
          let getSessionCount = _ref.getSessionCount;
          this.deps = {
            'last-query': inject.module('last-query')
          };

          this.window = window;
          this.extensionID = id;
          this.getSessionCount = getSessionCount;
          this.ui = inject.module('ui');
          this.core = inject.module('core');
          this.geolocation = inject.module('geolocation');
          this.autocomplete = inject.module('autocomplete');
          this.adultAssistant = new AdultContentAssistant();
          this.locationAssistant = new LocationSharingAssistant({
            updateGeoLocation: this.geolocation.action.bind(this.geolocation, 'updateGeoLocation'),
            resetGeoLocation: this.geolocation.action.bind(this.geolocation, 'resetGeoLocation')
          });
        }

        init() {}

        unload() {}

        selectAutocomplete() {}

        clearAutocomplete() {}

        sessionEnd() {
          if (this.dropdown) {
            // this might be called before the initiaization
            this.dropdown.selectedIndex = -1;
            this.adultAssistant.resetAllowOnce();
            this.locationAssistant.resetAllowOnce();
          }
        }

        keyDown(ev) {
          let preventDefault = false;
          const isModifierPressed = ev.altKey || ev.metaKey || ev.ctrlKey;

          // no popup, so no interactions, unless Enter is pressed.
          // report telemetry signal in this case.
          if (this.popupClosed !== false) {
            // Trigger new search on ArrowDown as some FF versions
            // just reopen last popup (EX-6310).
            if (ev.code === 'ArrowDown') {
              this.core.action('refreshPopup', this.popup.query);
              return true;
            }

            if (ev.code === 'Enter' || ev.code === 'NumpadEnter') {
              enterSignal({
                query: this.window.gURLBar.textValue,
                newTab: isModifierPressed
              });
            }
            return false;
          }

          switch (ev.code) {
            case 'ArrowRight':
            case 'ArrowLeft':
              {
                this.ui.windowAction(this.window, 'syncUrlbarValue');
                break;
              }
            case 'ArrowUp':
              {
                this.dropdown.results.firstResult.isAutocompleted = false;
                const result = this.dropdown.previousResult();
                this.ui.windowAction(this.window, 'setUrlbarValue', result.url, result.displayUrl);
                preventDefault = true;
                break;
              }
            case 'ArrowDown':
              {
                this.dropdown.results.firstResult.isAutocompleted = false;
                const result = this.dropdown.nextResult();
                this.ui.windowAction(this.window, 'setUrlbarValue', result.url, result.displayUrl);
                preventDefault = true;
                break;
              }
            case 'Tab':
              {
                this.dropdown.results.firstResult.isAutocompleted = false;
                let result;
                if (ev.shiftKey) {
                  result = this.dropdown.previousResult();
                } else {
                  result = this.dropdown.nextResult();
                }
                this.ui.windowAction(this.window, 'setUrlbarValue', result.url, result.displayUrl);
                preventDefault = true;
                break;
              }
            case 'Enter':
            case 'NumpadEnter':
              {
                const isNewTab = isModifierPressed;
                let clickedResult = null;
                preventDefault = true;

                if (this.popup.query === this.dropdown.results.query) {
                  const urlbarValue = this.popup.urlbarValue;
                  const urlbarVisibleValue = this.popup.urlbarVisibleValue;
                  const firstResult = this.dropdown.results.firstResult;

                  // find clicked result
                  clickedResult =
                  // check if it is a first autocompleted result
                  urlbarValue !== urlbarVisibleValue && this.popup.query === urlbarValue && firstResult.isAutocompleted && firstResult ||
                  // find result by urlbar value
                  this.dropdown.results.findSelectable(urlbarValue) || this.dropdown.results.findSelectable(urlbarVisibleValue) ||
                  // find by selected index
                  this.dropdown.selectedIndex >= 0 && this.dropdown.results.get(this.dropdown.selectedIndex);
                }

                enterSignal({
                  query: this.popup.query,
                  result: this.dropdown.selectedResult,
                  clickedResult,
                  results: this.dropdown.results,
                  newTab: isNewTab
                });

                if (clickedResult) {
                  clickedResult.click(this.window, clickedResult.url, ev);
                } else {
                  this.popup.close();
                  this.popup.execBrowserCommandHandler(ev, isNewTab ? 'tab' : 'current');
                }
                break;
              }
            case 'Delete':
            case 'Backspace':
              {
                if (!ev.shiftKey || ev.metaKey || ev.altKey && ev.ctrlKey) {
                  var _popup$urlbarSelectio = this.popup.urlbarSelectionRange;
                  const selectionStart = _popup$urlbarSelectio.selectionStart,
                        selectionEnd = _popup$urlbarSelectio.selectionEnd;

                  if (selectionStart !== selectionEnd) {
                    // wait for next tick so urlbarValue to contain the query after deletion
                    nextTick(() => {
                      const urlbarValue = this.popup.urlbarValue.trim();
                      if (urlbarValue === '') {
                        return;
                      }
                      this.core.action('refreshPopup', urlbarValue);
                    });
                  }
                  break;
                }
                const selectedResult = this.dropdown.selectedResult;
                if (!selectedResult.isDeletable) {
                  break;
                }

                const url = selectedResult.rawUrl;
                CliqzHistoryManager.removeFromHistory(url);
                if (selectedResult.isBookmark) {
                  CliqzHistoryManager.removeFromBookmarks(url);
                  removeFromHistorySignal({ withBookmarks: true });
                } else {
                  removeFromHistorySignal({});
                }

                getTabsWithUrl(this.window, url).forEach(tab => closeTab$1(this.window, tab));

                this.core.action('refreshPopup', this.dropdown.results.query);
                preventDefault = true;
                break;
              }
            default:
              {
                preventDefault = false;
              }
          }
          return preventDefault;
        }

        main(element) {
          this.dropdown = new Dropdown(element, this.window, this.extensionID);
          this.dropdown.init();
          this.popup = new Popup(this.window);
        }

        updateFirstResult() {
          const oldResults = this.dropdown.results;

          if (!oldResults || this.dropdown.selectedIndex === -1) {
            return;
          }

          const query = this.popup.query;

          if (query && oldResults.query !== query && (oldResults.firstResult instanceof NavigateToResult || oldResults.firstResult instanceof SupplementarySearchResult)) {
            oldResults.firstResult.rawResult.text = query;

            this.dropdown.renderResults(oldResults);

            this.popup.open();
          }
        }

        render(_ref2) {
          let query = _ref2.query,
              queriedAt = _ref2.queriedAt,
              rawResults = _ref2.rawResults;

          CliqzEvents.pub('ui:results', rawResults);

          const results = new Results({
            query,
            queriedAt,
            rawResults,
            queryCliqz: this.core.action.bind(this.core, 'queryCliqz'),
            adultAssistant: this.adultAssistant,
            locationAssistant: this.locationAssistant,
            rerender: () => this.dropdown.renderResults(results),
            getSnippet: this.autocomplete.action.bind(this.autocomplete, 'getSnippet'),
            copyToClipboard,
            isNewSearchMode: this.popup.isNewSearchMode,
            updateTabQuery: q => {
              const tabId = getCurrentTabId(this.window);
              this.deps['last-query'].windowAction(this.window, 'updateTabQuery', tabId, q);
            }
          });
          const queryIsUrl = isUrl(results.query);
          const queryIsNotEmpty = query.trim() !== '';
          const firstResult = results.firstResult;
          let didAutocomplete;
          let hasInstantResults;

          if (results.firstResult) {
            didAutocomplete = this.autocompleteQuery(firstResult.url, firstResult.title);
            firstResult.isAutocompleted = didAutocomplete;
            hasInstantResults = firstResult.rawResult.type === 'navigate-to' || firstResult.rawResult.type === 'supplementary-search';
          } else {
            // if no results found make sure we clear autocompleted
            // query in urlbar (see EX-5648)
            this.autocompleteQuery('', '');
          }

          // TODO remove this after switching to a new mixer completely
          if (!this.popup.isNewSearchMode && !didAutocomplete && !hasInstantResults) {
            if (queryIsUrl) {
              results.prepend(new NavigateToResult({ text: results.query }));
            } else if (queryIsNotEmpty) {
              const supplementaryResult = new SupplementarySearchResult({
                text: results.query,
                defaultSearchResult: true,
                data: {
                  suggestion: this.popup.query
                }
              });

              // Added SupplementarySearch might be a duplicate of the one from
              // search suggestions (see EX-5321). Make sure we removed them.
              results.results = results.results.filter(r => !equals(supplementaryResult.url, r.url));
              results.prepend(supplementaryResult);
            }
          }
          this.dropdown.renderResults(results);

          if (results.results.length) {
            this.popup.open();
          }
        }
      }

      const AGO_CEILINGS = [[0, '', 1], [120, 'ago1Minute', 1], [3600, 'agoXMinutes', 60], [7200, 'ago1Hour', 1], [86400, 'agoXHours', 3600], [172800, 'agoYesterday', 1], [604800, 'agoXDays', 86400], [4838400, 'ago1Month', 1], [29030400, 'agoXMonths', 2419200], [58060800, 'ago1year', 1], [2903040000, 'agoXYears', 29030400]];

      // Make sure the input string is in lower case
      function latinMap(str) {
        const map = [{ "base": "a", "letters": /[\u00E4]|ae/g }, { "base": "o", "letters": /[\u00F6]|oe/g }, { "base": "u", "letters": /[\u00FC]|ue/g }, { "base": "s", "letters": /[\u00DF]|ss/g }];

        map.forEach(mapper => {
          str = str.replace(mapper.letters, mapper.base);
        });

        return str;
      }

      function countRemovedChars(indexes, lBound, hBound) {
        let count = 0;
        indexes.forEach(index => {
          if (index >= lBound && index <= hBound) ++count;
        });
        return count;
      }

      var helpers = {
        take(array, number) {
          return array.slice(0, number || array.length);
        },

        even(value, options) {
          if (value % 2) {
            return options.fn(this);
          } else {
            return options.inverse(this);
          }
        },

        exists(variable, options) {
          if (typeof variable !== 'undefined') {
            return options.fn(this);
          } else {
            return options.inverse(this);
          }
        },

        emphasis() {
          let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          let q = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          let minQueryLength = arguments[2];
          let cleanControlChars = arguments[3];

          if (!q) return text;
          q = q.trim();

          if (text && cleanControlChars) {
            text.replace(/[\u0000-\u001F]/g, ' ');
          }

          var map = Array(text.length),
              tokens = latinMap(q.toLowerCase()).split(/\s+|\.+/).filter(function (t) {
            return t && t.length > 1;
          }),
              lowerText = latinMap(text.toLowerCase()),
              out,
              high = false;

          // Store a list of index(es) where a character has been removed
          var indexes = [],
              patt = /ae|oe|ue|ss/g,
              match = null;

          while (match = patt.exec(text.toLowerCase())) {
            indexes.push(match.index);
          }

          var lastRemovedChars = 0,
              currentRemovedChars = 0;

          tokens.forEach(function (token) {
            var poz = lowerText.indexOf(token);
            while (poz !== -1) {
              //Number of characters have been removed before this token
              lastRemovedChars = countRemovedChars(indexes, 0, poz - 1);
              //Number of characters have been remove in this token
              currentRemovedChars = countRemovedChars(indexes, poz, poz + token.length);
              for (var i = poz + lastRemovedChars; i < poz + token.length + currentRemovedChars + lastRemovedChars; i++) map[i] = true;
              poz = lowerText.indexOf(token, poz + 1);
            }
          });

          out = [];
          var current = '';
          for (var i = 0; i < text.length; i++) {
            if (map[i] && !high) {
              out.push(current);
              current = '';
              current += text[i];
              high = true;
            } else if (!map[i] && high) {
              out.push(current);
              current = '';
              current += text[i];
              high = false;
            } else current += text[i];
          }
          out.push(current);

          return new Handlebars.SafeString(templates.emphasis(out));
        },

        local(key) {
          var args = Array.prototype.slice.call(arguments);
          var name = args.shift();
          return CliqzUtils.getLocalizedString.apply(null, [name, args]);
        },

        agoline(ts, options) {
          if (!ts) return '';
          var now = new Date().getTime() / 1000,
              seconds = parseInt(now - ts),
              i = 0,
              slot;

          while (slot = AGO_CEILINGS[i++]) if (seconds < slot[0]) return CliqzUtils.getLocalizedString(slot[1], parseInt(seconds / slot[2]));
          return '';
        },

        agoDuration(duration, options) {
          if (!duration) return '';
          var seconds = parseInt(duration),
              i = 0,
              slot;

          while (slot = AGO_CEILINGS[i++]) if (seconds < slot[0]) return CliqzUtils.getLocalizedString(slot[1], parseInt(seconds / slot[2]));
          return '';
        },

        distance(meters) {
          if (!meters) {
            return null;
          }

          let distance;
          let unit;
          if (meters < 1000) {
            distance = meters.toFixed(0);
            unit = 'm';
          } else {
            distance = (meters / 1000).toFixed(1);
            unit = 'km';
          }
          return `${distance} ${unit}`;
        },

        concatLocale(prefix, locale) {
          if (!prefix) {
            return locale;
          }

          return `${prefix}-${locale}`;
        }
      };

      function addStylesheet(document, url) {
        const stylesheet = document.createElementNS('http://www.w3.org/1999/xhtml', 'h:link');
        stylesheet.rel = 'stylesheet';
        stylesheet.href = url;
        stylesheet.type = 'text/css';
        stylesheet.style.display = 'none';
        stylesheet.classList.add('cliqz-theme');

        document.documentElement.appendChild(stylesheet);
      }

      function removeStylesheet(document, url) {
        const styles = [].slice.call(document.getElementsByClassName('cliqz-theme'));
        styles.filter(style => style.href === url).forEach(stylesheet => {
          if (!stylesheet.parentNode) {
            return;
          }

          stylesheet.parentNode.removeChild(stylesheet);
        });
      }

      class AppWindow {
        constructor(_ref) {
          let windowId = _ref.windowId,
              window = _ref.window;

          this.windowId = windowId;
          this.window = window;
          this.eventHandlers = new Set();
        }

        init() {
          var _this = this;

          /*
           * wrap all event handlers into a check that verify
           * if we have a correct window
           */
          Object.keys(this.events).forEach(eventName => {
            const handler = subscribe(eventName, function () {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              if (typeof args[0] !== 'object' || args[0].windowId !== _this.windowId) {
                return;
              }

              _this.events[eventName].call(_this, ...args);
            });
            this.eventHandlers.add(handler);
          });
        }

        unload() {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.eventHandlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const handler = _step.value;

              handler.unsubscribe();
              this.eventHandlers.delete(handler);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }

      // TODO: remove dependency on autocomplete
      const STYLESHEET_URL = 'chrome://cliqz/content/dropdown/styles/styles.css';

      function getResults(ctrl) {
        const query = CliqzAutocomplete.lastSearch.trim();
        const rawResults = Array(ctrl.matchCount).fill().map((_, i) => {
          const data = ctrl.getDataAt(i) || {};
          const rawResult = {
            title: ctrl.getCommentAt(i),
            url: ctrl.getValueAt(i),
            description: data.description || '',
            originalUrl: ctrl.getValueAt(i),
            type: ctrl.getStyleAt(i),
            text: query,
            data,
            maxNumberOfSlots: i === 0 ? 3 : 1
          };
          return rawResult;
        }).filter(r => r.url !== null);

        return {
          query,
          queriedAt: CliqzAutocomplete.lastQueryTime,
          rawResults
        };
      }

      class DropdownWindow extends AppWindow {

        constructor(config) {
          super(config);
          this.events = {
            'urlbar:input': () => {
              if (prefs.get('searchMode') !== 'autocomplete') {
                return;
              }
              this.ui.updateFirstResult();
            },

            'search:results': _ref => {
              let windowId = _ref.windowId,
                  results = _ref.results;

              if (this.windowId !== windowId) {
                return;
              }

              if (!this.isReady) {
                return;
              }

              const query = this.window.gURLBar.mController.searchString.trim();

              this.ui.render({
                rawResults: results,
                queriedAt: Date.now(),
                query
              });
            }
          };
          this.actions = {
            init: () => {
              this.ui.handleResults = () => {
                if (prefs.get('searchMode', 'autocomplete') !== 'autocomplete') {
                  return;
                }

                const ctrl = CliqzAutocomplete.lastResult;

                if (!ctrl) {
                  return;
                }

                const results = getResults(ctrl);
                this.ui.render(results);
              };
              this.isReady = true;
              this.window.CLIQZ.UI = this.ui;
              this.ui.init();
            }
          };
          this.background = config.background;
          this.settings = config.settings;
          this.ui = new Ui(this.window, this.settings.id, {
            getSessionCount: this.background.getSessionCount.bind(this.background)
          });
          this.isReady = false;
        }

        init() {
          super.init();
          Handlebars.partials = Object.assign({}, Handlebars.partials, templates);
          addStylesheet(this.window.document, STYLESHEET_URL);

          Object.keys(helpers).forEach(helperName => Handlebars.registerHelper(helperName, helpers[helperName]));
        }

        unload() {
          super.unload();
          delete this.window.CLIQZ.UI;
          removeStylesheet(this.window.document, STYLESHEET_URL);
          this.ui.unload();
        }
      }

      var dropdownModule = {
        Background: Background$1,
        Window: DropdownWindow
      };

      var Rx = lazyLoader('Rx.min.js', 'Rx');

      class ObservableProxy {
        constructor() {
          this.observable = Rx.Observable.create(o => {
            this._next = o.next.bind(o);
          });
        }

        next(ev) {
          if (!this._next) {
            return;
          }
          this._next(ev);
        }
      }

      var _slicedToArray$6 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /**
        @namespace firefox-specific
        @module firefox-specific
        @class Background
       */
      var Background$2 = background({

        requiresServices: ['cliqz-config'],

        /**
          @method init
          @param settings
        */
        init() {
          this.clicksEventProxy = new ObservableProxy();
          this.locationChangeEventProxy = new ObservableProxy();
          const clicks$ = this.clicksEventProxy.observable;
          const locationChanges$ = this.locationChangeEventProxy.observable;

          // For every click (or enter) on a cliqz result, start a new stream that
          // will wait for upcoming page load
          clicks$.mergeMap(_ref => {
            let url = _ref.url,
                resultType = _ref.resultType;
            return Rx.Observable
            // open a time window to capture location change
            .interval(5000)
            // wait only once
            .take(1)
            // merge with location-change that matches the url
            .withLatestFrom(locationChanges$.filter(_ref2 => {
              let u = _ref2.url;
              return u === url;
            })).map(_ref3 => {
              var _ref4 = _slicedToArray$6(_ref3, 2);

              let status = _ref4[1].status;
              return { resultType, status };
            });
          }).subscribe(_ref5 => {
            let status = _ref5.status,
                resultType = _ref5.resultType;

            CliqzUtils.telemetry({
              type: 'performance',
              action: 'response',
              response_code: status / 100,
              result_type: resultType,
              v: 1
            });
          });
        },

        unload() {},

        beforeBrowserShutdown() {},

        events: {
          'content:location-change': function onLocationChange(_ref6) {
            let url = _ref6.url,
                status = _ref6.status;

            this.locationChangeEventProxy.next({
              url,
              status
            });
          },

          'ui:click-on-url': function onClick(_ref7) {
            let url = _ref7.url;
            var _ref7$rawResult = _ref7.rawResult;
            let style = _ref7$rawResult.style,
                type = _ref7$rawResult.type;

            this.clicksEventProxy.next({
              url,
              resultType: style || type
            });
          }
        },

        actions: {},

        whoAmI(_ref8) {
          let startup = _ref8.startup,
              windowId = _ref8.windowId;

          (Services.search.init ? new Promise(resolve => Services.search.init(resolve)) : Promise.resolve()).then(() => this.sendEnvironmentalSignal({
            startup,
            defaultSearchEngine: Services.search.currentEngine.name,
            windowId
          }));
        },

        sendEnvironmentalSignal(_ref9) {
          let startup = _ref9.startup,
              defaultSearchEngine = _ref9.defaultSearchEngine,
              windowId = _ref9.windowId;

          const screenWidth = { value: 0 };
          const screenHeight = { value: 0 };
          let screenMan;
          const window$$1 = Window.findById(windowId).window;

          /* eslint-disable */
          try {
            screenMan = Components.classes['@mozilla.org/gfx/screenmanager;1'].getService(Components.interfaces.nsIScreenManager);
            // our eslint rules do not like GetRect being not a constructor
            screenMan.primaryScreen.GetRect({}, {}, screenWidth, screenHeight);
          } catch (e) {}
          // our eslint rules do not like empty catch

          /* eslint-enable */

          CliqzHistoryManager.getStats(history => {
            const document = window$$1.document;
            const navigator = window$$1.navigator;
            const browserContainer = document.getElementById('browser');
            const info = {
              type: 'environment',
              agent: navigator.userAgent,
              language: navigator.language,
              width: document.width,
              height: document.height,
              inner_height: browserContainer.clientHeight,
              inner_width: browserContainer.clientWidth,
              screen_width: screenWidth.value,
              screen_height: screenHeight.value,
              version: CliqzUtils.extensionVersion,
              history_days: history.days,
              history_urls: history.size,
              startup: Boolean(startup),
              prefs: CliqzUtils.getCliqzPrefs(),
              defaultSearchEngine,
              isDefaultBrowser: CliqzUtils.isDefaultBrowser(),
              private_window: CliqzUtils.isPrivate(window$$1),
              distribution: prefs.get('distribution', ''),
              version_host: prefs.get('gecko.mstone', '', ''),
              version_dist: prefs.get('distribution.version', '', ''),
              install_date: prefs.get('install_date')
            };

            CliqzUtils.telemetry(info);
          });
        }
      });

      const INFO_INTERVAL = 60 * 60 * 1e3; // 1 hour

      class Win$2 {
        constructor(_ref) {
          let window = _ref.window,
              background = _ref.background;

          this.window = window;
          this.background = background;
        }

        init() {
          this.tabSelectEventProxy = CliqzEvents.proxyEvent('core:tab_select', this.window.gBrowser.tabContainer, 'TabSelect', false, event => {
            const tab = event.target;
            const browser = tab.linkedBrowser;
            const win = new Window(tab.ownerGlobal);
            const msg = {
              windowId: win.id,
              url: browser.currentURI.spec,
              tabId: browser.outerWindowID,
              isPrivate: browser.loadContext.usePrivateBrowsing
            };
            return [msg];
          });

          this.tabCloseEventProxy = CliqzEvents.proxyEvent('core:tab_close', this.window.gBrowser.tabContainer, 'TabClose', false, event => {
            const tab = event.target;
            const browser = tab.linkedBrowser;
            const win = new Window(tab.ownerGlobal);
            const msg = {
              windowId: win.id,
              tabId: browser.outerWindowID,
              isPrivate: browser.loadContext.usePrivateBrowsing
            };
            return [msg];
          });

          this.tabOpenEventProxy = CliqzEvents.proxyEvent('core:tab_open', this.window.gBrowser.tabContainer, 'TabOpen', false, event => {
            const tab = event.target;
            const browser = tab.linkedBrowser;
            const win = new Window(tab.ownerGlobal);
            const msg = {
              windowId: win.id,
              tabId: browser.outerWindowID,
              isPrivate: browser.loadContext.usePrivateBrowsing
            };
            return [msg];
          });

          this.whoAmItimer = CliqzUtils.setInterval(this.whoAmI.bind(this, { startup: false }), INFO_INTERVAL);

          return this.whoAmI({ startup: true });
        }

        whoAmI(_ref2) {
          let startup = _ref2.startup;

          const win = new Window(this.window);
          this.background.whoAmI({
            startup,
            windowId: win.id
          });
        }

        unload() {
          // Unsubsribe event proxies
          this.tabSelectEventProxy.unsubscribe();
          this.tabCloseEventProxy.unsubscribe();
          this.tabOpenEventProxy.unsubscribe();

          CliqzUtils.clearInterval(this.whoAmItimer);
        }

      }

      var firefoxSpecificModule = {
        Background: Background$2,
        Window: Win$2
      };

      var Background$3 = {
        init() {},
        unload() {}
      };

      class Win$3 {

        constructor(settings) {}

        init() {}

        unload() {}

      }

      var staticModule = {
        Background: Background$3,
        Window: Win$3
      };

      /*
       * This module handles the different country-specific search backends
       * cliqz provides
       *
       */

      class CliqzSearchCountryProviders {
        constructor() {}

        getProviders() {
          let available = JSON.parse(CliqzUtils.getPref('config_backends', '["de"]'));

          return available.reduce(function (acc, cur) {
            acc[cur] = {
              'selected': cur === CliqzUtils.getPref('backend_country', 'de'),
              'name': CliqzUtils.getLocalizedString('country_code_' + cur.toUpperCase())
            };

            return acc;
          }, {});
        }
      }

      function getSmartCliqz(url) {
        CliqzUtils.log('getSmartCliqz: start fetching for ' + url);

        return new Promise((resolve, reject) => {
          if (CliqzUtils.getDetailsFromUrl(url).scheme === '') {
            url = 'http://' + url;
          }
          const endpointUrl = 'https://api.cliqz.com/api/v1/rich-header?path=/map&bmresult=' + url;

          CliqzUtils.httpGet(endpointUrl, function success(req) {
            try {
              const smartCliqzData = JSON.parse(req.response).results[0];
              const smartCliqzExists = typeof smartCliqzData !== 'undefined';
              let smartCliqz;

              if (!smartCliqzExists) {
                reject({
                  type: 'URL_NOT_FOUND',
                  message: url + ' not found on server'
                });
              } else {
                smartCliqzData.subType = JSON.parse(smartCliqzData.subType);
                smartCliqz = Result.cliqz(smartCliqzData);
                CliqzUtils.log('getSmartCliqz: done fetching for ' + url);
                resolve(smartCliqz);
              }
            } catch (e) {
              reject({
                type: 'UNKNOWN_ERROR',
                message: e
              });
            }
          }.bind(this), function error() {
            reject({
              type: 'HTTP_REQUEST_ERROR',
              message: ''
            });
          });
        });
      }

      const notImplementedPromise = () => new Promise(() => notImplemented());

      /**
       * Read file from default location.
       *
       * @param {string|Array} path
       * @param {Object} options - {bool} isText: decodes data before returning
       * @returns {Promise}
       */
      const readFile$1 = readFile || notImplementedPromise;

      /**
       * Write to file from default location.
       *
       * @param {string|Array} path
       * @param {data} data - in a format accepted by the platform
       * @param {Object} options - {bool} isText: encodes data before writing
       * @returns {Promise}
       */
      const writeFile$1 = writeFile || notImplementedPromise;

      /**
       * Create directory in default location, does not fail if directory exists.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */
      const mkdir$1 = mkdir || notImplementedPromise;

      /**
       * Similar to writeFile, but this one does not do atomic write. Always truncates file.
       *
       * @param {string|Array} path
       * @param {data} data - in a format accepted by the platform
       * @param {Object} options - {bool} isText: encodes data before writing
       * @returns {Promise}
       */

      /**
       * Renames old path to new path.
       *
       * @param {string|Array} oldPath
       * @param {string|Array} newPath
       * @returns {Promise}
       */

      /**
       * Returns whether it exists a file with given path or not.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */
      const fileExists$1 = fileExists || notImplementedPromise;

      /**
       * Truncates file with given path.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Opens file with given file (creating if does not exist) and return
       * file object to be used in writeFD and closeFD functions.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Writes to given open file.
       *
       * @param {Object} openFile
       * @param {data} data - in a format accepted by the platform
       * @param {Object} options - {bool} isText: encodes data before writing
       * @returns {Promise}
       */

      /**
       * Closes given open file.
       *
       * @param {Object} openFile
       * @returns {Promise}
       */

      /**
       * Removes file with given path, does not fail if file does not exist.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Creates empty file with given path.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Returns file size.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Joins the given path components.
       *
       * @param {Array} paths
       * @returns {Promise}
       */

      /**
      * this simple cache is a dictionary that addionally stores
      * timestamps for each entry; life is time in seconds before
      * entries are marked stale (if life is not specified entries
      * are good forever); going stale has no immediate consequences
      * @namespace smart-cliqz-cache
      */
      class Cache {
        /**
        * @class Cache
        * @constructor
        */
        constructor(life) {
          this._cache = {};
          this._life = life ? life * 1000 : false;
        }

        /**
        * stores entry only if it is newer than current entry,
        * current time is used if time is not specified
        * @method store
        * @param key {string}
        * @param value {string}
        * @param time {timestamp}
        */
        store(key, value, time) {
          time = time || Date.now();

          if (this.isNew(key, value, time)) {
            this._cache[key] = {
              time: time,
              value: value
            };
          }
        }

        /**
        * deletes entry
        * @method delete
        * @param key {string}
        */
        delete(key) {
          if (this.isCached(key)) {
            delete this._cache[key];
          }
        }

        /**
        * returns cached entry or false if no entry exists for key
        * @method retrieve
        * @param key {string}
        */
        retrieve(key) {
          if (!this.isCached(key)) {
            return false;
          }
          return this._cache[key].value;
        }

        /**
        * @method isCached
        * @param key {string}
        */
        isCached(key) {
          return this._cache.hasOwnProperty(key);
        }

        /**
        * @method isNew
        * @param key {string}
        * @param value {string}
        * @param time {timestamp}
        * @returns true if there is no newer entry already cached for key
        */
        isNew(key, value, time) {
          return !this.isCached(key) || time > this._cache[key].time;
        }

        /** an entry is stale if it is not cached or has expired
        * (an entry can only expire if life is specified); this
        * has no immediate consequences, but can be used from
        * outside to decide if this entry should be updated
        * @method isStale
        * @param key {string}
        */
        isStale(key) {
          return !this.isCached(key) || this._life && Date.now() - this._cache[key].time > this._life;
        }

        /**
        * updates time without replacing the entry
        * @method refresh
        * @param key {string}
        * @param time {timestamp}
        */
        refresh(key, time) {
          time = time || Date.now();

          if (this.isCached(key)) {
            this._cache[key].time = time;
          }
        }

        /**
        * save cache to file
        * @method save
        * @param filename {string}
        */
        save(filename) {
          const content = new TextEncoder().encode(JSON.stringify(this._cache));
          writeFile$1(filename, content).then(() => {
            this.log('save: saved to ' + filename);
          }).catch(e => {
            this.log('save: failed saving: ' + e);
          });
        }

        /**
        * load cache from file
        * @method load
        * @param filename {string}
        */
        load(filename) {
          readFile$1(filename).then(data => {
            this._cache = JSON.parse(new TextDecoder().decode(data));
            this.log('load: loaded from: ' + filename);
          }).catch(e => {
            this.log('load: failed loading: ' + e);
          });
        }

        log(msg) {
          CliqzUtils.log(msg, 'Cache');
        }
      }

      var _slicedToArray$7 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const CUSTOM_DATA_CACHE_FOLDER = 'cliqz';
      const CUSTOM_DATA_CACHE_FILE = CUSTOM_DATA_CACHE_FOLDER + '/smartcliqz-custom-data-cache.json';
      // maximum number of items (e.g., categories or links) to keep
      const MAX_ITEMS = 5;

      const ONE_MINUTE$1 = 60;
      const ONE_HOUR$2 = ONE_MINUTE$1 * 60;
      /*
       * @namespace smart-cliqz-cache
       */
      class SmartCliqzCache {
        /**
        * This module caches SmartCliqz results in the extension. It
        * also customizes news SmartCliqz by re-ordering categories and
        * links based on the user's browsing history.
        * @class SmartCliqzCache
        * @constructor
        */
        constructor() {
          this._smartCliqzCache = new Cache(ONE_MINUTE$1);
          // re-customize after an hour
          this._customDataCache = new Cache(ONE_HOUR$2);
          this._isCustomizationEnabledByDefault = true;
          this._isInitialized = false;
          // to prevent fetching while fetching is still in progress
          this._fetchLock = {};

          mkdir$1(CUSTOM_DATA_CACHE_FOLDER).then(() => {
            // TODO: detect when loaded; allow save only afterwards
            this._customDataCache.load(CUSTOM_DATA_CACHE_FILE);
          }).catch(e => {
            console$1.error('init: unable to create cache folder:' + e);
          });

          this._isInitialized = true;
          this._log('init: initialized');
        }

        /*
        * stores SmartCliqz if newer than chached version
        * @method store
        * @param smartCliqz
        */
        store(smartCliqz) {
          const url = this.getUrl(smartCliqz);

          this._smartCliqzCache.store(url, smartCliqz);

          try {
            if (this.isCustomizationEnabled() && this.isNews(smartCliqz) && this._customDataCache.isStale(url)) {

              this._log('store: found stale data for url ' + url);
              this._prepareCustomData(url);
            }
          } catch (e) {
            console$1.error('store: error while customizing data: ' + e);
          }
        }
        /**
        * @method fetchAndStore
        * @param id
        */
        fetchAndStore(url) {
          if (this._fetchLock.hasOwnProperty(url)) {
            this._log('fetchAndStore: fetching already in progress for ' + url);
            return;
          }

          this._log('fetchAndStore: for ' + url);
          this._fetchLock[url] = true;
          getSmartCliqz(url).then(smartCliqz => {
            // limit number of categories/links
            if (smartCliqz.hasOwnProperty('data')) {
              if (smartCliqz.data.hasOwnProperty('links')) {
                smartCliqz.data.links = smartCliqz.data.links.slice(0, MAX_ITEMS);
              }
              if (smartCliqz.data.hasOwnProperty('categories')) {
                smartCliqz.data.categories = smartCliqz.data.categories.slice(0, MAX_ITEMS);
              }
            }
            this.store(smartCliqz);
            delete this._fetchLock[url];
          }, e => {
            console$1.error('fetchAndStore: error while fetching data: ' + e.type + ' ' + e.message);
            delete this._fetchLock[url];
          });
        }

        /**
        * customizes SmartCliqz if news or domain supported, and user preference is set
        * @method retrieve
        * @param url
        * @returns SmartCliqz from cache (false if not found)
        */
        retrieve(url) {
          const smartCliqz = this._smartCliqzCache.retrieve(url);

          if (this.isCustomizationEnabled() && smartCliqz && this.isNews(smartCliqz)) {
            try {
              this._customizeSmartCliqz(smartCliqz);
            } catch (e) {
              console$1.error('retrieveCustomized: error while customizing data: ' + e);
            }
          }

          return smartCliqz;
        }

        /**
         * Same as `retrieve`, but triggers asynchronous cache update:
         * fetches SmartCliqz (again) if not yet cached or if stale. If SmartCliqz
         * was not yet cached `false` is returned and update is initiated.
         * @param {String} url - The SmartCliqz trigger URL
         * @return {SmartCliqz} The cached SmartCliqz or false if not yet cached.
         */
        retrieveAndUpdate(url) {
          const smartCliqz = this.retrieve(url);

          if (this._smartCliqzCache.isStale(url)) {
            CliqzUtils.setTimeout(function () {
              this.fetchAndStore(url);
            }.bind(this), 0);
          }

          return smartCliqz;
        }

        /**
        * extracts domain from SmartCliqz
        * @method getDomain
        * @param smartCliqz
        */
        getDomain(smartCliqz) {
          // TODO: define one place to store domain
          if (smartCliqz.data.domain) {
            return smartCliqz.data.domain;
          } else if (smartCliqz.data.trigger_urls && smartCliqz.data.trigger_urls.length > 0) {
            return CliqzUtils.generalizeUrl(smartCliqz.data.trigger_urls[0]);
          } else {
            return false;
          }
        }

        /**
        * extracts id from SmartCliqz
        * @method getId
        * @param smartCliqz
        */
        getId(smartCliqz) {
          return smartCliqz.data.subType.id;
        }

        /**
        * extracts URL from SmartCliqz
        * @method getUrl
        * @param smartCliqz
        */
        getUrl(smartCliqz) {
          return CliqzUtils.generalizeUrl(smartCliqz.val, true);
        }

        /**
        * extracts timestamp from SmartCliqz
        * @method getTimestamp
        * @param smartCliqz
        */
        getTimestamp(smartCliqz) {
          return smartCliqz.data.ts;
        }
        /**
        * @method isNews
        * @param smartCliqz
        * returns true this is a news SmartCliqz
        */
        isNews(smartCliqz) {
          return typeof smartCliqz.data.news !== 'undefined';
        }

        /**
        * @method isCustomizationEnabled
        * @returns true if the user enabled customization
        */
        isCustomizationEnabled() {
          try {
            const isEnabled = CliqzUtils.getPref('enableSmartCliqzCustomization', undefined);
            return isEnabled === undefined ? this._isCustomizationEnabledByDefault : isEnabled;
          } catch (e) {
            return this._isCustomizationEnabledByDefault;
          }
        }

        // re-orders categories based on visit frequency
        _customizeSmartCliqz(smartCliqz) {
          const url = this.getUrl(smartCliqz);
          if (this._customDataCache.isCached(url)) {
            this._injectCustomData(smartCliqz, this._customDataCache.retrieve(url));

            if (this._customDataCache.isStale(url)) {
              this._log('_customizeSmartCliqz: found stale data for ' + url);
              this._prepareCustomData(url);
            }
          } else {
            this._log('_customizeSmartCliqz: custom data not yet ready for ' + url);
          }
        }

        // replaces all keys from custom data in SmartCliqz data
        _injectCustomData(smartCliqz, customData) {
          const url = this.getUrl(smartCliqz);
          this._log('_injectCustomData: injecting for ' + url);
          for (let key in customData) {
            if (customData.hasOwnProperty(key)) {
              smartCliqz.data[key] = customData[key];
              this._log('_injectCustomData: injecting key ' + key);
            }
          }
          this._log('_injectCustomData: done injecting for ' + url);
        }

        // prepares and stores custom data for SmartCliqz with given URL (async.),
        // (if custom data has not been prepared before and has not expired)
        _prepareCustomData(url) {
          if (this._customDataCache.isStale(url)) {
            // update time so that this method is not executed multiple
            // times while not yet finished (runs asynchronously)
            this._customDataCache.refresh(url);
            this._log('_prepareCustomData: preparing for ' + url);
          } else {
            this._log('_prepareCustomData: already updated or in update progress ' + url);
            return;
          }

          // for stats
          const oldCustomData = this._customDataCache.retrieve(url);

          // (1) fetch template from rich header
          getSmartCliqz(url).then(smartCliqz => {
            const domain = this.getDomain(smartCliqz);
            return Promise.all([Promise.resolve(smartCliqz), this._fetchVisitedUrls(domain)]);
          })
          // (2) fetch history for SmartCliqz domain
          .then(_ref => {
            var _ref2 = _slicedToArray$7(_ref, 2);

            let smartCliqz = _ref2[0],
                urls = _ref2[1];

            // now, (3) re-order template categories based on history
            const domain = this.getDomain(smartCliqz);

            // TODO: define per SmartCliqz what the data field to be customized is called
            if (!this.isNews(smartCliqz)) {
              smartCliqz.data.categories = smartCliqz.data.links;
            }

            let categories = smartCliqz.data.categories.slice();

            // add some information to facilitate re-ordering
            for (let j = 0; j < categories.length; j++) {
              categories[j].genUrl = CliqzUtils.generalizeUrl(categories[j].url);
              categories[j].matchCount = 0;
              categories[j].originalOrder = j;
            }

            // count category-visit matches (visit url contains category url)
            for (let i = 0; i < urls.length; i++) {
              const url = CliqzUtils.generalizeUrl(urls[i]);
              for (let j = 0; j < categories.length; j++) {
                if (this._isMatch(url, categories[j].genUrl)) {
                  categories[j].matchCount++;
                }
              }
            }

            // re-order by match count; on tie use original order
            categories.sort(function compare(a, b) {
              if (a.matchCount !== b.matchCount) {
                return b.matchCount - a.matchCount; // descending
              } else {
                return a.originalOrder - b.originalOrder; // ascending
              }
            });

            categories = categories.slice(0, MAX_ITEMS);

            let oldCategories = oldCustomData ?
            // previous customization: use either categories (news) or links (other SmartCliqz)
            this.isNews(smartCliqz) ? oldCustomData.categories : oldCustomData.links :
            // no previous customization: use default order
            smartCliqz.data.categories;

            // send some stats
            this._sendStats(oldCategories, categories, oldCustomData ? true : false, urls);

            // TODO: define per SmartCliqz what the data field to be customized is called
            if (this.isNews(smartCliqz)) {
              this._customDataCache.store(url, { categories: categories });
            } else {
              this._customDataCache.store(url, { links: categories });
            }

            this._log('_prepareCustomData: done preparing for ' + url);
            this._customDataCache.save(CUSTOM_DATA_CACHE_FILE);
          }).catch(e => console$1.error('_prepareCustomData: error while fetching data: ' + e.message));
        }

        // checks if URL from history matches a category URL
        _isMatch(historyUrl, categoryUrl) {
          // TODO: check for subcategories, for example,
          //       Spiegel 'Soziales' has URL 'wirtschaft/soziales',
          //     thus such entries are counted twice, for 'Sozialez',
          //     but also for 'Wirtschaft'
          return historyUrl.indexOf(categoryUrl) > -1;
        }

        // from history, fetches all visits to given domain within 30 days from now (async.)
        _fetchVisitedUrls(domain) {
          return new Promise((resolve, reject) => {
            this._log('_fetchVisitedUrls: start fetching for domain ' + domain);
            // TODO: make cross platform
            const historyService = Components.classes['@mozilla.org/browser/nav-history-service;1'].getService(Components.interfaces.nsINavHistoryService);

            if (!historyService) {
              reject('_fetchVisitedUrls: history service not available');
            } else {
              const options = historyService.getNewQueryOptions();
              const query = historyService.getNewQuery();
              query.domain = domain;
              // 30 days from now
              query.beginTimeReference = query.TIME_RELATIVE_NOW;
              query.beginTime = -1 * 30 * 24 * 60 * 60 * 1000000;
              query.endTimeReference = query.TIME_RELATIVE_NOW;
              query.endTime = 0;

              const result = historyService.executeQuery(query, options);
              const container = result.root;
              container.containerOpen = true;

              let urls = [];
              for (let i = 0; i < container.childCount; i++) {
                urls[i] = container.getChild(i).uri;
              }

              this._log('_fetchVisitedUrls: done fetching ' + urls.length + ' URLs for domain ' + domain);
              resolve(urls);
            }
          });
        }

        _sendStats(oldCategories, newCategories, isRepeatedCustomization, urls) {
          const stats = {
            type: 'activity',
            action: 'smart_cliqz_customization',
            // SmartCliqz id
            id: 'na',
            // total number of URLs retrieved from history
            urlCandidateCount: urls.length,
            // number of URLs that produced a match within shown categories (currently 5)
            urlMatchCount: 0,
            // average number of URL matches across shown categories
            urlMatchCountAvg: 0,
            // standard deviation of URL matches across shown categories
            urlMatchCountSd: 0,
            // number of categories that changed (per position; swap counts twice)
            categoriesPosChangeCount: 0,
            // number of categories kept after re-ordering (positions might change)
            categoriesKeptCount: 0,
            // average position change of a kept categories
            categoriesKeptPosChangeAvg: 0,
            // true, if this customization is a re-customization
            isRepeatedCustomization: isRepeatedCustomization
          };

          let oldPositions = {};
          const length = Math.min(oldCategories.length, newCategories.length);

          for (let i = 0; i < length; i++) {
            stats.urlMatchCount += newCategories[i].matchCount;
            oldPositions[oldCategories[i].title] = i;

            if (newCategories[i].title !== oldCategories[i].title) {
              stats.categoriesPosChangeCount++;
            }
          }
          stats.urlMatchCountAvg = stats.urlMatchCount / length;

          for (let i = 0; i < length; i++) {
            stats.urlMatchCountSd += Math.pow(stats.urlMatchCountAvg - newCategories[i].matchCount, 2);
          }
          stats.urlMatchCountSd /= length;
          stats.urlMatchCountSd = Math.sqrt(stats.urlMatchCountSd);

          for (let i = 0; i < length; i++) {
            if (oldPositions.hasOwnProperty(newCategories[i].title)) {
              stats.categoriesKeptCount++;
              stats.categoriesKeptPosChangeAvg += Math.abs(i - oldPositions[newCategories[i].title]);
            }
          }
          stats.categoriesKeptPosChangeAvg /= stats.categoriesKeptCount;

          CliqzUtils.telemetry(stats);
        }

        // log helper
        _log(msg) {
          CliqzUtils.log(msg, 'smart-cliqz-cache');
        }
      }

      const HOUR = 1000 * 60 * 60;
      const DAY = 24 * HOUR;
      /**
      * @namespace smart-cliqz-cache
      */
      class TriggerUrlCache extends Cache {
        /**
        * @class TriggerUrlCache
        * @constructor
        */
        constructor() {
          let file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cliqz/smartcliqz-trigger-urls-cache.json';

          super(false);
          this.file = file;
          this.init();
        }
        /**
        * @method init
        */
        init() {
          this.load();
          this.scheduleRecurringClean();
        }
        /**
        * @method load
        */
        load() {
          return super.load(this.file);
        }
        /**
        * @method save
        */
        save() {
          return super.save(this.file);
        }
        /**
        * @method scheduleRecurringClean
        * @param delay
        */
        scheduleRecurringClean(delay) {
          if (!delay) {
            const lastCleanTime = CliqzUtils.getPref('smart-cliqz-last-clean-ts');
            if (!lastCleanTime) {
              delay = 0;
            } else {
              const timeSinceLastClean = Date.now() - new Date(Number(lastCleanTime));
              delay = timeSinceLastClean > DAY ? 0 : DAY - timeSinceLastClean;
            }
          }

          this.cleanTimeout = CliqzUtils.setTimeout(_ => {
            this.clean().then(_ => {
              CliqzUtils.setPref('smart-cliqz-last-clean-ts', Date.now().toString());
              this.scheduleRecurringClean(DAY);
            });
          }, delay);
          CliqzUtils.log(`scheduled SmartCliqz trigger URLs cleaning in ${Math.round(delay / 1000 / 60)} minutes`);
        }

        /**
        * clean trigger URLs that are no longer valid
        * @method clean
        * @param delay {Number}
        */
        clean() {
          let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;

          return new Promise((resolve, reject) => {
            CliqzUtils.log('start cleaning SmartCliqz trigger URLs');

            const cleaners = Object.keys(this._cache).map((url, idx) => () => {
              return new Promise((resolve, reject) => {
                CliqzUtils.setTimeout(() => {
                  if (this.isUnloaded) {
                    reject('unloaded');
                    return;
                  }
                  getSmartCliqz(url).then(smartCliqz => {
                    if (!smartCliqz.data.trigger_urls.some(u => u === url)) {
                      CliqzUtils.log(`unknown trigger URL: deleting SmartCliqz ${url}`);
                      this.delete(url);
                      this.save();
                    }
                    resolve();
                  }).catch(e => {
                    if (e.type && e.type === 'URL_NOT_FOUND') {
                      CliqzUtils.log(`unkown URL: deleting SmartCliqz ${url}`);
                      this.delete(url);
                      this.save();
                    }
                    resolve();
                  });
                }, idx * delay);
              });
            });
            // final action: resolve
            cleaners.push(() => {
              CliqzUtils.log('done cleaning SmartCliqz trigger URLs');
              resolve();
              return Promise.resolve();
            });
            // execute sequentually
            cleaners.reduce((current, next) => current.then(_ => next(), e => {
              reject(e);return Promise.reject();
            }), Promise.resolve());
          });
        }
      }

      /*
       * This module handles results(url) comparison
       *
       */

      var UrlCompare = {

        // Compare two URLs and return true if same or differing only by
        // country code in subdomain or path.
        sameUrls: function sameUrls(url1, url2) {
          if (!url1 || !url2) {
            return false;
          }

          // Get generalized representation of each url
          var keys1 = UrlCompare._extractKeys(url1, '');
          var keys2 = UrlCompare._extractKeys(url2, '');

          // Compare the second one, which takes path into account
          return keys1[1] == keys2[1];
        },

        _filterTLDs: function _filterTLDs(domain) {
          var v = domain.toLowerCase().split('.');

          // remove the first level yes or yes
          var first_level = TLDs[v[v.length - 1]];
          v[v.length - 1] = null;

          if (v.length > 2 && first_level == 'cc') {
            // check if we also have to remove the second level, only if 3 or more
            //  levels and the first_level was a country code
            if (TLDs[v[v.length - 2]]) {
              v[v.length - 2] = null;
            }
          }

          // remove the nulls
          v = v.filter(function (n) {
            return n !== null;
          });

          // let's go to remove locales from the beginning, only if at least 2 or
          // more levels remaining and if the first_level was not a country code
          if (v.length > 1 && first_level != 'cc') {

            // cover the case de.wikipedia.org
            if (TLDs[v[0]] == 'cc' || v[0] == 'en') {
              v[0] = null;
            } else {
              // cover the case de-de.facebook.com
              var w = v[0].split('-');
              if (w.length == 2 && (TLDs[w[0]] == 'cc' || w[0] == 'en') && (TLDs[w[1]] == 'cc' || w[1] == 'en')) {
                v[0] = null;
              }
            }
          }

          // remove the nulls and join
          return v.filter(function (n) {
            return n !== null;
          }).join('.');
        },

        _filterTLDsInPath: function _filterTLDsInPath(path) {

          var v = path.toLowerCase().split('/');

          // it should have at least 2, "/".split('/') => ['', '']

          // we only consider the top level element in the path
          if (v.length > 1) {
            if (TLDs[v[1]] == 'cc') {
              v[1] = null;
            } else {
              var w = v[1].split('-');
              if (w.length == 2 && (TLDs[w[0]] == 'cc' || w[0] == 'en') && (TLDs[w[1]] == 'cc' || w[1] == 'en')) {
                v[1] = null;
              }
            }
          }

          // remove the nulls and join

          var clean_v = v.filter(function (n) {
            return n !== null;
          });

          var new_path = '/';

          if (clean_v.length > 1) {
            new_path = v.filter(function (n) {
              return n !== null;
            }).join('/');
          } else {
            // special case when clean_v has only one element, it will not join the
            // initial slash
            new_path = '/' + v.filter(function (n) {
              return n !== null;
            }).join('/');
          }

          new_path = new_path.replace('//', '/');

          return new_path;
        },

        _extractKeys: function _extractKeys(url, title) {
          var clean_url = url.toLowerCase().replace(/^http[s]*:\/\//, '').replace(/^www\./, '');
          var v = clean_url.split('/');
          var domain = v[0];
          var path = '/';

          if (v.length > 1) {
            // remove the query string
            v[v.length - 1] = v[v.length - 1].split('?')[0];

            if (v[1] == '#') {
              // the path starts with # which is used for internal routing,
              // remove for keys
              // http://klout.com/#/solso == http://klout.com/solso
              if (v.length > 2) path = '/' + v.splice(2, v.length - 1).join('/');
            } else path = '/' + v.splice(1, v.length - 1).join('/');
          }

          domain = UrlCompare._filterTLDs(domain);
          path = UrlCompare._filterTLDsInPath(path);

          // if no title or empty, generate a random key.
          // This is a fail-safe mechanism
          if (title === undefined || title === null || title.trim() === '') {
            title = '' + Math.random();
          }

          return [domain, domain + path, domain + title];
        }
      };

      var _extends$7 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      /*
       * This module mixes the results from cliqz with the history
       *
       */

      function objectExtend(target, obj) {
        Object.keys(obj).forEach(function (key) {
          target[key] = obj[key];
        });

        return target;
      }

      const isMovieTemplate = template => {
        return template === 'movieEZ' || template === 'cinemaEZ' || template === 'movie';
      };

      const allowOnlyOneMovie = results => {
        let hasMovie = false;
        return results.map(r => {
          if (isMovieTemplate(r.data.template) && hasMovie) {
            return _extends$7({}, r, {
              data: _extends$7({}, r.data, {
                template: 'generic'
              })
            });
          } else if (isMovieTemplate(r.data.template)) {
            hasMovie = true;
          }
          return r;
        });
      };

      // enriches data kind
      function kindEnricher(newKindParams, kind) {
        var parts = kind.split('|'),
            params = JSON.parse(parts[1] || '{}');

        objectExtend(params, newKindParams);

        return parts[0] + '|' + JSON.stringify(params);
      }

      function resultKindEnricher(newKindParams, result) {
        result.data.kind[0] = kindEnricher(newKindParams, result.data.kind[0]);
        return result;
      }

      class Mixer {
        constructor() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          let smartCliqzCache = _ref.smartCliqzCache,
              triggerUrlCache = _ref.triggerUrlCache;

          this.EZ_COMBINE = ['generic'];
          this.EZ_QUERY_BLACKLIST = ['www', 'www.', 'http://www', 'https://www', 'http://www.', 'https://www.'];
          this.smartCliqzCache = smartCliqzCache;
          this.triggerUrlCache = triggerUrlCache;
        }

        // Collect all sublinks and return a single list.
        //  - called recursively, looking for any keys that look like URLs
        _collectSublinks(data) {
          var links = [];

          for (var key in data) {
            if (typeof data[key] == 'object') {
              // recurse
              links = links.concat(this._collectSublinks(data[key]));
            } else if (['url', 'href'].indexOf(key) != -1) {
              links.push(data[key]);
            }
          }

          return links;
        }

        // mark entries in second that are found in first
        _getDuplicates(first, second) {
          var mixer = this;
          return second.map(function (c) {
            var duplicate = false;
            first.forEach(function (i) {
              // Does the main link match?
              if (UrlCompare.sameUrls(c.label, i.label)) {
                duplicate = true;
                return;
              }

              // Do any of the sublinks match?
              var sublinks = mixer._collectSublinks(i.data);
              sublinks.some(function (u) {
                if (UrlCompare.sameUrls(u, c.label)) {
                  duplicate = true;
                  return true; // stop iteration
                }
              });
            });

            if (duplicate) {
              return c;
            }
          }).filter(function (result) {
            return result;
          });
        }

        // Remove results from second list that are present in the first
        _deduplicateResults(first, second) {
          // 2 cases when the first backend result is an EZ and the url matches the first
          // history result
          if (first.length > 0 && first[0].style === 'cliqz-pattern' && !first[0].data.cluster && second.length > 0 && second[0].style === 'cliqz-extra' && UrlCompare.sameUrls(first[0].data.urls[0].href, second[0].val)) {
            // Case 1: History pattern
            second.shift();
          } else if (first.length > 0 && first[0].style === 'favicon' && second.length > 0 && second[0].style === 'cliqz-extra' && UrlCompare.sameUrls(first[0].val, second[0].val)) {
            // Case 2: Simple history result
            const localResult = first.shift();
            const globalResult = second.shift();
            globalResult.data.kind = [...(localResult.data.kind || []), ...(globalResult.data.kind || [])];
            first = [globalResult, ...first];
          }

          // Remove map result from first if exists in second
          if (first && first[0]) {
            if (first[0].data.urls) {
              // cluster
              first[0].data.urls = first[0].data.urls.filter(result => {
                return !second.some(secondResult => {
                  const data = secondResult.data;
                  if (data && data.extra && data.extra.mu) {
                    return result.href === data.extra.mu;
                  } else {
                    return false;
                  }
                });
              });
            } else {
              // simple history
              first = first.filter(result => {
                return !second.some(secondResult => {
                  const data = secondResult.data;
                  if (data && data.extra && data.extra.mu) {
                    return result.val === data.extra.mu;
                  } else {
                    return false;
                  }
                });
              });
            }
          }

          var duplicates = this._getDuplicates(first, second);
          // remove duplicates from second list
          second = second.filter(function (c) {
            return duplicates.indexOf(c) === -1;
          });
          // take data from duplicate second result to augment result
          // Note: this does not combine data if it is a sublink match
          first = first.map(function (r) {
            duplicates.forEach(function (dup) {
              if (UrlCompare.sameUrls(r.val, dup.val)) {
                r = Result.combine(r, dup);
              }
            });

            return r;
          });
          return { first: first, second: second };
        }

        // Special case deduplication: remove clustered links from history if already
        // somewhere else in the EZ
        _deduplicateHistory(result) {
          // Collect sublinks not in history
          var otherLinks = [];
          Object.keys(result.data).filter(function (key) {
            return key != 'urls';
          }).forEach(function (key) {
            var sublinks = this._collectSublinks(result.data[key]);
            otherLinks.concat(sublinks);
          }.bind(this));
          // Filter history entry, if
          result.data.urls = result.data.urls.filter(function (entry) {
            var duplicate = false;
            otherLinks.some(function (u) {
              if (UrlCompare.sameUrls(u, entry.label)) {
                duplicate = true;
                return true; // stop iteration
              }
            });

            return !duplicate;
          });
        }

        _getSmartCliqzId(smartCliqz) {
          return smartCliqz.data.subType.id;
        }
        // Find any entity zone in the results and cache them for later use.
        // Go backwards to prioritize the newest, which will be first in the list.
        _cacheEZs(extraResults) {
          if (!this.smartCliqzCache || !this.triggerUrlCache) {
            return;
          }
          var mixer = this;
          // slice creates a shallow copy, so we don't reverse existing array.
          extraResults.slice().reverse().forEach(function (r) {
            var trigger_urls = r.data.trigger_urls || [];
            var wasCacheUpdated = false;

            trigger_urls.forEach(function (url) {
              if (!mixer.triggerUrlCache.isCached(url)) {
                mixer.triggerUrlCache.store(url, true);
                wasCacheUpdated = true;
              }
            });

            if (wasCacheUpdated) {
              mixer.triggerUrlCache.save();
            }

            mixer.smartCliqzCache.store(r);
          });
        }

        // Take the first entry (if history cluster) and see if we can trigger an EZ
        // with it, this will override an EZ sent by backend.
        _historyTriggerEZ(result) {
          if (!result || !result.data || !result.data.cluster || // if not history cluster
          result.data.autoAdd) {
            // if the base domain was auto added (guessed)
            return undefined;
          }

          if (!this.smartCliqzCache || !this.triggerUrlCache) {
            return undefined;
          }

          var url = CliqzUtils.generalizeUrl(result.val, true),
              ez;

          if (this.triggerUrlCache.isCached(url)) {
            var ezId = this.triggerUrlCache.retrieve(url);
            // clear dirty data that got into the data base
            if (ezId === 'deprecated') {
              this.triggerUrlCache.delete(url);
              return undefined;
            }
            ez = this.smartCliqzCache.retrieveAndUpdate(url);
            if (ez) {
              // Cached EZ is available
              ez = Result.clone(ez);

              // copy over title and description from history entry
              if (!result.data.generic) {
                ez.data.title = result.data.title;
                if (!ez.data.description) ez.data.description = result.data.description;
              }

              resultKindEnricher({ trigger_method: 'history_url' }, ez);
            } else {
              // Not available: start fetching now so it is available soon
              this.smartCliqzCache.fetchAndStore(url);
            }

            if (this.triggerUrlCache.isStale(url)) {
              this.triggerUrlCache.delete(url);
            }
          }

          return ez;
        }

        // Filter out any EZs that conflict with the firstresult
        _filterConflictingEZ(cliqzExtra, firstresult) {
          return cliqzExtra.filter(function (ez) {

            // Did we make a 'bet' on a url from history that does not match this EZ?
            if (firstresult.data && firstresult.data.cluster && !UrlCompare.sameUrls(ez.val, firstresult.val)) {
              CliqzUtils.log('Not showing EZ ' + ez.val + ' because different than cluster ' + firstresult.val, 'Mixer');
              return false;
            }

            // Will the autocomplete change if we use this EZ?
            if (firstresult.autocompleted && !UrlCompare.sameUrls(ez.val, firstresult.val)) {
              CliqzUtils.log('Not showing EZ ' + ez.val + ' because autocomplete would change', 'Mixer');
              return false;
            }

            return true;
          });
        }

        // Mix together history, backend and custom results. Called twice per query:
        // once with only history (instant), second with all data.
        mix(q, cliqz, history, customResults, only_history) {
          // Prepare other incoming data
          customResults = customResults || [];
          var cliqzExtra = [],
              results = [],
              r = { first: [], second: [] }; // format returned by this._deduplicateResults()

          // Pick EZ if any is available. Give priority to customResults then history-triggered
          // EZ, then backend EZ.
          var historyEZ = this._historyTriggerEZ(history[0]);

          if (historyEZ) {
            cliqzExtra = [historyEZ];
          } else if (cliqz && cliqz.length > 0 && cliqz[0].style == 'cliqz-extra') {
            cliqzExtra = [cliqz[0]];
            this._cacheEZs(cliqzExtra);
          }
          var ez = cliqzExtra[0];
          // Add EZ to result list
          if (ez) {
            CliqzUtils.log('EZ (' + ez.data.kind + ') for ' + ez.val, 'Mixer');

            // Were any history results also available as a cliqz result?
            // if so, remove from backend list and combine sources in history result
            if (history.length > 0 && history[0].data.cluster && this.EZ_COMBINE.indexOf(ez.data.template) !== -1 && UrlCompare.sameUrls(history[0].val, ez.val)) {
              CliqzUtils.log('Making combined entry.', 'Mixer');
              history[0] = Result.combine(ez, history[0]);
              this._deduplicateHistory(history[0]);
            } else {
              // Add EZ to top of result list
              if (history.length > 0) {
                cliqzExtra = this._filterConflictingEZ(cliqzExtra, history[0]);
              }
              r = this._deduplicateResults(cliqzExtra, cliqz);
              results = r.first.concat(r.second);
            }
          }
          // start with the richer result
          r = this._deduplicateResults(history, cliqz);
          // Prepare results: history (first) then backend results (second)
          results = customResults.concat(r.first).concat(r.second);

          if (!isMobile) {
            results = allowOnlyOneMovie(results);
          }

          CliqzUtils.log('only_history:' + only_history + ' history:' + history.length + ' cliqz:' + cliqz.length + ' extra:' + cliqzExtra.length, 'Mixer');

          // At this point, history, EZs, custom results & search results are mixed &
          // deduplicated

          // Special case: adjust second result if it doesn't fit
          if (CliqzUtils.getPref('hist_search_type', 0) == 0 && results.length > 1 && results[1].data.template == 'pattern-h2') {
            CliqzUtils.log('Converting cluster for ' + results[1].val + ' to simple history', 'Mixer');

            // convert to simple history entry
            var simple = Result.generic('favicon', results[1].val, results[1].image, results[1].data.title, null, searchString);
            simple.data.kind = ['H'];
            simple.data.description = result[1].data.description;
            results[1] = simple;
          }

          // Only show a maximum 3 BM results and 3 suggestions
          var cliqzRes = 0,
              suggestions = 0;
          results = results.filter(function (r) {
            if (r.style.indexOf('cliqz-results ') === 0) {
              cliqzRes++;
              return cliqzRes <= 3;
            }
            if (r.style.indexOf('cliqz-suggestion') === 0) {
              suggestions++;
              return suggestions <= 3;
            }
            return true;
          });

          //TODO Refactor (EX-4497: Old dropdown cleanup)
          if (results.length === 0 && !only_history) {
            CliqzUtils.getNoResults && results.push(CliqzUtils.getNoResults(q));
          }

          return results;
        }
      }

      class SpellCheck {
        constructor() {
          this.active = false;
          this.spellCorrectionDict = {};
          this.resetState();
          if (isFirefox && CliqzUtils.getPref('backend_country', 'de') == 'de') {
            CliqzUtils.log('Initializing', 'SpellChecker');
            CliqzUtils.loadResource(`${config.baseURL}spell_check.list`, this.loadRecords.bind(this));
          }
        }
        resetState() {
          this.state = {
            'on': false,
            'correctBack': {},
            'override': false,
            'pushed': null,
            'userConfirmed': false,
            'searchTerms': []
          };
        }
        check(q) {
          var words = q.split(" ");
          var correctBack = {};
          for (var i = 0; i < words.length; i++) {
            if (words[i] == "") continue;
            if (this.spellCorrectionDict.hasOwnProperty(words[i])) {
              var correct = this.spellCorrectionDict[words[i]];
              if (correct.length > words[i].length && correct.slice(0, words[i].length) == words[i] && i == words.length - 1) continue;
              if (correct.length < words[i].length && words[i].slice(0, correct.length) == correct && i == words.length - 1) continue;
              if (i == words.length - 1 && words[i].length <= 10) // long enough to correct the last word
                continue;
              correctBack[correct] = words[i];
              words[i] = correct;
            }
          }
          return [words.join(" "), correctBack];
        }
        loadRecords(req) {
          var content = req.response.split("\n");
          for (var i = 0; i < content.length; i++) {
            var words = content[i].split("\t");
            var wrong = words[0];
            var right = words[1];
            this.spellCorrectionDict[wrong] = right;
          }
          this.active = true;
        }
        getCurrentMessage(urlbarVal) {
          if (this.active && // loading is done
          this.state.on && !this.state.override && !this.state.userConfirmed && CliqzUtils.getPref('spellCorrMessage', true)) {
            var terms = urlbarVal.split(" ");
            var messages = [];
            var termsObj = {};
            for (var i = 0; i < terms.length; i++) {
              termsObj = {
                correct: terms[i]
              };
              messages.push(termsObj);
              if (this.state.correctBack[terms[i]]) {
                messages[i].correctBack = this.state.correctBack[terms[i]];
              } else {
                messages[i].correctBack = "";
              }
            }
            //cache searchTerms to check against when user keeps spellcorrect
            this.state.searchTerms = messages;

            return messages;
          }
        }
        revert(urlbarVal) {
          for (var c in this.state.correctBack) {
            urlbarVal = urlbarVal.replace(c, this.state.correctBack[c]);
          }
          this.state.override = true;
          return urlbarVal;
        }
        keep() {
          for (var i = 0; i < this.state.searchTerms.length; i++) {
            //delete terms that were found in correctBack dictionary. User accepted our correction:-)
            for (var c in this.state.correctBack) {
              if (this.state.correctBack[c] === this.state.searchTerms[i].correctBack) {
                delete this.state.correctBack[c];
              }
            }
          }

          this.state.userConfirmed = true;
        }

        unload() {
          this.spellCorrectionDict = {};
        }
      }

      // TODO: to be removed after implementation
      /* eslint no-unused-vars: OFF */
      /* eslint import/prefer-default-export: OFF */
      function handleQuerySuggestions(query, suggestions) {
        // TBD
      }

      class TimeoutError extends Error {}

      function isQinvalid(q) {
        //TODO: add more
        if (q.indexOf('view-source:') === 0) return true;

        return false;
      }

      function delay(time) {
        return new Promise(function (resolve) {
          setTimeout(resolve, time);
        });
      }

      function timeout(promise, time) {
        const _timeout = delay(time).then(() => {
          throw new TimeoutError('Timeout');
        });
        return Promise.race([promise, _timeout]);
      }

      function handleError$1(e) {
        return {
          reason: e,
          isInvalid: true
        };
      }

      class HistoryCache {
        constructor(size) {
          this.cache = [];
          this.lastQuery = '';
          this.maxSize = size;
        }

        add(results, query) {
          // reset the cache is query changes completely
          if (query.indexOf(this.lastQuery) === -1 && this.lastQuery.indexOf(query) === -1) {
            this.cache = [];
          }

          // limit cache size by reducing oldest 25% of results
          if (this.cache.length > this.maxSize) {
            this.cache = this.cache.slice(0, this.maxSize - this.maxSize * 1 / 4);
          }

          this.lastQuery = query;

          // we reverse the results array as we are prepending all
          // the new unique results at the beginning of the cache
          results.reverse().forEach(r => {
            const exists = this.cache.some(function (c) {
              return c.value === r.value;
            });

            if (!exists) this.cache.unshift(r);
          });

          // console.log("History cache new state", this.cache, query);
        }

        search(query) {
          const queryParts = query.toLowerCase().split(' ');

          return {
            query: query,
            ready: true, // this function is only called as last resort - so we need to consider it final result
            results: this.cache.filter(function (r) {
              const querySpace = r.value.toLowerCase() + ' ' + r.comment.toLowerCase();

              // filter out all the results which do not contain the query
              return queryParts.some(queryPart => querySpace.indexOf(queryPart) !== -1);
            })
          };
        }
      }

      class ProviderAutoCompleteResultCliqz {
        constructor(searchString, searchResult, defaultIndex, errorDescription) {
          this._searchString = searchString;
          this._searchResult = searchResult;
          this._defaultIndex = defaultIndex;
          this._errorDescription = '';
          this._results = [];
        }

        get searchString() {
          return this._searchString;
        }
        get searchResult() {
          return this._searchResult;
        }
        get defaultIndex() {
          return this._defaultIndex;
        }
        get errorDescription() {
          return this._errorDescription;
        }
        get matchCount() {
          return this._results.length;
        }
        getValueAt(index) {
          return (this._results[index] || {}).val;
        }
        getFinalCompleteValueAt(index) {
          return this.getValueAt(index);
        }
        getCommentAt(index) {
          return (this._results[index] || {}).comment;
        }
        getStyleAt(index) {
          return (this._results[index] || {}).style;
        }
        getImageAt(index) {
          return (this._results[index] || {}).image || '';
        }
        getLabelAt(index) {
          return (this._results[index] || {}).label;
        }
        getDataAt(index) {
          return (this._results[index] || {}).data;
        }

        setResults(results) {

          this._results = results;
          CliqzAutocomplete.lastResult = this;
          CliqzEvents.pub('autocomplete.new_result', { result: this, isPopupOpen: CliqzAutocomplete.isPopupOpen });
          var order = CliqzAutocomplete.getResultsOrder(this._results);
          CliqzUtils.setResultOrder(order);

          // flag for rendering to avoid rendering of "unmixed" results
          this.isMixed = true;
        }

      }

      class Search {
        constructor() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          let successCode = _ref.successCode;

          this.TIMEOUT = 1000;
          this.HISTORY_TIMEOUT = 500;
          this.REFETCH_MAX_ATTEMPTS = 10; // How many times should we try fetching incomplete (promised) results before giving up?
          this.REFETCH_DELAY = 100; // delay before refetch

          var mixerArgs = isFirefox ? {
            smartCliqzCache: new SmartCliqzCache(),
            triggerUrlCache: new TriggerUrlCache()
          } : {};
          this.successCode = successCode;
          this.mixer = new Mixer(mixerArgs);
          this.spellCheck = new SpellCheck();
          this.resultsTimer = null;
          this.historyTimer = null;
          this.historyTimeout = false;
          this.instant = [];
          CliqzAutocomplete.spellCheck = this.spellCheck;
          this.resultProviders = CliqzAutocomplete.CliqzResultProviders;
          this.rerankerTimeouts = {
            before: 30,
            during: this.TIMEOUT,
            after: 30
          };

          this.cache = new HistoryCache(500);
        }

        search(searchString, callback) {
          if (CliqzUtils.getPref('searchMode', 'autocomplete') !== 'autocomplete') {
            // if there is a query, the new mixer (search module) always has some
            // results, thus here we push a dummy result so Firefox thinks it
            // should render something.
            if (!searchString.trim()) {
              return;
            }

            const results = new ProviderAutoCompleteResultCliqz(this.searchString, this.successCode, -2, // blocks autocomplete
            '');

            results.setResults([{}]);

            callback(results);

            return;
          }

          CliqzEvents.pub('autocomplete:search', searchString);

          CliqzAutocomplete.lastQueryTime = Date.now();
          CliqzAutocomplete.lastDisplayTime = null;
          //      CliqzAutocomplete.lastResult = null;
          CliqzAutocomplete.lastSuggestions = null;
          this.oldPushLength = 0;
          this.customResults = null;
          this.latency = {
            cliqz: null,
            history: null,
            backend: null,
            mixed: null,
            all: null
          };
          this.userRerankers = {};
          this.historyCacheHit = false;

          console$1.log('search: ' + searchString, CliqzAutocomplete.LOG_KEY);

          var invalidQ = isQinvalid(searchString.trim()),
              action = {
            type: 'activity',
            action: 'key_stroke',
            current_length: searchString.length,
            invalid: invalidQ
          };
          CliqzUtils.telemetry(action);

          if (invalidQ) {
            //we call the callback with no results to trigger a dropdown close
            callback(null, this);
            return;
          }

          if (CliqzAutocomplete.lastSearch.length > searchString.length) {
            this.spellCheck.state.override = true;
          }
          // analyse and modify query for custom results
          CliqzAutocomplete.lastSearch = searchString;
          searchString = this.analyzeQuery(searchString);

          // spell correction
          const window = CliqzUtils.getWindow();
          var urlbar = window ? window.document.getElementById('urlbar') : null;
          if (urlbar && //we do not have urlbar on mobile TODO - fix it better!
          !this.spellCheck.state.override && urlbar.selectionEnd == urlbar.selectionStart && urlbar.selectionEnd == urlbar.value.length) {
            var parts = CliqzAutocomplete.spellCheck.check(searchString);
            var newSearchString = parts[0];
            var correctBack = parts[1];

            for (var c in correctBack) {
              this.spellCheck.state.correctBack[c] = correctBack[c];
            }
          } else {
            // user don't want spell correction
            var newSearchString = searchString;
          }
          this.wrongSearchString = searchString;
          if (newSearchString != searchString) {
            // the local spell checker kicks in
            var action = {
              type: 'activity',
              action: 'spell_correction',
              current_length: searchString.length
            };
            CliqzUtils.telemetry(action);
            this.spellCheck.state.on = true;
            searchString = newSearchString;
            this.spellCheck.state.userConfirmed = false;
          }

          this.cliqzResults = null;
          this.cliqzResultsDone = false;
          this.cliqzResultsParams = {};
          this.cliqzCache = null;
          this.historyResults = null;
          this.instant = [];

          this.callback = callback;
          this.searchString = searchString;
          this.searchStringSuggest = null;
          this.mixedResults = new ProviderAutoCompleteResultCliqz(this.searchString, this.successCode, -2, // blocks autocomplete
          '');

          this.startTime = Date.now();
          this.mixedResults.suggestionsRecieved = false;
          // ensure context
          this.cliqzResultFetcher = this.cliqzResultFetcher.bind(this);
          this.pushResults = this.pushResults.bind(this);
          this.historyTimeoutCallback = this.historyTimeoutCallback.bind(this);
          this.pushTimeoutCallback = this.pushTimeoutCallback.bind(this);
          this.historyPatternCallback = this.historyPatternCallback.bind(this);
          this.createInstantResultCallback = this.createInstantResultCallback.bind(this);
          CliqzHistoryCluster.historyCallback = this.historyPatternCallback;
          if (searchString.trim().length) {
            this.getSearchResults(searchString).then(this.cliqzResultFetcher);

            if (this.spellCheck.state.on && !this.spellCheck.state.override) {
              this.mixedResults.suggestionsRecieved = true;
              // change the wrong string to the real wrong string
              for (var p in this.spellCheck.state.correctBack) {
                if (this.wrongSearchString.indexOf(this.spellCheck.state.correctBack[p]) == -1) {
                  this.wrongSearchString = this.wrongSearchString.replace(p, this.spellCheck.state.correctBack[p]);
                }
              }
              this.cliqzSuggestions = [searchString, this.wrongSearchString];
              CliqzAutocomplete.lastSuggestions = this.cliqzSuggestions;
              console$1.log(CliqzAutocomplete.lastSuggestions, 'spellcorr');

              //TODO: extract spell corrector out of CliqzAutocomplete
              if (urlbar) {
                urlbar.mInputField.setUserInput(searchString);
              }
            }
            CliqzUtils.clearTimeout(this.resultsTimer);
            this.resultsTimer = CliqzUtils.setTimeout(this.pushTimeoutCallback, CliqzUtils.RESULTS_TIMEOUT, this.searchString);
          } else {
            this.cliqzResults = null;
            this.cliqzResultsDone = true;
            CliqzAutocomplete.spellCheck.resetState();
          }

          CliqzUtils.clearTimeout(this.historyTimer);
          this.historyTimer = CliqzUtils.setTimeout(this.historyTimeoutCallback, this.HISTORY_TIMEOUT, this.searchString);
          this.historyTimeout = false;
          // trigger history search
          CliqzUtils.historySearch(searchString, this.onHistoryDone.bind(this), CliqzUtils.isPrivateMode(window));

          var hist_search_type = CliqzUtils.getPref('hist_search_type', 0);
          if (hist_search_type != 0) {
            console$1.log('Calling CliqzHM.cliqz_hm_search for: ' + searchString, 'CliqzHM');
            this.cliqz_hm_search(this, { 'query': searchString }, hist_search_type);
          }
        }

        static fetchAndCacheResult(query, fun) {
          return fun(query);
        }

        cliqz_hm_search(_this, res, hist_search_type) {
          var data = null;
          var query = res.query || res.q; // query will be called q if RH is down
          if (hist_search_type === 1) {
            data = CliqzUtils.hm.do_search(query, false);
            data['cont'] = null;
          } else {
            data = CliqzUtils.hm.do_search(query, true);
          }

          var urlAuto = CliqzUtils.hm.urlForAutoLoad(data);
          if (false && urlAuto) {
            var win = CliqzUtils.getWindow().gBrowser.contentWindow;
            //if (CliqzAutocomplete.currentAutoLoadURL==null || win.location.href=='about:cliqz') {
            if (win.location.href != urlAuto) {
              console$1.log(">> AUTOLOAD LAUNCH: " + urlAuto, 'CliqzHM');
              win.location.href = urlAuto;
              CliqzAutocomplete.currentAutoLoadURL = urlAuto;
            }
            //}
          }

          // Extract results
          var patterns = [];
          for (var i = 0; i < data.result.length; i++) {
            var url = CliqzUtils.cleanMozillaActions(data.result[i][0])[1],
                title = data.result[i][1];

            if (!title || title == 'N/A') {
              title = CliqzUtils.generalizeUrl(url);
            }
            if (title.length > 0 && url.length > 0 && isValidUrl(url)) {
              var item = {
                url: url,
                title: title,
                favicon: null, //history.results[i].image,
                _genUrl: CliqzUtils.generalizeUrl(url, true)
              };
              if (data.result[i][3]) {
                if (data.result[i][3].hasOwnProperty('c')) {
                  item['xtra_c'] = data.result[i][3]['c'];
                }
                if (data.result[i][3].hasOwnProperty('q')) {
                  item['xtra_q'] = data.result[i][3]['q'];
                }
              }
              patterns.push(item);
            }
            var cont = null;
            if (data.hasOwnProperty('cont')) {
              cont = data['cont'];
            }
          }

          if (patterns.length > 0) {
            var res3 = CliqzHistoryCluster._simplePreparePatterns(patterns, query);
            // This is also causing undefined issue. Specifically when the res.length == 0;
            if (res3.results.length == 0) {
              res3.results.push({ "url": query, "title": "Found no result in local history for query: ", "favicon": "", "_genUrl": "", "base": true, "debug": "" });
            }
            CliqzHistoryCluster.simpleCreateInstantResult(res3, cont, _this.searchString, function (kk2) {
              var vjoin = [];
              vjoin.push(kk2[0]);
              _this.createInstantResultCallback(vjoin, 'hm');
            });
          }
        }

        getSearchResults(searchString) {

          const beforeResults = Promise.all(CliqzUtils.RERANKERS.map(reranker => {
            const promise = reranker.beforeResults ? reranker.beforeResults.bind(reranker) : Promise.resolve.bind(Promise);
            return timeout(promise({ query: searchString }), this.rerankerTimeouts.before).catch(handleError$1);
          }));

          const duringResults = beforeResults.then(resultsArray => {
            const duringResultsPromises = CliqzUtils.RERANKERS.map((reranker, idx) => {
              const promise = reranker.duringResults ? reranker.duringResults.bind(reranker) : Promise.resolve.bind(Promise);
              return timeout(promise(resultsArray[idx]), this.rerankerTimeouts.during);
            });
            return Promise.all([...duringResultsPromises, Search.fetchAndCacheResult(searchString, CliqzUtils.getBackendResults)].map(promise => promise.catch(handleError$1)));
          });

          const afterResults = duringResults.then(results => {
            const backendResults = results.pop();
            return results.reduce((results, rerankerResults, index) => {
              if (!CliqzUtils.RERANKERS[index].afterResults) {
                return results;
              }

              return results.then(x => timeout(CliqzUtils.RERANKERS[index].afterResults(rerankerResults, x), this.rerankerTimeouts.after).catch(() => results).then(res => {
                if (!res.isInvalid && res.response && res.response.telemetrySignal) {
                  this.userRerankers[CliqzUtils.RERANKERS[index].name] = res.response.telemetrySignal;
                }
                return res;
              }));
            }, Promise.resolve(backendResults));
          });

          return afterResults;
        }

        historyTimeoutCallback(query) {
          console$1.log('History timeout', CliqzAutocomplete.LOG_KEY);
          this.historyTimeout = true;

          // if we do not have any history results we try our luck and search in cache
          if (!this.historyResults || !this.historyResults.results || this.historyResults.results.length === 0) {
            const cacheData = this.cache.search(query);
            if (cacheData.results.length > 0) {
              console$1.log("History cache hit", cacheData, this.historyResults);

              this.historyResults = cacheData;
              this.historyCacheHit = true;
            }
          }
          if (this.historyResults) {
            CliqzHistoryCluster.addFirefoxHistory(this.historyResults);
          } else {
            this.pushResults(this.searchString);
          }
        }

        onHistoryDone(result) {
          // delay the cache update
          setTimeout(this.cache.add.bind(this.cache), 0, result.results, result.query);

          if (!this.startTime) {
            return; // no current search, just discard
          }

          var now = Date.now();

          this.historyResults = result;
          this.latency.history = now - this.startTime;

          if (this.isHistoryReady()) {
            // history is ready -> push to UI
            CliqzHistoryCluster.addFirefoxHistory(result);

            // we cancel the history timout timer to avoid having a
            // random call out of the blue
            CliqzUtils.clearTimeout(this.historyTimer);
          } else {
            // history is not ready lets try to add an instant result
            if (this.isHistoryNotEmpty() && (this.instant || []).length == 0) {
              CliqzHistoryCluster.addFirefoxHistory(result);
            }
          }
        }

        isHistoryReady() {
          return this.historyResults && this.historyResults.ready;
        }

        isHistoryNotEmpty() {
          return this.historyResults && this.historyResults.results && this.historyResults.results.length > 0;
        }

        historyPatternCallback(res) {
          // abort if we already have results
          var query = res.query || res.q || ''; // query will be called q if RH is down
          if (this.mixedResults.matchCount > 0) return;

          if (query == this.searchString) {
            CliqzAutocomplete.lastPattern = res;
            var latency = 0;
            if (CliqzHistoryCluster.latencies[query]) {
              latency = new Date().getTime() - CliqzHistoryCluster.latencies[query];
            }
            this.latency.patterns = latency;
            // Create instant result
            CliqzHistoryCluster.createInstantResult(res, this.searchString, this.createInstantResultCallback, this.customResults);
          }
        }

        createInstantResultCallback(instant, type_res) {
          if (type_res == 'hm') {
            instant[0].type = 'hm';
            this.instant.unshift(instant[0]);
          } else {
            if (this.instant.length > 0 && this.instant[0].type == 'hm') {
              this.instant[1] = instant[0];
            } else {
              this.instant = instant;
            }
          }
          this.pushResults(this.searchString);
        }

        pushTimeoutCallback(params) {
          console$1.log("pushResults timeout", CliqzAutocomplete.LOG_KEY);
          this.pushResults(params);
        }

        // checks if all the results are ready or if the timeout is exceeded
        pushResults(q) {
          if (q == this.searchString && (this.startTime != null || this.waitingForPromise)) {
            // be sure this is not a delayed result
            var now = Date.now();

            if (now > this.startTime + CliqzUtils.RESULTS_TIMEOUT || // do we have a timeout or
            (this.isHistoryReady() || this.historyTimeout) && ( // history is ready or timed out and
            this.cliqzResults || this.cliqzResultsDone)) {
              // backend results are ready
              /// Push full result
              CliqzUtils.clearTimeout(this.resultsTimer);
              CliqzUtils.clearTimeout(this.historyTimer);
              this.prepareResults(q);
              this.mixResults(false);

              this.latency.mixed = Date.now() - this.startTime;

              this.callback(this.mixedResults, this);

              this.latency.all = Date.now() - this.startTime;

              // delay wrapping to make sure rendering is complete
              // otherwise we don't get up to date autocomplete stats
              CliqzUtils.setTimeout(this.fullWrapup.bind(this), 0, this);

              return;
            } else if (this.isHistoryReady()) {
              /// Push instant result
              this.latency.mixed = Date.now() - this.startTime;
              this.prepareResults(q);
              this.mixResults(true);

              // try to update as offen as possible if new results are ready
              // TODO - try to check if the same results are currently displaying
              this.mixedResults.matchCount && this.callback(this.mixedResults, this);

              this.latency.all = Date.now() - this.startTime;

              // Do partial wrapup, final wrapup will happen after all results are received
              CliqzUtils.setTimeout(this.instantWrapup, 0, this);
            } else {
              /// Nothing to push yet, probably only cliqz results are received, keep waiting
            }
          }
        }

        loadIncompleteResults(json, q, attemptsSoFar) {
          if (attemptsSoFar > this.REFETCH_MAX_ATTEMPTS) {
            return;
          }

          var incompleteResults = {};
          json.results.forEach(function (r, i) {
            if (r._incomplete) {
              var key = r.trigger_method == 'query' ? 'query' : r.url;
              incompleteResults[key] = {
                index: i,
                result: r
              };
            }
          });

          if (Object.keys(incompleteResults).length > 0) {
            this.waitingForPromise = true;
            var data = JSON.stringify({
              q: q,
              results: Object.keys(incompleteResults).map(k => incompleteResults[k]).filter(r => this.isReadyToRender(r.result)).map(r => ({
                snippet: r.result.snippet,
                template: r.result.template,
                url: r.result.url
              }))
            });
            var url = CliqzUtils.RICH_HEADER + CliqzUtils.getRichHeaderQueryString(q);

            CliqzUtils.httpPut(url, req => {
              var resp = JSON.parse(req.response);
              var newResultSetIndex = {};
              resp.results.forEach(function (result) {
                var key = result.trigger_method == 'query' ? 'query' : result.url;
                var oldRes = incompleteResults[key];
                newResultSetIndex[key] = result;
                if (oldRes) {
                  json.results[oldRes.index] = result;
                }
              });
              /* We need to remove results that were promised, but didn't arrive */
              Object.keys(incompleteResults).forEach(function (key) {
                if (newResultSetIndex[key] == undefined) {
                  json.results.splice(incompleteResults[key].index, 1);
                }
              });
              /*
                 Now json.results contains only ready results & NEW promises
                 (promises from the previous result set were removed)
              */
              this.cliqzResultFetcher({ response: json, query: q }, attemptsSoFar);
              this.waitingForPromise = false;
            }, data);
          }
        }

        isReadyToRender(result) {
          /*
            RH promises that were triggered by query should not be rendered
            immediately. The ones that were triggered by the BM url can be
            rendered as a generic result.
          */
          return result && result.url != 'n/a' && !(result._incomplete && result.type == 'rh' && result.trigger_method == 'query');
        }

        enhanceResult(r, i) {
          var subType = r.subType || {};
          if (r.type == 'rh') {
            subType.trigger_method = 'rh_query';
            delete subType.id;
            delete subType.name;
            subType.ez = 'deprecated';
          }
          subType.i = i;
          subType.cs = r.cs ? 1 : 0;
          r.subType = subType;
          return r;
        }

        // handles fetched results from the cache
        cliqzResultFetcher(res, attemptsSoFar) {
          var json = res.response,
              q = res.query || res.q; // query will be called q if RH is down
          // be sure this is not a delayed result
          if (q != this.searchString) {
            this.discardedResults += 1; // count results discarded from backend because they were out of date
          } else {
            this.latency.backend = Date.now() - this.startTime;
            setTimeout(this.loadIncompleteResults.bind(this), this.REFETCH_DELAY, json, q, (attemptsSoFar || 0) + 1);
            this.cliqzResults = json.results.filter(this.isReadyToRender).map(this.enhanceResult);
            this.cliqzResultsDone = true;

            handleQuerySuggestions(q, json.suggestions);

            this.cliqzResultsParams = {
              choice: json.choice
            };
            this.latency.cliqz = json.duration;

            this.client_cached = json.isClientCached;
          }
          this.pushResults(q);
        }

        prepareResults(q) {
          this.instant = (this.instant || []).map(function (r) {
            r = Result.clone(r);
            if (!r.data.template || CliqzUtils.isUnknownTemplate(r.data.template)) {
              r.data.template = 'generic';
            }
            return r;
          });

          this.cliqzResults = (this.cliqzResults || []).map(function (r, i) {
            return Result.cliqz(r, q);
          });
        }

        // mixes backend results, entity zones, history and custom results
        mixResults(only_instant) {
          // set first history entry as autocompleted if it was
          if (this.instant.length > 0 && CliqzAutocomplete.lastAutocompleteActive && !only_instant) {
            this.instant[0].autocompleted = true;
          }
          var results = this.mixer.mix(this.searchString, this.cliqzResults, this.instant, this.customResults, only_instant);
          CliqzAutocomplete.lastResultIsInstant = only_instant;
          CliqzAutocomplete.afterQueryCount = 0;
          this.mixedResults.setResults(results);
        }

        analyzeQuery(q) {
          var parts = this.resultProviders.getCustomResults(q);
          this.customResults = parts[1];
          return parts[0];
        }

        sendResultsSignal(obj, instant) {
          var results = obj.mixedResults._results;

          var action = {
            type: 'activity',
            action: 'results',
            query_length: CliqzAutocomplete.lastSearch.length,
            result_order: CliqzAutocomplete.prepareResultOrder(results),
            instant: instant,
            popup: CliqzAutocomplete.isPopupOpen ? true : false,
            latency_cliqz: obj.latency.cliqz,
            latency_history: obj.historyTimeout ? null : obj.latency.history,
            latency_patterns: obj.latency.patterns,
            latency_backend: obj.latency.backend,
            latency_mixed: obj.latency.mixed,
            latency_all: obj.startTime ? Date.now() - obj.startTime : null,
            discarded: obj.discardedResults,
            user_rerankers: obj.userRerankers,
            backend_params: obj.cliqzResultsParams,
            proxied: CliqzUtils.getPref('hpn-query', false),
            client_cached: Boolean(obj.client_cached),
            history_cache_hit: obj.historyCacheHit,
            v: 1
          };

          // reset count of discarded backend results
          obj.discardedResults = 0;

          if (CliqzAutocomplete.lastAutocompleteActive) {
            action.autocompleted = CliqzAutocomplete.lastAutocompleteActive;
            action.autocompleted_length = CliqzAutocomplete.lastAutocompleteLength;
          }

          if (action.result_order.indexOf('C') > -1 && CliqzUtils.getPref('logCluster', false)) {
            action.Ctype = CliqzUtils.getClusteringDomain(results[0].val);
          }

          if (CliqzAutocomplete.isPopupOpen) {
            // don't mark as done if popup closed as the user does not see anything
            CliqzAutocomplete.markResultsDone(Date.now());
          }

          // remembers if the popup was open for last result
          CliqzAutocomplete.lastPopupOpen = CliqzAutocomplete.isPopupOpen;
          if (results.length > 0) {
            CliqzAutocomplete.lastDisplayTime = Date.now();
          }
          CliqzUtils.telemetry(action);
        }

        // Wrap up after a completed search
        fullWrapup(obj) {
          if (!this.waitingForPromise) {
            obj.sendResultsSignal(obj, false);
            obj.startTime = null;
            CliqzUtils.clearTimeout(obj.resultsTimer);
            CliqzUtils.clearTimeout(obj.historyTimer);
            obj.resultsTimer = null;
            obj.historyTimer = null;
            obj.cliqzResults = null;
            obj.cliqzResultsDone = false;
            obj.cliqzCache = null;
            obj.historyResults = null;
            obj.instant = [];
          }
        }

        // Wrap up after instant results are shown
        instantWrapup(obj) {
          obj.sendResultsSignal(obj, true);
        }

        unload() {
          this.spellCheck.unload();
        }
      }

      function generateAutocompleteProvider(searchHolder) {
        const ProviderAutoCompleteSearch = function ProviderAutoCompleteSearch() {
          this.search = searchHolder.search;
        };

        ProviderAutoCompleteSearch.prototype.startSearch = function (searchString, searchParam, previousResult, listener) {
          this.search.search(searchString, listener.onSearchResult.bind(listener, this));
        };

        ProviderAutoCompleteSearch.prototype.stopSearch = function () {
          CliqzUtils.clearTimeout(this.search.resultsTimer);
          CliqzUtils.clearTimeout(this.search.historyTimer);
        };
        return ProviderAutoCompleteSearch;
      }

      class AutocompleteComponent {
        constructor() {
          this.searchHolder = {
            get search() {
              if (!this._search) {
                this._search = new Search({
                  successCode: Components.interfaces.nsIAutoCompleteResult.RESULT_SUCCESS
                });
              }
              return this._search;
            },
            unload() {
              if (this._search) {
                this._search.unload();
              }
            }
          };
          this.reg = Components.manager.QueryInterface(Components.interfaces.nsIComponentRegistrar);
          this.FFcontract = {
            classID: Components.ID('{59a99d57-b4ad-fa7e-aead-da9d4f4e77c8}'),
            classDescription: 'Cliqz',
            contractID: '@mozilla.org/autocomplete/search;1?name=cliqz-results',
            QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsIAutoCompleteSearch])
          };
        }

        unregister() {
          try {
            this.searchHolder.unload();
            this.reg.unregisterFactory(this.reg.contractIDToCID(this.FFcontract.contractID), this.reg.getClassObjectByContractID(this.FFcontract.contractID, Components.interfaces.nsISupports));
          } catch (e) {}
        }

        register() {
          const ProviderAutoCompleteSearch = generateAutocompleteProvider(this.searchHolder);
          Object.assign(ProviderAutoCompleteSearch.prototype, this.FFcontract);
          const cp = ProviderAutoCompleteSearch.prototype;
          const factory = XPCOMUtils.generateNSGetFactory([ProviderAutoCompleteSearch])(cp.classID);
          this.reg.registerFactory(cp.classID, cp.classDescription, cp.contractID, factory);
        }
      }

      let background$1 = {
        init() {
          this.autocomplete = new AutocompleteComponent();
          this.autocomplete.unregister();
          this.autocomplete.register();
        },

        unload() {
          this.autocomplete.unregister();
        }
      };

      let Window$1 = {
        init() {},
        unload() {}
      };

      /* eslint no-param-reassign: off */
      class ResultCache {
        constructor() {
          this.clear();
        }

        getResult(query, getBackendResults) {
          const now = Date.now();
          const cachedResult = this.cache.get(query);
          if (cachedResult && cachedResult.expiresAt > now) {
            cachedResult.response.isClientCached = true;
            cachedResult.response.duration = 0;
            return Promise.resolve(cachedResult);
          }
          return getBackendResults(query).then(results => {
            if (results.response && results.response.max_age) {
              results.expiresAt = Date.now() + results.response.max_age * 1000;
              this.cache.set(query, results);
            }
            return results;
          });
        }

        clear() {
          // save up to 20 results
          this.cache = new LRU(20);
        }
      }

      function onReady$1() {
        return new Promise(resolve => {
          if (isFirefox && Services.search && Services.search.init) {
            Services.search.init(resolve);
          } else {
            resolve();
          }
        });
      }

      const _getSnippet = (url, data) => CliqzUtils.fetchFactory()(url, { method: 'PUT', body: data }).then(r => r.json()).then(response => {
        const oldResult = JSON.parse(data).results[0];
        const result = response.results.find(r => oldResult.url === r.url);
        const snippet = result.snippet;
        if (!snippet) {
          throw new Error('unknown');
        }
        if (snippet && snippet.friendlyUrl === 'n/a') {
          throw new Error('n/a');
        }
        return snippet;
      });

      const getSnippetPromise = function getSnippetPromise(url, data) {
        let retry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        if (retry === 0) {
          return Promise.reject();
        }

        return _getSnippet(url, data).catch(e => {
          if (e.message === 'n/a') {
            return getSnippetPromise(url, data, retry - 1);
          }

          return Promise.reject();
        });
      };

      var Background$4 = background({

        enabled() {
          return true;
        },

        init() {
          this.resultCache = new ResultCache();
          Search.fetchAndCacheResult = this.resultCache.getResult.bind(this.resultCache);
          Search.clearResultCache = this.resultCache.clear.bind(this.resultCache);
          this.autocomplete = CliqzAutocomplete;
          this.autocomplete.setup();
          CliqzAutocomplete.CliqzSearchCountryProviders = new CliqzSearchCountryProviders();
          return onReady$1().then(() => {
            CliqzAutocomplete.CliqzResultProviders = new CliqzResultProviders();
            background$1.init();

            CliqzAutocomplete.CliqzHistoryCluster = CliqzHistoryCluster;

            // glueing stuff
            CliqzUtils.autocomplete = CliqzAutocomplete;
            CliqzUtils.registerResultProvider({
              ResultProviders: CliqzAutocomplete.CliqzResultProviders,
              Result
            });
          });
        },

        unload() {
          background$1.unload();
        },

        beforeBrowserShutdown() {},

        actions: {
          search(query, cb) {
            const search = new Search();
            search.search(query, cb);
          },

          clearResultCache() {
            Search.clearResultCache();
          },

          /**
           * fetches extra info for result from rich header
           */
          getSnippet(query, result) {
            const loc = {
              latitude: CliqzUtils.USER_LAT,
              longitude: CliqzUtils.USER_LNG
            };
            const url = CliqzUtils.RICH_HEADER + CliqzUtils.getRichHeaderQueryString(query, loc);
            const resultData = {
              q: query,
              loc,
              results: [{
                url: result.url,
                snippet: {
                  title: result.data.title,
                  description: result.data.description
                }
              }]
            };

            return getSnippetPromise(url, JSON.stringify(resultData), 10);
          }
        },

        events: {
          'control-center:setDefault-search': function setDefaultSearchEngine(engine) {
            this.autocomplete.CliqzResultProviders.setCurrentSearchEngine(engine);
          },
          'control-center:setDefault-indexCountry': function setDefaultIndexCountry(country) {
            CliqzUtils.setDefaultIndexCountry(country);
          },
          'core:urlbar_focus': function onUrlBarFocus() {
            if (isFirefox) {
              this.resultCache.clear();
            }
          },
          // there are a few places which can change some state and this state
          // must reset the whole result cache
          'core:reset_cache': function onResetCache() {
            if (isFirefox) {
              this.resultCache.clear();
            }
          }
        }
      });

      class Win$4 {
        constructor(settings) {
          this.window = settings.window;
          this.window.CliqzAutocomplete = CliqzAutocomplete;
        }

        init() {
          Window$1.init(this.window);
        }

        unload() {
          Window$1.unload(this.window);
          delete this.window.CliqzAutocomplete;
        }

        status() {
          var engines = [];
          // CliqzResultProviders might be uninitialized
          if (CliqzAutocomplete.CliqzResultProviders) {
            engines = CliqzAutocomplete.CliqzResultProviders.getSearchEngines();
          }
          return {
            visible: true,
            state: engines,
            supportedIndexCountries: CliqzAutocomplete.CliqzSearchCountryProviders.getProviders()
          };
        }
      }

      var autocompleteModule = {
        Background: Background$4,
        Window: Win$4
      };

      var getGeo$1 = function () {
        const geoService = Components.classes["@mozilla.org/geolocation;1"].getService(Components.interfaces.nsISupports);

        return new Promise((resolve, reject) => {
          geoService.getCurrentPosition(position => {
            resolve({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude
            });
          }, reject);
        });
      };

      class Defer {
        constructor() {
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
        }
      }

      // If the computer wakes up from a sleep that was longer than this many milliseconds, we update geolocation.
      const GEOLOCATION_UPDATE_MIN_WAIT = 3600 * 1000;

      /**
        @namespace geolocation
        @module geolocation
        @class Background
       */
      var Background$5 = background({

        // Number of decimal digits to keep in user's location
        LOCATION_ACCURACY: 3,

        GEOLOCATION_MESSAGE_NUM_SHOWN: 0,

        messageCenter: inject.module('message-center'),

        /**
          @method init
          @param settings
        */
        init(settings) {
          CliqzUtils.updateGeoLocation = this.actions.updateGeoLocation;

          this.cancelUpdate = new Defer();

          this.sleepObserver = new TopicForwarder(CliqzEvents, "geolocation:sleep-notification", Date.now);

          this.wakeObserver = new TopicForwarder(CliqzEvents, "geolocation:wake-notification", Date.now);

          if (isFirefox) {
            this.observerService = Components.classes["@mozilla.org/observer-service;1"].getService(Components.interfaces.nsIObserverService);

            this.observerService.addObserver(this.sleepObserver, "sleep_notification", false);

            this.observerService.addObserver(this.wakeObserver, "wake_notification", false);
          }
        },

        unload() {
          if (isFirefox) {
            this.observerService.removeObserver(this.sleepObserver, "sleep_notification");
            this.observerService.removeObserver(this.wakeObserver, "wake_notification");
          }
        },

        beforeBrowserShutdown() {},

        events: {
          "geolocation:update": function geolocationUpdate(_ref) {
            let timestamp = _ref.timestamp;

            this.LAST_GEOLOCATION_UPDATE = timestamp;
          },

          "geolocation:wake-notification": function geolocationWakeNotification(timestamp) {
            const lastTimestamp = Math.max(this.LAST_SLEEP || 0, this.LAST_GEOLOCATION_UPDATE || 0);
            if (timestamp - lastTimestamp >= GEOLOCATION_UPDATE_MIN_WAIT) {
              this.actions.updateGeoLocation();
            }
          },

          "geolocation:sleep-notification": function geolocationSleepNotification(timestamp) {
            this.LAST_SLEEP = timestamp;
          },

          "ui:missing_location_shown": function uiMissing_location_shown() {
            if (!CliqzUtils.getPref('share_location')) {
              this.GEOLOCATION_MESSAGE_NUM_SHOWN++;
            }

            if (this.GEOLOCATION_MESSAGE_NUM_SHOWN > 0) {
              this.messageCenter.action('showMessage', 'MESSAGE_HANDLER_FRESHTAB', {
                "id": "share-location",
                "template": "share-location"
              }).then(() => {
                this.GEOLOCATION_MESSAGE_NUM_SHOWN = 0;
              });
            }
          }
        },

        roundLocation(position) {
          return CliqzUtils.roundToDecimal(position, this.LOCATION_ACCURACY);
        },

        actions: {
          getGeo() {
            if (CliqzUtils.getPref('share_location', config.settings.geolocation || 'ask') !== 'yes' && CliqzUtils.getPref('share_location', config.settings.geolocation || 'ask') !== 'showOnce') {
              return Promise.reject("No permission to get user's location");
            }
            const telemetryEvent = {
              type: 'performance',
              action: 'api_request',
              target: 'geolocation',
              is_success: undefined
            };
            return Promise.race([getGeo$1(), this.cancelUpdate.promise]).then(position => {
              telemetryEvent.is_success = true;
              CliqzUtils.telemetry(telemetryEvent);
              return {
                latitude: this.roundLocation(position.latitude),
                longitude: this.roundLocation(position.longitude)
              };
            }).catch(error => {
              if (error.canceled) {
                telemetryEvent.is_canceled = true;
              }
              telemetryEvent.is_success = false;
              CliqzUtils.telemetry(telemetryEvent);
              return Promise.reject(error);
            });
          },

          updateGeoLocation() {
            return this.actions.getGeo().then(position => {
              CliqzUtils.USER_LAT = position.latitude;
              CliqzUtils.USER_LNG = position.longitude;
              this.LAST_GEOLOCATION_UPDATE = Date.now();
            }).catch(() => {
              CliqzUtils.USER_LAT = null;
              CliqzUtils.USER_LNG = null;
            }).then(() => {
              return {
                latitude: CliqzUtils.USER_LAT,
                longitude: CliqzUtils.USER_LNG
              };
            });
          },

          setLocationPermission(newPerm) {
            if (newPerm === 'yes' || newPerm === 'no' || newPerm === 'ask') {
              CliqzUtils.setPref('share_location', newPerm);
              this.actions.updateGeoLocation();
            }
          },

          resetGeoLocation() {
            this.cancelUpdate.reject({
              canceled: true
            });
            this.cancelUpdate = new Defer();
            CliqzUtils.USER_LAT = null;
            CliqzUtils.USER_LNG = null;
          }
        }

      });

      class TopicForwarder {

        constructor(events, eventName, fn) {
          this.events = events;
          this.eventName = eventName;
          this.fn = fn;
        }

        observe(subject, topic, data) {
          this.events.pub(this.eventName, this.fn.apply(this, arguments));
        }

      }

      class Win$5 {
        constructor(settings) {
          this.geolocation = inject.module('geolocation');
        }

        init() {
          this.geolocation.action("updateGeoLocation");
        }

        unload() {}

        status() {
          return {
            visible: true,
            state: CliqzUtils.getLocationPermState()
          };
        }
      }

      var geolocationModule = {
        Background: Background$5,
        Window: Win$5
      };

      // Need to load views by hand so they will be ready once UI.js need them
      // This should be moved to UI as soon as it will be moved from dist to sources
      const SEARCH_BAR_ID = 'search-container';
      const URL_BAR_ID = 'urlbar-container';
      const showSearchBar = 'dontHideSearchBar';
      const handleSearchWidgetInPhoton = 'handleSearchWidgetInPhoton';

      let CustomizableUI;

      var Background$6 = background({
        init() {
          if (isPlatformAtLeastInVersion('57.0')) {
            // Firefox 57 and above has the search widget hidden by default so we
            // do not need to do anything besides cleaning our old prefs

            if (!prefs.get(handleSearchWidgetInPhoton, false)) {
              // we try once to migrate the old setting
              prefs.set(handleSearchWidgetInPhoton, true);
              if (!prefs.get(showSearchBar, false)) {
                prefs.set('browser.search.widget.inNavBar', false, '');
              }
              if (prefs.has(showSearchBar)) {
                prefs.clear(showSearchBar);
              }
            }

            return;
          }

          CustomizableUI = Components.utils.import('resource:///modules/CustomizableUI.jsm', null).CustomizableUI;
          // we use CustomizableUI since 2.21.1
          prefs.clear('defaultSearchBarPosition');
          prefs.clear('defaultSearchBarPositionNext');

          this.customizableUIListener = {
            // Waiting for the nav-bar to be restored
            onAreaNodeRegistered(aAreaType) {
              if (aAreaType === CustomizableUI.AREA_NAVBAR) {
                if (!prefs.get(showSearchBar, false)) {
                  // we always hide the search bar when Cliqz starts
                  // as long as the user did not move it somewhere visible (showSearchBar pref)
                  CustomizableUI.removeWidgetFromArea(SEARCH_BAR_ID);
                }
              }
            }
          };

          CustomizableUI.addListener(this.customizableUIListener);

          if (!prefs.get(showSearchBar, false)) {
            // we always hide the search bar when Cliqz starts
            // as long as the user did not move it somewhere visible (showSearchBar pref)
            CustomizableUI.removeWidgetFromArea(SEARCH_BAR_ID);
          }
        },

        unload() {
          this.restoreSearchBar();
        },

        beforeBrowserShutdown() {
          this.restoreSearchBar();
        },

        restoreSearchBar() {
          if (isPlatformAtLeastInVersion('57.0')) {
            return; //Firefox 57 and above has the search widget hidden by default so we do not need to do anything
          }

          if (CustomizableUI.getPlacementOfWidget(SEARCH_BAR_ID) !== null) {
            // if the user moves the searchbar - we let him in full control
            prefs.set(showSearchBar, true);
          } else {
            // we always try to restore the searchbar close to the urlbar
            // both at shutdown and uninstall

            if (prefs.has(showSearchBar)) {
              prefs.clear(showSearchBar);
            }

            const urlbarPlacement = CustomizableUI.getPlacementOfWidget(URL_BAR_ID);
            CustomizableUI.addWidgetToArea(SEARCH_BAR_ID, CustomizableUI.AREA_NAVBAR, urlbarPlacement.position + 1);
          }

          CustomizableUI.removeListener(this.customizableUIListener);
        },

        events: {
          // The next two events came to be as a result for EX-3819 & EX-3905
          // For an unkown reason (@chrmod convinced it is FF bug), the browser (gecko?) is
          // reporting false status of the dropdown (popup) menu (closed when it's open). This in turn
          // triggers cliqz events that are handled when the popup is being closed and because it is not
          // really closed, it causes problems. Those next two event capturing, ensures that the popup
          // is hidden when it should be hidden (tab change & window content click)
          'core:tab_select': function onTabSelect() {
            CliqzEvents.pub('ui:popup_hide');
          },
          'core:mouse-down': function onMouseDown() {
            CliqzEvents.pub('ui:popup_hide');
          }
        }
      });

      const ACproviderName$1 = 'cliqz-results';

      var urlbarEventHandlers = {
        /**
        * Urlbar focus event
        * @event focus
        */
        focus() {
          if (this.urlbar.getAttribute('autocompletesearch').indexOf(ACproviderName$1) === -1) {
            // BUMMER!! Something happened and our AC provider was overriden!
            // trying to set it back while keeping the new value in case Cliqz
            // gets disabled
            this._autocompletesearch = this.urlbar.getAttribute('autocompletesearch');
            this.urlbar.setAttribute('autocompletesearch', ACproviderName$1);
            this.reloadUrlbar();
            this.urlbar.blur();
            setTimeout(() => {
              this.urlbar.focus();
            }, 0);
            return;
          }

          // try to 'heat up' the connection
          CliqzUtils.pingCliqzResults();

          CliqzAutocomplete.lastFocusTime = Date.now();
          CliqzUtils.setSearchSession(CliqzUtils.rand(32));
          this.urlbarEvent('focus');
          CliqzEvents.pub('urlbar:focus', {
            windowId: this.windowId,
            tabId: getCurrentTabId(this.window)
          });
        },
        /**
        * Urlbar blur event
        * @event blur
        * @param ev
        */
        blur() {
          if (CliqzAutocomplete.spellCheck) {
            CliqzAutocomplete.spellCheck.resetState();
          }
          // reset this flag as it can block the dropdown from opening
          CliqzAutocomplete.isPopupOpen = false;

          // force a dropdown close on urlbar blur
          this.window.CLIQZ.Core.popup.hidePopup();

          this.urlbarEvent('blur');

          // Update the url bar value to be its visible value
          if (this.urlbar.mInputField.selectionEnd > this.urlbar.mInputField.selectionStart) {
            this.urlbar.value = this.urlbar.mInputField.value;
          }

          CliqzAutocomplete.lastFocusTime = null;
          this.window.CLIQZ.UI.sessionEnd();
          CliqzEvents.pub('urlbar:blur', {
            windowId: this.windowId,
            tabId: getCurrentTabId(this.window)
          });
        },
        /**
        * Urlbar keypress event
        * @event keypress
        * @param ev
        */
        keypress(ev) {
          if (!ev.ctrlKey && !ev.altKey && !ev.metaKey) {
            const urlbar = this.urlbar;
            const mInputField = urlbar.mInputField;
            if (mInputField.selectionEnd !== mInputField.selectionStart && mInputField.value[mInputField.selectionStart] === String.fromCharCode(ev.charCode)) {
              // prevent the redraw in urlbar but send the search signal
              let query = urlbar.value;
              const old = mInputField.value;
              const start = mInputField.selectionStart;
              query = query.slice(0, urlbar.selectionStart) + String.fromCharCode(ev.charCode);
              mInputField.setUserInput(query);
              mInputField.value = old;
              mInputField.setSelectionRange(start + 1, mInputField.value.length);
              ev.preventDefault();
            }
          }
        },
        /**
        * Urlbar drop event
        * @event drop
        * @param ev
        */
        drop(ev) {
          const dTypes = ev.dataTransfer.types;
          if (dTypes.indexOf && dTypes.indexOf('text/plain') !== -1 || dTypes.contains && dTypes.contains('text/plain') !== -1) {
            // open dropdown on text drop
            const inputField = this.urlbar.mInputField;
            const val = inputField.value;
            inputField.setUserInput('');
            inputField.setUserInput(val);

            CliqzUtils.telemetry({
              type: 'activity',
              action: 'textdrop'
            });
          }
        },

        input() {
          nextTick(() => {
            const input = this.urlbar.mInputField;
            const hasSelection = input.selectionStart !== input.selectionEnd;
            let query = input.value;

            if (hasSelection) {
              query = query.slice(0, input.selectionStart);
            }

            CliqzEvents.pub('urlbar:input', {
              isPrivate: CliqzUtils.isPrivateMode(this.window),
              isTyped: this.urlbar.valueIsTyped,
              query,
              tabId: getCurrentTabId(this.window),
              windowId: this.windowId
            });
          });
        },

        keyup(ev) {
          CliqzEvents.pub('urlbar:keyup', {
            windowId: this.windowId,
            tabId: getCurrentTabId(this.window),
            code: ev.code
          });
        },

        keydown(ev) {
          CliqzAutocomplete._lastKey = ev.keyCode;
          let cancel;
          try {
            cancel = this.window.CLIQZ.UI.keyDown(ev);
          } catch (e) {
            console$1.error(e);
            throw e;
          }
          if (cancel) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
          }
          CliqzEvents.pub('urlbar:keydown', {
            windowId: this.windowId,
            tabId: getCurrentTabId(this.window),
            isHandledByCliqz: cancel,
            query: this.urlbar.value,
            code: ev.code
          });
        },
        /**
        * Urlbar paste event
        * @event paste
        * @param ev
        */
        paste(ev) {
          // wait for the value to change
          this.window.setTimeout(() => {
            // ensure the lastSearch value is always correct
            // although paste event has 1 second throttle time.
            CliqzAutocomplete.lastSearch = ev.target.value;
            CliqzUtils.telemetry({
              type: 'activity',
              action: 'paste',
              current_length: ev.target.value.length
            });
          }, 0);
        }
      };

      const ACproviderName = 'cliqz-results';

      function getPopupDimensions(urlbar, win) {
        var urlbarRect = urlbar.getBoundingClientRect();
        // x,y are the distance from the topleft of the popup to urlbar.
        return {
          width: win.innerWidth,
          x: -1 * (urlbarRect.left || urlbarRect.x || 0),
          y: 0
        };
      }

      function initPopup(popup, urlbar, win) {
        //patch this method to avoid any caching FF might do for components.xml
        popup._appendCurrentResult = function () {
          if (popup.mInput) {
            //try to break the call stack which cause 'too much recursion' exception on linux systems
            CliqzUtils.setTimeout(win.CLIQZ.UI.handleResults.bind(win), 0);
          }
        };

        popup._openAutocompletePopup = function (aInput, aElement) {
          const lr = CliqzAutocomplete.lastResult;
          if (lr && lr.searchString != aInput.value && aInput.value == '') {
            return;
          }

          if (!CliqzAutocomplete.isPopupOpen) {
            this.mInput = aInput;
            this._invalidate();
            let popupDimensions = getPopupDimensions(aElement, win);
            let attachToElement = aElement;

            attachToElement = win.document.querySelector('#nav-bar');
            popupDimensions = Object.assign(popupDimensions, {
              x: 0,
              y: 0
            });

            this.setAttribute("width", popupDimensions.width);
            win.document.getElementById('cliqz-popup').style.width = `${popupDimensions.width}px`;
            this.openPopup(attachToElement, "after_start", popupDimensions.x, popupDimensions.y, false, true);
          }
        }.bind(popup);

        // set initial width of the popup equal with the width of the urlbar
        setPopupWidth(popup, urlbar);
      }

      function setPopupWidth(popup, urlBar) {
        var width = urlBar.getBoundingClientRect().width;
        popup.setAttribute("width", width > 500 ? width : 500);
      }

      const STYLESHEET_URL$1 = 'chrome://cliqz/content/static/styles/styles.css';

      /**
        @namespace ui
      */
      class UIWindow extends AppWindow {

        /**
        * @class Window
        * @constructor
        */
        constructor(settings) {
          var _this;

          _this = super(settings);

          this.events = {};
          this.actions = {
            setUrlbarValue: function setUrlbarValue(value) {
              let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              const opts = typeof options === 'object' ? options : { visibleValue: options };

              let ifMatches = opts.match || (() => true);

              if (ifMatches instanceof RegExp) {
                const re = ifMatches;
                ifMatches = s => re.test(s);
              } else if (typeof ifMatches !== 'function') {
                const m = ifMatches.toString();
                ifMatches = s => m === s;
              }

              if (ifMatches(_this.urlbar.value)) {
                _this.urlbar.value = value;
              }

              if (ifMatches(_this.urlbar.mInputField.value)) {
                _this.urlbar.mInputField.value = opts.visibleValue || value;
              }

              if (opts.focus) {
                _this.urlbar.mInputField.focus();
              }
            },

            syncUrlbarValue: () => {
              this.urlbar.value = this.urlbar.mInputField.value;
            }
          };
          this.dropdown = inject.module('dropdown');
          this.autocompleteModule = inject.module('autocomplete');
          this.elems = [];
          this.settings = settings.settings;
          this.urlbar = this.window.gURLBar;
          this.urlbarGoClick = this.urlbarGoClick.bind(this);
          this.hidePopup = this.hidePopup.bind(this);
          this.initialized = false;
          this.window.CLIQZ.UI = {};
          this.urlbarEventHandlers = {};
          Object.keys(urlbarEventHandlers).forEach(ev => {
            this.urlbarEventHandlers[ev] = urlbarEventHandlers[ev].bind(this);
          });

          this.popupEventHandlers = {};
          Object.keys(popupEventHandlers).forEach(ev => {
            this.popupEventHandlers[ev] = popupEventHandlers[ev].bind(this);
          });
        }

        /**
        * @method init
        */
        init() {
          super.init();

          // do not initialize the UI if locationbar is invisible in this window
          if (!this.window.locationbar.visible) return;

          console$1.log("UI window init");

          //create a new panel for cliqz to avoid inconsistencies at FF startup
          var document = this.window.document;

          addStylesheet(this.window.document, STYLESHEET_URL$1);

          const autocompleteLoadingPromise = this.autocompleteModule.isReady().then(() => {
            // Load autocompletesearch as soon as possible - it is compatible with
            // default firefox and will work with any UI
            this._autocompletesearch = this.urlbar.getAttribute('autocompletesearch');
            this.urlbar.setAttribute('autocompletesearch', ACproviderName);
          });

          let uiLoadingPromise;
          return autocompleteLoadingPromise.then(() => {
            return this.dropdown.windowAction(this.window, 'init');
          }).then(() => {

            this.window.CLIQZ.Core.urlbar = this.urlbar;
            this.window.CLIQZ.settings = this.settings;

            this.popupHideEvent = CliqzEvents.subscribe('ui:popup_hide', this.hidePopup);

            this.window.CLIQZ.UI.autocompleteQuery = this.autocompleteQuery.bind(this);

            this.urlbar.setAttribute('pastetimeout', 0);

            var popup = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "panel");
            this.popup = popup;
            this.popup.oneOffSearchButtons = () => {};
            this.window.CLIQZ.Core.popup = this.popup;
            popup.setAttribute("type", 'autocomplete-richlistbox');
            popup.setAttribute("noautofocus", 'true');
            popup.setAttribute("id", 'PopupAutoCompleteRichResultCliqz');
            this.elems.push(popup);
            document.getElementById('PopupAutoCompleteRichResult').parentElement.appendChild(popup);
            initPopup(this.popup, this.urlbar, this.window);

            this.window.CLIQZ.UI.showDebug = CliqzUtils.getPref('showQueryDebug', false);

            this._autocompletepopup = this.urlbar.getAttribute('autocompletepopup');
            this.urlbar.setAttribute('autocompletepopup', /*'PopupAutoComplete'*/'PopupAutoCompleteRichResultCliqz');

            this.popup.addEventListener('popuphiding', this.popupEventHandlers.popupClose);
            this.popup.addEventListener('popupshowing', this.popupEventHandlers.popupOpen);

            Object.keys(this.urlbarEventHandlers).forEach(function (ev) {
              this.urlbar.addEventListener(ev, this.urlbarEventHandlers[ev]);
            }.bind(this));

            //mock default FF function
            this.popup.enableOneOffSearches = function () {};

            // make CMD/CTRL + K equal with CMD/CTRL + L
            this.searchShortcutElements = this.window.document.getElementById('mainKeyset').querySelectorAll('#key_search, #key_search2');
            [].forEach.call(this.searchShortcutElements, function (item) {
              item.setAttribute('original_command', item.getAttribute('command'));
              item.setAttribute('command', 'Browser:OpenLocation');
            });

            // Add search history dropdown
          }).then(() => {
            this.reloadUrlbar();
            this.initialized = true;

            var urlBarGo = document.getElementById('urlbar-go-button') ||
            // FF56+
            document.getAnonymousElementByAttribute(this.urlbar, 'anonid', 'go-button');

            if (urlBarGo) {
              this._urlbarGoButtonClick = urlBarGo.getAttribute('onclick');
              this._urlBarGo = urlBarGo;
              // we somehow break default FF -> on goclick the autocomplete doesnt get considered
              this._urlBarGo.addEventListener('click', this.urlbarGoClick);
            }

            this.applyAdditionalThemeStyles();
          });
        }

        autocompleteQuery(firstResult, firstTitle) {
          var urlBar = this.urlbar;
          if (urlBar.selectionStart !== urlBar.selectionEnd) {
            // TODO: temp fix for flickering,
            // need to make it compatible with auto suggestion
            urlBar.mInputField.value = urlBar.mInputField.value.slice(0, urlBar.selectionStart);
          }
          if (CliqzAutocomplete._lastKey === this.window.KeyEvent.DOM_VK_BACK_SPACE || CliqzAutocomplete._lastKey === this.window.KeyEvent.DOM_VK_DELETE) {
            if (CliqzAutocomplete.selectAutocomplete) {
              this.window.CLIQZ.UI.selectAutocomplete();
            }
            CliqzAutocomplete.selectAutocomplete = false;
            return;
          }
          CliqzAutocomplete.selectAutocomplete = false;

          // History cluster does not have a url attribute, therefore firstResult is null
          var lastPattern = CliqzAutocomplete.lastPattern,
              fRes = lastPattern ? lastPattern.filteredResults() : null;
          if (!firstResult && lastPattern && fRes.length > 1) {
            firstResult = fRes[0].url;
          }

          firstResult = CliqzUtils.cleanMozillaActions(firstResult)[1];

          var r,
              endPoint = urlBar.value.length;
          var lastPattern = CliqzAutocomplete.lastPattern;
          var results = lastPattern ? fRes : [];

          // try to update misspelings like ',' or '-'
          if (this.cleanUrlBarValue(urlBar.value).toLowerCase() != urlBar.value.toLowerCase()) {
            urlBar.mInputField.value = this.cleanUrlBarValue(urlBar.value).toLowerCase();
          }
          // Use first entry if there are no patterns
          if (results.length === 0 || lastPattern.query != urlBar.value || CliqzUtils.generalizeUrl(firstResult) != CliqzUtils.generalizeUrl(results[0].url)) {
            var newResult = [];
            newResult.url = firstResult;
            newResult.title = firstTitle;
            newResult.query = [];
            results.unshift(newResult);
          }
          // FIXME: we get [[]] here for dropdown module
          if (!CliqzUtils.isUrl(results[0].url)) return;

          // Detect autocomplete
          var historyClusterAutocomplete = CliqzAutocomplete.CliqzHistoryCluster.autocompleteTerm(urlBar.value, results[0], true);

          // No autocomplete
          if (!historyClusterAutocomplete.autocomplete || !CliqzUtils.getPref("browser.urlbar.autoFill", false, '')) {
            // user has disabled autocomplete
            this.window.CLIQZ.UI.clearAutocomplete();
            CliqzAutocomplete.lastAutocomplete = null;
            CliqzAutocomplete.lastAutocompleteType = null;
            CliqzAutocomplete.selectAutocomplete = false;
            return;
          }

          // Apply autocomplete
          CliqzAutocomplete.lastAutocompleteType = historyClusterAutocomplete.type;
          CliqzAutocomplete.lastAutocompleteLength = historyClusterAutocomplete.full_url.length;
          CliqzAutocomplete.lastAutocompleteUrlbar = historyClusterAutocomplete.urlbar;
          CliqzAutocomplete.lastAutocompleteSelectionStart = historyClusterAutocomplete.selectionStart;
          urlBar.mInputField.value = historyClusterAutocomplete.urlbar;
          urlBar.setSelectionRange(historyClusterAutocomplete.selectionStart, urlBar.mInputField.value.length);
          CliqzAutocomplete.lastAutocomplete = historyClusterAutocomplete.full_url;
          this.window.CLIQZ.UI.cursor = historyClusterAutocomplete.selectionStart;

          // Highlight first entry in dropdown
          if (historyClusterAutocomplete.highlight) {
            CliqzAutocomplete.selectAutocomplete = true;
            this.window.CLIQZ.UI.selectAutocomplete();
          }

          return true;
        }

        cleanUrlBarValue(val) {
          var cleanParts = CliqzUtils.cleanUrlProtocol(val, false).split('/'),
              host = cleanParts[0],
              pathLength = 0,
              SYMBOLS = /,|\./g;

          if (cleanParts.length > 1) {
            pathLength = ('/' + cleanParts.slice(1).join('/')).length;
          }
          if (host.indexOf('www') == 0 && host.length > 4) {
            // only fix symbols in host
            if (SYMBOLS.test(host[3]) && host[4] != ' ')
              // replace only issues in the host name, not ever in the path
              return val.substr(0, val.length - pathLength).replace(SYMBOLS, '.') + (pathLength ? val.substr(-pathLength) : '');
          }
          return val;
        }
        /**
        * triggers component reload at install/uninstall
        * @method reloadUrlbar
        */
        reloadUrlbar() {
          const el = this.urlbar;
          const oldVal = el.value;
          const hadFocus = el.focused;
          const popup = this.window.gURLBar.popup;

          const onFocus = () => {
            el.removeEventListener('focus', onFocus);

            if (this.urlbar.getAttribute('autocompletesearch').indexOf(ACproviderName) === -1) {
              return;
            }

            // close the old popup if it is open
            popup.closePopup();

            this.window.CLIQZ.Core.popup = this.popup;

            // redo search query
            if (oldVal) {
              inject.module('autocomplete').isReady().then(() => {
                inject.module('core').action('queryCliqz', oldVal);
              });
            }
          };

          if (el && el.parentNode) {
            el.blur();
            el.parentNode.insertBefore(el, el.nextSibling);
            el.value = oldVal;

            if (hadFocus) {
              el.addEventListener('focus', onFocus);
              el.focus();
            }
          }
        }

        applyAdditionalThemeStyles() {
          const urlbar = this.urlbar;

          this.originalUrlbarPlaceholder = urlbar.mInputField.placeholder;

          urlbar.style.maxWidth = '100%';
          urlbar.style.margin = '0px 0px';

          if (this.settings.id !== 'funnelcake@cliqz.com' && this.settings.id !== 'description_test@cliqz.com') {
            urlbar.mInputField.placeholder = CliqzUtils.getLocalizedString('freshtab.urlbar.placeholder');
          }
        }

        revertAdditionalThemeStyles() {
          const urlbar = this.urlbar;

          urlbar.style.maxWidth = '';
          urlbar.style.margin = '';
          urlbar.mInputField.placeholder = this.originalUrlbarPlaceholder;
        }

        /**
         * @method urlbarGoClick
         */
        urlbarGoClick() {
          //we somehow break default FF -> on goclick the autocomplete doesnt get considered
          this.urlbar.value = this.urlbar.mInputField.value;
          var action = {
            type: 'activity',
            position_type: ['inbar_' + (CliqzUtils.isUrl(this.urlbar.mInputField.value) ? 'url' : 'query')],
            autocompleted: CliqzAutocomplete.lastAutocompleteActive,
            action: 'urlbar_go_click'
          };
          CliqzUtils.telemetry(action);
        }

        popupEvent(open) {
          var action = {
            type: 'activity',
            action: 'dropdown_' + (open ? 'open' : 'close')
          };

          if (open) {
            action['width'] = this.popup ? Math.round(this.popup.width) : 0;
          }

          CliqzUtils.telemetry(action);
        }

        hidePopup() {
          this.window.CLIQZ.Core.popup.hidePopup();
        }

        urlbarEvent(ev) {
          var action = {
            type: 'activity',
            action: 'urlbar_' + ev
          };

          CliqzEvents.pub('core:urlbar_' + ev);
          CliqzUtils.telemetry(action);
        }

        unload() {
          super.unload();

          if (!this.initialized) return;

          removeStylesheet(this.window.document, STYLESHEET_URL$1);

          this.urlbar.setAttribute('autocompletesearch', this._autocompletesearch);

          if (this.popupHideEvent) {
            this.popupHideEvent.unsubscribe();
            this.popupHideEvent = undefined;
          }

          if (this.clickOnUrlEvent) {
            this.clickOnUrlEvent.unsubscribe();
            this.clickOnUrlEvent = undefined;
          }

          this.urlbar.setAttribute('autocompletepopup', this._autocompletepopup);

          this.popup.removeEventListener('popuphiding', this.popupEventHandlers.popupClose);
          this.popup.removeEventListener('popupshowing', this.popupEventHandlers.popupOpen);
          Object.keys(this.urlbarEventHandlers).forEach(function (ev) {
            this.urlbar.removeEventListener(ev, this.urlbarEventHandlers[ev]);
          }.bind(this));
          // revert onclick handler
          [].forEach.call(this.searchShortcutElements, function (item) {
            item.setAttribute('command', item.getAttribute('original_command'));
          });

          if (this._urlBarGo) {
            this._urlBarGo.removeEventListener('click', this.urlbarGoClick);
          }

          var searchContainer = this.window.document.getElementById('search-container');
          if (this._searchContainer) {
            searchContainer.setAttribute('class', this._searchContainer);
          }
          this.reloadUrlbar();
          this.revertAdditionalThemeStyles();

          this.elems.forEach(item => {
            item && item.parentNode && item.parentNode.removeChild(item);
          });

          delete this.window.CLIQZ.UI;
        }
      }

      const popupEventHandlers = {
        /**
        * @event popupOpen
        */
        popupOpen: function popupOpen(e) {
          CliqzAutocomplete.isPopupOpen = true;
          if (e.composedTarget !== this.popup) {
            return;
          }
          this.popupEvent(true);
          this.window.CLIQZ.UI.popupClosed = false;
        },

        /**
        * @event popupClose
        * @param e
        */
        popupClose: function popupClose(e) {
          CliqzAutocomplete.markResultsDone(null);
          CliqzAutocomplete.isPopupOpen = false;
          if (e.composedTarget !== this.popup) {
            return;
          }
          this.popupEvent(false);
          this.window.CLIQZ.UI.popupClosed = true;
        }
      };

      var uiModule = {
        Background: Background$6,
        Window: UIWindow
      };

      /**
        @namespace <namespace>
        @class Background
       */
      var Background$7 = background({
        /**
          @method init
          @param settings
        */
        init() {},

        unload() {},

        beforeBrowserShutdown() {},

        events: {},

        actions: {}
      });

      /*
       * This module remembers the last queries made in a tab and shows
       * them when appropiate
       *
       */

      class SearchHistoryUI {
        constructor(window, redoQuery) {
          this.tabQueries = new Map();
          this.redoLastQuery = () => redoQuery(this.currentQuery);
          this.window = window;
          this.container = window.document.createElement('hbox');
          this.container.className = 'hidden'; // Initially hide the container
          this.container.setAttribute('min-browser-version-is-58', isPlatformAtLeastInVersion('58.0'));

          // Add last search button to container
          this.queryBox = window.document.createElement('hbox');
          this.queryBox.className = 'cliqz-urlbar-Last-search';
          this.queryBox.addEventListener('click', this.redoLastQuery);
          this.container.appendChild(this.queryBox);
        }

        attach() {
          const $targetPosition = this.window.gURLBar.mInputField.parentElement;
          $targetPosition.insertBefore(this.container, $targetPosition.firstChild);
        }

        deattach() {
          this.tabQueries.clear();
          this.queryBox.removeEventListener('click', this.redoLastQuery);
          try {
            this.container.parentNode.removeChild(this.container);
          } catch (e) {
            // removed already, maybe by some other browser feature
          }
        }

        show(query) {
          if (!query) {
            return;
          }
          this.currentQuery = query;

          this.container.className = 'cliqz-urlbar-Last-search-container';
          this.container.setAttribute('channel', config.settings.channel);

          this.queryBox.textContent = query;
          this.queryBox.tooltipText = query;
          this.queryBox.query = query;
        }

        hide() {
          this.container.className = 'hidden';
        }

        clearTabQuery(tabId) {
          this.tabQueries.delete(tabId);
        }

        updateTabQuery(tabId, query) {
          this.tabQueries.set(tabId, query);
        }

        showTabQuery(tabId) {
          const query = this.tabQueries.get(tabId);
          if (query) {
            this.show(query);
          }
        }
      }

      class LastQueryWindow extends AppWindow {

        constructor(settings) {
          super(settings);
          this.deps = {
            core: inject.module('core'),
            ui: inject.module('ui')
          };
          this.actions = {
            updateTabQuery: (tabId, query) => this.searchHistoryUI.updateTabQuery(tabId, query)
          };
          this.events = {
            'urlbar:focus': () => {
              this.searchHistoryUI.hide();
            },

            'urlbar:blur': () => {
              this.searchHistoryUI.showTabQuery(getCurrentTabId(this.window));
            },

            'urlbar:keydown': _ref => {
              let code = _ref.code,
                  query = _ref.query,
                  isHandledByCliqz = _ref.isHandledByCliqz,
                  tabId = _ref.tabId;

              if (code !== 'Enter' && code !== 'NumpadEnter') {
                return;
              }

              // will be handled with ui:cliqz-on-url event
              if (isHandledByCliqz) {
                return;
              }

              if (isUrl(query)) {
                return;
              }

              this.queriesNotHandledByCliqz.add(query);
              this.ignoreNextLoad = true;
              this.searchHistoryUI.updateTabQuery(tabId, query);
              this.searchHistoryUI.show(query);
            },

            /*
             * Hide last query when new navigation has started
             */
            'content:location-change': _ref2 => {
              let url = _ref2.url,
                  originalUrl = _ref2.originalUrl,
                  referrer = _ref2.referrer,
                  triggeringUrl = _ref2.triggeringUrl,
                  tabId = _ref2.tabId;

              const potentialQuery = getDetailsFromUrl(url).host;

              if (getCurrentTabId(this.window) !== tabId) {
                return;
              }

              if (this.ignoreNextLoad) {
                this.ignoreNextLoad = false;

                // if the hostname is the query the last query should be removed
                if (this.queriesNotHandledByCliqz.has(potentialQuery)) {
                  this.queriesNotHandledByCliqz.delete(potentialQuery);
                } else {
                  return;
                }
              }

              // Clear the last query if visit was triggered not by navigation, eg.
              // bookmarks, history, speed dials
              if (referrer || triggeringUrl) {
                return;
              }

              if (this.searchedUrls.has(url)) {
                this.searchedUrls.delete(url);
                return;
              }

              if (this.searchedUrls.has(originalUrl)) {
                this.searchedUrls.delete(originalUrl);
                return;
              }

              if (this.searchedUrls.has(triggeringUrl)) {
                this.searchedUrls.delete(triggeringUrl);
                return;
              }

              this.searchHistoryUI.hide();
              this.searchHistoryUI.clearTabQuery(tabId);
            },

            'core:tab_select': _ref3 => {
              let tabId = _ref3.tabId;

              this.searchHistoryUI.hide();
              this.searchHistoryUI.showTabQuery(tabId);
            },

            'core:tab_close': _ref4 => {
              let tabId = _ref4.tabId;

              this.searchHistoryUI.clearTabQuery(tabId);
            },

            'ui:click-on-url': _ref5 => {
              let isNewTab = _ref5.isNewTab,
                  tabId = _ref5.tabId,
                  url = _ref5.url,
                  query = _ref5.query,
                  isFromAutocompletedURL = _ref5.isFromAutocompletedURL,
                  isPrivateWindow = _ref5.isPrivateWindow;

              if (isNewTab || isPrivateWindow || !url || isFromAutocompletedURL) {
                this.searchHistoryUI.hide();
                return;
              }

              if (isUrl(query)) {
                return;
              }

              this.searchedUrls.add(url);
              this.searchHistoryUI.updateTabQuery(tabId, query);
              this.searchHistoryUI.show(query);
            }
          };
          this.searchedUrls = new Set();
          this.queriesNotHandledByCliqz = new Set();
          this.ignoreNextLoad = false;
          this.searchHistoryUI = new SearchHistoryUI(this.window, query => this.deps.core.action('queryCliqz', query));
        }

        init() {
          super.init();
          return this.deps.ui.isWindowReady(this.window).then(() => {
            this.searchHistoryUI.attach();
          });
        }

        unload() {
          super.unload();
          this.searchHistoryUI.deattach();
        }
      }

      var lastQueryModule = {
        Background: Background$7,
        Window: LastQueryWindow
      };

      var state$1 = new Int32Array(4);
      var buffer = new ArrayBuffer(68);
      var buffer8 = new Uint8Array(buffer);
      var blocks = new Uint32Array(buffer);
      var extra = new Int32Array([128, 32768, 8388608, -2147483648]);
      var hexChars = '0123456789abcdef'.split('');

      var finalized = false;
      var first = true;
      var hashed = false;
      var bytes = 0;
      var start = 0;
      var lastByteIndex;

      function add32(a, b) {
        return a + b & 0xFFFFFFFF;
      }

      function ff(a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t | 0;
        return (n << s | n >>> 32 - s) + b | 0;
      }
      function gg(a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t | 0;
        return (n << s | n >>> 32 - s) + b | 0;
      }
      function hh(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t | 0;
        return (n << s | n >>> 32 - s) + b | 0;
      }
      function ii(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t | 0;
        return (n << s | n >>> 32 - s) + b | 0;
      }

      function hash$1() {
        var a, b, c, d, bc, da;

        if (first) {
          a = blocks[0] - 680876937;
          a = (a << 7 | a >>> 25) - 271733879 << 0;
          d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
          d = (d << 12 | d >>> 20) + a << 0;
          c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
          c = (c << 17 | c >>> 15) + d << 0;
          b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
          b = (b << 22 | b >>> 10) + c << 0;
        } else {
          a = state$1[0];
          b = state$1[1];
          c = state$1[2];
          d = state$1[3];
          a = ff(a, b, c, d, blocks[0], 7, -680876936);
          d = ff(d, a, b, c, blocks[1], 12, -389564586);
          c = ff(c, d, a, b, blocks[2], 17, 606105819);
          b = ff(b, c, d, a, blocks[3], 22, -1044525330);
        }

        a = ff(a, b, c, d, blocks[4], 7, -176418897);
        d = ff(d, a, b, c, blocks[5], 12, 1200080426);
        c = ff(c, d, a, b, blocks[6], 17, -1473231341);
        b = ff(b, c, d, a, blocks[7], 22, -45705983);
        a = ff(a, b, c, d, blocks[8], 7, 1770035416);
        d = ff(d, a, b, c, blocks[9], 12, -1958414417);
        c = ff(c, d, a, b, blocks[10], 17, -42063);
        b = ff(b, c, d, a, blocks[11], 22, -1990404162);
        a = ff(a, b, c, d, blocks[12], 7, 1804603682);
        d = ff(d, a, b, c, blocks[13], 12, -40341101);
        c = ff(c, d, a, b, blocks[14], 17, -1502002290);
        b = ff(b, c, d, a, blocks[15], 22, 1236535329);

        a = gg(a, b, c, d, blocks[1], 5, -165796510);
        d = gg(d, a, b, c, blocks[6], 9, -1069501632);
        c = gg(c, d, a, b, blocks[11], 14, 643717713);
        b = gg(b, c, d, a, blocks[0], 20, -373897302);
        a = gg(a, b, c, d, blocks[5], 5, -701558691);
        d = gg(d, a, b, c, blocks[10], 9, 38016083);
        c = gg(c, d, a, b, blocks[15], 14, -660478335);
        b = gg(b, c, d, a, blocks[4], 20, -405537848);
        a = gg(a, b, c, d, blocks[9], 5, 568446438);
        d = gg(d, a, b, c, blocks[14], 9, -1019803690);
        c = gg(c, d, a, b, blocks[3], 14, -187363961);
        b = gg(b, c, d, a, blocks[8], 20, 1163531501);
        a = gg(a, b, c, d, blocks[13], 5, -1444681467);
        d = gg(d, a, b, c, blocks[2], 9, -51403784);
        c = gg(c, d, a, b, blocks[7], 14, 1735328473);
        b = gg(b, c, d, a, blocks[12], 20, -1926607734);

        a = hh(a, b, c, d, blocks[5], 4, -378558);
        d = hh(d, a, b, c, blocks[8], 11, -2022574463);
        c = hh(c, d, a, b, blocks[11], 16, 1839030562);
        b = hh(b, c, d, a, blocks[14], 23, -35309556);
        a = hh(a, b, c, d, blocks[1], 4, -1530992060);
        d = hh(d, a, b, c, blocks[4], 11, 1272893353);
        c = hh(c, d, a, b, blocks[7], 16, -155497632);
        b = hh(b, c, d, a, blocks[10], 23, -1094730640);
        a = hh(a, b, c, d, blocks[13], 4, 681279174);
        d = hh(d, a, b, c, blocks[0], 11, -358537222);
        c = hh(c, d, a, b, blocks[3], 16, -722521979);
        b = hh(b, c, d, a, blocks[6], 23, 76029189);
        a = hh(a, b, c, d, blocks[9], 4, -640364487);
        d = hh(d, a, b, c, blocks[12], 11, -421815835);
        c = hh(c, d, a, b, blocks[15], 16, 530742520);
        b = hh(b, c, d, a, blocks[2], 23, -995338651);

        a = ii(a, b, c, d, blocks[0], 6, -198630844);
        d = ii(d, a, b, c, blocks[7], 10, 1126891415);
        c = ii(c, d, a, b, blocks[14], 15, -1416354905);
        b = ii(b, c, d, a, blocks[5], 21, -57434055);
        a = ii(a, b, c, d, blocks[12], 6, 1700485571);
        d = ii(d, a, b, c, blocks[3], 10, -1894986606);
        c = ii(c, d, a, b, blocks[10], 15, -1051523);
        b = ii(b, c, d, a, blocks[1], 21, -2054922799);
        a = ii(a, b, c, d, blocks[8], 6, 1873313359);
        d = ii(d, a, b, c, blocks[15], 10, -30611744);
        c = ii(c, d, a, b, blocks[6], 15, -1560198380);
        b = ii(b, c, d, a, blocks[13], 21, 1309151649);
        a = ii(a, b, c, d, blocks[4], 6, -145523070);
        d = ii(d, a, b, c, blocks[11], 10, -1120210379);
        c = ii(c, d, a, b, blocks[2], 15, 718787259);
        b = ii(b, c, d, a, blocks[9], 21, -343485551);

        if (first) {
          state$1[0] = add32(a, 1732584193);
          state$1[1] = add32(b, -271733879);
          state$1[2] = add32(c, -1732584194);
          state$1[3] = add32(d, +271733878);
          first = false;
        } else {
          state$1[0] = add32(state$1[0], a);
          state$1[1] = add32(state$1[1], b);
          state$1[2] = add32(state$1[2], c);
          state$1[3] = add32(state$1[3], d);
        }
      }

      function init$2() {
        blocks.fill(0);
        state$1.fill(0);
        bytes = 0;
        start = 0;
        finalized = false;
        first = true;
        hashed = false;
      }

      function update$1(message) {
        if (finalized) {
          return;
        }
        var length = message.length;
        var code,
            index = 0,
            i;

        while (index < length) {
          if (hashed) {
            hashed = false;
            blocks[0] = blocks[16];
            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          }

          for (i = start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              buffer8[i++] = code;
            } else if (code < 0x800) {
              buffer8[i++] = 0xc0 | code >> 6;
              buffer8[i++] = 0x80 | code & 0x3f;
            } else if (code < 0xd800 || code >= 0xe000) {
              buffer8[i++] = 0xe0 | code >> 12;
              buffer8[i++] = 0x80 | code >> 6 & 0x3f;
              buffer8[i++] = 0x80 | code & 0x3f;
            } else {
              code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
              buffer8[i++] = 0xf0 | code >> 18;
              buffer8[i++] = 0x80 | code >> 12 & 0x3f;
              buffer8[i++] = 0x80 | code >> 6 & 0x3f;
              buffer8[i++] = 0x80 | code & 0x3f;
            }
          }
          lastByteIndex = i;
          bytes += i - start;
          if (i >= 64) {
            start = i - 64;
            hash$1();
            hashed = true;
          } else {
            start = i;
          }
        }
      }

      function finalize() {
        if (finalized) {
          return;
        }
        finalized = true;
        var i = lastByteIndex;
        blocks[i >> 2] |= extra[i & 3];
        if (i >= 56) {
          if (!hashed) {
            hash$1();
          }
          blocks[0] = blocks[16];
          blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        }
        blocks[14] = bytes << 3;
        hash$1();
      }

      function hex(x) {
        var h0 = x[0],
            h1 = x[1],
            h2 = x[2],
            h3 = x[3];
        return hexChars[h0 >> 4 & 0x0F] + hexChars[h0 & 0x0F] + hexChars[h0 >> 12 & 0x0F] + hexChars[h0 >> 8 & 0x0F] + hexChars[h0 >> 20 & 0x0F] + hexChars[h0 >> 16 & 0x0F] + hexChars[h0 >> 28 & 0x0F] + hexChars[h0 >> 24 & 0x0F] + hexChars[h1 >> 4 & 0x0F] + hexChars[h1 & 0x0F] + hexChars[h1 >> 12 & 0x0F] + hexChars[h1 >> 8 & 0x0F] + hexChars[h1 >> 20 & 0x0F] + hexChars[h1 >> 16 & 0x0F] + hexChars[h1 >> 28 & 0x0F] + hexChars[h1 >> 24 & 0x0F] + hexChars[h2 >> 4 & 0x0F] + hexChars[h2 & 0x0F] + hexChars[h2 >> 12 & 0x0F] + hexChars[h2 >> 8 & 0x0F] + hexChars[h2 >> 20 & 0x0F] + hexChars[h2 >> 16 & 0x0F] + hexChars[h2 >> 28 & 0x0F] + hexChars[h2 >> 24 & 0x0F] + hexChars[h3 >> 4 & 0x0F] + hexChars[h3 & 0x0F] + hexChars[h3 >> 12 & 0x0F] + hexChars[h3 >> 8 & 0x0F] + hexChars[h3 >> 20 & 0x0F] + hexChars[h3 >> 16 & 0x0F] + hexChars[h3 >> 28 & 0x0F] + hexChars[h3 >> 24 & 0x0F];
      }

      function md5(message) {
        init$2();
        update$1(message);
        finalize();
        return hex(state$1);
      }

      var md5Cache = new FixedSizeCache(md5, 1600);

      function cachedMD5(s) {
        if (!s) return '';
        return md5Cache.get(s);
      }

      function fnv32a(v) {
        var FNV1_32A_INIT = 0x811c9dc5;
        var hval = FNV1_32A_INIT;
        for (var i = 0; i < v.length; ++i) {}
      }

      function BloomFilter(a, k) {
        // a the array, k the number of hash function
        var m = a.length * 32,

        // 32 bits for each element in a
        n = a.length,
            i = -1;
        this.m = m = n * 32;
        this.k = k;
        // choose data type
        var kbytes = 1 << Math.ceil(Math.log(Math.ceil(Math.log(m) / Math.LN2 / 8)) / Math.LN2),
            array = kbytes === 1 ? Uint8Array : kbytes === 2 ? Uint16Array : Uint32Array,
            kbuffer = new ArrayBuffer(kbytes * k),
            buckets = this.buckets = new Int32Array(n);
        while (++i < n) buckets[i] = a[i]; // put the elements into their bucket
        this._locations = new array(kbuffer); // stores location for each hash function
      }

      BloomFilter.prototype.locations = function (a, b) {
        // we use 2 hash values to generate k hash values
        var k = this.k,
            m = this.m,
            r = this._locations;
        a = parseInt(a, 16);
        b = parseInt(b, 16);
        var x = a % m;

        for (var i = 0; i < k; ++i) {
          r[i] = x < 0 ? x + m : x;
          x = (x + b) % m;
        }
        return r;
      };

      BloomFilter.prototype.test = function (a, b) {
        // since MD5 will be calculated before hand,
        // we allow using hash value as input to

        var l = this.locations(a, b),
            k = this.k,
            buckets = this.buckets;
        for (var i = 0; i < k; ++i) {
          var bk = l[i];
          if ((buckets[Math.floor(bk / 32)] & 1 << bk % 32) === 0) {
            return false;
          }
        }
        return true;
      };

      BloomFilter.prototype.testSingle = function (x) {
        // var a = CliqzBloomFilter.hash(x),
        //     b = CliqzBloomFilter.fnv32Hex(x);
        var md5 = CliqzBloomFilter.hash(x);
        var a = md5.substring(0, 8),
            b = md5.substring(8, 16);
        return this.test(a, b);
      };

      BloomFilter.prototype.add = function (a, b) {
        // Maybe used to add local safeKey to bloom filter
        var l = this.locations(a, b),
            k = this.k,
            buckets = this.buckets;
        for (var i = 0; i < k; ++i) buckets[Math.floor(l[i] / 32)] |= 1 << l[i] % 32;
      };

      BloomFilter.prototype.addSingle = function (x) {
        // var a = CliqzBloomFilter.hash(x),
        //     b = CliqzBloomFilter.fnv32Hex(x);
        var md5 = CliqzBloomFilter.hash(x);
        var a = md5.substring(0, 8),
            b = md5.substring(8, 16);
        return this.add(a, b);
      };

      BloomFilter.prototype.update = function (a) {
        // update the bloom filter, used in minor revison for every 10 min
        var m = a.length * 32,

        // 32 bit for each element
        n = a.length,
            i = -1;
        m = n * 32;
        if (this.m != m) throw "Bloom filter can only be updated with same length";
        while (++i < n) this.buckets[i] |= a[i];
      };

      var CliqzBloomFilter = {
        VERSION: '0.1',
        debug: 'true',
        BLOOM_FILTER_CONFIG: `${config.settings.CDN_BASEURL}/bloom_filter`,
        hash: function hash(str, alg) {
          return cachedMD5(str);
        },
        fnv32a: function fnv32a(str) {
          var FNV1_32A_INIT = 0x811c9dc5;
          var hval = FNV1_32A_INIT;
          for (var i = 0; i < str.length; ++i) {
            hval ^= str.charCodeAt(i);
            hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
          }
          return hval >>> 0;
        },
        fnv32Hex: function fnv32Hex(str) {
          return CliqzBloomFilter.fnv32a(str).toString(16);
        },
        BloomFilter: BloomFilter
      };

      Components.utils.import('resource://gre/modules/FileUtils.jsm');

      var Storage$2 = class {

        constructor(humanWeb) {
          this.humanWeb = humanWeb;
          this.dbConn = null;
        }

        init() {
          if (FileUtils.getFile("ProfD", ["cliqz.dbusafe"]).exists()) {
            if (this.olddbConn == null) {
              this.olddbConn = Services.storage.openDatabase(FileUtils.getFile("ProfD", ["cliqz.dbusafe"]));
            }

            try {
              (this.olddbConn.executeSimpleSQLAsync || this.olddbConn.executeSimpleSQL)('DROP TABLE usafe;');
            } catch (ee) {}
          }

          if (FileUtils.getFile("ProfD", ["cliqz.dbhumanweb"]).exists()) {
            if (this.dbConn == null) {
              this.dbConn = Services.storage.openDatabase(FileUtils.getFile("ProfD", ["cliqz.dbhumanweb"]));
            }
            this.createTable();
          } else {
            this.dbConn = Services.storage.openDatabase(FileUtils.getFile("ProfD", ["cliqz.dbhumanweb"]));
            this.createTable();
          }

          return Promise.resolve(this.dbConn);
        }

        asyncClose() {
          if (this.dbConn) {
            return new Promise((resolve, reject) => {
              try {
                this.dbConn.asyncClose(() => {
                  this.dbConn = null;
                  resolve();
                });
              } catch (e) {
                reject(e);
              }
            });
          } else {
            return Promise.resolve();
          }
        }

        getDBConn() {
          return this.dbConn;
        }

        removeUnsafe(url, callback) {
          var st = this.dbConn.createStatement("DELETE from usafe WHERE url = :url");
          st.params.url = url;
          //while (st.executeStep()) {};
          st.executeAsync({
            handleError: aError => {
              this.humanWeb.log("SQL error: " + aError.message);
              callback(false);
            },
            handleCompletion: aReason => {
              if (this.humanWeb.debug) {
                this.humanWeb.log("Delete success");
                callback(true);
              }
            }
          });
        }

        getListOfUnchecked(cap, sec_old, fixed_url, callback) {
          var tt = new Date().getTime();
          var stmt = null;
          if (fixed_url == null) {
            // all urls
            stmt = this.dbConn.createAsyncStatement("SELECT url, payload FROM usafe WHERE last_visit < :last_visit LIMIT :cap;");
          } else {
            stmt = this.dbConn.createAsyncStatement("SELECT url, payload FROM usafe WHERE last_visit < :last_visit and url = :url LIMIT :cap;");
            stmt.params.url = fixed_url;
          }
          stmt.params.last_visit = tt - sec_old * 1000;
          stmt.params.cap = cap;

          var res = [];
          stmt.executeAsync({
            handleResult: aResultSet => {
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                res.push([row.getResultByName("url"), JSON.parse(row.getResultByName("payload"))]);
              }
            },
            handleError: aError => {
              this.humanWeb.log("SQL error: " + aError.message);
            },
            handleCompletion: aReason => {
              if (aReason != Components.interfaces.mozIStorageStatementCallback.REASON_FINISHED) {
                this.humanWeb.log("SQL canceled or aborted");
              } else {
                if (res.length > 0) {
                  this.humanWeb.log("Got the result: " + res[0]);
                }
                callback(res.splice(0, cap), null);
              }
            }
          });
        }

        saveRecordTelemetry(id, data, callback) {
          if (!this.dbConn) return;
          var st = this.dbConn.createStatement("INSERT OR REPLACE INTO telemetry (id,data) VALUES (:id, :data)");
          st.params.id = id;
          st.params.data = data;

          st.executeAsync({
            handleError: aError => {
              if (this.humanWeb && this.humanWeb.debug) {
                this.humanWeb.log("SQL error: " + aError.message);
              }
              callback(false);
            },
            handleCompletion: aReason => {
              if (this.humanWeb && this.humanWeb.debug) {
                this.humanWeb.log("Insertion success save record");
              }
              callback(true);
            }
          });
        }

        loadRecordTelemetry(id, callback) {
          var stmt = this.dbConn.createAsyncStatement("SELECT id, data FROM telemetry WHERE id = :id;");
          stmt.params.id = id;

          var fres = null;
          var res = [];
          stmt.executeAsync({
            handleResult: aResultSet => {
              if (!this.humanWeb) return;
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                if (row.getResultByName("id") == id) {
                  res.push(row.getResultByName("data"));
                } else {
                  this.humanWeb.log("There are more than one record");
                  callback(null);
                }
                break;
              }
            },
            handleError: aError => {
              if (!this.humanWeb) return;
              this.humanWeb.log("SQL error: " + aError.message);
              callback(null);
            },
            handleCompletion: aReason => {
              if (!this.humanWeb) return;
              if (res.length == 1) callback(res[0]);else callback(null);
            }
          });
        }

        SQL(sql, onRow, callback, parameters) {
          // temporary fix to avoid console logs if human web is disabled
          // the history listner should be handled better if HW module is disabled
          if (!this.dbConn) return;

          var st = this.dbConn.createAsyncStatement(sql);

          for (var key in parameters) {
            st.params[key] = parameters[key];
          }

          this._SQL(this.dbConn, st, onRow, callback);
        }

        _SQL(dbConn, statement, onRow, callback) {
          statement.executeAsync({
            onRow: onRow,
            callback: callback,
            handleResult: aResultSet => {
              var resultCount = 0;
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                resultCount++;
                if (this.onRow) {
                  this.onRow(statement.row);
                }
              }
              if (this.callback) {
                this.callback(resultCount);
              }
            },

            handleError: aError => {
              this.humanWeb.log("Error (" + aError.result + "):" + aError.message);
              if (this.callback) {
                this.callback(0);
              }
            },
            handleCompletion: aReason => {
              // Always called when done
            }
          });
          statement.finalize();
        }

        historyTimeFrame(callback) {
          // TODO:
          Cu.import('resource://gre/modules/PlacesUtils.jsm');
          var history = [];
          var min, max;

          var res = [];
          var st = PlacesUtils.history.QueryInterface(Ci.nsPIPlacesDatabase).DBConnection.createStatement("SELECT min(last_visit_date) as min_date, max(last_visit_date) as max_date FROM moz_places");

          var res = [];
          st.executeAsync({
            handleResult: function handleResult(aResultSet) {
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                res.push({
                  "minDate": row.getResultByName("min_date"),
                  "maxDate": row.getResultByName("max_date")
                });
              }
            },
            handleError: function handleError(aError) {
              _log("SQL error: " + aError.message);
              callback(true);
            },
            handleCompletion: function handleCompletion(aReason) {
              if (aReason != Components.interfaces.mozIStorageStatementCallback.REASON_FINISHED) {
                _log("SQL canceled or aborted");
                callback(null);
              } else {
                try {
                  min = parseInt(res[0]['minDate'] / 1000);
                  max = parseInt(res[0]['maxDate'] / 1000);
                } catch (ex) {}
                callback(min, max);
              }
            }
          });
        }

        deleteVisit(url) {
          this.SQL("delete from usafe where url = :url", null, null, {
            url: this.escapeSQL(url)
          });
        }

        deleteTimeFrame() {
          this.humanWeb.historyTimeFrame(function (min, max) {
            this.SQL("delete from usafe where last_visit < :min", null, null, {
              min
            });
            this.SQL("delete from usafe where last_visit > :max", null, null, {
              max
            });
          });
        }

        clearHistory() {
          this.SQL("delete from usafe");
        }

        isPrivate(url, depth, callback) {

          // This needs to be rewritten.
          callback(false);
          return;
          /*
          // returns 1 is private (because of checked, of because the referrer is private)
          // returns 0 if public
          // returns -1 if not checked yet, handled as public in this cases,
          var res = [];
          var st = this.dbConn.createStatement("SELECT * FROM usafe WHERE url = :url");
          st.params.url = url;
           var res = [];
          st.executeAsync({
            handleResult: (aResultSet) => {
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                res.push({"url": row.getResultByName("url"), "ref": row.getResultByName("ref"), "private": row.getResultByName("private"), "checked": row.getResultByName("checked")});
              }
            },
            handleError: (aError) => {
              this.humanWeb.log("SQL error: " + aError.message);
              callback(true);
            },
            handleCompletion: (aReason) => {
              if (aReason != Components.interfaces.mozIStorageStatementCallback.REASON_FINISHED) {
                this.humanWeb.log("SQL canceled or aborted");
                callback(true);
              } else {
                if (res.length == 1) {
                  if (res[0].ref!='' && res[0].ref!=null) {
                    // the urls already exists in the DB, it has been seen before
                    if (depth < 10) {
                      if (this.humanWeb.auxSameDomain(res[0].ref, url)) {
                        this.isPrivate(res[0].ref, depth+1, function(priv) {
                          callback(priv);
                        });
                      }
                      else callback(false);
                    }
                    else {
                      // set to private (becasue we are not sure so beter safe than sorry),
                      // there is a loop of length > 10 between a <- b <- .... <- a, so if we do not
                      // break recursion it will continue to do the SELECT forever
                      //
                      callback(true);
                    }
                  }
                  else {
                    callback(false);
                  }
                }
                else {
                  callback(true);
                }
              }
            },
          });
          */
        }

        createTable() {
          var usafe = "create table if not exists usafe(\
                url VARCHAR(255) PRIMARY KEY NOT NULL,\
                ref VARCHAR(255),\
                last_visit INTEGER,\
                first_visit INTEGER,\
                reason VARCHAR(256), \
                private BOOLEAN DEFAULT 0,\
                checked BOOLEAN DEFAULT 0, \
                payload VARCHAR(4096), \
                ft BOOLEAN DEFAULT 1 \
            )";

          var hash_usafe = "create table if not exists hashusafe(\
                hash VARCHAR(32) PRIMARY KEY NOT NULL,\
                private BOOLEAN DEFAULT 0 \
            )";

          var hash_cans = "create table if not exists hashcans(\
                hash VARCHAR(32) PRIMARY KEY NOT NULL \
            )";

          var telemetry = "create table if not exists telemetry(\
                id VARCHAR(24) PRIMARY KEY NOT NULL,\
                data VARCHAR(1000000) \
            )";

          // TODO: Used to be asynchronous. In principle, there is no need
          // to use synchronous APIs here, but when using asynchronous APIs,
          // it should be changed, so that the function returns a promise.
          //
          // Once the profile exists, this operation is quite cheap (~1ms).
          //
          this.dbConn.executeSimpleSQL(usafe);
          this.dbConn.executeSimpleSQL(hash_usafe);
          this.dbConn.executeSimpleSQL(hash_cans);
          this.dbConn.executeSimpleSQL(telemetry);
        }

        escapeSQL(str) {
          return str.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, function (char) {
            switch (char) {
              case "'":
                return "''";
              default:
                return char;
            }
          });
        }

        saveURL(url, newObj, callback) {
          let st = this.dbConn.createStatement("INSERT INTO usafe (url,ref,last_visit,first_visit, payload, ft) VALUES (:url, :ref, :last_visit, :first_visit, :payload, :ft)");
          st.params.url = newObj.url;
          st.params.ref = newObj.ref;
          st.params.last_visit = newObj.last_visit;
          st.params.first_visit = newObj.first_visit;
          st.params.ft = newObj.ft;
          st.params.payload = JSON.stringify(newObj.payload);

          st.executeAsync({
            handleError: aError => {
              this.humanWeb.log("SQL error: " + aError.message);
            },
            handleCompletion: aReason => {
              if (this.humanWeb.debug) {
                this.humanWeb.log("Insertion success add urltoDB");
              }
              callback();
            }
          });
        }

        updateURL(url, newObj, callback) {
          let st = this.dbConn.createStatement("UPDATE usafe SET last_visit = :last_visit, payload = :payload WHERE url = :url");
          st.params.url = newObj.url;
          st.params.last_visit = newObj.last_visit;
          st.params.payload = JSON.stringify(newObj.payload);
          //while (st.executeStep()) {};
          st.executeAsync({
            handleError: aError => {
              this.humanWeb.log("SQL error: " + aError.message);
            },
            handleCompletion: aReason => {
              if (this.humanWeb.debug) {
                this.humanWeb.log("updated success");
              }
              callback();
            }
          });
        }

        getURL(url, callback) {
          let stmt = this.dbConn.createStatement("SELECT url, ft,  payload FROM usafe WHERE url = :url");
          stmt.params.url = url;

          let res = [];
          stmt.executeAsync({
            handleResult: aResultSet => {
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                res.push({ 'url': row.getResultByName("url"), 'ft': row.getResultByName('ft'), 'payload': row.getResultByName('payload') });
              }
            },
            handleError: aError => {
              this.humanWeb.log("SQL error: " + aError.message);
            },
            handleCompletion: aReason => {
              this.humanWeb.log(">> Completed >>> ");
              callback(res);
            }
          });
        }
      };

      var dns = class {
        constructor(CliqzHumanWeb) {
          this.CliqzHumanWeb = CliqzHumanWeb;
        }

        getDNS(hostname) {
          const dnsService = Components.classes['@mozilla.org/network/dns-service;1'].createInstance(Components.interfaces.nsIDNSService);

          return new Promise((resolve, reject) => {
            dnsService.asyncResolve(hostname, 0, {
              onLookupComplete(request, record, status) {
                if (!Components.isSuccessCode(status)) {
                  reject();
                } else if (record) {
                  const address = record.getNextAddrAsString();
                  resolve(address);
                } else {
                  reject();
                }
              }
            }, null);
          });
        }
      };

      const MAX_RECHECK_PERIOD = 503;
      const MAX_TIMEOUT = 600011;
      let hiddenWindowPromise = null;

      function waitForHiddenWindow(resolve, reject) {
        let observer;
        let recheckPeriod = 5;
        let timeTotal = 0;
        let timer = Components.classes['@mozilla.org/timer;1'].createInstance(Components.interfaces.nsITimer);

        // Check if appShell.hiddenDOMWindow is available. If not,
        // schedule a next check after a short period (which increases
        // with every unsuccessful attempt, up to MAX_RECHECK_PERIOD).
        function checkHiddenWindow() {
          try {
            resolve(Services.appShell.hiddenDOMWindow);
            timer = null;
          } catch (e) {
            timeTotal += recheckPeriod;
            if (timeTotal >= MAX_TIMEOUT) {
              timer = null;
              reject(null);
              return;
            }
            recheckPeriod *= 2;
            timer.init(observer, recheckPeriod, timer.TYPE_ONE_SHOT);
            if (recheckPeriod > MAX_RECHECK_PERIOD) {
              recheckPeriod = MAX_RECHECK_PERIOD;
            }
          }
        }

        observer = {
          observe() {
            timer.cancel();
            checkHiddenWindow();
          }
        };

        checkHiddenWindow();
      }

      // In FF57 `appShell.hiddenDOMWindow` may not be immediatelly available,
      // we should wait until it appears before using.
      var getWindowAPIAsync = function () {
        if (!hiddenWindowPromise) {
          hiddenWindowPromise = new Promise(waitForHiddenWindow);
        }

        return hiddenWindowPromise;
      };

      function getAllOpenPages() {
        const promise = new Promise((resolve, reject) => {
          const urls = [];
          try {
            forEachWindow(win => {
              const openTabs = queryActiveTabs(win);
              openTabs.forEach(data => {
                const url = data.url;
                if (url && urls.indexOf(url) === -1 && url.startsWith('about:') === false) {
                  urls.push(decodeURIComponent(url));
                }
              });
            });
          } catch (ee) {
            reject(ee);
          }
          resolve(urls);
        });
        return promise;
      }

      /* eslint-disable import/prefer-default-export */

      /**
       * Google pagead aclk look like this:
       * https://www.googleadservices.com/pagead/aclk?sa=L&ai=DChcSEwjNi5bcsbPWAhUW4BsKHUePBAwYABARGgJ3bA&ohost=www.google.de&cid=CAASEuRo7v8yDlI1j5_Xe3oAtyANqQ&sig=AOD64_0I3As2z06whZRtfqOC3PGdhk9SIQ&ctype=5&q=&ved=0ahUKEwjc7JLcsbPWAhVLuhQKHQWpCRcQ9aACCKIB&adurl=
       *
       * This function takes such an url and returns a normalized string
       * (which is no longer an url). Links to identical ads should be
       * normalized to the same string while links to different ads
       * should be mapped to different keys.
       */
      function normalizeAclkUrl(url) {
        const parts = url.split('aclk?');
        if (parts.length !== 2) {
          throw new Error(`Expected Google pagead "aclk" URL. Instead got: ${url}`);
        }

        // Ignore the "ved" code, as it seems to change between clicks.
        //
        // For background information about the "ved" code, see
        // https://deedpolloffice.com/blog/articles/decoding-ved-parameter
        const noVed = parts[1].replace(/ved=.*&/, '');

        // TODO: hack, needs to be replaced by a more robust solution
        return noVed.replace(/&q=&adurl=$/, '').replace(/&adurl=&q=$/, '');
      }

      function getRequest(url) {
        const promise = new Promise((resolve, reject) => {
          let errorMessage = null;

          const req = new XMLHttpRequest();

          /*
          We need a try catch block here, because there are some URLs which throw malformed URI error,
          hence stalling the double fetch on the same row.
          Such URLs should not be there at the first place, but in-case they are, we set them as private.
          */

          try {
            req.open('GET', url, true);
          } catch (ee) {
            reject();
            return;
          }
          req.overrideMimeType('text/html');
          req.channel.loadFlags |= Components.interfaces.nsIRequest.LOAD_ANONYMOUS;
          //  req.withCredentials = false;
          //  req.setRequestHeader("Authorization", "true");

          req.onload = function () {
            if (req.status !== 200 && req.status !== 0 /* local files */) {
                errorMessage = `status not valid: ${req.status}`;
                req.onerror();
              } else {
              // there has been a redirect, we cannot guarantee that cookies were
              // not sent, therefore fail and consider as private
              if (!equals(req.responseURL, url) && !equals(decodeURI(decodeURI(req.responseURL)), decodeURI(decodeURI(url)))) {
                errorMessage = 'dangerous redirect';
                req.onerror();
                return;
              }
              resolve(req.responseText);
            }
          };

          req.onerror = function () {
            reject(errorMessage);
          };
          req.ontimeout = function () {
            errorMessage = 'timeout';
            req.onerror();
            reject(errorMessage);
          };

          req.timeout = 10000;
          req.send(null);
        });
        return promise;
      }

      /**
       * No-op function.
       */
      function noop() {}

      function multiArgsDump() {
        if (arguments.length > 0) {
          dump(arguments.length <= 0 ? undefined : arguments[0]);

          for (let i = 1; i < arguments.length; i += 1) {
            dump(' ');
            dump(arguments.length <= i ? undefined : arguments[i]);
          }

          dump('\n');
        }
      }

      function Logger(options) {
        const useDump = options.useDump === true;
        const level = options.level || 'log';
        const prefix = options.prefix;

        let debug = console$1.debug;
        let log = console$1.log;
        let error = console$1.error;

        if (useDump) {
          debug = multiArgsDump.bind(null, '[DEBUG]');
          log = multiArgsDump.bind(null, '[LOG]');
          error = multiArgsDump.bind(null, '[ERROR]');
        }

        if (prefix) {
          debug = debug.bind(null, prefix);
          log = log.bind(null, prefix);
          error = error.bind(null, prefix);
        }

        if (level === 'log') {
          debug = noop;
        }

        if (level === 'error') {
          debug = noop;
          log = noop;
        }

        return {
          debug,
          log,
          error
        };
      }

      var logger = Logger({
        useDump: false,
        level: 'error',
        prefix: '[human-web]'
      });

      const State = {
        DISABLED: 'DISABLED',
        INITIALIZING: 'INITIALIZING',
        READY: 'READY'
      };

      /**
       * Helper class to execute doublefetch requests:
       *
       * - Attempt an anonymous GET request against the URL
       *   (stripping login information, etc.)
       * - Requests that timeout or exceed a size limit
       *   ("maxDoubleFetchSize") are rejected.
       *
       * Scheduling of doublefetch requests is not handled, here.
       * Also processing the results of the requests (i.e., whether the
       * content of the page from anonymous GET is similar to the
       * content that the authenticated user got before).
       */
      class DoublefetchHandler {
        constructor() {
          // requests exceeding this size in bytes will be cancelled
          this.maxDoubleFetchSize = 2097152; // default: 2MB

          // Conservative time limit that should never to exceeded,
          // but is intended for leak detection only.
          //
          // Should not be confused with a request timeout, as
          // it is only relevant for internal cleanup.
          this.zombieRequestTimelimitMs = 10 * 60 * 1000; // default: 10 minutes

          // Array of { ts: Date, url: String } sorted by timestamp (oldest comes first).
          this._pendingRequests = [];

          // init/unload lifecycle:
          //
          // Notes:
          // * _pendingInit is a promise that is only used for
          //   sequentializing and should always resolve successfully
          // * we start in DISABLED state, which means that all doublefetch
          //   requests will be rejected until "init" has been called.
          this._pendingInit = Promise.resolve();
          this._setState(State.DISABLED);

          this._webRequestPipeline = inject.module('webrequest-pipeline');

          // mostly for debugging purposes to get an idea what doublefetch does
          this._stats = {
            callsToAnonymousHttpGet: 0,
            httpRequests: {
              started: 0,
              finished: 0
            },
            rejected: {
              doubleFetchDisabled: 0,
              exceededSizeLimit: 0
            },
            allowDoublefetch: 0,
            redirectsFollowed: 0,
            errors: {
              inconsistentStateDetected: 0,
              danglingEntryFound: 0
            },
            matchDetails: {
              noMatch: 0,
              perfectMatch: 0,
              relaxedMatch: 0
            },
            strippedHeaders: 0
          };
        }

        /**
         * Starts the doublefetch for the given URL and returns
         * a promise which resolves to the content of the response,
         * or is rejected if the doublefetch is aborted.
         */
        anonymousHttpGet(url) {
          this._stats.callsToAnonymousHttpGet += 1;

          return this._pendingInit.catch(logger.debug).then(() => {
            const requestStartedAt = new Date();
            this._purgeObsoleteRequests(requestStartedAt);

            if (this._state === State.DISABLED) {
              this._stats.rejected.doubleFetchDisabled += 1;
              return Promise.reject(`doublefetch disabled: skipping request to fetch ${url}`);
            }

            // bookkeeping: remember the request and clean it up in the end
            const entry = { ts: requestStartedAt, url, originalUrl: url };
            this._pendingRequests.push(entry);
            logger.debug('doublefetch: pending requests', this._pendingRequests.length);

            // start the anonymous GET request (stripping cookies, etc)
            this._stats.httpRequests.started += 1;
            const requestPromise = getRequest(url);
            entry.requestPromise = requestPromise;

            requestPromise.catch(logger.debug).then(() => {
              const elapsedMs = new Date() - requestStartedAt;
              logger.debug(`doublefetch for ${entry.url} completed after ${elapsedMs / 1000} seconds.`);
              this._stats.httpRequests.finished += 1;

              const index = this._pendingRequests.indexOf(entry);
              if (index !== -1) {
                this._pendingRequests.splice(index, 1);
              } else if (elapsedMs < this.zombieRequestTimelimitMs) {
                logger.error(`_pendingRequests is in an inconsistent state (url=${entry.url}).`);
                this._stats.errors.inconsistentStateDetected += 1;
              }
            });

            return requestPromise;
          });
        }

        _correlatePendingDoublefetchRequest(request) {
          const match = this._findPendingDoublefetchRequest(request);

          // Remember the requestId, so we can avoid all URL comparisons later.
          if (match && !match.requestId) {
            match.requestId = request.requestId;
          }

          return match;
        }

        _findPendingDoublefetchRequest(request) {
          // First, check for the requestId because it is the only information
          // that is 100% reliable. If we find a match, take it.
          // Otherwise, we need to fallback to heuristics.
          const pendingWithUnknownRequestId = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this._pendingRequests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const pending = _step.value;

              if (!pending.requestId) {
                pendingWithUnknownRequestId.push(pending);
              } else if (pending.requestId === request.requestId) {
                return pending;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          if (!(request.tabId && request.tabId === -1)) {
            // ignore requests to tabs
            return null;
          }

          const completeMatch = pendingWithUnknownRequestId.filter(x => equals(request.url, x.url));
          if (completeMatch.length > 0) {
            // should not be ambiguous, but when in doubt, let the oldest one win
            this._stats.matchDetails.perfectMatch += 1;
            return completeMatch[0];
          }

          // If there was no match, fallback to a version the where schema (http vs https) is ignored.
          // Requests like "http://goo.gl/..." may have been modified to "https://goo.gl/...".
          const normalizeSchema = x => x.replace(/^https:\/\//, 'http://');
          const ignoringSchema = pendingWithUnknownRequestId.filter(x => equals(normalizeSchema(request.url), normalizeSchema(x.url)));
          if (ignoringSchema.length > 0) {
            // should not be ambiguous, but when in doubt, let the oldest one win
            this._stats.matchDetails.relaxedMatch += 1;
            return ignoringSchema[0];
          }

          this._stats.matchDetails.noMatch += 1;
          return null;
        }

        /**
         * In general, requests should be cleaned up automatically.
         * If that is not the case, it indicates that something went wrong.
         * To avoid leaking memory, clean up after a while when it is
         * obvious that the entry is no longer relevant.
         */
        _purgeObsoleteRequests(requestStartedAt) {
          while (this._pendingRequests.length > 0 && requestStartedAt - this._pendingRequests[0].ts > this.zombieRequestTimelimitMs) {
            logger.error(`doublefetch for url ${this._pendingRequests[0].url} was not cleaned up after ${this.zombieRequestTimelimitMs} ms.`);
            this._stats.errors.danglingEntryFound += 1;
            this._pendingRequests.shift();
          }
        }

        _createOnBeforeSendHeadersHandler() {
          // List of headers that should be removed before sending out the request:
          // (Fetch requests in Firefox web-extension have a flaw. They attach
          //  origin: moz-extension//ID , which is specific to a user.*)
          const sensitiveHeaders = ['cookie', 'origin'];

          return {
            name: 'human-web.stripSensitiveHeadersInDoublefetch',
            spec: 'blocking',
            fn: (request, response) => {
              const matchingPendingEvent = this._correlatePendingDoublefetchRequest(request);
              if (matchingPendingEvent) {
                /* eslint-disable no-param-reassign */
                response.requestHeaders = request.requestHeaders.filter(header => !sensitiveHeaders.includes(header.name.toLowerCase()));
                if (response.requestHeaders.length !== request.requestHeaders.length) {
                  this._stats.strippedHeaders += 1;
                }

                // webrequest-pipeline has the modifyHeader API, but it does not work
                // as I expected: Effectively, the following code clears all headers.
                /*
                for (const header of sensitiveHeaders) {
                  if (request.getRequestHeader(header)) {
                    this._stats.strippedHeaders += 1;
                    response.modifyHeader(header, '');
                  }
                } */
              }
            }
          };
        }

        /**
         * This is the actual logic that we add to the WebRequest pipeline:
         *
         * Based on the "Content-Length" HTTP header, we abort all
         * requests that exceed our limit.
         *
         * To avoid cancelling non-doublefetch requests, skip
         * requests where the URL does not match any of the
         * double fetch requests.
         */
        _createOnHeadersReceivedHandler() {
          return {
            name: 'human-web.preventExpensiveDoublefetchRequests',
            spec: 'blocking',
            fn: (request, response) => {
              const matchingPendingEvent = this._correlatePendingDoublefetchRequest(request);
              if (!matchingPendingEvent) {
                // do not block request
                return true;
              }

              const contentLength = request.getResponseHeader('content-length');
              if (contentLength && contentLength > this.maxDoubleFetchSize) {
                this._stats.rejected.exceededSizeLimit += 1;
                logger.debug(`Response of ${request.url} exceeds limit of ${this.maxDoubleFetchSize} bytes. Aborting double fetch request.`);

                response.block();
                return false;
              }

              if (request.statusCode >= 300 && request.statusCode < 400) {
                const locationHeader = request.getResponseHeader('location');
                if (locationHeader) {
                  this._stats.redirectsFollowed += 1;
                  const redirectedTo = locationHeader;
                  matchingPendingEvent.url = redirectedTo;
                }
              }

              // do not block request
              this._stats.allowDoublefetch += 1;
              return true;
            }
          };
        }

        init() {
          this._pendingInit = this._pendingInit.catch(logger.debug).then(() => {
            if (this._state === State.INITIALIZING) {
              throw new Error('Assertion failed: After all pending operation have finished, ' + 'we must never end up in the INITIALIZING state');
            }

            if (this._state === State.READY) {
              return Promise.resolve();
            }

            this._setState(State.INITIALIZING);

            const pendingLoad = this._initPipeline().then(() => {
              this._setState(State.READY);
            }).catch(e => {
              logger.error('Failed to initialize pipeline', e);
              this._setState(State.DISABLED);
            });
            this._pendingInit = pendingLoad;
            return pendingLoad;
          });
          return this._pendingInit;
        }

        unload() {
          if (this._state === State.INITIALIZING) {
            // Edge case: cannot abort the initialization.
            // So, wait for it and then immediately clean up.
            // (Calling "unload" multiple time is safe.)
            this._pendingInit = this._pendingInit.then(() => this.unload()).catch(logger.error);
          }

          // Has an immediate effect:
          // No new HTTP requests will be started. Instead all doublefetch
          // attempts will be rejected from now on until "init" is called.
          this._setState(State.DISABLED);

          // The rest is an async operation, but in case the extension is unloaded,
          // the WebRequestPipeline module will synchronously cleanup all listeners.
          //
          // But to avoid any races, delay the next initialization.
          // Also wait for all pending requests to end.
          const pendingUnload = this._pendingInit.then(() => Promise.all(this._pendingRequests.filter(x => x.requestPromise).map(x => x.requestPromise.catch(() => {})))).then(() => this._unloadPipeline()).then(() => this._setState(State.DISABLED));
          this._pendingInit = pendingUnload.catch(logger.error);

          return pendingUnload;
        }

        _setState(newState) {
          if (newState !== this._state) {
            logger.log(`changing state: ${this._state} => ${newState}`);
            this._state = newState;
          }
        }

        _initPipeline() {
          if (this._onHeadersReceivedHandler) {
            return Promise.resolve();
          }

          const beforeSendHeadersHandler = this._createOnBeforeSendHeadersHandler();
          const headersReceivedHandler = this._createOnHeadersReceivedHandler();
          return this._webRequestPipeline.isReady().then(() => this._webRequestPipeline.action('addPipelineStep', 'onBeforeSendHeaders', beforeSendHeadersHandler)).then(() => {
            this._onBeforeSendHeadersHandler = beforeSendHeadersHandler;
          }).then(() => this._webRequestPipeline.action('addPipelineStep', 'onHeadersReceived', headersReceivedHandler)).then(() => {
            this._onHeadersReceivedHandler = headersReceivedHandler;
          });
        }

        _removePipelineStep(handler, stage) {
          if (!handler) {
            return Promise.resolve();
          }

          return ifModuleEnabled(this._webRequestPipeline.action('removePipelineStep', stage, handler.name));
        }

        _unloadPipeline() {
          return this._removePipelineStep(this._onBeforeSendHeadersHandler, 'onBeforeSendHeaders').then(() => this._removePipelineStep(this._onHeadersReceivedHandler, 'onHeadersReceived')).then(() => {
            this._onBeforeSendHeadersHandler = null;
            this._onHeadersReceivedHandler = null;
          });
        }
      }

      // Default polling interval for patterns from the backend
      const DEFAULT_UPDATE_INTERVAL_IN_MS = 60 * 60 * 1000; // 1 hour

      // Faster retry interval if the initial fetching of the
      // resources failed because the network was down.
      // If that network call fails again, give up and keep
      // waiting for the longer default interval.
      const RETRY_INTERVAL_IN_MS = 60 * 1000; // 1 min

      // If the internet connection is slow, loading the patterns
      // for the first time will block the start of the Human Web module.
      //
      // If this timeout is exceeded, stop waiting and continue
      // even if Human Web is not fully initialized yet.
      // The ongoing requests will not be aborted, so human web will
      // eventually be fully initialized.
      //
      const DEFAULT_INIT_TIMEOUT_IN_MS = 3 * 1000;

      /**
       * Loads contact extraction patterns from the Cliqz backend.
       * For instance, these pattern define rules to recognize
       * queries from search engine result pages.
       * To keep in sync with the backend, the client will regularly
       * poll for changes.
       *
       * If the initial loading of the pattern fails because the network
       * is not available, human web will start in a well-defined state
       * but some functionality will be disabled until the patterns could
       * be successfully fetched from the server.
       *
       * Well-defined state means that no patterns will be active.
       * In other words, there should be no errors, but at the same
       * time no content will be collected. Once the patterns are
       * loaded, full functionality of human web will be restored.
       */
      class ContentExtractionPatternsLoader {
        /**
         * @param onUpdateCallback: (patternsConfig, mode)
         *
         * where mode = 'strict' or 'normal'
         */
        constructor(onUpdateCallback) {
          this.updatePatternsDefaultIntervalInMs = DEFAULT_UPDATE_INTERVAL_IN_MS;
          this.updatePatternsRetryIntervalInMs = RETRY_INTERVAL_IN_MS;
          this.initTimeoutInMs = DEFAULT_INIT_TIMEOUT_IN_MS;

          this.config = {
            normal: {
              name: 'patterns',
              chromeURL: `${config.baseURL}human-web/patterns.json`,
              remoteURL: config.settings.ENDPOINT_PATTERNSURL
            },
            strict: {
              name: 'patterns-anon',
              chromeURL: `${config.baseURL}human-web/anonpatterns.json`,
              remoteURL: config.settings.ENDPOINT_ANONPATTERNSURL
            }
          };

          this.onUpdateCallback = onUpdateCallback;
          this.resourceLoaders = {};
          this._activeTimers = new Set();
        }

        isLoaded() {
          return Object.keys(this.resourceLoaders).length > 0;
        }

        init() {
          if (this.isLoaded()) {
            return Promise.resolve();
          }

          const promises = Object.keys(this.config).map(ruleset => {
            const cfg = this.config[ruleset];
            const resourceLoader = new ResourceLoader(['human-web', cfg.name], {
              chromeURL: cfg.chromeURL,
              remoteURL: cfg.remoteURL,
              cron: this.updatePatternsDefaultIntervalInMs,
              remoteOnly: true
            });
            this.resourceLoaders[ruleset] = resourceLoader;

            resourceLoader.onUpdate(patternsConfig => {
              logger.debug(`Updating "${ruleset}" content extraction patterns`);
              this.onUpdateCallback(patternsConfig, ruleset);
            });

            const loading = resourceLoader.load().then(patternsConfig => {
              this.onUpdateCallback(patternsConfig, ruleset);
            }).catch(e => {
              logger.error(`Failed to initialize "${ruleset}" content extraction patterns: ${e}`);

              // make one retry attempt, in case that the network was only unavailable for a short time
              const timer = setTimeout(() => {
                logger.debug(`Retry to update "${ruleset}" content extraction patterns`);
                resourceLoader.updateFromRemote({ force: true }).catch(() => {});
                this._activeTimers.delete(timer);
              }, this.updatePatternsRetryIntervalInMs);
              this._activeTimers.add(timer);
            });

            const timeout = new Promise((resolve, reject) => {
              setTimeout(reject, this.initTimeoutInMs);
            });

            return Promise.race([loading, timeout]).catch(() => {
              logger.log(`WARNING: Timeout of ${this.initTimeoutInMs} ms exceeded ` + `while initializing the "${ruleset}" content extraction patterns`);
            });
          });

          return Promise.all(promises);
        }

        unload() {
          Object.keys(this.resourceLoaders).forEach(x => this.resourceLoaders[x].stop());
          this.resourceLoaders = {};

          // cancel all retry attempts
          this._activeTimers.forEach(x => clearTimeout(x));
          this._activeTimers = new Set();

          return Promise.resolve();
        }
      }

      // Just a mock, so should be safe. Bootstrap has better way to detect private mode.

      function getTabInfo(tabId, type) {
        const tabInfo = {
          type,
          isWebExtension: false,
          isPrivate: false
        };

        return Promise.resolve(tabInfo);
      }

      // import getIP from '../core/dns';
      // import console from '../core/console';
      let refineFuncMappings;

      /*
      Configuration for Bloomfilter
      */

      const bloomFilterSize = 500001; // false-positive 0.01, hashes 7
      const bloomFilterNHashes = 7;
      const allowedCountryCodes = config.settings.ALLOWED_COUNTRY_CODES;
      const tryDecodeURI$1 = CliqzUtils.tryDecodeURI;
      const tryDecodeURIComponent$1 = CliqzUtils.tryDecodeURIComponent;

      function _log$1(msg) {
        if (CliqzHumanWeb.debug) {
          console.log(CliqzHumanWeb.LOG_KEY, msg);
        }
      }

      function getRandomIntInclusive(min, max) {
        const _min = Math.ceil(min);
        const _max = Math.floor(max);
        return Math.floor(Math.random() * (_max - _min + 1)) + min;
      }

      function getHTML() {
        const core = inject.module('core');

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return core.action('getHTML', ...args);
      }

      function cleanFinalUrl(domain, href) {
        /*
        We need to get the final domain, there are 2 elements that we try to capture.
        1. Which is mentioned in the key 'fu' in the scraping rules. It is not clean in all the cases.
        For eg: That URL at times comes as aclk?. In this case we will try and fall back on data-preconnect-urls.
        2. data-preconnect-urls: We are not using it as primary source, because at times, this contains the ad-server domain.
        When we use this attribute, we need to ensure we do not send back the complete chain.
        */

        let cleanDomain = href;

        // Parse domain from href.
        let parsedLink = CliqzHumanWeb.parseURL(href);
        if (parsedLink && parsedLink.hostname && parsedLink.hostname.indexOf('google') === -1 && parsedLink.path.indexOf('aclk?') === -1) {
          cleanDomain = parsedLink.hostname;
        } else if (domain) {
          if (domain.indexOf(',') > -1) {
            cleanDomain = domain.split(',')[0];
          } else {
            cleanDomain = domain;
          }
        }
        return cleanDomain;
      }

      const CliqzHumanWeb = {
        adDetails: {},
        CHANNEL: config.settings.HW_CHANNEL,
        VERSION: '2.7',
        WAIT_TIME: 2000,
        PAGE_WAIT_TIME: 5000,
        LOG_KEY: 'humanweb',
        debug: false,
        httpCache: {},
        httpCache401: {},
        domParser: null,
        queryCache: {},
        privateCache: {},
        UrlsCache: false,
        docCache: {},
        strictMode: false,
        qs_len: 30,
        rel_part_len: 18,
        rel_segment_len: 15,
        doubleFetchTimeInSec: 3600,
        MAX_NUMBER_DOUBLEFETCH_ATTEMPS: 3,
        can_urls: {},
        deadFiveMts: 5,
        deadTwentyMts: 20,
        msgType: 'humanweb',
        domain2IP: {},
        probHashLogM: [[-1.839225984234144, -1.8009413231413045, -2.5864601561900273, -2.779077348461893, -2.41154163187108, -2.8701669802592216, -3.010853183897427, -2.9831997811803244, -3.0258844950086354, -3.028549665472028, -4.922879838696041, -4.503195676571833, -4.598154161855354, -5.027344698225922, -5.217723368153992, -5.366375752342653, -5.195909278900248, -3.2940850310881387, -5.181468249477294, -6.110371416838184, -5.766202229535159, -5.393352786265537, -4.920024681004049, -6.049294408676102, -6.399015490326156, -4.690163484884073, -7.459851804835359, -5.825337077308845, -4.675000760327133, -5.3635239851672845, -6.331713706782754, -6.169284763337202, -5.951151191317628, -5.768078242705815, -7.332129653597336, -6.766704624275413, -6.01222435569866, -5.268617743244878, -6.279416117827666, -5.861972559492891, -5.838071468059843, -6.267250173459698, -6.283981033030117, -6.454759516784266, -6.5195694451700765, -6.83526729571271, -6.458157413359671, -6.359696067797872, -6.250241538141395, -6.647172527007435, -6.973987597161365, -6.4598607011160425, -7.685547265665763, -6.5912026847359835, -5.794718807999361, -6.474629988987015, -7.135098972554303, -6.880960523371609, -6.747429130747086, -7.733118660641065, -8.398636456057481, -7.6323973914922005], [-2.11332750230783, -2.3060786022344897, -2.3740965556720726, -2.5398307619465608, -2.463417892707307, -2.130953109899374, -2.8009573227909073, -2.9401508827086436, -2.748847204575824, -2.8414237914951976, -5.010884149435608, -4.7716590964777925, -4.868359687249472, -5.322380370933768, -5.037006822424893, -5.279762905036231, -5.635270908532894, -2.9219817650555973, -5.50179037155463, -6.5406369920023, -6.311742070591071, -5.516975693542294, -5.7251712834206305, -6.083331008626942, -6.409455776722731, -4.856277028595425, -7.356357334609669, -6.255977591877104, -5.042089425488359, -5.723688703460408, -6.9306288690141455, -5.879866127104103, -6.269949621534028, -6.969512838475713, -7.475373123729266, -6.802062729887527, -6.566109586768108, -6.661695002244713, -6.634070998648396, -6.128265317507457, -6.0654489711795785, -6.79728322915323, -6.99559673771516, -6.996654379273295, -7.671972036661277, -7.840255377779173, -7.132455920432357, -7.233113706563278, -6.737551430374816, -7.2706736012479585, -7.430290364348156, -6.991903776514698, -8.559572276072503, -7.231105001502197, -6.117005677632925, -6.669675284003577, -7.87022016648111, -7.635233211015519, -7.18343028641663, -8.53463332772525, -8.567176875457722, -7.573077285525099], [-1.6313545940843748, -2.457209014039589, -2.565380346827546, -2.767788786784649, -2.6386222432933284, -2.595661570703591, -2.6893427324813977, -2.7198733792574403, -2.720533202987637, -2.8467380805237736, -5.029918409868431, -4.178710463028381, -5.07588590483658, -5.057436988529895, -4.899938336310833, -5.271744381251988, -5.715419865537325, -3.1739071041721116, -5.367102243680773, -6.224018730172038, -5.866973141306898, -5.730015933050199, -5.360958031920617, -6.20201967617667, -6.328452890969734, -4.837569916970598, -7.520833339090353, -5.8325529174204185, -4.950768880962046, -5.339171801246006, -6.500538943869661, -6.141626179853517, -5.826929659866057, -6.371549418153106, -7.095602530626063, -6.863928261303842, -6.26532998038965, -6.486382994639529, -6.568804701240378, -5.928030195562504, -6.138501621140467, -6.375855129864318, -6.672567424416514, -6.87690014131182, -7.500698430681298, -7.486404619424152, -7.110483757622713, -6.948864783187929, -6.7689909475117735, -7.44680608044408, -7.305175362028806, -6.490004000406482, -8.278142463867583, -7.100043692626031, -6.262757631704339, -6.785644569035485, -7.917859578552653, -6.966883288690608, -6.7663306639529575, -7.827911341889713, -7.709275282211631, -7.650980633730635], [-2.2483023852308777, -2.2601431921520803, -2.543211818297523, -2.6290975996017654, -2.597012293697696, -2.425038774903284, -2.6464962853598264, -2.7268820909874645, -2.7170988469992086, -2.6384412943652213, -4.8059842634060495, -4.801920790322523, -4.881995682865955, -4.399130557719554, -4.977525552072196, -5.254333597613871, -5.4861286120783905, -3.172333855510997, -5.311009967578493, -6.3787775808955045, -6.060833750357407, -5.179488625881995, -5.284849141539821, -6.185226477248653, -6.342526765978808, -5.0477193482508715, -7.229508117457252, -5.92913163950562, -4.781563610047119, -5.175693021409531, -6.686598785853124, -5.953265540842049, -5.765108625614716, -6.249636653394711, -7.053405713688212, -6.871084156894258, -4.746700678954438, -4.435206614193364, -6.2492260600816145, -5.437566316202071, -5.90294982336378, -6.5708663077474965, -6.4774110336687505, -6.642451113295277, -7.490560332753359, -7.638809897851904, -7.037026821604173, -6.792453878834064, -6.557926605402683, -7.183535297458448, -7.556615154408894, -6.675849393697125, -7.929241490870054, -6.920447880012594, -5.937211886970303, -6.536908132533395, -7.266281062975223, -7.138583909596181, -6.9407325511841, -7.611188320541975, -8.063402408224212, -7.7539194100649205], [-2.0350349956205984, -2.348602646771946, -2.41594411405956, -2.651370395735765, -2.563410442434685, -2.706962611141542, -2.7917112923152776, -2.7483543933766477, -2.6785026736567357, -2.8111298756441037, -4.759837736546805, -4.20618015484438, -4.787453629928326, -4.659538126267765, -5.015532806050122, -5.056335259588051, -5.339468177159593, -3.040667184111712, -5.203144447478613, -6.2264472230490675, -5.7097357671058155, -5.585194192596145, -5.035187712987706, -5.542988699592872, -6.206189420830567, -4.864552817623237, -7.387161020524848, -5.130725109803191, -4.710070938057912, -5.015532806050122, -5.563665939332496, -5.8412571088023135, -5.744609136156329, -6.206575148897066, -6.842735398083401, -6.794361813799185, -5.850672107736916, -6.088449236501511, -6.348519254409916, -5.725588459198469, -6.064735388153122, -6.479956671206651, -6.2209527037314265, -6.70094736915976, -7.3405268040104845, -7.140183173146506, -6.467358872953416, -6.7233339772218645, -6.184068000080206, -6.381516598393398, -7.406185056529545, -6.368731036096427, -7.402351186018824, -6.6091509166536255, -5.9623588984476195, -6.352529061520146, -7.133337180638517, -7.24783614109371, -6.901266731308386, -7.234806640803376, -7.432126848507545, -7.494477663675224], [-2.0215812860615885, -2.455637406643175, -2.4330253990141046, -2.6113902739466517, -2.6033787533338284, -2.6337646574813993, -2.7111759743895725, -2.7471499108067454, -2.721672070749707, -2.7644985821403028, -4.771735346669196, -4.967298931497775, -4.806933772233218, -4.796223062219612, -4.702049659123834, -4.615986584200591, -5.422222957790021, -3.024083897225106, -5.341473161524181, -5.691932137893965, -5.870247680316981, -5.6516120254419615, -4.85258639108815, -5.9684706438872475, -6.205102036008844, -4.762283950640148, -7.106211026775939, -5.754565801069223, -4.28552037163959, -5.083154204506742, -6.514533306380853, -5.91282033178054, -5.801594696670316, -6.211408552601299, -6.884100000075919, -6.5060032575028, -6.051550266183317, -6.1528452495165125, -6.237040028392324, -5.845664774991169, -5.83750622157883, -6.376088248894053, -6.3936457603588925, -6.58430154569624, -7.071724850704769, -7.213982427018076, -6.56730052905341, -6.608473779316545, -6.403307671270629, -6.973970456584425, -7.485700648480843, -6.5060032575028, -7.126013654072119, -6.592294210440276, -5.525669597265563, -6.0726189713973024, -6.168884085714272, -7.057863242618145, -6.702467385782517, -7.84259108644045, -7.932742183434748, -6.889071012797939], [-2.3515175517946965, -2.4895377785815813, -2.455794452354539, -2.6177065611128625, -2.3916765698655924, -2.55893036105207, -2.621684157393488, -2.6988517931658524, -2.630805311213068, -2.6634082117951667, -4.639123440452939, -4.108116635400416, -4.850674635561831, -4.879642999369406, -5.020506071184806, -5.079702479761731, -5.3856932140647995, -2.922465393995544, -5.272571266829349, -6.095451326503016, -5.703507123198923, -5.5861660464475555, -5.144197286007818, -5.722031888813277, -6.28586346876822, -4.872555039237073, -6.886991750607913, -5.521389523166842, -4.712785087276782, -4.712557943607434, -6.258849400356963, -5.781080159458192, -5.683518571573409, -6.497978247391754, -6.801813554699944, -6.640350228026399, -6.23670827447975, -6.480528140170159, -6.503409353749256, -6.035279500709713, -6.187868456644626, -6.634900623258835, -6.227883924459252, -6.665648019797556, -7.5457712876636505, -7.422426740346121, -6.235666064901307, -6.769319721223498, -6.343344078699495, -6.975730165249003, -7.353206363454935, -6.635677322327007, -7.937813375439674, -6.762240045635436, -6.147006740966892, -6.741296871790193, -7.715813334827543, -7.183705495090042, -6.938232467377743, -7.593211012735211, -8.021194984378726, -7.326496213127361], [-2.404503840183417, -2.43761707422273, -2.4108252303609095, -2.2999425986283435, -2.542843475674806, -2.6029429346724786, -2.584141922741018, -2.5855127818195496, -2.5510561981552526, -2.647681869737238, -4.782820501953572, -4.808208666935694, -4.979563332219715, -5.008211525808261, -5.046432738628459, -5.142457459370653, -5.485491564024772, -3.1144173778919617, -5.417825855041213, -6.245547233803318, -5.938268453446564, -5.963941744764968, -5.450843208258146, -6.059373833665894, -6.223182084343739, -4.942745700375246, -7.208409268623897, -6.038143491827719, -4.6277437642171355, -4.892513996642899, -6.694766741586792, -6.117821568685912, -5.949820065666706, -6.502648045547855, -6.835922059321975, -6.694766741586792, -6.361312919572388, -6.403294392961231, -6.118769885494771, -5.676056523505988, -6.406451957946552, -6.5244722133881785, -6.6333977952105005, -6.6574953467895615, -7.573786078663716, -7.446115322000925, -6.883692335590661, -6.903250344490318, -6.3498910941692, -6.905331510694142, -7.588115904218541, -6.879623153983935, -8.035692497676832, -6.939233062369824, -5.959077527634608, -6.324513515108117, -7.549688527084656, -7.120692921566297, -6.988939594552065, -7.891731808755324, -7.727259481120012, -7.430143376434873], [-2.2924692182301323, -2.450539739657926, -2.3769703926915984, -2.532604294663703, -2.55393918066343, -2.609718771364289, -2.6246425013179655, -2.661744915258029, -2.6011009513028984, -2.6236780353341946, -4.669477044233787, -4.1521285006409165, -4.955491059584871, -4.818890308190988, -5.030853379357302, -5.002039294312803, -5.278250342600015, -3.076829272811893, -5.307731406455737, -5.826171280206974, -6.022604681193609, -5.8364861502494865, -5.222160875948972, -5.86734719439116, -6.263453577434854, -5.1217643044016885, -7.32073988901422, -5.758783848671988, -4.666476541899311, -5.259001445170042, -6.374002568031498, -6.083417735921755, -5.695962812152638, -6.490715185357981, -6.417147740477192, -6.55681384079998, -5.431378631989581, -5.843302320137157, -6.369727752361356, -5.638321273173884, -6.50456582229188, -6.275027142828877, -6.210627212225794, -6.774279201200845, -7.54625217416398, -7.377527245335997, -6.968174323388823, -6.961544464850153, -6.5738576027632725, -6.808653231033201, -7.247759185607984, -6.667823395181603, -8.06567857870257, -6.862038055489511, -5.923075085846576, -6.772454383176216, -7.732534132174032, -6.980444415980637, -6.935456028765855, -7.926350068393722, -7.409760739910981, -7.357691884279851], [-2.395140177772492, -2.3972905877762423, -2.4380054501613637, -2.59514809923619, -2.5304957080424493, -2.553494441315067, -2.592658670737186, -2.6234135177213647, -2.5068257242437872, -2.493912396989218, -4.415128005729072, -4.8162395242315545, -4.805681457561184, -4.959588437581088, -5.013259465745109, -5.070148436368585, -5.778302005668334, -3.0289910877331776, -5.527143864017425, -6.11105402601701, -6.123887370951674, -5.975929983744964, -5.442482986164537, -6.151079378646925, -6.120416006196215, -5.065655600056955, -7.071974876907828, -5.957253719340739, -4.781773843113505, -5.354948164056644, -6.520450343119245, -6.293473674919533, -5.817016517849025, -6.85914069525248, -6.81356318675616, -6.777584585720929, -5.97764525003172, -6.226877237430227, -6.02961643394924, -5.9729353291005545, -6.418715298488868, -5.532354351604477, -6.803710890313149, -6.889653320113874, -7.354541848692839, -7.502757793000282, -6.938924369120657, -6.214291571987144, -6.749334119435077, -7.237514956739779, -7.394443065445024, -6.457482478746571, -7.947443614261728, -6.86121538479334, -5.698583920623846, -6.845759126556648, -7.683896617545187, -7.180188461548061, -6.757725777071325, -7.8704825731256, -7.881944016644606, -7.107203568791572], [-6.7847523397462, -4.956382101946025, -5.55168468117927, -6.54694976738503, -6.679027997805541, -6.920449307304025, -6.651631877885628, -7.028532297007316, -6.819873006155468, -6.9668156836069475, -5.07824502580267, -3.6978375281608122, -3.2158001218369128, -3.221520357616586, -3.5888259593254497, -4.18118917224718, -3.0226572253435795, -3.971027081545084, -3.562365839815367, -6.241860395850777, -3.738063429007306, -2.286143322088719, -2.8154088123469325, -1.9366972011829824, -6.402763696295053, -4.09673956284193, -6.7632686126933175, -2.217315348390325, -2.7898081670861736, -2.2970370063901697, -2.7943042308650328, -4.45525252224197, -5.6170558845712195, -5.634999368405547, -4.204524838877218, -5.247540598697068, -7.679731693977602, -7.496500850432476, -7.694782629326121, -7.660949127015419, -8.444625153562612, -8.02242837580043, -7.9107342568656245, -7.844229700045118, -8.496568431723452, -8.90528981102539, -7.744710798608082, -7.796294560812227, -7.4084137546993, -8.54315037261458, -8.96995880381818, -7.702981796781846, -9.818649422090688, -7.982756374523151, -7.087136791691802, -7.726484291615801, -9.302472289566692, -8.264363329731667, -8.520253749464962, -9.573314897467998, -10.041792973404897, -9.03352354731742], [-5.530908158078372, -5.12660572425173, -5.285205739999349, -5.724471900365845, -5.873312125055024, -6.16534879225732, -6.148934708170209, -6.3610443530793574, -6.311033932504697, -6.085846837289822, -1.9318371570117603, -3.9897678769234868, -4.264721024425275, -4.508665668126993, -1.397989588361542, -5.165043688633805, -5.1354703161064155, -4.710076673495516, -2.2812710196631696, -5.744808587095395, -6.153180999051661, -2.7741841902487896, -4.878049696777151, -5.0409257316634655, -2.3898944653854226, -5.13595610674021, -7.841822106027579, -2.8471437524600627, -3.4340095911141377, -4.619316513108799, -2.3549200090866647, -5.921518406898233, -5.302848234969303, -6.786138406296854, -4.207750888408638, -6.039012800612939, -7.841822106027579, -7.704962923310382, -7.065002449743519, -7.589296290560376, -8.260096172428325, -8.035112694192108, -7.871344545293901, -7.140827013169332, -8.545938317958099, -8.836893715754849, -7.993349965830133, -7.27788665694764, -7.741565502287929, -7.888977243944857, -8.111485672976682, -7.875096894912451, -10.091297373707675, -7.392485113590403, -6.863268166852988, -7.610229500226842, -8.901213681542407, -8.92241588919301, -8.313038591698524, -9.803615301255896, -9.310181420201774, -9.00812940746704], [-5.262771475279199, -4.784242541566078, -5.27970172852834, -5.684918512820975, -5.945292208575153, -6.218979090786592, -6.228233983716081, -6.354509212158639, -6.204315840281487, -6.442281485719593, -2.526983467749325, -5.114296740462473, -4.530006859098648, -5.422625873895182, -2.9651924820539826, -5.615416770210166, -5.759915004501759, -0.738654569892248, -3.9951800832331146, -7.496424744983864, -2.271649654828947, -3.6688863968618732, -4.479075949205008, -6.406971077861438, -2.7704548687771466, -5.064362048924221, -7.65209604855975, -4.10990241837356, -4.3379100438872245, -3.144791234860585, -4.257400003418622, -6.678114421469913, -6.866487433947222, -7.697728752690109, -5.8045538215356425, -6.443871311173693, -8.079096309219214, -8.153204281372934, -8.17767713789166, -8.353264662504271, -8.864090286270262, -8.820319623214933, -8.693771874337664, -8.686253041923635, -8.948055666387596, -9.842684901480572, -8.909864867655205, -8.569719225667685, -8.285794202093616, -9.08611589448313, -9.094531091408415, -7.571541334321345, -10.622843459030147, -8.818180584966184, -7.823031278179709, -8.265917771336019, -8.826764328657575, -9.481851947393176, -9.0917181500318, -8.558120089824332, -9.233307603986084, -10.138335143581529], [-6.352576341887475, -4.375482811098582, -5.097247890129581, -5.253867383491415, -5.300921501088017, -5.719261065235271, -5.695077377144448, -4.664604980788103, -6.0509261540753565, -6.1211148128546835, -2.6955840583648807, -4.0885439717448415, -4.601612684872268, -4.3272866151564005, -0.8335121453767717, -4.368698782518719, -4.841722524158204, -3.6648788033138118, -2.5172646408008483, -5.8838060715240985, -5.03345350892465, -4.275021730152804, -4.6405776530763765, -5.25643229403688, -3.133213396702524, -3.881602832644344, -7.333792367288475, -3.6375800962202542, -3.280343679384232, -4.168603006615407, -3.0158762344692915, -4.957870530657444, -4.673357005846336, -7.071279326505898, -4.732292586433726, -6.102987428262127, -6.308187629826426, -6.692855118141101, -6.912844895031934, -6.811275201992611, -7.387021770702892, -6.866694309094154, -6.971677700053924, -7.120054614261141, -7.672123196561181, -8.47105299909571, -7.06564216575394, -7.303313817631059, -6.877175818825198, -7.588372692026248, -7.710844848156796, -7.012073355807918, -9.487490679574803, -7.203069557208429, -6.086293297912648, -6.450936411500557, -8.098699438256325, -7.677018501414594, -7.313496820953744, -9.611543328244782, -8.931691690166081, -8.112931574673333], [-6.278777370845214, -4.701340011999448, -5.078865738235898, -5.8830885176004895, -6.165050673343658, -6.274964098411205, -6.212416394644692, -6.400778791567437, -6.741692863598321, -6.816576094912807, -3.3928904712107735, -3.566247086795751, -3.646180662937257, -3.523693462975528, -4.243767227003855, -4.080529251966207, -3.795135190780714, -3.596123418433819, -2.7581828008765474, -6.336206897605354, -4.412794119233608, -2.7790238541384125, -3.7937492847610685, -1.8714655708089012, -4.039189587014222, -3.917817104421266, -7.57147815542886, -1.7211826197805813, -2.454732555101985, -3.258178620019967, -3.831607640543702, -4.745787338078659, -3.8173867609921763, -3.6132042458306612, -5.788388393117924, -5.078865738235898, -6.509442541403006, -6.358094961721853, -6.982655840165303, -5.955633264954192, -7.203135532877834, -6.519814112808369, -6.508748303549079, -6.5805671825510945, -7.521390752829464, -8.307422019239775, -6.987204748691672, -6.90870144071007, -6.578332663638785, -7.263487211998134, -7.281252691733005, -6.635300404511988, -9.747550691415777, -6.939413018359865, -5.8716986926591, -6.717215468733563, -8.061948046761787, -7.4055504084105825, -7.052394044113555, -9.471951436870118, -9.440772718621666, -8.392393495069179], [-6.019277337678054, -4.809610930457335, -5.353723551448762, -5.676382755872694, -5.70371603264992, -5.986064759126338, -5.8139317591377235, -5.978144349530662, -6.042881895447475, -6.198360420377549, -2.2921047448703056, -4.34095023979577, -4.345648109454055, -4.367598309292761, -2.0155741702111323, -3.0132780221373907, -4.923111941566577, -4.563679111444075, -2.223531060167143, -6.691102686207805, -5.506010794027101, -3.0594865563826104, -4.849221407410736, -4.504665385487454, -1.9294270482862954, -4.87704758753489, -7.8125932274537675, -2.476262613634102, -3.9821539473427885, -2.8193399945915623, -2.274864811699418, -5.85738068573614, -5.424700477670406, -7.189965927648669, -6.389275800912233, -5.638934468614081, -7.03745392086323, -7.341255375194895, -6.260863632640313, -7.279063354938447, -7.679061834829245, -7.811259004440631, -7.236144890792278, -7.5275849533863886, -7.494018129747305, -9.1181262319292, -7.907769904821474, -7.576977708715964, -7.061731490444577, -8.083943001314976, -8.105182737815888, -7.709906510180343, -8.65367988774833, -7.560240916360441, -6.676421938949557, -6.335428678009885, -9.006382193489584, -8.143473650809202, -7.5376758563683515, -10.154666091954931, -9.349927845986523, -8.656780665426579], [-6.45948206141902, -4.541389017548509, -5.0469147172405115, -5.714893702071352, -5.93765911006474, -6.159588168280474, -6.484829040506417, -6.54643138634695, -6.777423978144398, -6.472536180151478, -2.0992585177991696, -4.351360197286945, -4.810779680772453, -4.478347221038041, -1.057979923268165, -4.503803429976553, -4.369600328148692, -3.1761274441594316, -2.5925706700973334, -6.132316774171815, -5.0527495258256305, -3.548319221739584, -4.665298532220545, -4.239092161682817, -2.8823289365699227, -3.9799558061803935, -7.613527691788449, -2.9149052754992715, -3.0856952412535055, -3.988705873974733, -3.519423658731669, -5.380012776918168, -5.236242140888087, -7.294418265937878, -5.378236234528395, -5.653900468202214, -6.843339306558724, -6.1506932535462235, -7.23734725322546, -6.366553451469326, -7.364460455464448, -6.868708500684183, -6.652923233094938, -6.285920796794185, -7.434940854111734, -8.332992180665768, -7.045904469629325, -7.3935637933916185, -6.8666551118723405, -7.771896007559911, -7.6868589648739984, -6.982133113853507, -9.79784886428876, -7.098382406877942, -6.05045863483477, -6.643853499354418, -7.8988076492249855, -7.62952803313489, -7.2191872449632415, -9.030593711575094, -9.78510983851133, -8.512650620040239], [-7.312010848930209, -5.9704021836204655, -6.3878250976208735, -6.964626238636961, -6.946983784483292, -7.4124339237241115, -7.3181741966378775, -7.680384414313297, -7.712878247789743, -7.554150900935073, -2.446039713635401, -5.2426041270797, -5.947299500896444, -4.663409565765878, -1.9484553212571183, -5.736061416021277, -5.712018325729332, -4.9933347157551395, -3.124667578606162, -6.881965531986077, -5.837272445819192, -3.4071965596735665, -4.466780007835062, -3.7439634287862087, -2.4245394005655605, -2.7481043832730636, -7.96925132102691, -3.001717011027925, -4.3613498567188325, -1.0557054893757776, -3.70597885137566, -6.306264213716016, -4.571775536818785, -8.174476930790583, -5.896948417633875, -6.225037976827956, -7.408704473732679, -7.482057817244962, -7.278478028822127, -7.6772808871048746, -8.27951403118039, -7.874318428531343, -7.723948471543991, -7.700568997316141, -8.91379761462879, -8.048158534515101, -7.944081716081054, -7.980577820654186, -7.290733450482923, -8.159308709317411, -8.547715834521, -7.821812931153412, -10.179602578494553, -7.600205085285631, -6.935111692528849, -7.541317747952087, -8.80008790436004, -8.364689804291782, -8.08874001915325, -10.681459532277783, -10.11675467483489, -9.167510387022356], [-7.888212115175222, -6.644858293408979, -6.899926832152373, -7.644887076927795, -7.6845832447435445, -7.532598742461448, -8.35541557609491, -8.047237610771814, -8.039272966898704, -8.151069111852731, -3.668932909455333, -4.782855975285661, -2.6659061839419613, -2.8967154778709228, -2.0223904901109755, -4.446771913881909, -3.000219123980515, -4.8870757508472185, -5.930891109758962, -6.823383785692898, -3.2455278628878323, -2.6715253337166462, -3.4540042231373063, -1.613293110190054, -3.32378892967727, -4.249589417392827, -7.22956773062339, -3.479217249500404, -2.6394006861426296, -2.505331420610824, -5.608431497999796, -3.9128781321838506, -6.817651617834854, -5.899129031817539, -6.838124773860243, -4.798082958969038, -6.707198867504101, -6.862144714309829, -6.946702102337892, -6.119321735858142, -7.3106242225785305, -7.047703884629593, -7.1735103563413185, -7.1142937780684905, -7.8727953781736435, -7.684274173500164, -7.105593531784784, -7.043298950514618, -6.705339482889372, -7.153500510194026, -7.545964351744817, -6.429130146514012, -9.208169648866278, -7.146978747947639, -6.381569697965211, -6.863775814304458, -8.274721978073412, -7.87653370028425, -7.678419897035876, -9.611509357662127, -9.195484489338961, -8.64028017837942], [-5.479179331884548, -5.058052917950845, -5.462604366790335, -6.042749073104725, -5.955329948912708, -5.958323963125313, -6.182592584875092, -6.134964535885837, -5.987223312688662, -6.092926822690444, -1.4103668710151773, -5.3350267357418115, -4.970584606980225, -5.289457186272422, -1.770010358993832, -4.901554513033236, -5.37688758694302, -5.089624713826659, -3.3520314691389803, -5.392942008652894, -4.734460344193294, -5.4364649785873, -5.373540303482963, -5.098468738623112, -1.787587681664556, -3.2734283276295595, -6.018573842572738, -5.287155689284143, -2.4508369623232906, -5.268931950327691, -2.1042922431924556, -5.627005270227098, -5.60465202444635, -5.974953220096848, -5.917202163476144, -5.89303609762896, -7.4048682036926285, -7.92851451588768, -7.027392005486696, -7.609083745121319, -7.38594019380711, -7.373517673808553, -7.797674914928869, -7.69894007424318, -6.9721762828842495, -7.92851451588768, -7.9072371174403955, -7.498269378781029, -7.24617825143195, -7.836141195756666, -7.972477639308797, -8.030297210197622, -7.424161406627308, -8.130380668754604, -5.985681292336846, -7.548459123304884, -7.876146530370365, -7.886403030537553, -8.383576565135217, -8.509870290459508, -8.104405182351345, -7.3612475812167375], [-4.615704248273826, -5.059874046144977, -5.605352624766998, -6.125932548297868, -6.262849675716521, -6.79239877505316, -6.990929985784472, -6.841047905444769, -7.1584533214794765, -6.9886390340379165, -2.1061188583709898, -4.694960766195293, -5.294767434713961, -4.877455498156362, -1.7372915500183557, -4.54913156517679, -5.204152324138941, -4.129384627657894, -2.037945671503165, -6.073264053143508, -4.589028985169175, -2.990753289694604, -4.778969963958759, -4.689721987339014, -2.425686266522293, -4.746481928875957, -7.836127606736178, -3.351158263461062, -3.2418172438356554, -2.1018059989954563, -2.7036646563447677, -4.616611132654885, -4.89196974360223, -7.672674534246606, -4.594182160042578, -5.702759391924034, -6.928687676907251, -6.888038111045066, -6.879281938695605, -7.0247524516915965, -7.464610089759517, -7.314413547152238, -7.29014621148154, -7.293244587314209, -7.623992355607218, -8.372647679876952, -7.108856380340105, -7.38925322665568, -6.931385277679899, -7.915280634635728, -8.074744053353632, -6.836124212582984, -10.164407149105006, -7.372318020898097, -6.283267109907934, -7.0071153102054895, -7.702596214111655, -7.848216404055182, -7.332806708624255, -9.549591811814969, -9.295811291038868, -8.128717117098297], [-6.86596902684244, -5.052082122851932, -5.150933488599681, -5.292208274141252, -6.214682697483703, -6.745331904339627, -6.68552490120206, -6.760045968476806, -7.227305715576431, -6.950863382929711, -2.1215717821722215, -3.9228106947364623, -4.840908762978201, -3.0664686008437925, -1.6983460154315366, -4.061987675375524, -4.329017422576037, -4.468146834761754, -2.0559567932823986, -6.284656471404593, -4.495653917304999, -2.239702601986903, -4.059167724800704, -4.675038779649125, -2.554078005507218, -4.208324039380938, -7.846798279854166, -4.952711862629422, -3.1510988852700317, -2.942373372199169, -3.3895078376634635, -4.604176621456193, -5.1138376420493366, -7.9144140567925305, -4.640693910453494, -5.102920313867999, -6.555881088992486, -6.826369644359554, -6.799686147757116, -6.863359893400418, -7.558312671802701, -7.067443904093005, -7.193279183729173, -7.1899393531824245, -7.705592764618944, -8.457679157012771, -7.256276285899237, -7.186610639983997, -7.0503828029559665, -7.591798854832744, -8.06246715675167, -7.178062400973902, -9.768878866076495, -6.917516203514602, -5.665418470446385, -7.260143611855673, -6.937390775844807, -7.687607497719584, -7.3485921408206325, -9.2384661090352, -9.464847655623185, -7.897922355187247], [-6.774920173861653, -5.204290861824316, -5.43566671911157, -6.296930641076284, -6.565626027570306, -6.7373590105822805, -6.991252066666452, -7.063233360250443, -7.2676834795551315, -7.1966044322333405, -2.083909994196951, -4.067585265323549, -5.182321460673428, -4.835732283228186, -1.980079058156674, -5.0283663440075825, -5.072641431371989, -4.6392056435133515, -2.7086094993416667, -6.770304135451181, -5.008181972697398, -1.1019554288598505, -3.2594369265598493, -5.6765883311043766, -2.736784393019736, -3.364824539297133, -7.918041582638827, -5.789527217909832, -3.4282422713486094, -4.498435097687583, -3.6322465613937016, -5.355734234640129, -5.0804532195051415, -7.17597860187687, -4.9759313787901425, -6.718299350460867, -6.452973839496266, -6.266241964550636, -6.756169624516277, -6.43275589071587, -7.149632742116933, -6.722481373881418, -6.632646871978412, -6.5830057991087605, -7.441299494170494, -7.5325638154552745, -7.295254585596671, -7.196283868037615, -6.683920964952739, -7.4835386813502325, -7.587428922371031, -6.992558402580507, -9.54477866233574, -7.0691430439756715, -6.0008086042221205, -6.0079129112663265, -8.273962947039259, -7.457398913104675, -7.183861348039058, -9.235518989239411, -9.247910721534573, -8.527701618931673], [-6.725963719695806, -4.710012269685353, -4.981543035572536, -5.7693914443296395, -5.741238652017211, -6.34104225410854, -6.461701921452123, -6.616580803658851, -7.050213688876461, -6.932988782385651, -2.7442254377569215, -3.902092293780571, -4.081087684032349, -1.8459531867558991, -2.260196124051401, -3.8113055093318327, -2.1904142607255017, -3.5077174805325915, -3.070625904070985, -5.688404814159279, -3.676818033328958, -3.705969932950152, -4.175966474127823, -3.555777846153588, -3.6599169276373167, -4.233380646142029, -7.565625193952616, -4.758247211588438, -2.668505149650637, -2.593317887541856, -3.982238613532973, -4.922572014698711, -4.457568202222798, -6.922768742308341, -4.874097132395777, -3.7366670217502587, -6.099051002533345, -5.950541812233132, -6.754321355464054, -6.000835251677606, -6.818602573551164, -6.538250446625281, -6.5136752899401404, -5.7389354920585625, -6.837502673710269, -7.922940958163197, -6.4879709082904045, -6.559235554477551, -6.415308634074, -6.963830229106114, -7.464928001069955, -6.466545899251641, -9.489635645899149, -6.3635319575989815, -5.527598474760337, -6.407003965795449, -7.463914829757348, -7.418626873140783, -6.4607730713017455, -8.850715648219035, -9.544876513609825, -7.984492491801492], [-7.251231594323855, -5.21374696908488, -5.698223064924641, -6.1375976604763816, -6.322511629217009, -6.768362468268195, -6.494106816635844, -6.457670861321346, -6.860741199932812, -6.755693520691695, -4.0580333694338515, -3.9411669781297105, -3.7467312772977017, -3.0227837077197126, -3.61529958808048, -3.574469853485688, -3.2007714947116837, -4.080705573827712, -4.670471138732819, -5.7966968651863855, -4.155602316322404, -2.9527040483599185, -2.862751521261682, -2.037725742388079, -3.7818488691194445, -3.113228390392548, -8.164264994327704, -1.8458475827404217, -2.5467378386179824, -2.7020967605017185, -3.188124830525815, -3.6799312814828857, -3.4909044267832696, -5.197365837878935, -5.202188998354364, -5.870321468395694, -7.4721345906728445, -7.508740887837122, -7.308294052687071, -7.524695844262695, -8.528908107915612, -7.92499206108361, -7.684820971302881, -8.246116020758024, -8.52404191826444, -9.16793672064164, -7.835273241415741, -7.178620119286367, -7.559608480967977, -8.499112535221915, -8.875184344633446, -7.775193695995215, -10.198665810583236, -8.01769231637253, -6.730988787795164, -7.673144441641045, -9.323628945401888, -8.330457169191774, -8.013022138590646, -9.77099654516406, -9.908396414566504, -9.416350685452109], [-6.383306695601549, -4.903894061372386, -5.294037540593016, -5.450500954330478, -5.333223053427145, -6.308171725769449, -6.710407117707228, -6.887542628987831, -6.847572675445971, -7.035457528925254, -2.2105034037003235, -5.0202198363584465, -4.228806005807516, -4.2610399361561155, -2.630714925229401, -3.899363165669206, -4.911168632565807, -1.9598915311908123, -2.357698156549484, -6.874278408705108, -5.4856719078268386, -2.9453898821076563, -4.76865138002776, -5.849682782165729, -2.1582691520417923, -3.13711767038794, -7.932068702852963, -2.1341546758789423, -3.3759594869296796, -3.525124340216131, -3.4812218611704324, -5.083766155674364, -5.7936328268294535, -4.353576622920111, -5.907706290260866, -6.135534326871947, -6.846532994187875, -4.609063889576182, -7.503287789431182, -7.483445868632177, -7.2287173521187755, -7.853210127940644, -7.155334806184752, -7.407188463381393, -8.090673733029602, -9.081164896953064, -7.857960730699241, -7.896800564015505, -7.262268886290009, -8.128645226782451, -8.177248142566354, -7.485412437604219, -9.720755973044048, -7.9739596445621235, -6.796539470357211, -6.907958941482774, -8.646989682962468, -8.283628546124925, -7.797896489956591, -6.6686665609139695, -9.771081056931564, -8.750720965163202], [-4.685181991517679, -3.1394221383869034, -4.505733999919456, -4.7128201143378075, -4.721709061755053, -4.800636320344724, -4.867216645426291, -4.85864761270119, -4.820149134568306, -4.881081685563463, -3.6610088191091923, -4.523883318425133, -4.405422178721609, -4.511747247142908, -4.4973757423052545, -4.410859930021738, -4.692381446660533, -3.970040309575452, -4.061847858828575, -4.724689689893191, -4.678033998252392, -4.350556098635668, -4.167208374486401, -4.450909776342023, -4.644417387453407, -3.724277324458299, -4.630737283549326, -4.509337607422754, -3.787718752781497, -4.309323510802315, -0.6823718671879156, -4.449775346271411, -4.306372205167735, -4.410859930021738, -4.920232593125288, -4.3914208729895154, -6.478377211171838, -6.487035273914953, -6.801150603434889, -6.531487036485786, -6.875258575588611, -6.039010551387992, -6.9553012832621475, -5.362670489144429, -7.042312660251777, -7.027274782887236, -6.983472160228843, -6.58757650313683, -6.732157731947938, -5.820321350423163, -6.504579583565862, -6.710178825229162, -6.395685495326725, -6.710178825229162, -6.559138567816296, -5.802621773323762, -6.789316145787886, -6.8131267944816045, -6.29749346914751, -7.1889161344436525, -7.012459697102096, -6.888161980424519], [-6.973841065843466, -5.090695336189662, -5.341561221116127, -6.0115634498929555, -6.202945132409144, -6.628849553394376, -6.911669409716161, -7.0009992844957765, -6.886081347969349, -6.711294966663227, -2.260331825727248, -3.839334077735597, -3.9667628422059718, -3.420241689905642, -1.8735787833427253, -4.188499103605226, -3.691171678101274, -3.8593630820739957, -2.3524981891706576, -6.231341006564324, -3.7662373591100775, -3.6465568924129386, -3.4963200738799767, -3.4321214183238204, -2.593050419274572, -4.346868167488547, -7.8364379197408365, -3.990422275679548, -2.904818352752614, -2.3714612152432646, -3.1378637759089556, -4.357037863124861, -4.651314292504279, -6.760867254793699, -4.107313187039242, -4.3976920060255535, -6.440759053046417, -6.465477098310146, -6.582182413654962, -6.610599862587676, -6.978263755093254, -6.719449335464573, -6.730879435939417, -6.514035039942995, -7.843934206718764, -7.66305587798569, -6.780807453646412, -6.810345466083276, -6.347157031161333, -7.321885120582923, -7.779113558339937, -6.602957069625781, -9.658525717989464, -6.893034874465941, -5.640541915214837, -6.61808064554899, -7.825297811959789, -7.623352248005446, -6.729273803531229, -8.625119353004427, -9.394209194493895, -8.033505455437194], [-5.604855175474509, -4.462285490693087, -4.571350651692403, -5.056493889833258, -5.072440143885144, -5.681064638387167, -6.280536665394942, -5.74786868753166, -6.300402104581103, -6.443541857970619, -3.08781816164275, -3.6971443171127936, -2.396573090959646, -4.216785762291264, -2.055069601332964, -4.2400357108180975, -4.510301966657801, -2.8725223515174108, -2.985980079879496, -6.151031964062443, -4.17853136290412, -3.739735408911567, -4.177743865892257, -4.758224336321508, -3.406169247786832, -2.7407038589797272, -6.9336687884910315, -4.884332887441078, -2.4403221799860293, -1.8263508274951405, -3.4054696763623764, -4.562592776233452, -4.420217843796468, -6.782722037918705, -4.9372619598181355, -5.457485531187882, -6.256287610141627, -6.611108985431037, -6.565907361549403, -6.49534726380481, -7.061567128112425, -6.599672447239019, -6.7013251912547664, -6.80746927442344, -7.516987128232732, -8.06324629910308, -6.809992050813993, -6.860502751231873, -6.646463246903641, -7.480934599971211, -7.54322475844959, -6.575185095427639, -8.985698479921282, -6.994899040702809, -5.767168821265772, -6.530694737719788, -7.839611467995152, -7.435063610819411, -7.091053743823944, -8.707954377459634, -9.10781723001913, -8.370947238445352], [-6.890344120648169, -5.02940421086846, -5.408867487897182, -5.967857793669728, -6.047653312106489, -6.46237897058548, -6.749954722267399, -6.888388607925276, -6.98955227182629, -7.21719797180092, -2.4868466816371, -4.771074471877903, -3.6481121610473157, -4.664656454469179, -1.6817234068168874, -4.586866350603287, -4.845552155508254, -3.154508356873059, -2.57905575846229, -6.254276196451527, -4.921506816489567, -4.4705470709445265, -1.6402347840968394, -5.1280286653720175, -2.882844123251368, -4.595878517780293, -8.231899529453244, -3.131328577959143, -2.841674626039629, -3.3059284308174086, -3.1776616460738145, -4.478455963747706, -4.881954395151054, -7.651052083171771, -4.569886902888001, -4.27044926534142, -6.859624364774909, -6.620591583748609, -7.035724951332805, -7.0226528697654516, -7.663432064808081, -6.880725735179707, -7.096836038369936, -7.001238775261635, -7.94609099384926, -8.742881147291776, -7.2506609077408095, -7.3153280695559095, -7.053568548019118, -7.728589206441718, -8.033869830584925, -6.95515998225557, -10.250083546611185, -7.317576103473792, -6.34314386192865, -6.83930777142871, -8.443181097280567, -7.8493114938202, -7.476614929901965, -9.60010853791645, -8.54213954241637, -8.677952686589895], [-7.97530600380511, -6.415691397743754, -6.861539964259856, -7.354178676035024, -7.5544322703441, -7.956843940965374, -8.00285595557334, -7.941715059369074, -7.997284910523884, -7.042078762400056, -4.593656623473984, -3.4358427231129607, -2.813804032113097, -3.8443096208464707, -2.253236786554918, -3.523372060796657, -3.771274119941123, -4.213005093082092, -4.26676474950711, -6.604661414352346, -4.071781743539046, -3.0636392294004997, -2.748766550188664, -1.5979085155684218, -6.096125476162904, -3.8319741165296572, -8.437883856353995, -2.362166563210972, -2.079080404566457, -2.423752746988421, -6.1373971409737065, -6.112261605870961, -6.033619491127531, -6.187046440930159, -5.880551407088361, -5.508879098944167, -8.771401153617497, -8.582218506443597, -8.081702252336468, -7.820268405959624, -9.01805471242806, -8.991966276343762, -8.037776271878622, -8.339328192194554, -9.20125771484982, -9.932145223392613, -8.711282886564021, -8.633361864553784, -8.75433589306331, -8.724333642759511, -9.49070501282617, -8.37573721938598, -10.194509487860104, -8.552742688310644, -7.968342726152964, -7.956843940965374, -9.863152351905661, -9.598817643450872, -9.08877973142313, -9.278218755985948, -10.729432663205156, -9.20125771484982], [-5.1527222081970026, -5.012025127950751, -5.39388426501389, -6.217687012129963, -6.355002880531065, -5.6351154829069525, -6.363993950090922, -6.903492332891861, -6.853964796193012, -7.129436704737862, -2.71361594954537, -4.917813116205636, -4.909342477322127, -4.834757647401019, -1.3606202815267094, -5.049186428683174, -4.831934627067998, -4.02878090419557, -0.9857025802248848, -6.9583248115172545, -5.928056254423655, -5.1548164498001166, -5.532591229650075, -5.575217341325883, -2.1159432194090155, -4.2897086796604516, -7.362881241689201, -5.200780422733714, -4.007732553855012, -4.899317914996637, -5.732412626945404, -5.409409253401815, -4.570479874572386, -6.004563148213606, -4.806034206660294, -6.602559371961363, -8.008146936015933, -8.264296783798311, -8.114951495245993, -7.067733915701082, -8.653122572902513, -8.40456220860418, -8.35558820400772, -8.362968311305343, -9.101577865942044, -9.242891399008622, -8.693532111240389, -8.468328826963168, -8.348262163915647, -8.71436619814323, -8.123659823137777, -7.872345394856871, -9.1093600063841, -8.693532111240389, -7.279281672853908, -7.536521246398329, -8.924437667890087, -8.99854564004381, -8.061492916721225, -8.91796515338447, -7.579574252897618, -8.90514446495541], [-6.625065979493934, -4.788580474517243, -5.256407824340383, -5.37832984858721, -5.2038978790684185, -6.079823689638168, -6.317086566978479, -6.646320764762257, -6.72855886299923, -6.886116701148103, -1.505097000684665, -4.82588581184553, -5.253602398681012, -4.989577089424305, -1.5758741362397704, -5.185784176269271, -4.916501452893276, -3.8159863951228723, -1.6041923545980379, -5.633841418592661, -5.7199839934992545, -5.2161585690547705, -5.369003667873634, -3.3721189713516244, -2.661522576130661, -4.670108701549678, -7.227790153984301, -5.183916064386551, -2.494756625753895, -3.869077211017653, -4.27104038948766, -6.0954898063825675, -4.71167529774246, -7.136943681210728, -5.987593808088792, -6.590446143960144, -7.403791666759668, -6.814987319540992, -7.030531087602099, -7.451894781778061, -8.262224216961, -7.8389014914528286, -7.199379152151521, -7.871278420177289, -7.002535480112671, -8.630549778119708, -8.06204504276704, -7.169938203345767, -7.199379152151521, -8.169374062997537, -8.264930578558742, -7.090662928646722, -9.550754409315, -8.033689817011913, -7.078178371984477, -7.674437552058881, -7.921898411023797, -8.116604027017473, -8.273093889197904, -9.39660372948774, -7.831846788472939, -9.063739434242727], [-5.33959692367457, -3.901875433911095, -3.3263523840890916, -4.682859878096868, -5.0569946532038434, -4.833678156338227, -5.439237690659609, -5.4278954140556746, -5.662170026427569, -5.462315637942154, -3.751806551579704, -4.660118258928943, -3.8333548860836233, -3.8811153084238335, -3.4958051088141735, -4.553750303632283, -4.534932311997922, -1.8458046740483725, -3.0281790617647277, -4.436160927561686, -4.943995470762378, -4.549402848736927, -3.9218705969950047, -5.328568099202016, -4.452091297246621, -1.4302390343932077, -6.080922600826194, -5.1148485422425125, -3.3219189169449392, -2.621905648275213, -4.3789508674983555, -4.262632175345694, -5.088920047216344, -3.3849839728869298, -3.307281062205608, -5.974439120423745, -4.379829216259262, -6.791884017661267, -6.8166991867809905, -6.068955964208674, -7.1565271312491765, -6.683586642330131, -6.801736314104279, -6.532793078538745, -7.518256845849533, -8.152370494825284, -7.391505140210389, -6.7194113688482755, -6.416271872702784, -7.279027156783699, -6.4871905993829495, -6.66039719741122, -8.204669994228134, -6.878895394650897, -6.094660190607558, -6.427558674237414, -8.084652320770335, -7.339319387039819, -7.347830076707727, -6.950948712290955, -8.303341521735163, -7.468823387994359], [-5.431835629645527, -3.900968951139421, -4.151004765492447, -4.646528675532386, -4.521804796114552, -5.283128043243618, -5.29007437093391, -5.66335521876192, -5.740643416211578, -5.366660147370001, -2.670098748915231, -3.286242237340954, -3.3585141055181613, -3.755602707715123, -2.5586532961090027, -3.6926656242369105, -3.8330192649391925, -3.254475467118251, -3.8290307266838655, -5.019290301102854, -4.363753678748955, -2.9684754808494547, -3.151618081678543, -3.50657051212598, -2.895083629045828, -2.91665360144011, -6.285849431998168, -3.6228229122699127, -2.152751777383897, -3.3162167836347605, -4.2488413058475105, -4.652746019284857, -3.9288228848114928, -5.349158624766704, -5.572231075081914, -5.261791793324819, -5.624778734167247, -5.278347157643276, -5.3043854022704995, -5.210237912616575, -6.346428699255328, -5.93048158286466, -5.615084400228674, -5.89255288484716, -5.916841563358977, -6.777270925569916, -6.237681480853062, -5.483828321441287, -5.599254877723378, -5.735607736245962, -6.332645938959907, -5.443956990177872, -7.787390135984574, -5.974679054270741, -4.487700164671342, -5.484479363130949, -7.787390135984574, -6.624646575217306, -5.915838554247808, -7.256570295689133, -7.872330812633658, -7.3300889926342885], [-5.8962959205599565, -5.022482812723318, -5.262967235210922, -5.638331471894197, -5.778457744433211, -6.3109845765456285, -6.29163873510587, -6.56832765910669, -6.49255510063436, -6.3650100589758205, -2.863492599093995, -4.089024629780227, -5.154949557468251, -4.484159695248834, -0.9343644420039627, -4.498161263246394, -4.6279862283262885, -3.982370058053253, -2.2035282537140866, -6.199482179547703, -4.571665803362194, -4.084960905072187, -4.755413554835734, -4.800997636581884, -3.6971982708382995, -4.566795129611478, -6.871351961660363, -5.099526707333125, -4.135788994836005, -3.1706024468180507, -2.212641008744242, -5.078715683958774, -3.5811841558979225, -6.741940888008861, -4.856098125468122, -3.980907107020626, -6.712325967469931, -6.644006723492454, -7.153784678226001, -6.945055157447498, -6.898020208742524, -7.021563043483541, -7.173168545047049, -6.854391346353318, -7.669859657878135, -8.284314569862415, -6.895321151773359, -7.513205847832758, -6.795366054682441, -7.556635405760094, -7.827916592672458, -7.241272132349116, -8.35137880044296, -7.187505708193456, -6.1188193168155305, -7.139919638088829, -8.075324765986299, -7.379987004046535, -7.364785842714484, -8.480789874094464, -8.527936652520165, -7.717773013574032], [-5.1596391409467905, -4.446625879300866, -4.792661465824471, -5.092676376197713, -3.486026851337387, -5.293817992318437, -5.4207097441730605, -5.031624556083574, -5.433394903700377, -5.123410202650332, -4.715036303793935, -3.7021536789683007, -3.7870302329121537, -4.088809455118969, -4.812132309601868, -4.898021981482298, -4.704305701448848, -5.045386241156256, -4.694501701352228, -7.439823297251669, -3.3979941838940024, -2.7387677229303073, -3.4751598040428164, -2.0375451283648167, -7.179408351140228, -3.811103778633784, -5.971540702552751, -2.9729698958508197, -3.825149191015764, -4.478865937874288, -2.6641628726801234, -5.3193066285353545, -5.996634270150407, -6.375549146164451, -6.785390628872414, -6.572829186888741, -4.124487206195906, -4.535138151336436, -3.7135200209337587, -3.96463850525401, -4.554386339641352, -4.765674647825141, -4.429638997109137, -5.277664924510665, -5.02086262836912, -5.937153360243275, -4.7565501004863675, -3.693750268171921, -3.749678820831146, -3.176252392796863, -5.722496422806384, -4.546642548744449, -5.417354036326088, -3.1803577086920454, -3.749362815140414, -4.066652137558128, -4.660532401294013, -5.1570534898617675, -5.430844966067104, -5.284241491875228, -5.5748604240003194, -5.63236491848051], [-2.1543734650260515, -4.349659150265929, -4.518901599180162, -4.334150339570116, -5.146931928181808, -4.726677895862385, -3.8738862022041083, -5.547738126032732, -4.965611539500847, -5.329386916158828, -2.0510193107742145, -7.017067715762613, -6.5514024881154755, -6.782731624016124, -2.1387030138865364, -6.887331394106641, -7.26098839501858, -5.915573580719614, -2.792353319034718, -6.475549145597215, -8.196805549243091, -2.7290425937620233, -6.57338139483425, -7.482751683863832, -2.7069370493135643, -6.6217549791184664, -7.959675755954141, -2.6929063910157374, -6.402701413055781, -7.378081061299943, -3.038722067403394, -7.146279447242619, -7.442205589469482, -7.777354199160186, -5.436617340201765, -7.9268859331311505, -4.21410095816366, -3.7159537926574395, -3.274052690014408, -3.8709022387814955, -3.903841048493916, -4.907248138723605, -5.564815386850924, -5.634025390029099, -4.794669640998671, -6.37044055083756, -5.773624479216047, -4.984713243886536, -4.705003878814023, -5.884409585684786, -4.869643914101749, -5.8105008762596295, -6.426399204485604, -4.552569937605819, -4.688840192155229, -5.1496039404596194, -5.387063525747035, -5.940338138344011, -5.40158748887255, -6.8282736444630405, -6.302506440698851, -6.49077786629904], [-5.042027972011844, -4.299718672656642, -4.243324982365076, -1.9825142998026875, -4.725280240738409, -4.751810055033314, -5.528415080508104, -5.372269658882421, -5.58057814379269, -5.634199235231788, -2.092585085927561, -5.359310514239916, -4.924244936355461, -6.182928172882705, -4.358300013368391, -5.644135441890917, -5.3193472574280785, -2.4216711986248063, -3.5454438576615357, -6.6553797837670805, -6.406683158028254, -3.42063060974259, -6.230496589801815, -5.313180742512414, -2.1141313157147192, -6.38251279710044, -7.199431055161392, -3.210947634389801, -4.823896962521179, -5.599497627038855, -3.7500872171087103, -6.903338504201014, -6.960201366095558, -7.542682978767983, -5.613234106766742, -6.36476085164199, -3.6714819678600925, -4.875454772186028, -4.20471280907303, -3.884017303250544, -3.4828969984685907, -4.20471280907303, -5.449056802096191, -3.411103801364231, -4.476181634325785, -6.299489461288767, -4.386290645201218, -5.042027972011844, -4.789932598747867, -5.333885415874105, -4.1803254304220925, -4.950988261330972, -6.251222720318932, -4.73156059252596, -4.355150404465494, -4.750641830601388, -5.174666905853347, -5.78646844695934, -5.852762894799176, -6.180486169227153, -6.353098911894147, -6.096324376905443], [-3.621153540136533, -3.927545190670303, -4.761298021301781, -5.2327070159671, -5.390836480884121, -5.489330016767771, -5.419938023343771, -5.638503085521277, -4.333907884333748, -4.5925613698517225, -2.3774699118392917, -7.240027999198052, -5.856199730573355, -5.309006462636489, -2.1188535037876086, -6.988713570917146, -7.259929153515347, -5.733217613565709, -2.1988937611323722, -6.914879308906094, -7.285375819176511, -7.471829613255376, -6.297483936486472, -6.369085087302357, -3.0144535413397078, -6.131611710433321, -8.510182710405289, -3.290870578196505, -5.79050447130796, -7.191941812530414, -3.661034886200146, -5.933160771709483, -6.992552347224311, -6.430741168725453, -6.006448567479316, -7.6405790925037875, -3.820123280601132, -4.60874181430768, -4.552214016916188, -4.152125265844404, -1.8440074384079603, -4.33229280995845, -4.748982594711727, -5.590043992369601, -4.083551769494654, -5.885005729822436, -5.570371226770897, -4.35431953325285, -5.037889407059404, -5.600505333614971, -5.2234842891983275, -5.239347146606377, -6.012203979049936, -3.2506791222758458, -3.493367719618491, -4.386449689183688, -4.5929103490909995, -3.6635121789617022, -5.259536257638402, -6.071656848963408, -5.913358144413303, -6.637031915632404], [-2.697794466436189, -3.604662393389068, -4.011263957500705, -4.728080882146555, -4.781372179196779, -5.33155887684335, -5.439355447299057, -5.586922158039964, -5.370633615250003, -5.513150772897161, -4.398260316869362, -5.11207163673225, -4.190082883743458, -3.4501177344839546, -6.597640067453566, -5.490434815062624, -5.150911470048515, -4.837107457567751, -2.85030853825846, -7.320346050255055, -5.997701716211621, -3.4753179136511876, -4.2866759373606715, -3.397053452568678, -6.703360230660674, -4.113003141200578, -6.444877312901155, -3.074043686998346, -3.452623303723489, -5.193702907090925, -3.9327969395172757, -4.131242383720524, -5.418238523858134, -3.7478131640115406, -6.184652086682414, -7.063123185287982, -3.7394230709797665, -3.4179694218787144, -4.267288710081795, -3.0709940324857143, -4.263518677341253, -4.701005637323521, -4.417094629495229, -4.569236359692398, -4.473887479448818, -5.8432973258667005, -4.728080882146555, -3.754953367214181, -4.1263095154005, -3.415012032977706, -4.81618158386264, -4.691820172692138, -5.666572324000903, -2.795735372125381, -3.2437129699651224, -3.9019638438387987, -3.582993942690341, -5.112804505947904, -4.894364079117085, -4.722110715160052, -6.056219323109372, -5.5022692727096265], [-4.619141531251806, -4.242478414047348, -4.655112011634125, -5.260049492712331, -5.018630839221239, -5.434973330528597, -5.291682300504695, -5.652426966065128, -4.133100006910822, -4.834429582625707, -1.998550183209591, -5.7433143168994505, -6.845817661060527, -6.562531200081784, -2.4549848852751466, -6.626189051853761, -6.290387731057782, -5.567486289416045, -2.141146196531367, -7.242549089199937, -7.104679294976816, -2.8517566389677937, -5.192894636686687, -7.082206439124757, -2.3092018462234853, -6.71448165899944, -8.017189304011065, -2.1705324264442973, -5.663122255181876, -6.392769837961348, -2.584044215625091, -7.28700085177077, -6.816997222525035, -7.454881724409931, -7.498844847831047, -6.3210545294507545, -3.9234738704665255, -5.210974225191004, -4.156261002958894, -4.841496749848799, -4.597299789336757, -4.421170202790724, -4.975365923256807, -5.672123216040852, -4.474317672329112, -6.090327349926446, -5.367408011032831, -4.491383872387231, -5.280618880960439, -5.815780620152271, -4.640826054386648, -5.541761398177608, -6.307308608546119, -4.360911011272527, -3.968855752517438, -5.060904184340462, -5.092811178129705, -5.9935197902566175, -5.119506808592894, -5.086750553518014, -6.052587021943599, -5.38489332537385], [-5.261046281621696, -4.9148297535258045, -5.093521542269181, -5.160962823064713, -5.492794680129424, -5.583178741597693, -5.608843109973599, -5.828958322395465, -5.818217080564052, -5.6351835265880075, -1.9431063436877503, -5.762127613913009, -6.364566555601998, -6.310693565661846, -1.465488331318766, -6.653479397439911, -6.983078754773362, -4.701955198551832, -2.920630198813372, -7.381717897811127, -7.114655112562081, -3.628618850962897, -4.741931970713727, -6.050483313874263, -2.961525855445553, -6.683481647743711, -7.823550650090166, -2.1208799042866553, -6.236585593508124, -6.735576759627112, -3.3232120191551315, -6.891511561247872, -6.08336298799342, -7.9413336857465495, -5.554867108771802, -7.122498290023107, -4.193090909121505, -3.901105949199606, -4.152689701478908, -4.935827900365578, -3.224590180736388, -5.347946392964479, -5.205112607677643, -4.550306897288771, -4.485129674572183, -6.303724896345753, -5.654950567328784, -4.928779413034516, -5.0770940681272325, -5.30867433061095, -4.570963767879653, -4.7737511552658995, -6.146602446129337, -3.6472116840395126, -4.583317229489316, -4.247999881283233, -5.050961927850385, -5.554867108771802, -5.239253651630843, -5.752077278059507, -6.0889495947020595, -6.114482896707225], [-4.8357984388643835, -4.657872493543467, -5.438431611883497, -5.481947249319659, -5.480513557317811, -5.739017089171186, -5.670890393572083, -5.859121927588727, -6.047318448825703, -5.930658377913943, -1.7234534048021994, -6.808376835001858, -7.018097365983928, -6.515303913915201, -2.0800327647225068, -6.985307543160936, -6.434021280478344, -5.690138581877, -3.0546210789668655, -7.433612809945593, -7.609892052283585, -6.846949109788098, -7.145930737493813, -6.771237288052402, -1.3242305561151027, -6.88123818326673, -7.934388097858083, -6.599387031125742, -6.8029859863669815, -6.569147145936024, -2.3927324727103167, -7.200418922777882, -7.33738477785104, -7.62201341281593, -4.893045313052039, -5.366877919534872, -4.1899951004809015, -5.453656819480563, -4.694403309779647, -3.431804500645092, -4.0124147615767685, -5.525942614164559, -5.309719505694924, -5.568828205702649, -4.124028746206436, -6.415604553692113, -5.4275025413513065, -4.984699762805498, -5.237511197353998, -5.157641365469638, -4.101047614464405, -5.085610237260755, -5.550223017871613, -4.869440755282619, -4.489173830779152, -4.234321454353582, -5.041242413079193, -5.780689785571754, -5.231908941805328, -5.964947451392574, -5.752089170738539, -6.139854701747302], [-5.508465007700513, -4.839258034686576, -5.109472414097966, -5.519275923804729, -5.707703038161169, -5.439902336263216, -5.7235763873174585, -5.821556795677663, -5.734300350680434, -5.610247702010455, -5.910709501108635, -5.7235763873174585, -4.435262434557772, -3.8610478472011964, -5.758858201462099, -6.0632537548876195, -6.044700346991872, -4.117878794499082, -6.575328598054043, -7.243783166023616, -6.403478341127383, -5.083829983484629, -3.317712944869911, -1.7163886672099804, -5.622223893057171, -5.543479525545615, -7.373836294271814, -4.235327303674574, -3.4757995308184078, -3.8216678856997803, -6.863010670505823, -5.619817153026606, -5.966922645949188, -7.096625521687328, -7.1845942946332855, -6.5629060780554855, -3.9611313057581787, -4.164449795424729, -3.6745940531223313, -2.809054169189011, -3.303860323066671, -4.356804692686432, -4.075943929085389, -4.993775889109478, -3.5055329961999946, -5.4956443192714515, -3.896020865817486, -3.604273312212492, -3.5622476861654384, -2.789152302491872, -3.9102728885246876, -3.0660244750660355, -5.631909198791635, -4.404134333185408, -2.9033092297609358, -3.155554830818952, -5.387104150696246, -4.341290047595106, -5.258585299895267, -5.109472414097966, -5.821556795677663, -5.14024407276472], [-4.364789554126129, -4.918384854279969, -4.918384854279969, -5.1613310328903585, -4.587530609962979, -4.784853461655446, -5.006160465162354, -5.0403784224726955, -4.994002260682545, -5.402493089707247, -1.4796200682550344, -6.181000119218348, -6.701776073837507, -6.252825853789604, -2.1508860947624866, -6.086590434747274, -5.772240115213331, -5.482914657017821, -3.9652464014134288, -6.426672783592586, -6.401671481387169, -6.285261129542758, -5.890845857621178, -6.3772800282630095, -1.9660163181458141, -6.770768945324459, -7.107241181945672, -5.362398632505369, -5.920923312858457, -6.7530693682250575, -2.0597919147266994, -6.701776073837507, -6.505661194911217, -6.5476253940102485, -6.637237552699936, -6.7530693682250575, -3.9354569646113213, -4.092932522818745, -4.814706424805127, -4.961309898997003, -4.355174095426687, -4.949681861001884, -4.869194610089197, -5.046727650151355, -4.8507000274530325, -5.115948027042541, -4.814706424805127, -4.689097748317353, -4.863875448611597, -5.043547997233975, -3.6732539774605253, -3.9481153614832447, -5.340799520701906, -4.835115296436334, -4.068688911208753, -5.024679512929592, -4.753487802377227, -4.994002260682545, -5.247044551164388, -4.698046353893368, -5.307182909902921, -5.227776132298511], [-5.115394338583977, -4.7561420736309445, -5.007842676853897, -5.66123448019507, -5.033665707964376, -5.645764558422938, -5.535809351386801, -5.907471144471458, -5.828086115216893, -6.105296887801378, -1.6832402388074508, -7.437524027650993, -5.590313253886724, -6.862982589498895, -3.0491034044747836, -5.586172461220692, -6.632458930887062, -5.218606625703514, -2.4710973040085813, -7.398809515470303, -7.268447697607059, -2.7116510959031834, -6.686853002952861, -3.7188303108266303, -1.9217106058640063, -6.098376444956805, -7.548749662761217, -2.711068175455316, -6.088084758920257, -7.1630871819492326, -2.4953178542046213, -6.5371487510827375, -6.531815405107375, -6.592107635363495, -5.218606625703514, -7.464192274733154, -4.025855346121542, -5.098759278079445, -4.812664759541027, -5.369662433402117, -3.845996309584077, -5.031290409935469, -4.627804324836165, -5.549657248245595, -3.554062953084761, -6.151486270270753, -4.8426621708268565, -4.640563668589926, -5.069989313821911, -5.128381534110789, -4.6191257693799175, -5.164313543336852, -5.9721996171719525, -5.146851716173189, -4.482065653234942, -4.222339216728002, -5.190396010216277, -5.978297197040071, -4.681519433426748, -6.057830350562455, -5.619789072019677, -5.749664153441089], [-4.867406343870729, -4.4533740975545415, -4.953434176237852, -5.384635998990067, -5.328952912513263, -5.6593669190947695, -5.597013688377717, -5.757806991908022, -5.710273291442284, -6.117674508577314, -2.0752354231922467, -5.330274789771179, -7.239817294655618, -4.653127950557675, -1.9861891376978962, -6.498730651806554, -6.748830013109291, -5.799220777458779, -1.8880861157511444, -7.060476365999801, -6.592340150928861, -6.615981913985901, -5.98705432616025, -6.055682832549346, -2.2283490142554703, -6.244583360441343, -7.060476365999801, -6.9543698600052535, -6.005072831662928, -6.675112437212724, -3.324941220245065, -6.737960340872387, -6.846328377594169, -7.276184938826493, -5.466076330930241, -7.601607339261121, -3.2284338811241238, -4.7571452826690335, -4.2772171644143535, -3.794375211195705, -2.9321390456478555, -4.655146114713912, -4.556474587206883, -4.658518799192551, -3.9133691163329902, -6.159223511490186, -4.874928318325417, -3.9851607325065794, -4.593769151695071, -4.865742449976033, -4.192747084853396, -4.158562847663465, -5.583291346122616, -4.6687056444995445, -4.403457644910037, -4.135470875670939, -4.338591952168042, -5.484425469598437, -5.10713123845697, -4.666659956776251, -5.507845743806536, -5.56639905255811], [-5.367738120634485, -4.778432275797196, -5.153988612512787, -4.9880684755260525, -5.022992659762126, -5.315533041364984, -5.937669186281741, -6.10637419308453, -5.985149724514735, -6.0666028696576335, -1.4917500304139726, -5.449683054485573, -5.538947192058466, -5.596026010244295, -2.1356770840200325, -7.153812526227932, -7.094389105757131, -6.013018623523528, -2.2775252846627545, -6.010847070010019, -7.246405313055757, -6.755173383190167, -6.697507741340358, -5.530860894627108, -1.9981251565724831, -5.698525293621089, -8.083802102460249, -4.860110306811463, -5.882753428685626, -6.945748081740843, -2.8863534391722627, -7.100819996087421, -6.962461562714583, -7.231590227270615, -4.4224533361891325, -6.0688990819179836, -3.292438554454217, -4.782234561746934, -4.459461169483883, -4.359771877270199, -3.9163352754091854, -5.15214868559078, -5.0863471755948115, -5.622152314836516, -4.041658687615878, -6.321199217523649, -5.22160122153078, -5.082053480720112, -4.742403534262838, -4.896452531238822, -4.577416633798337, -4.325814840936012, -5.22258692885554, -5.570564946046022, -3.7753199382595333, -4.751597592285044, -5.351900685535859, -5.538947192058466, -3.6838339356894148, -5.717756655548977, -5.9396873504379775, -6.193602560418941], [-4.999514188504179, -4.700587505853424, -4.67022803135639, -4.81576740495976, -4.92872993147181, -5.418517964945142, -5.4525477135314535, -5.471965799388554, -5.601583292691941, -5.294558257397029, -2.0675057720915833, -6.606510097282728, -6.66295140818768, -6.268297216183731, -1.8472066532219233, -6.801101746668497, -6.464629510047284, -5.518112402024337, -2.6153829107633095, -5.40926720517299, -7.042937430994859, -6.122880216325227, -4.984950824316282, -6.978988706394586, -2.5341534752438712, -6.335738496979263, -7.22903971062872, -5.047082605423289, -6.606510097282728, -7.195517018590076, -3.3881221963080814, -6.764734102497622, -6.935691900641261, -6.06802185577318, -5.518112402024337, -6.21743879895024, -3.306166689176508, -4.5835098665078435, -4.096018906794089, -2.7778687007936327, -3.149770331333854, -4.522505810044474, -3.6065186143693406, -4.579485716208118, -3.9009018998360694, -5.695109350702764, -4.592420415540891, -4.39850374434322, -4.858371250530563, -4.687974726037726, -4.284600731462279, -4.828050056815601, -5.7714823294873385, -4.760362534007699, -3.6910492160852075, -3.1337486268025883, -5.114702793098268, -5.044521784561615, -4.990993138772245, -5.21262268525524, -5.1495981689488834, -4.939033399841534], [-5.573013579156251, -4.7557456323553735, -4.835888625843566, -5.4310032481645445, -5.375816832597254, -5.748275644237248, -5.617589203744957, -5.426286258286405, -5.527732874623095, -6.027336973645122, -5.771265162461947, -3.4363190171520683, -4.863649827007062, -5.342810536129083, -3.9603112459777443, -3.1741279621323484, -6.522548369609561, -4.089429329592385, -5.667234434234122, -6.573100648772392, -5.74180312973163, -3.6814950844272993, -4.555731535734934, -2.60141208694855, -6.057840427938536, -2.6538446056843625, -7.3352407008192895, -2.4633202784204524, -3.0508881488790776, -5.069846636151324, -3.6495408996227328, -4.548858656447172, -5.7613477258046, -6.031638055544512, -6.61856302284915, -5.764642621701453, -4.906092884516815, -3.945751808422034, -4.075923906392578, -4.145352412824341, -4.3284585910787134, -4.1375398730875474, -4.386633312115669, -4.864991208831262, -5.2459274106602996, -5.389330551763976, -4.366047982499911, -3.5236520927129136, -3.6216686341149815, -3.0467401241562313, -4.4457511661828155, -3.28056139498962, -5.728982441302569, -3.2282776746379773, -3.3483163872180257, -3.6120365041642786, -4.280940073114231, -4.240597235287379, -4.439591885822281, -4.571620648562269, -5.13801612348307, -5.583972592945972], [-5.648871675811755, -4.741030782968909, -5.070478143556586, -5.038332518583169, -4.984450311189462, -5.652113169735926, -5.878916005474925, -6.018576120040821, -5.698633185370818, -5.924757364823166, -1.8468585970227798, -6.844251516414859, -7.126600242891277, -6.081398705962876, -2.934905888757429, -3.6595354362414967, -6.817864761241664, -3.5921374614243615, -2.9623018840998165, -7.15537920744132, -5.837035508229937, -2.956367800752568, -5.44072677540776, -6.135188880549014, -2.35874447462609, -6.817864761241664, -7.744626792983114, -1.829808862763535, -4.656579250518651, -7.012765100242478, -3.346772137573546, -6.156466278996299, -6.772055225210369, -5.459294948136628, -6.2464145156592386, -6.772055225210369, -3.9054574859103, -5.259720143195114, -3.484916480113615, -4.59888775210554, -4.26703708287839, -5.280773552392946, -4.568219053541838, -5.236954932422101, -4.227597595795837, -6.429913235626207, -5.14878310004672, -4.299244656170703, -5.066854951187166, -5.722730736949879, -4.343868104023761, -4.895290258966649, -5.924757364823166, -4.2366225736701635, -3.439140235431567, -5.290903070631802, -4.913738130330258, -5.32777360644013, -5.700335313441349, -4.118883335232663, -6.285399962372192, -5.825384891009962], [-4.134798672989471, -4.089847285127205, -4.1376763728170864, -4.175860159787245, -3.5867437074551245, -4.073498147125676, -4.247208240584712, -4.485742942219219, -4.161001045383496, -4.76664532768562, -4.782994465687151, -5.224827217966189, -5.79734641073752, -5.371880635922686, -5.362028339479674, -4.805217602471861, -5.696541711615555, -5.1428140663053545, -4.243997964954463, -5.696541711615555, -6.074978147335799, -4.388579193765571, -4.887134724939747, -5.433124261163405, -5.127188748402274, -5.465212575714905, -5.5681605449673475, -3.871109027280912, -4.3522115495946965, -4.887134724939747, -1.4812734394569864, -4.9697213159490214, -5.42265296129611, -5.5681605449673475, -5.696541711615555, -5.592551998091507, -3.9025017396887742, -4.303421385425264, -4.377529357578986, -3.2036759521599856, -4.414847120586181, -4.370230055097374, -4.283218678107745, -4.293269013961246, -4.570900750559526, -4.639893622046477, -4.473572406598963, -3.944368319081564, -3.9659778034144195, -4.663991173625537, -3.393956618621509, -4.489832927470744, -3.9232159440763374, -4.221810049979101, -3.677082874537429, -4.095356940938174, -3.0285527594662907, -4.570900750559526, -4.348646483430199, -4.449666885745409, -4.481669616831582, -4.21556002963393], [-5.468543074118657, -4.3409301123745765, -4.939132602788878, -5.030955774234888, -5.486636817561356, -5.444018684255573, -5.476853371252285, -5.808607963491769, -5.908385471304435, -5.666153323427702, -2.5849374499856705, -5.739356727450997, -6.452595908093631, -6.391754248837386, -1.3630653142736813, -7.218432822021854, -6.741508749931544, -4.321907198551311, -2.3295168721177877, -7.554905058643067, -7.600367432719824, -7.660265574300893, -6.068262723688894, -7.064282142194595, -2.4089621725210324, -6.261701120589188, -7.218432822021854, -7.400754378815808, -6.405740490812126, -6.66108718262097, -3.202908170420881, -7.345184527660997, -7.318516280578836, -7.17951740577218, -6.2346317986209705, -7.685266876506311, -3.523815890500982, -5.001129001779655, -4.254551658580372, -3.1791480369827805, -3.272238460048792, -4.979751531007288, -4.696520976240299, -4.996816791561475, -3.7821441205484283, -6.068262723688894, -4.767838317222632, -4.961310103104565, -3.3169412686460493, -4.254142074302682, -3.686717843919221, -4.781622132973809, -6.395232513213711, -4.882290151848487, -4.035101934573064, -4.142657840794326, -4.886134831709296, -5.154991621688459, -5.261248596393322, -5.763145589415012, -5.307128202144016, -5.4187681732866855], [-3.7153348719791315, -4.23835637018879, -5.401341822408315, -5.655381048015406, -5.3230099791384085, -5.723838105173554, -5.787159933132683, -6.191069830974041, -6.118044695959151, -6.512733837722823, -2.85919837658876, -7.902248813542757, -2.4061387894065027, -6.693770047296114, -2.250325724429897, -7.350962550860164, -6.005451461342365, -3.2057646919026945, -3.1269276063809657, -8.282234836349936, -4.929356031958588, -4.893377430923357, -4.350779231381914, -5.039126698093967, -3.0950598675329433, -2.702149075140166, -7.065140944061303, -6.4656293685353505, -6.6671525062961585, -1.5532677412410396, -3.407685858090993, -6.917395410231305, -4.818860209735889, -8.330553413620743, -4.697144805661785, -7.44034239452964, -4.201345166462018, -5.036551747250591, -4.447052124631202, -4.271306064673767, -4.3875307527168115, -5.68024420720805, -5.463555006909888, -4.6680077696105, -4.729585831829687, -6.877248342217893, -5.7894972929813875, -4.744562286019245, -4.863271676535759, -5.996776708148691, -5.115645847928164, -4.782587554878788, -6.69569868820252, -5.6198664278662305, -4.372289459396023, -3.8304137647360905, -5.143464614214886, -5.692911512408815, -5.442384299786921, -6.144390895990383, -6.553756817069401, -6.771887826560066], [-5.439192275092616, -4.781176186054329, -4.766861598657258, -5.578787193555129, -5.543563426336324, -5.577507602849504, -5.742587353208953, -6.240425781448133, -6.11031213333427, -6.461710020172159, -2.6665339561656087, -5.7471225083743445, -6.597455272456702, -6.655866034613116, -2.1677366785812078, -7.063212610820987, -6.615344837207477, -1.8542823223629723, -2.8203019407701473, -7.921874229858505, -5.964600322152877, -7.4190807777897785, -7.115398363991557, -7.50316389500032, -2.434370037607787, -6.75042461723813, -8.501692725111447, -2.436966652419961, -5.508344242912733, -7.262628600974241, -3.3318853658660776, -6.320468489121669, -4.662752576421778, -7.96269622437876, -4.3951216252530045, -7.773454224740232, -3.4248833433841024, -4.6171877485771935, -4.856615893655904, -5.148452521314832, -3.262215858586344, -5.067705520626301, -4.995134827791466, -4.808655260848847, -4.056803079326151, -6.372894286461519, -5.283769734998518, -4.869131701587735, -4.356292992089062, -5.580068423711178, -4.205055407055328, -5.300108397353307, -6.413362236014366, -4.081705328198343, -3.5651654031689133, -4.4607321960690065, -4.914213385439241, -3.3562768189902368, -5.301077859377855, -5.2191716350828905, -5.66568217643417, -5.148452521314832], [-4.692472771166889, -4.3008934499719516, -4.549181741142988, -4.955265087292482, -5.083773336506403, -5.36724487642184, -5.286555965171697, -5.606625988867734, -5.3561026998685985, -5.6766361544403825, -6.310506725070788, -5.345083304618988, -6.354631529979725, -5.436838168221035, -2.778870257014558, -5.888394383529467, -5.518132910614282, -3.971194340356585, -5.541198183545278, -7.353160360090853, -5.418980550821029, -3.590537431731367, -3.3241709789128793, -1.8944436557320132, -5.91226186493611, -3.390599447549114, -7.2559966116372046, -3.6807421830309885, -3.742794171598555, -5.40143624117012, -6.914247317915148, -6.268246915780905, -5.966865998970962, -6.802329401711162, -7.18453764765506, -6.063197107909394, -4.040088147996806, -3.4233375319614976, -2.7095546985241823, -4.374927246403353, -3.562959147374605, -4.404434128912793, -4.579296940419071, -4.391681565015401, -4.438151297809303, -5.606625988867734, -4.3282656378478706, -4.1449534915722195, -4.0950638220693705, -3.3913758451036427, -5.0164696546102965, -4.409796072054178, -6.030044900592494, -3.187603169643488, -2.500811269450856, -3.4121731416766146, -5.192891489277063, -4.804034117568558, -4.273312053475689, -5.056716535118889, -5.514880875227905, -5.219114684376165], [-5.262101982971463, -4.751704716461968, -4.4750082149096455, -5.006514043913175, -5.07515161250067, -5.251452255054804, -5.285938431125974, -5.392274080942006, -5.414469813333791, -5.840086736879263, -2.606359904105076, -6.823463761969788, -6.89757173412351, -5.234645136738424, -1.8016665052081617, -5.931967688708849, -5.7146991018376605, -5.437169400849897, -1.672652532530341, -6.72630001351614, -6.773702252410724, -5.308112288620296, -6.00575385876808, -6.6810434219280195, -2.3521748840468923, -5.96169386897405, -7.419447194076086, -6.095225261598572, -5.008173795331539, -6.397795946544104, -5.514028406375509, -5.907173030095633, -6.070893160939042, -4.572171963363293, -6.91979487090822, -6.823463761969788, -3.666029218824578, -4.169934399745995, -4.315857524665681, -2.6071122929751187, -3.822642418908326, -5.326212330263914, -4.3600448319184775, -4.917707706137853, -3.8075287810982776, -5.953110125282659, -5.187841070540621, -4.792366055507543, -4.8403533292283845, -5.164264339976624, -4.320022461964966, -3.8952676954062846, -5.745470760504414, -4.036941945426083, -4.228361366337563, -4.708930900478682, -5.247223918945283, -5.006514043913175, -3.8952676954062846, -4.574322501826521, -5.886970322778113, -5.748949024880739], [-5.49714261021104, -4.668772759709356, -4.7793028170607235, -5.269011517385791, -5.403728165571614, -5.600190986110487, -5.607143505425369, -5.736034518493389, -5.749350294469161, -5.980569259788917, -1.8463761496649909, -6.7957313909118255, -6.842614976810675, -6.277301167760615, -1.6016725181239624, -6.834646807161499, -6.483542908272222, -3.3781298559126016, -1.9147238137262874, -7.264209466848723, -6.97044834832056, -6.2503937148406905, -6.323821183395508, -6.466922027036182, -2.304012035094697, -6.232849405189781, -7.182292344380837, -4.500040235600472, -6.194465162181466, -7.045955900828706, -3.7335540179496816, -6.633976111699347, -6.224191342446667, -7.560054849939665, -6.541029999189903, -7.7391030813886506, -3.9953827115751284, -5.225208894727398, -4.2623981472183505, -4.983820106246462, -3.5900722944719905, -4.880831478599072, -4.625152137233465, -5.350160419862394, -4.464551422640724, -6.03257404477923, -5.25911044640308, -4.290672925686517, -4.802954305142684, -5.287422079228971, -4.798800612773991, -4.757191363453292, -5.977196575310277, -4.844383490556383, -2.946883968159507, -4.887603513509017, -5.795997983260946, -5.6188395451885595, -4.719156549714065, -5.921535728204724, -6.1778672707724285, -5.694577804815043], [-4.469097220436953, -3.6430767584970343, -3.7844067498952314, -3.931680914923784, -4.272838155799217, -4.129621978555971, -4.297357772973536, -4.384369149963165, -4.338992745625113, -4.178787025578902, -4.976420213651742, -4.292052720743842, -5.461928029433443, -5.887479896108345, -4.57562801124297, -5.526466550571014, -6.262964172004573, -4.4462034005711, -5.238784478119233, -6.017291507630335, -6.355745905455539, -5.968972930359527, -5.520424236115051, -6.328346931267425, -5.70515833931439, -4.218953067304238, -6.6434279779073195, -5.648805402763258, -5.5635078222513625, -4.870360641691417, -6.412904319295488, -1.949196049230905, -5.968972930359527, -4.4990139814749455, -6.027241838483503, -6.442757282445169, -4.057336183871974, -4.448263133534111, -4.000410247075965, -3.7940068236242506, -4.150834895195163, -4.166267300233975, -4.566303934367847, -4.3901887590164295, -4.028468199871122, -4.376661982718227, -4.915384323065373, -3.014652447863089, -3.369082406994758, -4.61381880997536, -4.55706599338291, -3.5814225774035497, -4.577972678202224, -4.001728638829222, -3.270401473211861, -3.264703452097223, -3.9718368746319084, -3.132988733879366, -4.361423592613295, -2.595191993338583, -4.516519898988561, -4.912100247864183], [-3.9699474093476774, -4.189042372135887, -4.058989243887689, -4.102030995146257, -4.171520021443684, -4.318254103615893, -4.424253392850214, -4.758810531535327, -4.504029895277935, -4.414714369803455, -3.0879080140350674, -5.469976217597951, -3.790334046490602, -5.366435538657111, -3.235086137375257, -5.727805326900051, -5.408282648592611, -4.971959552124542, -5.070590155566169, -5.076706382583605, -6.181472536826093, -5.921961341341008, -4.9999725883522155, -5.5070174892783, -1.5568628976878147, -5.5070174892783, -6.110013572843948, -4.0678979887767985, -5.089052218405905, -5.200643283814367, -3.6661684098537215, -4.557328477002297, -5.479108701161223, -5.159821289294111, -5.479108701161223, -5.616579691789827, -3.7152580200502454, -4.23556238777078, -4.212031890360586, -3.866007780968386, -4.0678979887767985, -4.4633463186414915, -4.142178063159669, -4.318254103615893, -4.276053749125516, -4.772293881872614, -4.332726136224427, -4.11133338780857, -3.9089648990693253, -4.309670359924501, -3.9127889955077286, -4.338574106106851, -4.528549512452254, -4.149433234040841, -3.5292744136497762, -3.6009751629760713, -4.350373653038005, -4.828122331425556, -4.047963773875981, -4.665125047458004, -4.673288358097166, -4.633122316371831], [-4.806719860900339, -3.6507473420444714, -4.429814962058902, -4.347330952102998, -4.3949170222076255, -4.698366552912107, -4.809448375553543, -4.35423944244681, -4.534137594904308, -4.3611959922401695, -2.871768725634745, -4.598399529122678, -5.564587232141456, -5.519124858064699, -2.4250566837898457, -5.688201188108633, -5.967149580591659, -5.01834957015221, -2.505498094634157, -5.3939617151106924, -6.3813483686685775, -5.360223575478843, -5.821732580733155, -5.742268409378909, -2.5427453130265225, -6.0299504818306895, -5.949907774157153, -6.048642614842842, -6.106911522966818, -6.522426966928483, -1.9368412502165815, -5.384205540165328, -3.2469989725553616, -5.166904264475346, -4.662348253722951, -5.93295821584338, -4.052787789271272, -3.8964417188805776, -4.725629703670472, -3.994277013931218, -3.570836586604418, -4.883136091344702, -4.20182336843176, -4.894970548991704, -4.1342203512338624, -5.159122124033291, -4.442985425248647, -4.740819869164446, -4.583031498894364, -4.589588899440523, -4.4058064220068935, -4.87144005158151, -4.8541485544714496, -4.806719860900339, -4.241282205172307, -4.937530163410501, -4.382360803432213, -5.0116381355642226, -4.368201274828579, -4.782492565565015, -4.544565218066568, -4.4563316672015425]],
        probHashThreshold: 0.015,
        probHashChars: { '1': 1, '0': 0, '3': 3, '2': 2, '5': 5, '4': 4, '7': 7, '6': 6, '9': 9, '8': 8, 'A': 36, 'C': 38, 'B': 37, 'E': 40, 'D': 39, 'G': 42, 'F': 41, 'I': 44, 'H': 43, 'K': 46, 'J': 45, 'M': 48, 'L': 47, 'O': 50, 'N': 49, 'Q': 52, 'P': 51, 'S': 54, 'R': 53, 'U': 56, 'T': 55, 'W': 58, 'V': 57, 'Y': 60, 'X': 59, 'Z': 61, 'a': 10, 'c': 12, 'b': 11, 'e': 14, 'd': 13, 'g': 16, 'f': 15, 'i': 18, 'h': 17, 'k': 20, 'j': 19, 'm': 22, 'l': 21, 'o': 24, 'n': 23, 'q': 26, 'p': 25, 's': 28, 'r': 27, 'u': 30, 't': 29, 'w': 32, 'v': 31, 'y': 34, 'x': 33, 'z': 35 },
        userTransitions: {
          search: {}
        },

        // Patterns for content extraction.
        // Will be initialized by the ContentExtractionPatternsLoader,
        // which polls for configuration changes from the backend.
        patterns: {
          normal: {
            searchEngines: [],
            rArray: [],
            extractRules: {},
            payloads: {}
          },
          strict: {
            searchEngines: [],
            rArray: [],
            extractRules: {},
            payloads: {}
          }
        },
        patternsLoader: new ContentExtractionPatternsLoader((patternsConfig, ruleset) => {
          CliqzHumanWeb.updateContentExtraction(patternsConfig, ruleset);
        }),

        messageTemplate: {},
        configURL: config.settings.ENDPOINT_CONFIGURL,
        // searchCache: {},
        ts: "",
        mRefresh: {},
        can_url_match: {},
        ismRefresh: false,
        userTransitionsSearchSession: 5 * 60,
        key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
        q: {
          name: "queryKey",
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        },
        activeUsage: null,
        activeUsageThreshold: 2,
        pageStatusCountSent: null,
        actionStats: null,
        actionStatsLastSent: null,
        bloomFilter: null,
        bf: null,
        strictQueries: [],
        oc: null,
        SAFE_QUORUM_ENDPOINT: config.settings.ENDPOINT_SAFE_QUORUM_ENDPOINT,
        SAFE_QUORUM_PROVIDER: config.settings.ENDPOINT_SAFE_QUORUM_PROVIDER,
        quorumBloomFilters: {},
        safeQuorumProvider: null,
        getAllOpenPages: getAllOpenPages,
        prefs: {
          humanWebOptOut: false,
          config_ts: null,
          config_location: null
        },
        _md5: function _md5(str) {
          return cachedMD5(str);
        },
        maskURL: function maskURL(url) {
          var url_parts = null;
          var masked_url = null;
          // Fix
          // url_parts = CliqzHumanWeb.parseUri(url);
          url_parts = CliqzHumanWeb.parseURL(url);

          // TO BE FIXED
          if (!url_parts) return '';

          // Fix
          if (CliqzHumanWeb.dropLongURL(url)) {
            //Explicit check for google search url.
            if (url_parts['hostname'].indexOf('google') > 0) {
              if (url_parts['query_string']) {
                var query_stringsParts = CliqzHumanWeb.parseQueryString(url_parts['query_string']);
                if (query_stringsParts['url']) {
                  masked_url = query_stringsParts['url'][0];
                  masked_url = CliqzHumanWeb.maskURL(decodeURIComponent('' + masked_url));
                  return masked_url;
                }
              }
            }
            masked_url = url_parts.protocol + "://" + url_parts.hostname + "/ (PROTECTED)";
            return masked_url;
          }
          return url;
        },
        maskURLStrict: function maskURLStrict(url) {
          var url_parts = null;
          var masked_url = null;
          // Fix
          // url_parts = CliqzHumanWeb.parseUri(url);
          url_parts = CliqzHumanWeb.parseURL(url);

          // TO BE FIXED
          if (!url_parts) return '';

          masked_url = url_parts.protocol + "://" + url_parts.hostname + "/ (PROTECTED)";
          return masked_url;
        },
        isShortenerURL: function isShortenerURL(url) {
          try {
            var url_parts = CliqzHumanWeb.parseURL(url);
            if (!url_parts) return true;

            if (url_parts.hostname.length < 8 && url_parts.path.length > 4) {
              var v = url_parts.path.split('/');
              for (var i = 0; i < v.length; i++) if (CliqzHumanWeb.isHash(v[i])) return true;
            }
            return false;
          } catch (ee) {
            return true;
          }
        },
        getTime: function getTime() {
          // Need to fix.
          try {
            var ts = CliqzUtils.getPref('config_ts', null);
          } catch (ee) {}
          if (!ts) {
            var d = null;
            var m = null;
            var y = null;
            var h = null;
            var hr = null;
            var _ts = null;
            d = (new Date().getDate() < 10 ? "0" : "") + new Date().getDate();
            m = (new Date().getMonth() < 9 ? "0" : "") + parseInt(new Date().getMonth() + 1);
            h = (new Date().getUTCHours() < 10 ? "0" : "") + new Date().getUTCHours();
            y = new Date().getFullYear();
            _ts = y + "" + m + "" + d + "" + h;
          } else {
            h = (new Date().getUTCHours() < 10 ? "0" : "") + new Date().getUTCHours();
            _ts = ts + "" + h;
          }
          return _ts;
        },
        isSuspiciousDomainName: function isSuspiciousDomainName(hostname) {
          /*
           We need to identify is a hostname looks suspicious.
          */

          let splitDomain = hostname.split('.');

          if (splitDomain.length > 6) {
            return true;
          }

          if (CliqzHumanWeb.checkForLongNumber(hostname, 5)) {
            return true;
          }

          let splitHyphen = hostname.split('-');

          if (splitHyphen.length > 4) {
            return true;
          }

          return false;
        },
        isSuspiciousURL: function isSuspiciousURL(aURI) {
          try {
            var url_parts = {};
            url_parts = CliqzHumanWeb.parseURL(aURI);

            if (!url_parts) return true;

            _log$1(JSON.stringify(url_parts));
            if (aURI.indexOf('about:') == 0) return true;

            if (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(url_parts.hostname)) {
              return true;
            }

            if (url_parts.username != "" || url_parts.password != "") {
              return true;
            }

            if (url_parts.port != "" & (url_parts.port != "80" && url_parts.port != "443")) {
              return true;
            }

            if (url_parts.protocol != "http" & url_parts.protocol != "https" & url_parts.protocol != "") {
              return true;
            }

            var pos_hash_char = aURI.indexOf('#');

            if (pos_hash_char > -1) {
              if (CliqzHumanWeb.checkSearchURL(aURI) == -1 && aURI.length - pos_hash_char >= 10) {
                _log$1("Dropped because of # in url: " + decodeURIComponent(aURI));
                return true;
              }
            }

            if (url_parts.hostname.indexOf('localhost') > -1) {
              return true;
            }

            if (CliqzHumanWeb.isSuspiciousDomainName(url_parts.hostname)) {
              return true;
            }

            _log$1("Sanitize: URL is ok: " + aURI);

            return false;
          } catch (ee) {
            // if there were any exception, we return true for safety
            _log$1("Exception in isSuspiciousURL: " + ee);
            return true;
          }
        },
        calculateStrictness: function calculateStrictness(url, page_doc) {
          var strict_value = true;
          if (page_doc && page_doc['x'] && page_doc['x']['canonical_url']) {
            // there is canonical,
            var can_url_parts = CliqzHumanWeb.parseURL(page_doc['x']['canonical_url']);
            var url_parts = CliqzHumanWeb.parseURL(url);

            if (!url_parts || !can_url_parts) return true;

            if (url_parts.hostname != null && url_parts.hostname != '' && url_parts.hostname == can_url_parts.hostname) {
              // both canonical and url have a hostname and is the same,

              if (page_doc['x']['canonical_url'] != url && page_doc['x']['canonical_url'].length < url.length) {
                // the page has a canonical of same domain, which usually is a sign that is public,
                // and the canonical is not the same url, which comes out of automatic generation
                // of canonicals
                strict_value = false;
              }
            }
          }
          return strict_value;
        },
        dropLongURL: function dropLongURL(url, options) {
          try {
            if (options == null) options = { 'strict': false };

            if (CliqzHumanWeb.checkForEmail(url)) return true;

            var url_parts = CliqzHumanWeb.parseURL(url);
            if (!url_parts) return true;

            if (options.strict == true) {
              if (url_parts.query_string && url_parts.query_string.length > CliqzHumanWeb.qs_len * 0.75) return true;
              // check the number of parameters too,

              if (url_parts.query_string) {
                var v = url_parts.query_string.split(/[&;]/);
                if (v.length > 1) {
                  // that means that there is a least one &; hence 2 params
                  return true;
                }

                for (var i = 0; i < v.length; i++) {
                  if (v[i].length > 3 && CliqzHumanWeb.isHash(v[i])) return true;
                }

                if (CliqzHumanWeb.checkForLongNumber(url_parts.query_string, 8) != null) return true;
              }

              if (CliqzHumanWeb.checkForLongNumber(url_parts.path, 8) != null) return true;
            } else {
              if (url_parts.query_string && url_parts.query_string.length > CliqzHumanWeb.qs_len) return true;

              if (url_parts.query_string) {

                var v = url_parts.query_string.split(/[&;]/);
                if (v.length > 4) {
                  // that means that there is a least one &; hence 5 params
                  return true;
                }
                if (CliqzHumanWeb.checkForLongNumber(url_parts.query_string, 12) != null) return true;
              }

              if (CliqzHumanWeb.checkForLongNumber(url_parts.path, 12) != null) return true;
            }

            var vpath = url_parts.path.split(/[\/\._ \-:\+;]/);
            for (var i = 0; i < vpath.length; i++) {
              if (vpath[i].length > CliqzHumanWeb.rel_part_len) {
                return true;
              }

              if (options.strict == true) {
                // if strict, check the no token in path looks like a hash
                if (vpath[i].length > 5 && CliqzHumanWeb.isHash(vpath[i])) return true;
              } else {
                if (vpath[i].length > 12 && CliqzHumanWeb.isHash(vpath[i])) return true;
              }
            }

            var vpath = url_parts.path.split('/');
            for (var i = 0; i < vpath.length; i++) {
              var cstr = vpath[i].replace(/[^A-Za-z0-9]/g, '');
              var mult = 1.0;
              if (options.strict == true) mult = 0.5;
              if (cstr.length > CliqzHumanWeb.rel_segment_len * mult) {
                if (CliqzHumanWeb.isHash(cstr)) return true;
              }
            }

            var v = [/\/admin([\/\?#=]|$)/i, /\/wp-admin([\/\?#=]|$)/i, /\/edit([\/\?#=]|$)/i, /[&\?#\/]share([\/\?#=]|$)/i, /[&\?#\/;]sharing([\/\?#=]|$)/i, /[&\?#\/;]logout([\/\?#=]|$)/i, /WebLogic/i, /[&\?#\/;]token([\/\?#=_;]|$)/i, /[&\?#\/;]trk([\/\?#=_]|$)/i, /[&\?#\/=;](http|https)(:\/|\%3A\%2F)/];

            // url_rel contains path and query_string
            //
            var url_rel = (url_parts.path || '/') + '?' + (url_parts.query_string || '');
            for (var i = 0; i < v.length; i++) if (v[i].test(url_rel)) return true;

            // checks specific to the query string
            //
            // real query string (?) or a 'fake' one with a sharp on the path, they should be treated the same way
            //
            var path_query_string = null;
            var ind_pos = url_parts.path.indexOf('#');
            if (ind_pos != -1) path_query_string = url_parts.path.slice(ind_pos, url_parts.path.length);

            if (url_parts.query_string && url_parts.query_string.length > 0 || path_query_string && path_query_string.length > 0) {

              var v = [/[&\?#_\-;]user/i, /[&\?#_\-;]token/i, /[&\?#_\-;]auth/i, /[&\?#_\-;]uid/i, /[&\?#_\-;]email/i, /[&\?#_\-;]usr/i, /[&\?#_\-;]pin/i, /[&\?#_\-;]pwd/i, /[&\?#_\-;]password/i, /[&\?#;]u[=#]/i, /[&\?#;]url[=#]/i, /[&\?#_\-;]http/i, /[&\?#_\-;]ref[=#]/i, /[&\?#_\-;]red[=#]/i, /[&\?#_\-;]trk/i, /[&\?#_\-;]track/i, /[&\?#_\-;]shar/i, /[&\?#_\-;]login/i, /[&\?#_\-;]logout/i, /[&\?#_\-;]session/i];

              if (url_parts.query_string && url_parts.query_string.length > 0) {
                for (var i = 0; i < v.length; i++) if (v[i].test('?' + url_parts.query_string)) return true;
              }

              if (path_query_string && path_query_string.length > 0) {
                for (var i = 0; i < v.length; i++) if (v[i].test(path_query_string)) return true;
              }
            }

            return false;
          } catch (ee) {
            // if there were any exception, we return true for safety
            _log$1("Exception in dropLongURL: " + ee);
            return true;
          }
        },
        cleanDocCache: function cleanDocCache() {
          for (var key in CliqzHumanWeb.docCache) {
            if (CliqzHumanWeb.counter - CliqzHumanWeb.docCache[key]['time'] > 3600 * CliqzHumanWeb.tmult) {
              delete CliqzHumanWeb.docCache[key];
            }
          }
        },
        cleanHttpCache: function cleanHttpCache() {
          for (var key in CliqzHumanWeb.httpCache) {
            if (CliqzHumanWeb.counter - CliqzHumanWeb.httpCache[key]['time'] > 60 * CliqzHumanWeb.tmult) {
              delete CliqzHumanWeb.httpCache[key];
            }
          }
          for (var key in CliqzHumanWeb.httpCache401) {
            if (CliqzHumanWeb.counter - CliqzHumanWeb.httpCache401[key]['time'] > 60 * CliqzHumanWeb.tmult) {
              delete CliqzHumanWeb.httpCache401[key];
            }
          }
        },
        getHeaders: function getHeaders(strData) {
          var o = {};
          let _status = strData.split(" ")[1];

          if (parseInt(_status)) {
            _status = parseInt(_status);
          } else {
            _status = null;
          }

          o['status'] = _status;

          var l = strData.split("\n");
          for (var i = 0; i < l.length; i++) {
            if (l[i].indexOf('Location: ') == 0) {
              o['loc'] = decodeURIComponent(l[i].split(" ")[1].trim());
            }
            if (l[i].indexOf('WWW-Authenticate: ') == 0) {
              var tmp = l[i].split(" ");
              var tmp = tmp.slice(1, tmp.length).join(" ");
              o['auth'] = tmp;
            }
          }

          return o;
        },
        httpObserver: {
          // check the non 2xx page and report if this is one of the cliqz result
          observeActivity: function observeActivity(_ref) {
            let aUrl = _ref.url,
                type = _ref.type,
                responseStatus = _ref.responseStatus,
                statusCode = _ref.statusCode,
                responseHeaders = _ref.responseHeaders,
                isPrivate = _ref.isPrivate,
                tabId = _ref.tabId;

            // For bootstrap, we can rely on isPrivate.
            // For web-extensions, we need to get the tab.incognito property,
            // That is why we have an implementation in platforms.
            // The platform/firefox, just mocks the needed properties.

            // If isPrivate true, then drop it. Works for bootstrap.
            // Once #4705 lands in master, isPrivate should work for web-extension.

            if (isPrivate) {
              return;
            }

            // But we are only concerned, with main_frame tabs,
            // hence we can return all the others, from this point.

            if (type !== 6 && type !== 'main_frame') {
              return;
            }

            // If it's webextension and private mode, it will still reach this point,
            // so we need to get the details from tab, which is async.
            // The platform/firefox/human-web/tabInfo.es is just a mock of properties required.
            // For bootstrap-privateMode it should never reach here, hence the mocked properties.

            getTabInfo(tabId, type).then(tab => {

              if (tab.isWebExtension && tab.isPrivate) {
                return;
              } else {

                // Detect ad click
                CliqzHumanWeb.detectAdClick(aUrl);

                const url = decodeURIComponent(aUrl);
                const status = responseStatus || statusCode;
                const headers = responseHeaders;

                if (status === 301 || status === 302) {
                  let location;
                  headers.forEach(eachHeader => {
                    if (eachHeader.name && eachHeader.name.toLowerCase() === 'location') {
                      location = eachHeader.value;
                    }
                  });
                  CliqzHumanWeb.httpCache[url] = {
                    status: status,
                    time: CliqzHumanWeb.counter,
                    location
                  };
                } else if (status === 401) {
                  CliqzHumanWeb.httpCache401[url] = {
                    time: CliqzHumanWeb.counter
                  };
                } else if (status) {
                  CliqzHumanWeb.httpCache[url] = {
                    status: status,
                    time: CliqzHumanWeb.counter
                  };
                }
              }
            }).catch(e => {
              _log$1(e);
            });
          }
        },
        onVisitRemoved(_ref2) {
          let urls = _ref2.urls,
              allHistory = _ref2.allHistory;

          if (allHistory) {
            CliqzHumanWeb.db.clearHistory();
          } else if (urls.length === 1) {
            CliqzHumanWeb.db.deleteVisit(urls[0]);
          } else if (urls.length > 1) {
            CliqzHumanWeb.db.deleteTimeFrame();
          }
        },
        linkCache: {},
        cleanLinkCache: function cleanLinkCache() {
          for (var key in CliqzHumanWeb.linkCache) {
            if (CliqzHumanWeb.counter - CliqzHumanWeb.linkCache[key]['time'] > 60 * CliqzHumanWeb.tmult) {
              delete CliqzHumanWeb.linkCache[key];
            }
          }
        },
        getRedirects: function getRedirects(url, _res) {
          var res = _res || [];

          // This needs simplification.
          try {
            for (var key in CliqzHumanWeb.httpCache) {
              if (CliqzHumanWeb.httpCache[key]) {
                if (CliqzHumanWeb.httpCache[key]['location'] != null && (CliqzHumanWeb.httpCache[key]['status'] === 301 || CliqzHumanWeb.httpCache[key]['status'] === 302)) {
                  if (CliqzHumanWeb.httpCache[key]['location'] == url || decodeURIComponent(CliqzHumanWeb.httpCache[key]['location']) == url || CliqzHumanWeb.httpCache[key]['location'] + '/' == url) {
                    res.unshift(key);
                    CliqzHumanWeb.getRedirects(key, res);
                  }
                }
              }
            }
          } catch (ee) {
            _log$1(">>>> REDIRECT ERROR >>> " + ee);
          }
          return res;
        },
        userSearchTransition: function userSearchTransition(rq) {
          // now let's manage the userTransitions.search
          if (rq != null) {
            var source = rq['qurl'];
            var query = rq['q'].replace(/\s+/g, " ").trim().toLowerCase();

            if (source && query && query.length > 0) {
              // we have both the source and the query,
              // let's see if we have done the query

              if (CliqzHumanWeb.userTransitions['search'][query] == null) {
                CliqzHumanWeb.userTransitions['search'][query] = { 'time': CliqzHumanWeb.counter, 'data': [] };
              }
              CliqzHumanWeb.userTransitions['search'][query]['data'].push([source, CliqzHumanWeb.counter - CliqzHumanWeb.userTransitions['search'][query]['time']]);
            }
          }
        },
        getParametersQS: function getParametersQS(url) {
          var res = {};
          var KeysValues = url.split(/[\?&]+/);
          for (var i = 0; i < KeysValues.length; i++) {
            var kv = KeysValues[i].split("=");
            if (kv.length == 2) res[kv[0]] = kv[1];
          }
          return res;
        },
        getEmbeddedURL: function getEmbeddedURL(targetURL) {
          var ihttps = targetURL.lastIndexOf('https://');
          var ihttp = targetURL.lastIndexOf('http://');
          if (ihttps > 0 || ihttp > 0) {
            // contains either http or https not ont he query string, very suspicious
            let parqs = fastUrlParser.parse(targetURL, true, true, true);

            if (parqs && parqs._query && parqs._query.url) {
              return decodeURIComponent(parqs._query.url);
            }
          } else return null;
        },
        auxIsAlive: function auxIsAlive() {
          return true;
        },

        auxGetPageData: function auxGetPageData(url, page_data, original_url, onsuccess, onerror) {
          CliqzHumanWeb.doublefetchHandler.anonymousHttpGet(url).then(CliqzHumanWeb.createDoc).then(doc => {
            const x = CliqzHumanWeb.getPageData(url, doc);

            CliqzHumanWeb.docCache[url] = {
              time: CliqzHumanWeb.counter,
              doc
            };

            onsuccess(url, page_data, original_url, x);
          }).catch(error_message => {
            _log$1(`Error on doublefetch: ${error_message}`);
            onerror(url, page_data, original_url, error_message);
          });
        },
        auxIntersection: function auxIntersection(a, b) {
          var ai = 0,
              bi = 0;
          var result = new Array();
          while (ai < a.length && bi < b.length) {
            if (a[ai] < b[bi]) {
              ai++;
            } else if (a[ai] > b[bi]) {
              bi++;
            } else {
              result.push(a[ai]);
              ai++;
              bi++;
            }
          }
          return result;
        },
        auxUnion: function auxUnion(a, b) {
          var h = {};
          for (var i = a.length - 1; i >= 0; --i) h[a[i]] = a[i];
          for (var i = b.length - 1; i >= 0; --i) h[b[i]] = b[i];
          var res = [];
          for (var k in h) {
            if (h.hasOwnProperty(k)) res.push(h[k]);
          }
          return res;
        },
        validDoubleFetch: function validDoubleFetch(struct_bef, struct_aft, options) {
          // compares the structure of the page when rendered in Firefox with the structure of
          // the page after.

          _log$1("xbef: " + JSON.stringify(struct_bef));
          _log$1("xaft: " + JSON.stringify(struct_aft));

          // Check if struct_bef or struct_aft is not null, in case anyone is then we mark it as private.

          // if any of the titles is null (false), then decline (discard)
          if (!(struct_bef && struct_aft)) {
            _log$1("fovalidDoubleFetch: found an empty structure");
            return false;
          }

          if (!(struct_bef['t'] && struct_aft['t'])) {
            _log$1("fovalidDoubleFetch: found an empty title");
            return false;
          }

          // if any of the two struct has a iall to false decline
          if (!(struct_bef['iall'] && struct_aft['iall'])) {
            _log$1("fovalidDoubleFetch: found a noindex");
            return false;
          }

          // check that there are not different number of frames (or iframes) with an internal
          // link on the two different loads (with and with session), if so, the frame (iframe)
          // might contain a password field. Cannot afford to fetch all iframes on page. Only
          // internal are considered, externals are likely to vary a lot due to advertisement.
          //

          /*
          Adding key to check how many pages will we loose if frame check is turned on
          if (struct_bef['nfsh']==null || struct_aft['nfsh']==null || struct_bef['nfsh']!=struct_aft['nfsh']) {
              _log("fovalidDoubleFetch: number of internal frames does not match");
              return false;
          }
           if (struct_bef['nifsh']==null || struct_aft['nifsh']==null || struct_bef['nifsh']!=struct_aft['nifsh']) {
              _log("fovalidDoubleFetch: number of internal iframes does not match");
              return false;
          }
          */
          if (struct_bef['canonical_url'] != struct_aft['canonical_url']) {
            // if canonicals are different, in principle are different pages,

            if (struct_aft['canonical_url'] != null && struct_aft['canonical_url'].length > 0 && struct_bef['canonical_url'] == null) {
              // unless in the case that struct_aft (after) has a canonical different than null
              // and struct_bef has no canonical,
            } else {
              return false;
            }
          }

          if (options.structure_strict == true) {

            // if there is enough html length, do the ratio, if below or above 10% then very imbalance, discard

            var length_html_ok = true;
            var length_text_ok = true;

            var ratio_lh = (struct_bef['lh'] || 0) / ((struct_bef['lh'] || 0) + (struct_aft['lh'] || 0));
            if ((struct_bef['lh'] || 0) > 10 * 1024) {
              var ratio_lh = (struct_bef['lh'] || 0) / ((struct_bef['lh'] || 0) + (struct_aft['lh'] || 0));
              if (ratio_lh < 0.10 || ratio_lh > 0.90) {
                _log$1("fovalidDoubleFetch: lh is not balanced");
                length_html_ok = false;
              }
            }

            // if there is enough html length, do the ratio, if below or above 10% then very imbalance, discard
            var ratio_nl = (struct_bef['nl'] || 0) / ((struct_bef['nl'] || 0) + (struct_aft['nl'] || 0));
            if ((struct_bef['lh'] || 0) > 30) {
              var ratio_nl = (struct_bef['nl'] || 0) / ((struct_bef['nl'] || 0) + (struct_aft['nl'] || 0));
              if (ratio_nl < 0.10 || ratio_nl > 0.90) {
                _log$1("fovalidDoubleFetch: nl is not balanced");
                length_text_ok = false;
              }
            }

            if (!length_text_ok && !length_html_ok) return false;
          }

          // check for passwords and forms if there is no canonical on the after (double fetched with no session)
          if (struct_aft['canonical_url'] == null || struct_aft['canonical_url'] == '') {
            // if had no password inputs before and it has after, decline
            if (struct_bef['nip'] == null || struct_aft['nip'] == null || struct_bef['nip'] == 0 && struct_aft['nip'] > 0) {
              _log$1("validDoubleFetch: fail nip");
              return false;
            }

            // if had no forms before and it has after, decline
            if (struct_bef['nf'] == null || struct_aft['nf'] == null || struct_bef['nf'] == 0 && struct_aft['nf'] > 0) {
              _log$1("validDoubleFetch: fail text nf");
              return false;
            }
          }

          // compare that titles are equal, if not equal, use the jaccard coefficient, decline if <=0.5
          var t1 = struct_bef['t'] || '';
          var t2 = struct_aft['t'] || '';
          var jc = 1.0;

          if (t1 != t2) {

            var vt1 = t1.split(' ').filter(function (el) {
              return el.length > 1;
            });
            var vt2 = t2.split(' ').filter(function (el) {
              return el.length > 1;
            });

            jc = CliqzHumanWeb.auxIntersection(vt1, vt2).length / CliqzHumanWeb.auxUnion(vt1, vt2).length;

            if (Math.max(vt1.length, vt2.length) <= 4) {
              // the longest titles is 4 tokens long, the, we are a bit flexible on title differences
              if (jc >= 0.5) return true;else {
                _log$1("short title fail title overlap");
                return false;
              }
            } else {
              // the longest titles has 4 or more tokens, be more restrictive
              if (jc <= 0.5) {
                // one last check, perhaps it's an encoding issue

                var tt1 = t1.replace(/[^A-Za-z 0-9 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]*/g, '');
                var tt2 = t2.replace(/[^A-Za-z 0-9 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]*/g, '');

                if (tt1.length > t1.length * 0.5 && tt2.length > t2.length * 0.5) {
                  // if we have not decreased the titles by more than 50%
                  var vtt1 = tt1.split(' ').filter(function (el) {
                    return el.length > 1;
                  });
                  var vtt2 = tt2.split(' ').filter(function (el) {
                    return el.length > 1;
                  });
                  jc = CliqzHumanWeb.auxIntersection(vtt1, vtt2).length / CliqzHumanWeb.auxUnion(vtt1, vtt2).length;
                  // we are more demanding on the title overlap now
                  if (jc <= 0.80) {
                    _log$1("validDoubleFetch: fail title overlap after ascii");
                    return false;
                  }
                } else {
                  _log$1("validDoubleFetch: fail title overlap");
                  return false;
                }
              }

              // if the titles are not a perfect match then check for more structural things like number of inputs
              // that are type password and number of forms. This is prone to false positives because when not logged in
              // legitimate sites something prompt you to register

              // if had no password inputs before and it has after, decline
              if (struct_bef['nip'] == null || struct_aft['nip'] == null || struct_bef['nip'] == 0 && struct_aft['nip'] > 0) {
                _log$1("validDoubleFetch: fail nip");
                return false;
              }

              // if had no forms before and it has after, decline
              if (struct_bef['nf'] == null || struct_aft['nf'] == null || struct_bef['nf'] == 0 && struct_aft['nf'] > 0) {
                _log$1("validDoubleFetch: fail text nf");
                return false;
              }

              return true;
            }
          } else {
            // exactly same title
            return true;
          }

          _log$1("validDoubleFetch: default option");

          return false;
        },
        getCleanerURL: function getCleanerURL(url) {

          var clean_url = url;
          // check first if there is a query string,

          var url_parts = CliqzHumanWeb.parseURL(url);
          if (!url_parts) return null;

          if (url_parts && url_parts.query_string && url_parts.query_string != '') {
            // it has a query string, either by ? # or ;
            clean_url = url_parts.protocol + '://' + url_parts.hostname + url_parts.path;
          } else {
            // it has neither query_string or hash or semicolon, so let's try to remove the last segment

            if (url_parts && url_parts.path && url_parts.path != '') {
              var qs = url_parts.path.split('/');
              var cqs = [];
              for (let i = 0; i < qs.length; i++) if (qs[i] != '') cqs.push(qs[i]);

              if (cqs.length >= 3) {
                // more than 3, /a/b/c, let's remove the last one

                var new_path = cqs.slice(0, cqs.length - 1).join('/');
                clean_url = url_parts.protocol + '://' + url_parts.hostname + '/' + new_path + '/';
              }
            }
          }

          if (clean_url != url) {
            // they are different, sanity checks
            if (CliqzHumanWeb.isSuspiciousURL(clean_url) || CliqzHumanWeb.dropLongURL(clean_url)) return url;else return clean_url;
          } else return url;
        },
        fetchReferral: function fetchReferral(referral_url, callback) {

          _log$1("PPP in fetchReferral: " + referral_url);

          if (referral_url && referral_url != '') {
            if (CliqzHumanWeb.docCache[referral_url] == null) {
              CliqzHumanWeb.auxGetPageData(referral_url, null, null, function (referral_url) {
                _log$1("PPP in fetchReferral success auxGetPageData: " + referral_url);
                callback();
              }, function (referral_url) {
                _log$1("PPP in fetchReferral failure auxGetPageData: " + referral_url);
                callback();
              });
            } else {
              _log$1("PPP in fetchReferral already in docCache: " + referral_url);
              callback();
            }
          } else callback();
        },
        doubleFetch: function doubleFetch(url, page_doc) {
          // Need to add check for page MU.
          // one last validation whether should be fetchable or not. If we cannot send that URL because it's
          // private/suspicious/search_result page/etc. we can mark it as private directly

          var isok = true;

          if (page_doc == null || page_doc['x'] == null) {
            // this should not happen, but it does. Need to debug why the 'x' field gets lost
            // right now, let's set is a private to avoid any risk
            //
            isok = false;
          }

          if (page_doc && page_doc['x'] && page_doc['x']['iall'] == false) {
            // the url is marked as noindex
            isok = false;
          }

          // the url is suspicious, this should never be the case here but better safe
          //
          if (CliqzHumanWeb.isSuspiciousURL(url) == true) isok = false;

          if (CliqzHumanWeb.dropLongURL(url)) {
            _log$1("The url: " + url + " is long");

            if (page_doc && page_doc['x'] && page_doc['x']['canonical_url']) {
              // the url is to be drop, but it has a canonical URL so it should be public
              if (CliqzHumanWeb.dropLongURL(page_doc['x']['canonical_url'])) {
                // wops, the canonical is also bad, therefore mark as private
                _log$1("The canonical url: " + page_doc['x']['canonical_url'] + " is also long");
                isok = false;
              } else {
                // there we are in the good scenario in which canonical looks ok although
                // url did not
                isok = true;
              }
            } else {
              if (page_doc['isMU']) {
                isok = true;
              } else {
                isok = false;
              }
            }
          }

          if (isok) {
            _log$1("going to double-fetch: " + url);

            CliqzHumanWeb.auxGetPageData(url, page_doc, url, function (url, page_doc, original_url, data) {

              // data contains the public data of the url double-fetch,

              _log$1("success on doubleFetch, need further validation" + url);

              if (CliqzHumanWeb.validDoubleFetch(page_doc['x'], data, { 'structure_strict': false })) {

                //
                // If the double fetch is validated, we will now check for the iFrame and frameSets
                // Since we only need the telemetry for now, this seems to be the right place
                // we need to inject the page structure. The final event will have an extra key
                // nifshmatch : true / false , nfshmatch: true / false.,
                // nifshbf : Iframe count in struct_bef, nifshbf : framsetcount in before.
                // This key is added to both page_doc and data.
                //

                let nifshmatch = CliqzHumanWeb.validFrameCount(page_doc['x'], data);
                let nfshmatch = CliqzHumanWeb.validFrameSetCount(page_doc['x'], data);

                data.nifshmatch = nifshmatch;
                data.nfshmatch = nfshmatch;
                data.nifshbf = page_doc.x.nifsh;
                data.nfshbf = page_doc.x.nifsh;

                //
                // url, we should have the data of the double for the referral in CliqzHumanWeb.docCache
                //
                CliqzHumanWeb.fetchReferral(page_doc['ref'], function () {

                  var strict_value = CliqzHumanWeb.calculateStrictness(url, page_doc);

                  if (page_doc['ref'] && page_doc['ref'] != '') {
                    // the page has a referral
                    _log$1("PPP: page has a referral, " + url + " < " + page_doc['ref']);
                    var hasurl = CliqzHumanWeb.hasURL(page_doc['ref'], url);
                    _log$1("PPP: page has a referral, " + url + " < " + page_doc['ref'] + ">>>> " + hasurl);

                    // overwrite strict value because the link exists on a public fetchable page
                    if (hasurl) strict_value = false;
                  } else {
                    // page has no referral
                    _log$1("PPP: page has NO referral, " + url);

                    // we do not know the origin of the page, run the dropLongURL strict version, if
                    // there is no canonical or if there is canonical and is the same as the url,
                  }

                  _log$1("strict URL:" + url + " > " + strict_value);

                  if (CliqzHumanWeb.validDoubleFetch(page_doc['x'], data, { 'structure_strict': strict_value })) {

                    // we do not know the origin of the page, run the dropLongURL strict version

                    if (CliqzHumanWeb.dropLongURL(url, { 'strict': strict_value })) {
                      if (page_doc && page_doc['x'] && page_doc['x']['canonical_url']) {
                        if (CliqzHumanWeb.dropLongURL(page_doc['x']['canonical_url'], { 'strict': strict_value })) {
                          _log$1("doubleFetch failed on dropLongURL strict=true:" + url);
                          CliqzHumanWeb.setAsPrivate(url);
                          return;
                        }
                      } else {
                        _log$1("doubleFetch failed on dropLongURL strict=true:" + url);
                        CliqzHumanWeb.setAsPrivate(url);
                        return;
                      }
                    }
                  } else {
                    // the strict version of validDoubleFetch fails for a page with no referral,
                    // since we do not know the origin mark as private
                    _log$1("doubleFetch failed on structure_strict=true: " + url);
                    CliqzHumanWeb.setAsPrivate(url);
                    return;
                  }

                  _log$1("success on doubleFetch, need further validation");

                  //
                  // we need to modify the 'x' field of page_doc to substitute any structural information about
                  // the page content by the data coming from the doubleFetch (no session)
                  //

                  var first_url_double_fetched = url;

                  //
                  // we need to modify the 'x' field of page_doc to substitute any structural information about
                  // the page content by the data coming from the doubleFetch (no session)
                  //

                  // at this point we might have 3 different urls: url, page_doc['x']['canonical_url'] (either
                  // one of them has to have passed the dropLongURL test), and finally we also have data['canonical_url']
                  // (which has not passed the dropLongURL test). In principle, data['canonical_url']==page_doc['x']['canonical_url']
                  // but is not always the case, different calls can give different urls

                  if (data['canonical_url'] != null && data['canonical_url'] != '' && CliqzHumanWeb.dropLongURL(data['canonical_url']) == false) {
                    page_doc['url'] = data['canonical_url'];
                    page_doc['x'] = data;
                  } else {
                    if (page_doc['x']['canonical_url'] != null && page_doc['x']['canonical_url'] != '' && CliqzHumanWeb.dropLongURL(page_doc['x']['canonical_url']) == false) {
                      page_doc['url'] = page_doc['x']['canonical_url'];
                      page_doc['x'] = data;
                      page_doc['x']['canonical_url'] = page_doc['url'];
                    } else {
                      // there was no canonical either on page_doc['x'] or in data or it was droppable

                      if (CliqzHumanWeb.dropLongURL(url) == false) {
                        page_doc['url'] = url;
                        page_doc['x'] = data;

                        if (page_doc['x']['canonical_url'] != null && page_doc['x']['canonical_url'] != '') {
                          page_doc['x']['canonical_url'] = url;
                        }
                      } else {
                        // this should not happen since it would be covered by the isok checks, but better safe,
                        CliqzHumanWeb.setAsPrivate(url);
                        return;
                      }
                    }
                  }

                  var clean_url = CliqzHumanWeb.getCleanerURL(page_doc['url']);

                  if (clean_url != page_doc['url']) {
                    // we have a candidate for a cleaner url (without query_string) or without the last segment
                    // of the path, we want to double fetch it and if successful, then, we could replace the url
                    // because it would be cleaner hence safer
                    //

                    _log$1("going to clean_url double-fetch: " + clean_url);

                    CliqzHumanWeb.auxGetPageData(clean_url, page_doc, first_url_double_fetched, function (url, page_doc, original_url, data) {

                      _log$1("success on clean_url doubleFetch, need further validation");

                      if (CliqzHumanWeb.validDoubleFetch(page_doc['x'], data, { 'structure_strict': false })) {
                        // if it the second double fetch is valid, that means that the clean_url is (url parameter) is
                        // equivalent, so we can replace
                        page_doc['url'] = url;
                        page_doc['x'] = data;
                        CliqzHumanWeb.setAsPublic(original_url);
                        CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'page', 'payload': page_doc });
                      } else {
                        // the page with the clean_urls does not return the same, it can be two cases here, one is that
                        // the content is just totally different, in this case, we should send the page with the unclean_url,
                        // the other case is that the content is different but now we have passwords where we did not have before,
                        // in such a case, it's safer to assume that the fragments cleaned were identifiying a user, and the
                        // website is redirecting to the login page, in such a case, we should not send the page at all, in fact, we
                        // should mark it as private just to be sure,

                        if (CliqzHumanWeb.debug) {
                          _log$1("checking clean_url, page_doc: " + JSON.stringify(page_doc));
                          _log$1("checking clean_url, data: " + JSON.stringify(data));
                        }

                        if (page_doc['x']['nip'] < data['nip']) {
                          // the page with url_clean have more input password fields or more forms, this is dangerous,
                          _log$1("failure on checking the password and forms for clean_url: " + original_url + " set as private");
                          CliqzHumanWeb.setAsPrivate(original_url);
                        } else {
                          // safe, here we will send the url before clean_url
                          CliqzHumanWeb.setAsPublic(original_url);
                          CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'page', 'payload': page_doc });
                        }
                      }
                    }, function (url, page_doc, original_url, error_message) {
                      _log$1("failure on clean_url doubleFetch! " + "structure did not match");
                      // there was a failure, the clean_url does not go to the same place, therefore it's better
                      // not to replace

                      CliqzHumanWeb.setAsPublic(original_url);
                      CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'page', 'payload': page_doc });
                    });
                  } else {
                    CliqzHumanWeb.setAsPublic(original_url);
                    CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'page', 'payload': page_doc });
                  }
                });
              } else {
                _log$1("failure on doubleFetch! " + "structure did not match");
                CliqzHumanWeb.setAsPrivate(url);
              }
            }, function (url, page_doc, original_url, error_message) {
              _log$1("failure on doubleFetch! " + error_message);
              CliqzHumanWeb.setAsPrivate(url);
            });
          } else {
            _log$1("doubleFetch refused to process this url: " + url);
            CliqzHumanWeb.setAsPrivate(url);
          }
        },
        hasURL: function hasURL(source_url, target_url) {
          // the target_url is in the source_url

          try {

            var tt = CliqzHumanWeb.docCache[source_url];
            if (tt) {
              var cd = tt['doc'];
              if (!cd) {
                // fetch the content of the source_url,
                //
                _log$1("hasURL no CD!!! ");
                return false;
              }
            } else return false;

            var target_url_no_protocol = target_url.replace(/^http(s?)\:\/\//, '');
            var target_url_relative = null;
            try {
              var source_hostname = CliqzHumanWeb.parseURL(source_url).hostname;
              var target_hostname = CliqzHumanWeb.parseURL(target_url).hostname;
            } catch (ee) {
              return false;
            }

            if (source_hostname == target_hostname) {
              // same domain, path could be relative
              target_url_relative = '/';
              var v = target_url_no_protocol.split('/');
              if (v.length > 1) target_url_relative = '/' + v.slice(1, v.length).join('/');
            }

            //var html = cd.documentElement.innerHTML;
            //var ind1 = html.indexOf(target_url_no_protocol);
            var found = false;

            var links = cd.documentElement.getElementsByTagName('a');

            for (var i = 0; i < links.length; i++) {
              try {
                var link = links[i].href;
                link = link.replace(/^http(s?)\:\/\//, '');

                if (link == target_url_no_protocol) {
                  found = true;
                  break;
                } else {
                  if (target_url_relative && link == target_url_relative) {
                    found = true;
                    break;
                  }
                }
              } catch (ee) {}
            }

            return found;
          } catch (ee) {
            _log$1("Error on hasURL: " + ee);
            return false;
          }
        },
        getPageData: function getPageData(url, cd) {

          var len_html = null;
          var len_text = null;
          var title = null;
          var numlinks = null;
          var inputs = null;
          var inputs_nh = null;
          var inputs_pwd = null;
          var frames_same_host = null;
          var iframes_same_host = null;
          var frames = null;
          var forms = null;
          var pg_l = null;
          var metas = null;
          var tag_html = null;
          var iall = true;
          var all = null;
          var canonical_url = null;

          var url_host = null;
          var frame_host = null;

          let ourl = CliqzHumanWeb.parseURL(url);

          try {
            url_host = CliqzHumanWeb.parseURL(url).hostname;
          } catch (ee) {
            url_host = null;
          }

          try {
            len_html = cd.documentElement.innerHTML.length;
          } catch (ee) {}
          try {
            len_text = cd.documentElement.textContent.length;
          } catch (ee) {}
          try {
            title = cd.getElementsByTagName('title')[0].textContent;
          } catch (ee) {}
          //title = unescape(encodeURIComponent(title));

          try {
            numlinks = cd.getElementsByTagName('a').length;
          } catch (ee) {}
          try {
            inputs = cd.getElementsByTagName('input') || [];
            inputs_nh = 0;
            inputs_pwd = 0;
            for (var i = 0; i < inputs.length; i++) {
              if (inputs[i]['type'] && inputs[i]['type'] != 'hidden') inputs_nh += 1;
              if (inputs[i]['type'] && inputs[i]['type'] == 'password') inputs_pwd += 1;
            }
          } catch (ee) {}

          try {
            frames = cd.getElementsByTagName('frame') || [];
            frames_same_host = 0;
            for (var i = 0; i < frames.length; i++) {
              if (frames[i]['src']) {
                var tsrc = frames[i]['src'];
                if (frames[i]['src'].startsWith('//')) tsrc = 'http:' + frames[i]['src'];
                try {
                  frame_host = CliqzHumanWeb.parseURL(tsrc).hostname;
                  if (frame_host === url_host || frame_host == 'browser') frames_same_host++;
                } catch (ee) {
                  frames_same_host++;
                }
              }
            }
          } catch (ee) {}

          try {
            frames = cd.getElementsByTagName('iframe') || [];
            iframes_same_host = 0;
            for (var i = 0; i < frames.length; i++) {
              if (frames[i]['src']) {
                var tsrc = frames[i]['src'];
                if (frames[i]['src'].startsWith('//')) tsrc = 'http:' + frames[i]['src'];
                try {
                  frame_host = CliqzHumanWeb.parseURL(tsrc).hostname;
                  if (frame_host === url_host || frame_host == 'browser') iframes_same_host++;
                } catch (ee) {
                  iframes_same_host++;
                }
              }
            }
          } catch (ee) {}

          try {
            forms = cd.getElementsByTagName('form');
          } catch (ee) {}

          var metas = cd.getElementsByTagName('meta');

          // extract the language of th
          try {
            for (let i = 0; i < metas.length; i++) {
              if (metas[i].getAttribute("http-equiv") == "content-language" || metas[i].getAttribute("name") == "language") {
                pg_l = metas[i].getAttribute("content");
              }
            }

            if (pg_l == null) {
              tag_html = cd.getElementsByTagName('html');
              pg_l = tag_html[0].getAttribute("lang");
            }

            // Keep a tab on the length of pagel.
            if (pg_l) {
              if (pg_l.length > 10) {
                pg_l = null;
              }
            }
          } catch (ee) {}

          // Check if page is not allowed for indexing, by checking the no-index tag.
          let headTag = '';
          try {
            headTag = cd.querySelector('head');
            if (headTag) {
              let headContent = headTag.innerHTML.toLowerCase();
              if (headContent && headContent.indexOf('noindex') > -1) {
                iall = false;
              }
            }
          } catch (ee) {
            _log$1("no-index check failed " + ee);
          }

          // extract the canonical url if available
          var link_tag = cd.getElementsByTagName('link');
          for (var j = 0; j < link_tag.length; j++) {
            if (link_tag[j].getAttribute("rel") == "canonical") {
              canonical_url = link_tag[j].href;

              // This check is done because of misplaces titles on sites like 500px, youtube etc.
              // Since could not find a proper fix, hence dropping canonical URL looks like a safe idea.

              if (CliqzHumanWeb.can_url_match[canonical_url] && CliqzHumanWeb.can_url_match[canonical_url] != url) canonical_url = null;
            }
          }

          if (canonical_url != null && canonical_url.length > 0) {
            // check that canonical url is not relative.
            // Possible variations
            // ourl:
            // http://www.liceubarcelona.cat/ca/properament_2017/opera
            // curl:
            // ca/properament_2017/opera,
            // /liceubarcelona.cat/ca/properament_2017/opera
            // chrome://www.liceubarcelona.cat/ca/properament_2017/opera
            // //www.ghacks.net/

            if (canonical_url.startsWith('//')) {
              canonical_url = canonical_url.replace('//', '');
            }

            let _urlDetails = getDetailsFromUrl(canonical_url);
            if (_urlDetails.scheme.startsWith('chrome') || _urlDetails.scheme === '' || _urlDetails.name && !_urlDetails.tld) {
              canonical_url = `${ourl.protocol}:\/\/${ourl.hostname}${_urlDetails.path}`;
            }
          }

          // extract the location of the user (country level)
          try {
            var location = CliqzHumanWeb.getCountryCode();
          } catch (ee) {}

          var x = { 'lh': len_html, 'lt': len_text, 't': title, 'nl': numlinks, 'ni': (inputs || []).length, 'ninh': inputs_nh, 'nip': inputs_pwd, 'nf': (forms || []).length, 'pagel': pg_l, 'ctry': location, 'iall': iall, 'canonical_url': canonical_url, 'nfsh': frames_same_host, 'nifsh': iframes_same_host };

          return x;
        },
        getHTML(url) {
          // lazy load fallback urls
          /*
          var possibleUrls = [function (url) {
              console.log(">>>>> after 1" + url);
              return decodeURI(decodeURI(url));
          }, function (url) {
              return decodeURIComponent(url);
          }];
          */
          var possibleUrls = [];
          possibleUrls.push(tryDecodeURI$1(tryDecodeURI$1(url)));
          possibleUrls.push(tryDecodeURIComponent$1(url));

          function getDoc(url) {
            return getHTML(url).then(docs => {
              const doc = docs[0];
              if (doc) {
                return doc;
              } else {
                throw "not found";
              }
            }).catch(() => {
              const possibleUrl = possibleUrls.shift();
              if (possibleUrl) {
                const url = possibleUrl;
                return getDoc(url);
              } else {
                throw "not found";
              }
            });
          }

          return getDoc(url);
        },
        createDoc(html) {
          if (CliqzHumanWeb.domParser) {
            return Promise.resolve(CliqzHumanWeb.domParser.parseFromString(html, "text/html"));
          }

          return getWindowAPIAsync().then(wAPI => {
            CliqzHumanWeb.domParser = new wAPI.DOMParser();
            return CliqzHumanWeb.domParser.parseFromString(html, "text/html");
          });
        },
        getCD(url) {
          var _this = this;
          return CliqzHumanWeb.getHTML(url)
          // monkey patching the doc so it looks like regular document element
          .then(CliqzHumanWeb.createDoc);
        },
        listener: {
          tmpURL: undefined,

          onLocationChange: function onLocationChange(_ref3) {
            let isPrivate = _ref3.isPrivate,
                isLoadingDocument = _ref3.isLoadingDocument,
                url = _ref3.url,
                referrer = _ref3.referrer,
                frameId = _ref3.frameId;

            // New location, means a page loaded on the top window, visible tab
            // Return if it's a private tab.
            if (isPrivate) {
              return;
            }

            if (url === this.tmpURL) {
              return;
            }

            this.tmpURL = url;

            var requery = /\.google\..*?[#?&;]q=[^$&]+/; // regex for google query
            var yrequery = /.search.yahoo\..*?[#?&;]p=[^$&]+/; // regex for yahoo query
            var brequery = /\.bing\..*?[#?&;]q=[^$&]+/; // regex for yahoo query
            var reref = /\.google\..*?\/(?:url|aclk)\?/; // regex for google refurl
            var rerefurl = /url=(.+?)&/; // regex for the url in google refurl

            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActiveAll = CliqzHumanWeb.counter;

            var activeURL = CliqzHumanWeb.cleanCurrentUrl(url);

            //Check if the URL is know to be bad: private, about:, odd ports, etc.
            if (CliqzHumanWeb.isSuspiciousURL(activeURL)) {
              return;
            }

            if (activeURL.indexOf('about:') != 1) {

              if (CliqzHumanWeb.state['v'][activeURL] == null) {

                var se = CliqzHumanWeb.checkSearchURL(activeURL);
                if (se > -1) {
                  CliqzUtils.setTimeout(function (url) {
                    if (!CliqzHumanWeb) {
                      return;
                    }
                    CliqzHumanWeb.getCD(url).then(doc => {
                      CliqzHumanWeb.checkURL(doc, url, "normal");
                    });
                  }, CliqzHumanWeb.WAIT_TIME, activeURL);
                }

                var status = null;

                if (CliqzHumanWeb.httpCache[activeURL] != null) {
                  status = CliqzHumanWeb.httpCache[activeURL]['status'];
                }

                var referral = null;
                var qreferral = null;

                if (CliqzHumanWeb.linkCache[activeURL] != null) {
                  //referral = CliqzHumanWeb.maskURL(CliqzHumanWeb.linkCache[activeURL]['s']);
                  referral = CliqzHumanWeb.linkCache[activeURL]['s'];
                }

                //Get redirect chain
                var red = [];
                red = CliqzHumanWeb.getRedirects(activeURL, red);
                if (red.length == 0) {
                  red = null;
                }

                //Set referral for the first redirect in the chain.
                if (red && referral == null) {
                  var redURL = red[0];
                  var refURL = CliqzHumanWeb.linkCache[redURL];
                  if (refURL) {
                    referral = refURL['s'];
                  }

                  //Update query cache with the redirected URL

                  if (CliqzHumanWeb.queryCache[redURL]) {
                    CliqzHumanWeb.queryCache[activeURL] = CliqzHumanWeb.queryCache[redURL];
                  }
                }
                // Page details to be saved.
                CliqzHumanWeb.state['v'][activeURL] = {
                  url: activeURL,
                  a: 0,
                  x: null,
                  tin: new Date().getTime(),
                  e: {
                    cp: 0,
                    mm: 0,
                    kp: 0,
                    sc: 0,
                    md: 0
                  },
                  st: status,
                  c: [],
                  ref: referral,
                  red: red
                };

                if (referral) {
                  // if there is a good referral, we must inherit the query if there is one
                  if (CliqzHumanWeb.state['v'][referral] && CliqzHumanWeb.state['v'][referral]['qr']) {
                    CliqzHumanWeb.state['v'][activeURL]['qr'] = {};
                    CliqzHumanWeb.state['v'][activeURL]['qr']['q'] = CliqzHumanWeb.state['v'][referral]['qr']['q'];
                    CliqzHumanWeb.state['v'][activeURL]['qr']['t'] = CliqzHumanWeb.state['v'][referral]['qr']['t'];
                    CliqzHumanWeb.state['v'][activeURL]['qr']['d'] = CliqzHumanWeb.state['v'][referral]['qr']['d'] + 1;

                    //If the depth is greater then two, we need to check if the ref. is of same domain.
                    //If not then drop the QR object, else keep it.
                    if (CliqzHumanWeb.state['v'][activeURL]['qr']['d'] > 2) {
                      delete CliqzHumanWeb.state['v'][activeURL]['qr'];
                    } else if (CliqzHumanWeb.state['v'][activeURL]['qr']['d'] == 2) {
                      try {
                        if (CliqzHumanWeb.parseURL(activeURL)['hostname'] != CliqzHumanWeb.parseURL(referral)['hostname']) {
                          delete CliqzHumanWeb.state['v'][activeURL]['qr'];
                        }
                      } catch (ee) {
                        delete CliqzHumanWeb.state['v'][activeURL]['qr'];
                      }
                    }
                  }
                }

                CliqzUtils.setTimeout(function (currURL) {

                  // Extract info about the page, title, length of the page, number of links, hash signature,
                  // 404, soft-404, you name it
                  //


                  // we cannot get it directly via
                  // var cd = currWin.gBrowser.selectedBrowser.contentDocument;
                  // because during the time of the timeout there can be win or tab switching
                  //
                  //var activeURL = CliqzHumanWeb.currentURL();
                  //if (activeURL != currURL) {}

                  CliqzHumanWeb.getCD(currURL).then(function (cd) {

                    var se = CliqzHumanWeb.checkSearchURL(currURL);

                    if (se == -1) {
                      try {
                        CliqzHumanWeb.checkURL(cd, currURL, "normal");
                      } catch (e) {}
                      //Check active usage...
                      // CliqzHumanWeb.activeUsage += 1;
                      CliqzHumanWeb.incrActiveUsage();
                    }

                    var x = CliqzHumanWeb.getPageData(currURL, cd);

                    if (x['canonical_url']) {
                      CliqzHumanWeb.can_urls[currURL] = x['canonical_url'];
                      CliqzHumanWeb.can_url_match[x['canonical_url']] = currURL;
                    }

                    if (CliqzHumanWeb.state['v'][currURL] != null) {
                      CliqzHumanWeb.state['v'][currURL]['x'] = x;
                    }

                    if (CliqzHumanWeb.queryCache[currURL]) {
                      CliqzHumanWeb.state['v'][currURL]['qr'] = CliqzHumanWeb.queryCache[currURL];
                      delete CliqzHumanWeb.queryCache[currURL];
                    }

                    if (CliqzHumanWeb.state['v'][currURL] != null) {
                      CliqzHumanWeb.addURLtoDB(currURL, CliqzHumanWeb.state['v'][currURL]['ref'], CliqzHumanWeb.state['v'][currURL]);
                      CliqzHumanWeb.queryCache[currURL];
                    }
                  }, function () {
                    if (CliqzHumanWeb.debug) {
                      _log$1("CANNOT GET THE CONTENT OF : " + currURL);
                    }
                  }).catch(ee => {
                    _log$1("Error fetching title and length of page: " + ee + " : " + currURL);
                  });
                }, CliqzHumanWeb.PAGE_WAIT_TIME, activeURL);
              } else {
                // wops, it exists on the active page, probably it comes from a back button or back
                // from tab navigation
                CliqzHumanWeb.state['v'][activeURL]['tend'] = null;
                CliqzEvents.pub('HW-activeURL:', { activeURL });
              }
            }
          }
        },
        pacemaker: function pacemaker() {

          CliqzHumanWeb.currentURL().then(activeURL => {
            if (activeURL && activeURL.indexOf('about:') !== 0) {
              if (CliqzHumanWeb.counter - CliqzHumanWeb.lastActive < 5 * CliqzHumanWeb.tmult) {
                // if there has been an event on the last 5 seconds, if not do no count, the user must
                // be doing something else,
                //
                try {
                  CliqzHumanWeb.state['v'][activeURL]['a'] += 1;
                } catch (ee) {}
              }
            }
          }).catch(e => {
            _log$1('Error fetching fetching the currentURL: ' + e);
          });

          /* We do not need this, so should can remove it.
          if ((activeURL==null) && ((CliqzHumanWeb.counter/CliqzHumanWeb.tmult) % 10 == 0)) {
              // this one is for when you do not have the page open, for instance, no firefox but console opened
              CliqzHumanWeb.pushAllData();
          }
          */

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % 5 == 0) {

            CliqzHumanWeb.getAllOpenPages().then(openPages => {
              var tt = new Date().getTime();

              for (var url in CliqzHumanWeb.state['v']) {
                if (CliqzHumanWeb.state['v'].hasOwnProperty(url)) {

                  if (openPages.indexOf(url) == -1) {
                    // not opened

                    if (CliqzHumanWeb.state['v'][url]['tend'] == null) {
                      CliqzHumanWeb.state['v'][url]['tend'] = tt;
                    }

                    if (tt - CliqzHumanWeb.state['v'][url]['tend'] > CliqzHumanWeb.deadFiveMts * 60 * 1000) {
                      // move to "dead pages" after 5 minutes
                      CliqzHumanWeb.state['m'].push(CliqzHumanWeb.state['v'][url]);
                      CliqzHumanWeb.addURLtoDB(url, CliqzHumanWeb.state['v'][url]['ref'], CliqzHumanWeb.state['v'][url]);
                      delete CliqzHumanWeb.state['v'][url];
                      delete CliqzHumanWeb.queryCache[url];
                    }
                  } else {
                    // stil opened, do nothing.
                    if (tt - CliqzHumanWeb.state['v'][url]['tin'] > CliqzHumanWeb.deadTwentyMts * 60 * 1000) {
                      // unless it was opened more than 20 minutes ago, if so, let's move it to dead pages

                      CliqzHumanWeb.state['v'][url]['tend'] = null;
                      CliqzHumanWeb.state['v'][url]['too_long'] = true;
                      CliqzHumanWeb.state['m'].push(CliqzHumanWeb.state['v'][url]);
                      CliqzHumanWeb.addURLtoDB(url, CliqzHumanWeb.state['v'][url]['ref'], CliqzHumanWeb.state['v'][url]);
                      delete CliqzHumanWeb.state['v'][url];
                      delete CliqzHumanWeb.queryCache[url];
                      //_log("Deleted: moved to dead pages after 20 mts.");
                      //_log("Deleted: moved to dead pages after 20 mts: " + CliqzHumanWeb.state['m'].length);
                    }
                  }
                }
              }
            }).catch(ee => {
              _log$1(ee);
            });
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % 10 == 0) {
            let counter = CliqzHumanWeb.counter;
            CliqzHumanWeb.currentURL().then(activeURL => {
              _log$1('Pacemaker: ' + counter / CliqzHumanWeb.tmult + ' ' + activeURL);
            }).catch(e => {
              _log$1('Error fetching fetching the currentURL: ' + e);
            });

            CliqzHumanWeb.cleanHttpCache();
            CliqzHumanWeb.cleanDocCache();
            CliqzHumanWeb.cleanLinkCache();
            CliqzHumanWeb.purgeAdLookUp();
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (1 * 60) == 0) {
            // every minute
            CliqzHumanWeb.listOfUnchecked(1, CliqzHumanWeb.doubleFetchTimeInSec, null, CliqzHumanWeb.processUnchecks);
            CliqzHumanWeb.auxGetQuery();
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % 10 == 0) {
            var ll = CliqzHumanWeb.state['m'].length;
            if (ll > 0) {
              var v = CliqzHumanWeb.state['m'].slice(0, ll);
              CliqzHumanWeb.state['m'] = CliqzHumanWeb.state['m'].slice(ll, CliqzHumanWeb.state['m'].length);
            }
            if (!CliqzHumanWeb.bloomFilter) {
              CliqzHumanWeb.loadBloomFilter();
            }
          }

          //Load ts config
          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 20 * 1) == 0) {
            if (CliqzHumanWeb.debug) {
              _log$1('Load ts config');
            }
            CliqzHumanWeb.expireQuorumBloomFilter();
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 20 * 1) == 0) {
            if (CliqzHumanWeb.debug) {
              _log$1('Check if alive');
            }
            CliqzHumanWeb.checkActiveUsage();
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 20 * 1) == 0) {
            if (CliqzHumanWeb.debug) {
              _log$1('Save actions stats');
            }
            CliqzHumanWeb.saveActionStats();
            CliqzHumanWeb.sendActionStatsIfNeeded();
          }

          // To avoid sending duplicate call when extension starts, it's already in init.
          if (CliqzHumanWeb.counter > 10 && CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 20 * 1) == 0) {
            CliqzHumanWeb.fetchSafeQuorumConfig();
          }

          CliqzHumanWeb.counter += 1;
        },
        cleanUserTransitions: function cleanUserTransitions(force) {
          for (var query in CliqzHumanWeb.userTransitions['search']) {
            if (force || CliqzHumanWeb.counter - CliqzHumanWeb.userTransitions['search'][query]['time'] > CliqzHumanWeb.userTransitionsSearchSession * CliqzHumanWeb.tmult) {

              // the query session is more than 5 minutes old or we are forcing the event,
              // if the condition is met and there are more than two elements in data we
              // must create the signal
              //
              if (CliqzHumanWeb.userTransitions['search'][query]['data'].length > 1) {
                try {
                  var location = CliqzHumanWeb.getCountryCode();
                } catch (ee) {}
                var doc = { 'q': query, 'sources': CliqzHumanWeb.userTransitions['search'][query]['data'], 'ctry': location };
                if (CliqzHumanWeb.debug) {
                  _log$1(JSON.stringify(doc, undefined, 2));
                }
                CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'userTransition.search', 'payload': doc });
              }
              delete CliqzHumanWeb.userTransitions['search'][query];
            }
          }
        },
        pushAllData: function pushAllData() {

          // force send user Transitions sessions even if not elapsed because the browser is shutting down
          CliqzHumanWeb.cleanUserTransitions(true);

          var tt = new Date().getTime();
          var res = [];
          for (var url in CliqzHumanWeb.state['v']) {
            if (CliqzHumanWeb.state['v'][url]) res.push(url);
          }

          for (var i = 0; i < res.length; i++) {
            // move all the pages to m set
            var url = res[i];
            if (CliqzHumanWeb.state['v'][url]) {
              if (CliqzHumanWeb.state['v'][url]['tend'] == null) {
                CliqzHumanWeb.state['v'][url]['tend'] = tt;
              }
              CliqzHumanWeb.addURLtoDB(url, CliqzHumanWeb.state['v'][url]['ref'], CliqzHumanWeb.state['v'][url]);
              CliqzHumanWeb.state['m'].push(CliqzHumanWeb.state['v'][url]);
              delete CliqzHumanWeb.state['v'][url];
              delete CliqzHumanWeb.queryCache[url];
            }
          }

          // send them to telemetry if needed
          var ll = CliqzHumanWeb.state['m'].length;
          if (ll > 0) {
            var v = CliqzHumanWeb.state['m'].slice(0, ll);
            CliqzHumanWeb.state['m'] = CliqzHumanWeb.state['m'].slice(ll, CliqzHumanWeb.state['m'].length);
            CliqzHumanWeb.pushTelemetry();
          }
        },
        unload: function unload() {
          //Check is active usage, was sent
          CliqzHumanWeb.checkActiveUsage();
          // send all the data
          CliqzHumanWeb.pushTelemetry();

          if (CliqzHumanWeb.pacemakerId) {
            CliqzUtils.clearTimeout(CliqzHumanWeb.pacemakerId);
            CliqzHumanWeb.pacemakerId = undefined;
          }
          if (CliqzHumanWeb.trkTimer) {
            CliqzUtils.clearTimeout(CliqzHumanWeb.trkTimer);
            CliqzHumanWeb.trkTimer = undefined;
          }

          CliqzHumanWeb.patternsLoader.unload();
          CliqzHumanWeb.doublefetchHandler.unload();
        },
        currentURL: function currentURL() {
          return getActiveTab().then(_ref4 => {
            let url = _ref4.url;
            return CliqzHumanWeb.cleanCurrentUrl(url);
          });
        },
        cleanCurrentUrl: function cleanCurrentUrl(url) {
          try {
            url = decodeURIComponent(url.trim());
          } catch (ee) {}

          if (url != null || url != undefined) return url;else return null;
        },
        pacemakerId: null,
        // load from the about:config settings
        captureKeyPressPage: function captureKeyPressPage(ev) {
          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['keypresspage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              //_log('captureKeyPressPage');
            }
            CliqzHumanWeb.lastEv['keypresspage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['kp'] += 1;
            }
          }
        },
        captureMouseMovePage: function captureMouseMovePage(ev) {
          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['mousemovepage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              _log$1('captureMouseMovePage');
            }
            CliqzHumanWeb.lastEv['mousemovepage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['mm'] += 1;
            }
          }
        },
        getURLFromEvent: function getURLFromEvent(ev) {
          _log$1(">>>> Get url from event >>> " + ev.target.href);
          try {
            if (ev.target.href != null || ev.target.href != undefined) {
              return decodeURIComponent('' + ev.target.href);
            } else {
              if (ev.target.parentNode.href != null || ev.target.parentNode.href != undefined) {
                return decodeURIComponent('' + ev.target.parentNode.href);
              }
            }
          } catch (ee) {
            if (CliqzHumanWeb.debug) {
              _log$1('Error in getURLFromEvent: ' + ee);
            }
          }
          return null;
        },
        contextFromEvent: null,
        setContextFromEvent: function setContextFromEvent(ev) {
          try {
            var tar = ev.target;

            var found = false;
            var count = 0;
            var def_html = null;

            while (!found) {

              var html = tar.innerHTML;

              if (html.indexOf('http://') != -1 || html.indexOf('https://') != -1) {
                found = true;
                def_html = html;
                break;
              }

              tar = tar.parentNode;

              count += 1;
              if (count > 4) break;
            }

            if (found && def_html) {
              CliqzHumanWeb.contextFromEvent = { 'html': def_html, 'ts': new Date().getTime() };
            }
          } catch (ee) {
            CliqzHumanWeb.contextFromEvent = null;
          }
        },
        captureMouseClickPage: function captureMouseClickPage(ev, contextHTML, href) {

          // if the target is a link of type hash it does not work, it will create a new page without referral
          //

          var targetURL = CliqzHumanWeb.getURLFromEvent(ev) || href;

          _log$1('captureMouseClickPage>> ' + targetURL);
          if (contextHTML) {
            CliqzHumanWeb.contextFromEvent = {
              html: contextHTML,
              ts: Date.now()
            };
          } else {
            CliqzHumanWeb.contextFromEvent = null;
          }

          if (targetURL != null) {

            var embURL = CliqzHumanWeb.getEmbeddedURL(targetURL);
            if (embURL != null) targetURL = embURL;

            // Need to improve.
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.debug) {
              _log$1('captureMouseClickPage>> ' + CliqzHumanWeb.counter + ' ' + targetURL + ' : ' + " active: " + activeURL + " " + (CliqzHumanWeb.state['v'][activeURL] != null) + " " + ev.target + ' :: ' + ev.target.value + ' >>' + JSON.stringify(CliqzHumanWeb.lastEv));
            }

            if (CliqzHumanWeb.state['v'][activeURL] != null) {
              CliqzHumanWeb.linkCache[targetURL] = { 's': '' + activeURL, 'time': CliqzHumanWeb.counter };
              //Fix same link in 'l'
              //Only add if gur. that they are public and the link exists in the double fetch page(Public).it's available on the public page.Such
              //check is not done, therefore we do not push the links clicked on that page. - potential record linkage.
              //We need to check for redirections and use the final link for 'l' this is why the logic is here. This will
              //for sure miss the first time it's see, cause we don't know on mouse click where it redirects.

              var linkURL = targetURL;
              if (CliqzHumanWeb.httpCache[targetURL]) {
                if (CliqzHumanWeb.httpCache[targetURL]['status'] === 301) {
                  linkURL = CliqzHumanWeb.httpCache[targetURL]['location'];
                }
              }

              if (!CliqzHumanWeb.isSuspiciousURL(linkURL) && !CliqzHumanWeb.dropLongURL(linkURL)) {
                CliqzHumanWeb.isAlreadyMarkedPrivate(linkURL, function (_res) {
                  if (_res && _res['private'] == 0) {
                    CliqzHumanWeb.state['v'][activeURL]['c'].push({ 'l': '' + CliqzHumanWeb.maskURL(linkURL), 't': CliqzHumanWeb.counter });
                  } else if (!_res) {
                    CliqzHumanWeb.state['v'][activeURL]['c'].push({ 'l': '' + CliqzHumanWeb.maskURL(linkURL), 't': CliqzHumanWeb.counter });
                  }
                });
              }
            }
          }

          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['mouseclickpage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              _log$1('captureMouseClickPage');
            }
            CliqzHumanWeb.lastEv['mouseclickpage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['md'] += 1;
            }
          }
        },
        captureScrollPage: function captureScrollPage(ev) {
          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['scrollpage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              _log$1('captureScrollPage ');
            }

            CliqzHumanWeb.lastEv['scrollpage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['sc'] += 1;
            }
          }
        },
        captureCopyPage: function captureCopyPage(ev) {
          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['copypage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              _log$1('captureCopyPage');
            }
            CliqzHumanWeb.lastEv['copypage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['cp'] += 1;
            }
          }
        },
        counter: 0,
        tmult: 4,
        tpace: 250,
        lastEv: {},
        lastActive: null,
        lastActiveAll: null,

        doublefetchHandler: new DoublefetchHandler(),

        init: function init() {
          return Promise.resolve().then(() => {
            if (CliqzUtils.getPref("humanWebOptOut", false)) {
              return;
            }

            CliqzUtils.hw = this;

            refineFuncMappings = {
              "splitF": CliqzHumanWeb.refineSplitFunc,
              "parseU": CliqzHumanWeb.refineParseURIFunc,
              "maskU": CliqzHumanWeb.refineMaskUrl
            };

            _log$1("Init function called:");
            CliqzHumanWeb.log = _log$1;
            return Promise.resolve().then(() => {
              if (CliqzHumanWeb.db) {
                _log$1('Closing database connections...');
                return CliqzHumanWeb.db.asyncClose().then(() => {
                  CliqzHumanWeb.db = undefined;
                  _log$1('Closing database connections...done');
                }).catch(e => _log$1(e));
              } else {
                return Promise.resolve();
              }
            }).then(() => {
              const db = new Storage$2(CliqzHumanWeb);
              return db.init().then(() => {
                CliqzHumanWeb.db = db;
                _log$1('Successfully connected to database');
              });
            }).then(() => {
              CliqzHumanWeb.dns = new dns(CliqzHumanWeb);
              if (CliqzHumanWeb.state == null) {
                CliqzHumanWeb.state = {};
              }

              if (CliqzHumanWeb.actionStats == null) {
                CliqzHumanWeb.loadActionStats();
              }
              if (CliqzHumanWeb.actionStatsLastSent == null) {
                CliqzHumanWeb.loadActionStatsLastSent();
              }

              // Load bloom filter
              if (!CliqzHumanWeb.bloomFilter) {
                CliqzHumanWeb.loadBloomFilter();
              }

              // Load strict queries
              CliqzHumanWeb.loadStrictQueries();

              const promises = [];

              promises.push(CliqzHumanWeb.patternsLoader.init());
              promises.push(CliqzHumanWeb.doublefetchHandler.init());

              // Load config from the backend
              promises.push(CliqzHumanWeb.fetchSafeQuorumConfig());

              // Load quorum bloom filter
              CliqzHumanWeb.loadQuorumBloomFilter();

              // Load active usage stats.
              if (CliqzHumanWeb.activeUsage === null) {
                CliqzHumanWeb.db.loadRecordTelemetry('activeUsage', data => {
                  if (data === null) {
                    CliqzHumanWeb.activeUsage = {};
                  } else {
                    CliqzHumanWeb.activeUsage = JSON.parse(data);
                  }
                });
              }

              // Check last alive signal sent.
              CliqzHumanWeb.db.loadRecordTelemetry('activeUsageLastSent', data => {
                if (data === null) {
                  // Means we have never sent the signal.
                  CliqzHumanWeb.saveActiveUsageTime();
                } else {
                  _log$1(`Active usage last sent  from db as ${data}`);
                  CliqzHumanWeb.activeUsageLastSent = parseInt(data);
                }
              });

              return Promise.all(promises).then(() => {
                if (CliqzHumanWeb.pacemakerId == null) {
                  CliqzHumanWeb.pacemakerId = CliqzUtils.setInterval(CliqzHumanWeb.pacemaker, CliqzHumanWeb.tpace, null);
                }
              });
            });
          });
        },
        state: { 'v': {}, 'm': [], '_id': Math.floor(Math.random() * 1000) },
        hashCode: function hashCode(s) {
          return s.split("").reduce(function (a, b) {
            a = (a << 5) - a + b.charCodeAt(0);return a & a;
          }, 0);
        },
        msgSanitize: function msgSanitize(msg) {

          //Check and add time , else do not send the message
          msg.channel = CliqzHumanWeb.CHANNEL;

          // Applying '--' , instead of null;
          msg.ts = CliqzHumanWeb.getTS();

          if (!msg.ts || msg.ts == '') {
            return null;
          }

          // Adding anti-duplicate key, so to detect duplicate messages on the backend.
          msg['anti-duplicates'] = Math.floor(random() * 10000000);

          if (msg.action == 'page') {
            if (msg.payload.tend && msg.payload.tin) {
              var duration = msg.payload.tend - msg.payload.tin;
              _log$1("Duration spent: " + msg.payload.tend + " : " + msg.payload.tin + " : " + duration);
            } else {
              var duration = null;
              _log$1("Duration spent: " + msg.payload.tend + " : " + msg.payload.tin + " : " + duration);
            }

            msg.payload['dur'] = duration;

            delete msg.payload.tend;
            delete msg.payload.tin;

            // Check for fields which have urls like ref.
            // Check if they are suspicious.
            // Check if they are marked private.
            if (msg.payload.ref) {
              if (CliqzHumanWeb.isSuspiciousURL(msg.payload['ref'])) {
                msg.payload['ref'] = null;
              } else {
                msg.payload['ref'] = CliqzHumanWeb.maskURL(msg.payload['ref']);
              }

              // Check if ref. exists in bloom filter, then turn ref to null.
              CliqzHumanWeb.isAlreadyMarkedPrivate(msg.payload.ref, function (_res) {
                if (_res) {
                  if (_res['private'] == 1) {
                    msg.payload['ref'] = null;
                  }
                }
              });
            }

            // Check for title.
            if (msg.payload.x.t) {
              if (CliqzHumanWeb.isSuspiciousTitle(msg.payload.x.t)) {
                _log$1("Suspicious Title: " + msg.payload.x.t);
                return null;
              }
            } else {
              _log$1("Missing Title: " + msg.payload.x.t);
              return null;
            }

            // Remove C
            if (msg.payload.c) {
              msg.payload.c = null;
            }

            if (CliqzHumanWeb.dropLongURL(msg.payload.url) == true) {
              // the url is not safe, replace by the canonical if exists and is safe
              var canonical_url = msg.payload.x.canonical_url;

              if (canonical_url != null && canonical_url != '' && CliqzHumanWeb.dropLongURL(canonical_url) == false) {
                // the canonical exists and is ok
                msg.payload.url = canonical_url;
              } else {
                _log$1("Suspicious url with no/bad canonical: " + msg.payload.url);
                return null;
              }
            } else {
              var canonical_url = msg.payload.x.canonical_url;
              if (canonical_url != null && canonical_url != '' && CliqzHumanWeb.dropLongURL(canonical_url) == true) {
                // the canonical is not safe, but the url is, remove only the canonical
                msg.payload.x.canonical_url = null;
              }
            }

            // validate that is not a shortener url, they are not useful anyway

            var short_url = CliqzHumanWeb.isShortenerURL(msg.payload.url);
            var short_canonical_url = false;
            if (msg.payload.x.canonical_url != null && msg.payload.x.canonical_url != '') {
              short_canonical_url = CliqzHumanWeb.isShortenerURL(msg.payload.x.canonical_url);
            }

            if (short_url || short_canonical_url) return null;

            // check if suspiciousURL
            if (CliqzHumanWeb.isSuspiciousURL(msg.payload.url)) return null;

            if (msg.payload.x.canonical_url != null && msg.payload.x.canonical_url != '') {
              if (CliqzHumanWeb.isSuspiciousURL(msg.payload.x.canonical_url)) return null;
            }

            //Mask the long ugly redirect URLs
            if (msg.payload.red) {
              var cleanRed = [];
              msg.payload.red.forEach(function (e) {
                if (!CliqzHumanWeb.isSuspiciousURL(e)) {
                  cleanRed.push(CliqzHumanWeb.maskURL(e));
                }
              });
              msg.payload.red = cleanRed;
            }

            // Check for canonical seen or not.
            if (msg.payload['x']['canonical_url']) {
              if (msg.payload['url'] == msg.payload['x']['canonical_url']) {
                _log$1("Canoncial is same: ");
                // canonicalSeen = CliqzHumanWeb.canoincalUrlSeen(msg.payload['x']['canonical_url']);
                if (msg.payload['csb'] && msg.payload['ft']) {
                  _log$1("Canoncial seen before: ");
                  delete msg.payload.csb;
                  delete msg.payload.ft;
                }
              }

              // if the url is not replaces by canonical then also clear the csb key.
              if (msg.payload['csb']) delete msg.payload.csb;
            }
          }

          //Check the depth. Just to be extra sure.

          if (msg.payload.qr) {
            if (msg.payload.qr.d > 2) {
              delete msg.payload.qr;
            }
          }

          // Check if qr.q is suspicious.
          if (msg.payload.qr) {
            if (CliqzHumanWeb.isSuspiciousQuery(msg.payload.qr.q)) {
              delete msg.payload.qr;
            }
          }

          //Check for doorway action durl
          if (msg.action == 'doorwaypage') {
            if (CliqzHumanWeb.isSuspiciousURL(msg.payload['durl']) || CliqzHumanWeb.isSuspiciousURL(msg.payload['url'])) {
              return null;
            }
            if (CliqzHumanWeb.dropLongURL(msg.payload['durl']) || CliqzHumanWeb.dropLongURL(msg.payload['url'])) {
              return null;
            }
          }

          //Remove the msg if the query is too long,

          if (msg.action == 'query' || msg.action == 'anon-query') {
            //Remove the msg if the query is too long,
            if (msg.payload.q == null || msg.payload.q == '') {
              return null;
            } else {
              if (CliqzHumanWeb.isSuspiciousQuery(msg.payload.q)) {
                return null;
              }
            }

            // We need to check the URLs for suspicious patterns,
            // Remove the suspicious URLs and limit them to 8 results.
            // Ensure reordering is done.
            if (msg.payload.r) {
              let cleanR = [];
              let newR = {};

              Object.keys(msg.payload.r).forEach(eachResult => {
                if (!CliqzHumanWeb.isSuspiciousURL(msg.payload.r[eachResult].u)) {
                  cleanR.push(msg.payload.r[eachResult]);
                }
              });
              // If after the check, the number of results is less than 8,
              // drop the message.

              if (cleanR.length < 8) return null;
              cleanR.slice(0, 8).forEach((each, idx) => {
                newR[idx] = each;
              });

              _log$1("Original: " + JSON.stringify(msg.payload.r));
              _log$1("New: " + JSON.stringify(newR));
              msg.payload.r = newR;
            }
          }

          return msg;
        },
        // ****************************
        // telemetry, PREFER NOT TO SHARE WITH utils for safety, blatant rip-off though
        // ****************************
        trk: [],
        trkTimer: null,
        notification: function notification(payload) {
          try {
            var location = CliqzHumanWeb.getCountryCode();
          } catch (ee) {}

          if (payload && typeof payload === 'object') {
            payload['ctry'] = location;
            CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'telemetry', 'payload': payload });
          } else {
            _log$1("Not a valid object, not sent to notification");
          }
        },
        telemetry: function telemetry(msg, instantPush) {
          if (!CliqzHumanWeb || //might be called after the module gets unloaded
          CliqzUtils.getPref('humanWebOptOut', false) || CliqzUtils.isPrivate(CliqzUtils.getWindow())) {
            return Promise.resolve();
          }

          // Sanitize message before doing the quorum check.
          msg.ver = CliqzHumanWeb.VERSION;
          msg = CliqzHumanWeb.msgSanitize(msg);
          _log$1("Message sanitized");

          if (msg) {
            // Check if host is private or not.
            return CliqzHumanWeb.isPublicDomain(msg).then(success => CliqzHumanWeb.safeQuorumCheck(msg), fail => Promise.reject("localcheck")).then(isSafe => {
              _log$1("Quorum consent ?" + isSafe);
              if (isSafe) {

                // Check and sanitize all other urls.
                return CliqzHumanWeb.quorumCheckOtherUrls(msg).then(msg => {
                  CliqzHumanWeb.incrActionStats(msg.action);
                  CliqzHumanWeb.trk.push(msg);
                  _log$1("Added to the queue");

                  CliqzUtils.clearTimeout(CliqzHumanWeb.trkTimer);
                  if (instantPush || CliqzHumanWeb.trk.length % 100 == 0) {
                    CliqzHumanWeb.pushTelemetry();
                  } else {
                    CliqzHumanWeb.trkTimer = CliqzUtils.setTimeout(CliqzHumanWeb.pushTelemetry, 60000);
                  }
                }).catch(err => _log$1("Error while checking other urls for quorum.: " + err));
              } else {
                // Send telemetry.
                _log$1("Dropping data as quorum check failed");
                CliqzHumanWeb.incrActionStats("droppedQC");
              }
            }).catch(err => {
              _log$1("Error while safe quorum check: " + err);
              CliqzHumanWeb.incrActionStats("dropped-" + err);
            });
          } else {
            _log$1("Message failed sanitization step");
          }
          return Promise.resolve();
        },
        _telemetry_req: null,
        _telemetry_sending: [],
        telemetry_MAX_SIZE: 500,
        pushTelemetry: function pushTelemetry() {
          if (CliqzHumanWeb._telemetry_req) return;

          // put current data aside in case of failure
          CliqzHumanWeb._telemetry_sending = CliqzHumanWeb.trk.splice(0);
          var data = JSON.stringify(CliqzHumanWeb._telemetry_sending);
          CliqzHumanWeb._telemetry_req = CliqzUtils.promiseHttpHandler('POST', CliqzUtils.SAFE_BROWSING, data, 60000, true);
          CliqzHumanWeb._telemetry_req.then(CliqzHumanWeb.pushTelemetryCallback);
          CliqzHumanWeb._telemetry_req.catch(CliqzHumanWeb.pushTelemetryError);
        },
        pushTelemetryCallback: function pushTelemetryCallback(req) {
          try {
            var response = JSON.parse(req.response);
            CliqzHumanWeb._telemetry_sending = [];
            CliqzHumanWeb._telemetry_req = null;
          } catch (e) {}
        },
        pushTelemetryError: function pushTelemetryError(req) {
          // pushTelemetry failed, put data back in queue to be sent again later
          CliqzHumanWeb.trk = CliqzHumanWeb._telemetry_sending.concat(CliqzHumanWeb.trk);

          // Remove some old entries if too many are stored, to prevent unbounded growth when problems with network.
          var slice_pos = CliqzHumanWeb.trk.length - CliqzHumanWeb.telemetry_MAX_SIZE + 100;
          if (slice_pos > 0) {
            CliqzHumanWeb.trk = CliqzHumanWeb.trk.slice(slice_pos);
          }

          CliqzHumanWeb._telemetry_sending = [];
          CliqzHumanWeb._telemetry_req = null;
        },
        // ************************ Database ***********************
        // source modules/CliqzHistory
        // *********************************************************
        auxSameDomain: function auxSameDomain(url1, url2) {
          try {
            var d1 = CliqzHumanWeb.parseURL(url1).hostname.replace('www.', '');
            var d2 = CliqzHumanWeb.parseURL(url2).hostname.replace('www.', '');
            return d1 == d2;
          } catch (ee) {
            return false;
          }
        },
        isAlreadyMarkedPrivate: function isAlreadyMarkedPrivate(url, callback) {
          var hash = cachedMD5(url).substring(0, 16);
          var r = null;
          if (CliqzHumanWeb.bloomFilter) {
            var sta = CliqzHumanWeb.bloomFilter.testSingle(hash);
            if (sta) {
              r = { "hash": hash, "private": 1 };
            } else {
              r = { "hash": hash, "private": 0 };
            }
          }
          callback(r);
        },
        parseHostname: function parseHostname(hostname) {
          var o = { 'hostname': null, 'username': '', 'password': '', 'port': null };

          var h = hostname;
          var v = hostname.split('@');
          if (v.length > 1) {
            var w = v[0].split(':');
            o['username'] = w[0];
            o['password'] = w[1];
            h = v[1];
          }

          v = h.split(':');
          if (v.length > 1) {
            o['hostname'] = v[0];
            o['port'] = parseInt(v[1]);
          } else {
            o['hostname'] = v[0];
            o['port'] = 80;
          }

          return o;
        },
        parseURL: function parseURL(url) {
          // username, password, port, path, query_string, hostname, protocol
          var o = {};

          var v = url.split('://');
          if (v.length >= 2) {

            o['protocol'] = v[0];
            var s = v.slice(1, v.length).join('://');
            v = s.split('/');

            // Check for hostname, if not present then return null.
            if (v[0] === '') return null;

            // Check if the hostname is invalid by checking for special characters.
            // Only special characters like - and _ are allowed.
            var hostnameRegex = /[?!@#\$\^\&*\)\(+=]/g;
            if (hostnameRegex.test(v[0])) return null;

            var oh = CliqzHumanWeb.parseHostname(v[0]);
            o['hostname'] = oh['hostname'];
            o['port'] = oh['port'];
            o['username'] = oh['username'];
            o['password'] = oh['password'];
            o['path'] = '/';
            o['query_string'] = null;

            if (v.length > 1) {
              s = v.splice(1, v.length).join('/');
              v = s.split('?');
              o['path'] = '/' + v[0];
              if (v.length > 1) {
                o['query_string'] = v.splice(1, v.length).join('?');
              }

              v = o['path'].split(';');
              o['path'] = v[0];
              if (v.length > 1) o['query_string'] = v.splice(1, v.length).join(';') + '&' + (o['query_string'] || '');

              v = o['path'].split('#');
              o['path'] = v[0];
              if (v.length > 1) o['query_string'] = v.splice(1, v.length).join('#') + '&' + (o['query_string'] || '');
            }
          } else {
            return null;
          }

          return o;
        },
        // to invoke in console: CliqzHumanWeb.listOfUnchecked(1000000000000, 0, null, function(x) {console.log(x)})
        forceDoubleFetch: function forceDoubleFetch(url) {
          CliqzHumanWeb.listOfUnchecked(1000000000000, 0, url, CliqzHumanWeb.processUnchecks);
        },

        /**
         * Update content extraction patterns with the latest one from the backend.
         */
        updateContentExtraction: function updateContentExtraction(patternConfig, ruleset) {
          CliqzHumanWeb.patterns[ruleset] = {
            searchEngines: patternConfig.searchEngines,
            extractRules: patternConfig.scrape,
            payloads: patternConfig.payloads,
            idMappings: patternConfig.idMapping,
            rArray: patternConfig.urlPatterns.map(x => new RegExp(x))
          };
        },

        checkForEmail: function checkForEmail(str) {
          if (str.match(/[a-z0-9\-_@]+(@|%40|%(25)+40)[a-z0-9\-_]+\.[a-z0-9\-_]/i) != null) return true;else return false;
        },
        checkForLongNumber: function checkForLongNumber(str, max_number_length) {

          var cstr = str.replace(/[^A-Za-z0-9]/g, '');

          var lcn = 0;
          var maxlcn = 0;
          var maxlcnpos = null;

          for (let i = 0; i < cstr.length; i++) {
            if (cstr[i] >= '0' && cstr[i] <= '9') lcn += 1;else {
              if (lcn > maxlcn) {
                maxlcn = lcn;
                maxlcnpos = i;
                lcn = 0;
              } else lcn = 0;
            }
          }

          if (lcn > maxlcn) {
            maxlcn = lcn;
            maxlcnpos = cstr.length;
            lcn = 0;
          } else lcn = 0;

          if (maxlcnpos != null && maxlcn > max_number_length) return cstr.slice(maxlcnpos - maxlcn, maxlcnpos);else return null;
        },
        checkURL: function checkURL(pageContent, url, ruleset) {
          const patterns = CliqzHumanWeb.patterns[ruleset];
          const rArray = patterns.rArray;
          const searchEngines = patterns.searchEngines;

          for (var i = 0; i < rArray.length; i++) {
            if (rArray[i].test(url)) {
              CliqzHumanWeb.extractContent(i, pageContent, url, ruleset);

              //Do not want to continue after search engines...
              if (searchEngines.indexOf('' + i) != -1) {
                return;
              }
              if (CliqzHumanWeb.debug) {
                _log$1('Continue further after search engines ');
              }
            }
          }
        },

        _checkSearchURL: function _checkSearchURL(url, ruleset) {
          const patterns = CliqzHumanWeb.patterns[ruleset];
          const searchEngines = patterns.searchEngines;
          const rArray = patterns.rArray;

          for (let i = 0; i < rArray.length; i++) {
            if (rArray[i].test(url)) {
              if (searchEngines.indexOf('' + i) != -1) {
                return i;
              }

              if (CliqzHumanWeb.debug) {
                _log$1(`Not search engine >>> url=${url}, i=${i}, searchEngines=${searchEngines}, ruleset=${ruleset}`);
              }
              return -1;
            }
          }

          return -1;
        },

        checkSearchURL: function checkSearchURL(url) {
          return CliqzHumanWeb._checkSearchURL(url, 'normal');
        },

        checkAnonSearchURL: function checkAnonSearchURL(url) {
          return CliqzHumanWeb._checkSearchURL(url, 'strict');
        },

        extractContent: function extractContent(ind, cd, url, ruleset) {
          var scrapeResults = {};
          var eventMsg = {};
          var key = "";
          var rule = "";

          const patterns = CliqzHumanWeb.patterns[ruleset];
          const rules = patterns.extractRules[ind];
          const payloadRules = patterns.payloads[ind];
          const idMappings = patterns.idMappings[ind];

          if (CliqzHumanWeb.debug) {
            _log$1('rules' + rules + ind);
          }
          var urlArray = [];
          var titleArray = [];
          for (key in rules) {
            var _keys = Object.keys(rules[key]);
            if (CliqzHumanWeb.debug) {
              _log$1('keys' + _keys);
            }
            var innerDict = {};
            _keys.forEach(function (each_key) {
              if (rules[key][each_key]['type'] == 'standard') {

                //Depending on etype, currently only supporting url. Maybe ctry too.
                if (rules[key][each_key]['etype'] == 'url') {
                  var qurl = url;
                  var functionsApplied = rules[key][each_key]['functionsApplied'] || null;
                  // Check if the value needs to be refined or not.
                  if (functionsApplied) {
                    qurl = functionsApplied.reduce(function (attribVal, e) {
                      if (refineFuncMappings.hasOwnProperty(e[0])) {
                        return refineFuncMappings[e[0]](attribVal, e[1], e[2]);
                      } else {
                        return attribVal;
                      }
                    }, qurl);
                  }
                  innerDict[each_key] = [qurl];
                }

                if (rules[key][each_key]['etype'] == 'ctry') {
                  try {
                    var location = CliqzHumanWeb.getCountryCode();
                  } catch (ee) {}
                  innerDict[each_key] = [location];
                }
              } else if (rules[key][each_key]['type'] == 'searchQuery') {
                urlArray = CliqzHumanWeb._getAttribute(cd, key, rules[key][each_key]['item'], rules[key][each_key]['etype'], rules[key][each_key]['keyName'], rules[key][each_key]['functionsApplied'] || null);
                innerDict[each_key] = urlArray;
                if (ruleset === 'normal') {
                  _log$1("Populating query Cache <<<<  " + url + " >>>> " + urlArray[0]);

                  // Pass it to save strict queries.
                  CliqzHumanWeb.addStrictQueries(url, urlArray[0]);

                  CliqzHumanWeb.queryCache[url] = {
                    d: 0,
                    q: urlArray[0],
                    t: idMappings
                  };
                } else {
                  urlArray = CliqzHumanWeb._getAttribute(cd, key, rules[key][each_key]['item'], rules[key][each_key]['etype'], rules[key][each_key]['keyName'], rules[key][each_key]['functionsApplied'] || null);
                  innerDict[each_key] = urlArray;
                }
              } else {
                urlArray = CliqzHumanWeb._getAttribute(cd, key, rules[key][each_key]['item'], rules[key][each_key]['etype'], rules[key][each_key]['keyName'], rules[key][each_key]['functionsApplied'] || null);
                innerDict[each_key] = urlArray;
              }
            });

            if (CliqzHumanWeb.messageTemplate[ind]) {
              CliqzHumanWeb.messageTemplate[ind][key] = innerDict;
            } else {
              CliqzHumanWeb.messageTemplate[ind] = {};
              CliqzHumanWeb.messageTemplate[ind][key] = innerDict;
            }

            //Check if array has values.
            var _mergeArr = CliqzHumanWeb.mergeArr(CliqzHumanWeb.messageTemplate[ind][key]);
            if (_mergeArr.length > 0) {
              scrapeResults[key] = _mergeArr;
            }
          }

          for (rule in payloadRules) {
            CliqzHumanWeb.createPayload(scrapeResults, ind, rule, ruleset);
          }
        },
        mergeArr: function mergeArr(arrS) {
          var messageList = [];
          var allKeys = [];
          allKeys = Object.keys(arrS);
          arrS[allKeys[0]].forEach(function (e, idx) {
            var innerDict = {};messageList.push(allKeys.map(function (e, _idx, arr) {
              innerDict[e] = arrS[e][idx];return innerDict;
            })[0]);
          });
          return messageList;
        },
        _getAttribute: function _getAttribute(cd, parentItem, item, attrib, keyName, functionsApplied) {
          var arr = [];
          var rootElement = Array.prototype.slice.call(cd.querySelectorAll(parentItem));
          for (var i = 0; i < rootElement.length; i++) {
            var val = rootElement[i].querySelector(item);
            if (val) {
              //Not Null
              var innerDict = {};
              var attribVal = val[attrib] || val.getAttribute(attrib);

              // Check if the value needs to be refined or not.
              if (functionsApplied) {
                attribVal = functionsApplied.reduce(function (attribVal, e) {
                  if (refineFuncMappings.hasOwnProperty(e[0])) {
                    return refineFuncMappings[e[0]](attribVal, e[1], e[2]);
                  } else {
                    return attribVal;
                  }
                }, attribVal);
              }
              arr.push(innerDict[keyName] = attribVal);
            } else {
              var innerDict = {};
              arr.push(innerDict[keyName] = val);
            }
          }
          return arr;
        },
        createPayload: function createPayload(scrapeResults, idx, key, ruleset) {
          try {
            const patterns = CliqzHumanWeb.patterns[ruleset];
            const payloadRules = patterns.payloads[idx][key];

            if (payloadRules['type'] == 'single' && payloadRules['results'] == 'single') {
              scrapeResults[key].forEach(function (e) {
                try {
                  var location = CliqzHumanWeb.getCountryCode();
                } catch (ee) {}
                e['ctry'] = location;
                CliqzHumanWeb.sendMessage(payloadRules, e);
              });
            } else if (payloadRules['type'] == 'single' && payloadRules['results'] == 'custom') {
              var payload = {};
              payloadRules['fields'].forEach(function (e) {
                try {
                  payload[e[1]] = scrapeResults[e[0]][0][e[1]];
                } catch (ee) {}
                CliqzHumanWeb.sendMessage(payloadRules, payload);
              });
            } else if (payloadRules['type'] == 'query' && payloadRules['results'] == 'clustered') {
              var payload = {};
              payloadRules['fields'].forEach(function (e) {
                if (e.length > 2) {
                  var joinArr = {};
                  for (var i = 0; i < scrapeResults[e[0]].length; i++) {
                    joinArr['' + i] = scrapeResults[e[0]][i];
                  }
                  payload[e[1]] = joinArr;
                } else {
                  payload[e[1]] = scrapeResults[e[0]][0][e[1]];
                }
              });
              CliqzHumanWeb.sendMessage(payloadRules, payload);
            } else if (payloadRules['type'] == 'query' && payloadRules['results'] == 'scattered') {
              var payload = {};
              payloadRules['fields'].forEach(function (e) {
                if (e.length > 2) {
                  var joinArr = {};
                  var counter = 0;
                  e[0].forEach(function (eachPattern) {
                    for (var i = 0; i < scrapeResults[eachPattern].length; i++) {
                      joinArr['' + counter] = scrapeResults[eachPattern][i];
                      counter += 1;
                    }
                  });
                  if (Object.keys(joinArr).length > 0) {
                    payload[e[1]] = joinArr;
                  }
                } else {
                  payload[e[1]] = scrapeResults[e[0]][0][e[1]];
                }
              });
              CliqzHumanWeb.sendMessage(payloadRules, payload);
            }
          } catch (ee) {
            if (CliqzHumanWeb.debug) {
              _log$1(`createPayload failed: ${ee}`);
            }
          }
        },
        sendMessage: function sendMessage(payloadRules, payload) {
          if (CliqzHumanWeb.debug) {
            _log$1("sendMessage");
          }
          var c = true;
          var e = "";
          var allKeys = Object.keys(payload);
          for (e in payloadRules['fields']) {
            if (allKeys.indexOf(payloadRules['fields'][e][1]) == -1) {
              c = false;
            } else {
              allKeys.forEach(function (each_field) {
                if (!payload[each_field]) {
                  c = false;
                }
              });
            }
          }
          if (c) {
            CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': payloadRules['action'], 'payload': payload });
          }
          CliqzHumanWeb.messageTemplate = {};
        },
        refineSplitFunc: function refineSplitFunc(splitString, splitON, arrPos) {
          var result = splitString.split(splitON)[arrPos];
          if (result) {
            return decodeURIComponent(result);
          } else {

            return decodeURIComponent(splitString);
          }
        },
        refineParseURIFunc: function refineParseURIFunc(url, extractType, keyName) {
          var urlParts = CliqzHumanWeb.parseURL(url);
          if (urlParts && urlParts.query_string) {
            var result = CliqzHumanWeb.parseQueryString(urlParts.query_string);
            if (extractType == 'qs') {
              if (result[keyName]) {
                return decodeURIComponent(result[keyName][0]);
              } else {
                return url;
              }
            }
          } else {
            return url;
          }
        },
        refineReplaceFunc: function refineReplaceFunc(replaceString, replaceWhat, replaceWith) {
          var result = decodeURIComponent(replaceString.replace("", replaceWhat, replaceWith));
          return result;
        },
        refineMaskUrl: function refineMaskUrl(url) {
          var result = CliqzHumanWeb.maskURL(url);
          return result;
        },
        aggregateMetrics: function aggregateMetrics(metricsBefore, metricsAfter) {
          var aggregates = { "cp": 0, "mm": 0, "kp": 0, "sc": 0, "md": 0 };
          if (CliqzHumanWeb.debug) {
            _log$1("aggregates: " + JSON.stringify(metricsBefore) + JSON.stringify(metricsAfter));
          }

          var _keys = Object.keys(aggregates);
          for (var i = 0; i < _keys.length; i++) {
            aggregates[_keys[i]] = metricsBefore[_keys[i]] + metricsAfter[_keys[i]];
          }
          if (CliqzHumanWeb.debug) {
            _log$1("aggregates: " + JSON.stringify(aggregates));
          }

          return aggregates;
        },
        isSuspiciousTitle: function isSuspiciousTitle(title) {
          // 1. Need to check if the title is suspicious or not.
          // 2. Title should should not contain number greater than 8.
          // 3. Title should not contain html.

          if (title.length > 500) return true;
          var vt = title.split(' ');
          for (var i = 0; i < vt.length; i++) {
            if (vt[i].length > CliqzHumanWeb.rel_segment_len) {
              var cstr = vt[i].replace(/[^A-Za-z0-9]/g, '');
              if (cstr.length > CliqzHumanWeb.rel_segment_len) {
                if (CliqzHumanWeb.isHash(cstr)) return true;

                var pp = CliqzHumanWeb.isHashProb(cstr.toLowerCase());
                if (pp < CliqzHumanWeb.probHashThreshold * 1.5) {
                  return true;
                }
              }
            }
            var cstr = vt[i].replace(/[^A-Za-z0-9]/g, '');
            if (CliqzHumanWeb.checkForLongNumber(cstr, 8) != null) {
              return true;
            }

            if (CliqzHumanWeb.checkForEmail(cstr)) {
              return true;
            }

            if (/<[^<]+>/.test(cstr)) {
              return true;
            }
          }

          if (CliqzHumanWeb.checkForLongNumber(title, 8) != null) {
            return true;
          }

          if (CliqzHumanWeb.checkForEmail(title)) {
            return true;
          }

          if (/<[^<]+>/.test(title)) {
            return true;
          }

          return false;
        },
        auxProbString: function auxProbString(h, p, s, c) {

          // h[i] = k : there are k bins (letter) with i balls (repetitions) on it,
          // h[2] = 1 : there is one letter that is repeated twice


          if (h[1] == s) {
            // recursion stop condition
            return 1.0;
          } else {
            var tot_p = 0.0;
            var kkp = 1.0;

            for (let i = h.length - 1; i > 1; i--) {
              if (h[i] != 0) {
                // it has repetitions,
                var pi = (h[i - 1] + 1) * p;
                var h2 = h.slice();

                h2[i] -= 1;

                if (false && h2[i] == 0 && h2[i - 1] == 0 && i > 1) {
                  // minimize number of recursions
                  h2[i - 1] += 1;

                  kkp = kkp * p;
                } else {
                  h2[i - 1] += 1;

                  var lab = h2.join('-');
                  if (!c[lab]) c[lab] = CliqzHumanWeb.auxProbString(h2, p, s, c);
                  tot_p += kkp * pi * c[lab];
                }
              }
            }

            return tot_p;
          }
        },
        probString: function probString(str) {

          var bins = {};

          for (let i = 0; i < str.length; i++) bins[str[i]] = (bins[str[i]] || 0) + 1;

          var keys = Object.keys(bins);

          var p = 1.0 / keys.length;
          var k = str.length - keys.length;

          var h = [];
          for (let i = 0; i < str.length + 1; i++) h[i] = 0;
          var s = 0;

          var max_freq = 0;
          for (let i = 0; i < keys.length + 1; i++) {
            var freq = bins[keys[i]];

            if (freq > 0) {
              h[bins[keys[i]]] += 1;
              s += 1;

              if (freq > max_freq) {
                max_freq = freq;
              }
            }
          }

          h = h.slice(0, max_freq + 1);

          var cache = {};
          var prob_conf = CliqzHumanWeb.auxProbString(h, p, s, cache);

          // probability of the string to be random, e.g. hash. Better to keep it for
          // strings > 15, lower probability means not random, > 0.25, random.

          return prob_conf;
        },
        isHashProb: function isHashProb(str) {

          var log_prob = 0.0;
          var trans_c = 0;
          str = str.replace(/[^A-Za-z0-9]/g, '');

          for (var i = 0; i < str.length - 1; i++) {

            var pos1 = CliqzHumanWeb.probHashChars[str[i]];
            var pos2 = CliqzHumanWeb.probHashChars[str[i + 1]];

            if (pos1 && pos2) {
              log_prob += CliqzHumanWeb.probHashLogM[pos1][pos2];
              trans_c += 1;
            }
          }

          if (trans_c > 0) return Math.exp(log_prob / trans_c);else return Math.exp(log_prob);
        },
        isHash: function isHash(str) {
          var p = CliqzHumanWeb.isHashProb(str);
          return p < CliqzHumanWeb.probHashThreshold;
        },
        parseQueryString: function parseQueryString(q) {
          /* parse the query */
          var x = q.replace(/;/g, '&').split('&'),
              i,
              name,
              t;

          /* q changes from string version of query to object */
          for (q = {}, i = 0; i < x.length; i++) {
            t = x[i].split('=', 2);
            name = unescape(t[0]);
            if (!q[name]) q[name] = [];
            if (t.length > 1) {
              q[name][q[name].length] = unescape(t[1]);
            }
            /* next two lines are nonstandard */
            else q[name][q[name].length] = true;
          }
          return q;
        },
        incrActiveUsage: function incrActiveUsage() {
          let t = CliqzHumanWeb.getTime();

          if (!CliqzHumanWeb.activeUsage.hasOwnProperty(t)) {
            CliqzHumanWeb.activeUsage[t] = 0;
          }
          CliqzHumanWeb.activeUsage[t] += 1;

          // Persist active usage count.
          CliqzHumanWeb.db.saveRecordTelemetry('activeUsage', JSON.stringify(CliqzHumanWeb.activeUsage), result => {
            _log$1("Active usage stats saved");
          });
        },
        checkActiveUsage: function checkActiveUsage() {
          /*
            This event is generated every 60 minutes to check a user
            was active or not. We treat the user to be active if in the
            last hour, the user visited two non search pages.
            Get the active usage from DB.
            hen generate & send payload.
            Update the time last sent, and reset the value to 0.
             Sample payload:
              {
              "action": "alive",
              "ver": "2.7",
              "type": "humanweb",
              "payload": {
              "status": true,
              "ctry": "de",
              "t": "2016110909"
              },
              "ts": "2016110909"
              }
          */

          const tDiff = parseInt((new Date().getTime() - CliqzHumanWeb.activeUsageLastSent) / 1000);
          if (tDiff > 3600) {
            const activeHours = Object.keys(CliqzHumanWeb.activeUsage);
            activeHours.forEach(h => {
              if (CliqzHumanWeb.activeUsage[h] > CliqzHumanWeb.activeUsageThreshold && h != CliqzHumanWeb.getTime()) {
                CliqzHumanWeb.sendAliveMessage(h);
                delete CliqzHumanWeb.activeUsage[h];
                CliqzHumanWeb.db.saveRecordTelemetry('activeUsage', JSON.stringify(CliqzHumanWeb.activeUsage), result => {
                  _log$1("Active usage stats saved");
                });
                CliqzHumanWeb.saveActiveUsageTime();
              }
            });
          }
        },
        sendAliveMessage: function sendAliveMessage(h) {
          const payload = {
            status: true,
            t: h,
            ctry: CliqzHumanWeb.getCountryCode() // Need to fix this.
          };

          _log$1(`Sending alive message for the hour: ${h} , ${JSON.stringify(payload)}`);

          CliqzHumanWeb.telemetry({
            type: CliqzHumanWeb.msgType,
            action: 'alive',
            payload: payload
          });
        },
        loadActionStats: function loadActionStats() {
          CliqzHumanWeb.db.loadRecordTelemetry('actionStats', function (data) {
            if (data == null) {
              _log$1("There was no data on action stats");
              CliqzHumanWeb.actionStats = {};
            } else {
              try {
                CliqzHumanWeb.actionStats = JSON.parse(data);
              } catch (ee) {
                CliqzHumanWeb.actionStats = {};
              }
            }
          });
        },
        loadActionStatsLastSent: function loadActionStatsLastSent() {
          CliqzHumanWeb.db.loadRecordTelemetry('actionStats_last_send', function (data) {
            if (data == null) {
              _log$1("There was no data on CliqzHumanWeb.actionstats");
              CliqzHumanWeb.actionStatsLastSent = CliqzHumanWeb.getTime().slice(0, 8);
              CliqzHumanWeb.saveActionStatsLastSent();
            } else CliqzHumanWeb.actionStatsLastSent = data;
          });
        },
        incrActionStats: function incrActionStats(action) {
          if (!CliqzHumanWeb.actionStats) return;
          if (CliqzHumanWeb.actionStats[action] == null) CliqzHumanWeb.actionStats[action] = 0;
          if (CliqzHumanWeb.actionStats['total'] == null) CliqzHumanWeb.actionStats['total'] = 0;
          CliqzHumanWeb.actionStats[action]++;
          CliqzHumanWeb.actionStats['total']++;
        },
        saveActionStats: function saveActionStats() {
          if (CliqzHumanWeb.actionStats && Object.keys(CliqzHumanWeb.actionStats).length > 0) {
            CliqzHumanWeb.db.saveRecordTelemetry('actionStats', JSON.stringify(CliqzHumanWeb.actionStats), result => {
              _log$1(result);
            });
          }
        },
        saveActiveUsageTime: function saveActiveUsageTime() {
          let t = new Date().getTime();
          CliqzHumanWeb.db.saveRecordTelemetry('activeUsageLastSent', t, result => {
            CliqzHumanWeb.activeUsageLastSent = t;
            _log$1(`Active usage last sent as ${t}`);
          });
        },
        sendActionStats: function sendActionStats() {
          var payl;
          if (CliqzHumanWeb.actionStats && Object.keys(CliqzHumanWeb.actionStats).length > 0) {
            payl = { 'data': CliqzHumanWeb.actionStats };

            CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'hw.telemetry.actionstats', 'payload': payl });

            // reset the state
            CliqzHumanWeb.actionStats = {};
            CliqzHumanWeb.saveActionStats();
          }
        },
        saveActionStatsLastSent: function saveActionStatsLastSent() {
          CliqzHumanWeb.db.saveRecordTelemetry('actionStats_last_send', CliqzHumanWeb.actionStatsLastSent, result => {
            _log$1(result);
          });
        },
        saveStrictQueries: function saveStrictQueries() {
          _log$1("Saving local table");
          CliqzHumanWeb.db.saveRecordTelemetry('localStrictQueries', JSON.stringify(CliqzHumanWeb.strictQueries), result => {
            _log$1(result);
          });
        },
        sendActionStatsIfNeeded: function sendActionStatsIfNeeded() {
          // Send action stats once per day.
          // Day resolution.
          var timestamp = CliqzHumanWeb.getTime().slice(0, 8);

          if (timestamp != CliqzHumanWeb.actionStatsLastSent) {
            // it's not the same timestamp (hour) of the last time that was sent
            // or the first install (defaults to current timestamp)

            CliqzHumanWeb.actionStatsLastSent = timestamp;
            CliqzHumanWeb.saveActionStatsLastSent();
            CliqzHumanWeb.sendActionStats();
          }
        },
        dumpBloomFilter: function dumpBloomFilter() {
          var bf = [].slice.call(CliqzHumanWeb.bloomFilter.buckets);
          if (bf) {
            CliqzHumanWeb.db.saveRecordTelemetry('bf', bf.join("|"), result => {
              _log$1(result);
            });
          }
        },
        loadBloomFilter: function loadBloomFilter() {
          CliqzHumanWeb.db.loadRecordTelemetry('bf', function (data) {
            if (data == null) {
              _log$1("There was no data on CliqzHumanWeb.bf");
              CliqzHumanWeb.bloomFilter = new CliqzBloomFilter.BloomFilter(Array(bloomFilterSize).join('0'), bloomFilterNHashes);
            } else {
              var _data = data.split("|").map(Number);
              CliqzHumanWeb.bloomFilter = new CliqzBloomFilter.BloomFilter(_data, bloomFilterNHashes);
            }
          });
        },
        loadStrictQueries: function loadStrictQueries() {
          CliqzHumanWeb.db.loadRecordTelemetry('localStrictQueries', function (data) {
            if (data == null || data.length == 0) {
              _log$1("There was no data on CliqzHumanWeb.bf");
              CliqzHumanWeb.strictQueries = [];
            } else {
              CliqzHumanWeb.strictQueries = JSON.parse(data);
            }
          });
        },
        auxGetQuery: function auxGetQuery() {
          CliqzHumanWeb.strictQueries.forEach(function (e, idx) {
            var t = Date.now();
            if (t - e.ts > e.tDiff * 60 * 1000) {
              CliqzHumanWeb.auxGetPageData(e.qurl, null, e.qurl, function (url, page_data, ourl, x) {
                let cd = CliqzHumanWeb.docCache[url]['doc'];
                CliqzHumanWeb.checkURL(cd, url, "strict");
              }, function (a, b, c, d) {
                _log$1("Error aux>>>> " + d);
              });
              CliqzHumanWeb.strictQueries.splice(idx, 1);
              CliqzHumanWeb.saveStrictQueries();
            }
          });
        },
        isSuspiciousQuery: function isSuspiciousQuery(query) {
          //Remove the msg if the query is too long,
          if (query.length > 50) return true;
          if (query.split(' ').length > 7) return true;

          // Remove the msg if the query contains a number longer than 7 digits
          // can be 666666 but also things like (090)90-2, 5555 3235
          // note that full dates will be removed 2014/12/12
          //
          var haslongnumber = CliqzHumanWeb.checkForLongNumber(query, 7);
          if (haslongnumber != null) return true;

          //Remove if email (exact), even if not totally well formed
          if (CliqzHumanWeb.checkForEmail(query)) return true;
          //Remove if query looks like an http pass
          if (/[^:]+:[^@]+@/.test(query)) return true;
          //Remove if email
          if (/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(query)) return true;

          var v = query.split(' ');
          for (let i = 0; i < v.length; i++) {
            if (v[i].length > 20) return true;
            if (/[^:]+:[^@]+@/.test(v[i])) return true;
            if (/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v[i])) return true;
          }

          if (query.length > 12) {

            var cquery = query.replace(/[^A-Za-z0-9]/g, '');

            if (cquery.length > 12) {
              var pp = CliqzHumanWeb.isHashProb(cquery);
              // we are a bit more strict here because the query
              // can have parts well formed
              if (pp < CliqzHumanWeb.probHashThreshold * 1.5) return true;
            }
          }
          return false;
        },
        isPublicDomain: function isPublicDomain(msg) {
          // We need to check for action page, if the URLs in the message
          // are not private because of local domains. like fritzbox or admin.example.com.

          let promise = new Promise(function (resolve, reject) {
            if (msg.action == 'page') {
              // Get all the urls in the payload.
              let urls = [];
              urls.push(msg.payload.url);
              if (msg.payload.ref) urls.push(msg.payload.ref);
              if (msg.payload.red) {
                msg.payload.red.forEach(redURL => {
                  urls.push(redURL);
                });
              }

              _log$1("All urls in the message:" + JSON.stringify(urls));

              // Check for each URL if the host is public or private,
              // If any of the host is private then it should resolve as true and exit.
              // Else should resolve as not private.

              Promise.all(urls.map(CliqzHumanWeb.isHostNamePrivate)).then(results => {
                _log$1(JSON.stringify(results));
                // Now that we have checked all the URLS, if any of the URL resulted as private
                // We drop the message.
                if (results.indexOf(true) > -1) {
                  _log$1("Contains private URL");
                  reject(false);
                } else {
                  _log$1("URLs are public");
                  resolve(true);
                }
              });
            } else {
              resolve(true);
            }
          });
          return promise;
        },
        isHostNamePrivate: function isHostNamePrivate(url) {
          let host;
          try {
            host = CliqzHumanWeb.parseURL(url).hostname;
          } catch (ee) {
            // If the parsing of the host fails for some reason,
            // we would mark it as private.
            return Promise.resolve(true);
          }

          if (!host) {
            return Promise.resolve(true);
          }

          // return getIP(host).then((address) => {
          return CliqzHumanWeb.dns.getDNS(host).then(address => {
            _log$1("Host= " + host + " Address: " + address);
            return CliqzHumanWeb.isIPInternal(address);
          }, () => false);
        },
        isIPInternal: function isIPInternal(ip) {
          // Need to check for ipv6.
          const ipSplit = ip.split(".");
          if (parseInt(ipSplit[0]) === 10 || parseInt(ipSplit[0]) === 172 && parseInt(ipSplit[1]) >= 16 && parseInt(ipSplit[1]) <= 31 || parseInt(ipSplit[0]) === 192 && parseInt(ipSplit[1]) === 168 || parseInt(ipSplit[0]) === 127 || parseInt(ipSplit[0]) === 0) {
            return true;
          } else {
            return false;
          }
        },
        sanitizeResultTelemetry: function sanitizeResultTelemetry(data) {
          /*
          Sanitize result telemetry. Does NOT send it, but returns sanitized telemetry.
          */
          // If there is a problem in initializing human-web, we should return.
          if (CliqzHumanWeb && CliqzHumanWeb.counter === 0) {
            return Promise.reject("HumanWeb not initialized");
          }

          const msg = data.msg;
          const msgType = data.type;

          let query = data.q;
          let sanitisedQuery = null;
          let url = msg.u;

          const hostNameDetails = getDetailsFromUrl(url);
          const hostName = hostNameDetails.host;

          // Check if there is a query.
          if (!query || query.length == 0) {
            _log$1("No Query");
            return Promise.reject("No Query");
          }

          // If suspicious query.
          if (CliqzHumanWeb.isSuspiciousQuery(query)) {
            _log$1("Query is suspicious");
            sanitisedQuery = "(PROTECTED)";
          }

          // Check if query is like a URL.
          let query_parts = CliqzHumanWeb.parseURL(query);
          let queryLikeURL = false;
          if (query_parts && (query_parts.protocol === "http" || query_parts.protocol === "https" || query_parts.protocol === "www")) {
            queryLikeURL = true;
          }

          if (queryLikeURL && (CliqzHumanWeb.isSuspiciousURL(query) || CliqzHumanWeb.dropLongURL(query))) {
            _log$1("Query is dangerous");
            sanitisedQuery = "(PROTECTED)";
          }

          // Queries also appear on the URL, in which
          // case we need to check whether it's a URL or not.
          if (hostName.length > 0 && url && url.length > 0) {
            // Check if the URL is marked as already private.

            // If there is a problem in initializing human-web bloom-filter, we should return.
            if (!CliqzHumanWeb.bloomFilter) {
              return Promise.reject("Bloom filter not initialized");
            }
            const urlPrivate = CliqzHumanWeb.bloomFilter.testSingle(cachedMD5(url));
            if (urlPrivate) {
              _log$1("Url is already marked private");
              return Promise.reject("Url is already marked private");
            }

            // Check URL is suspicious
            if (CliqzHumanWeb.isSuspiciousURL(url)) {
              _log$1("Url is suspicious");
              url = '(PROTECTED)';
            }

            // Check URL is dangerous, with strict DROPLONGURL.
            if (CliqzHumanWeb.dropLongURL(url, { strict: true })) {
              // If it's Google / Yahoo / Bing. Then mask and send them.
              if (CliqzHumanWeb.checkSearchURL(url) > -1) {
                url = CliqzHumanWeb.maskURL(url);
              } else {
                url = '(PROTECTED)';
              }
            }

            // Check for DNS.
            return CliqzHumanWeb.isHostNamePrivate(url).then(res => {
              let maskedURL = null;
              if (res) {
                _log$1("Private Domain");
                maskedURL = '(PROTECTED)';
              } else {
                // Mask URL.
                maskedURL = CliqzHumanWeb.maskURL(url);
              }

              // Cases when query and URL are same.
              if (url === query) {
                sanitisedQuery = "(PROTECTED)";
                maskedURL = sanitisedQuery;
              }
              // Check if query failed any checks, then replace it with
              // a placeholder.
              if (sanitisedQuery) {
                query = sanitisedQuery;
                maskedURL = sanitisedQuery;
              }
              return {
                query,
                url: maskedURL,
                data
              };
            });
          } else {
            // The URL was not a URL hence drop it.
            // Check if query failed any checks, then replace it with
            // a placeholder.

            // As a final check, if query is a single token, and can be a private domain.
            // Like my.adminportal.com
            if (query.indexOf(' ') === -1 && query.indexOf('.') > -1) {
              return CliqzHumanWeb.isHostNamePrivate(query).then(res => {
                if (res) {
                  _log$1("Private Domain");
                  sanitisedQuery = "(PROTECTED)";
                }
                if (sanitisedQuery) {
                  query = sanitisedQuery;
                }
                return {
                  query,
                  url: null,
                  data
                };
              });
            } else {
              if (sanitisedQuery) {
                query = sanitisedQuery;
              }
              return Promise.resolve({
                query,
                url: null,
                data
              });
            }
          }
        },
        sendResultTelemetry: function sendResultTelemetry(query, url, data) {
          const params = encodeURIComponent(query) + (data.msg.a ? '&a=' + encodeURIComponent(data.msg.a) : '') + '&i=' + data.msg.i + (url ? '&u=' + encodeURIComponent(url) : '') + data.s + data.msg.o + (data.msg.e ? '&e=' + data.msg.e : '');
          const payLoadURL = data.endpoint + params;
          CliqzUtils.httpGet(payLoadURL);
        },
        validFrameCount: function validFrameCount(struct_bef, struct_aft) {
          //
          // To take into account, the transition state, when the extension is updated
          // Data saved in the DB will not have the key nifsh, hence we should return true
          // for those cases.
          //

          if (struct_bef.nifsh == null || struct_aft.nifsh == null || struct_bef.nifsh != struct_aft.nifsh) {
            _log$1("fovalidDoubleFetch: number of internal iframes does not match");
            return false;
          }

          return true;
        },
        validFrameSetCount: function validFrameSetCount(struct_bef, struct_aft) {
          //
          // To take into account, the transition state, when the extension is updated
          // Data saved in the DB will not have the key nfsh, hence we should return true
          // for those cases.
          //

          if (struct_bef.nfsh == null || struct_aft.nfsh == null || struct_bef.nfsh != struct_aft.nfsh) {
            _log$1("fovalidDoubleFetch: number of internal frameset does not match");
            return false;
          }

          return true;
        },
        performQC: function performQC(msg) {
          if (msg.action === "page") {
            let parse_url = CliqzHumanWeb.parseURL(msg.payload.url);

            if (msg.payload.qr && (msg.payload.qr.t === "cl" || msg.payload.qr.t === "othr")) {
              if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) return true;
            } else if (!msg.payload.qr) {
              if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) return true;
            }
          }
          return false;
        },
        safeQuorumCheck: function safeQuorumCheck(msg) {
          //
          // Check for conditions.
          //

          let promise = new Promise((resolve, reject) => {
            if (CliqzHumanWeb.performQC(msg)) {
              _log$1("Perform QC: true");
              let url = msg.payload.url;

              return CliqzHumanWeb.sha1(url).then(CliqzHumanWeb.sendQuorumIncrement).then(CliqzHumanWeb.getQuorumConsent).then(result => resolve(result)).catch(err => {
                _log$1("Error while safe quorum check: " + err);
                reject("quorumcheck");
              });
            } else {
              _log$1("Perform QC: false");
              resolve(true);
            }
          });
          return promise;
        },
        sha1: function sha1(s) {
          return CliqzHumanWeb.hpn.action('sha1', s);
        },
        sendQuorumIncrement: function sendQuorumIncrement(hashedUrl) {
          let promise = new Promise((resolve, reject) => {
            // Check for hashed URL in quorum bloom filter;
            CliqzHumanWeb.isPageVisitedQuorumBloomFilter(hashedUrl).then(status => {
              _log$1("Page already visited: " + status);
              if (status) {
                resolve(hashedUrl);
              } else {
                let payload = `?hu=${hashedUrl}&oc=${CliqzHumanWeb.oc}`;
                let _rp = `${CliqzHumanWeb.SAFE_QUORUM_ENDPOINT}incrquorum`;
                return CliqzHumanWeb.hpn.action('sendInstantMessage', _rp, payload);
              }
            }).then(CliqzHumanWeb.setPageVisitQuorumBloomFilter(hashedUrl)).then(() => resolve(hashedUrl)).catch(err => {
              _log$1("Error while sending send quorum increment" + err);
              reject("quorumincr");
            });
          });
          return promise;
        },
        getQuorumConsent: function getQuorumConsent(hashedUrl) {
          let payload = "?hu=" + hashedUrl;
          let _rp = CliqzHumanWeb.SAFE_QUORUM_ENDPOINT + "checkquorum";

          return CliqzHumanWeb.hpn.action('sendInstantMessage', _rp, payload);
        },
        registerQuorumBloomFilters: function registerQuorumBloomFilters() {
          let promise = new Promise((resolve, reject) => {
            // Check for current date.
            let currentDay = CliqzHumanWeb.getTime().slice(0, 8);
            // Check if quorumBF exists for current date.
            if (Object.keys(CliqzHumanWeb.quorumBloomFilters).indexOf(currentDay) === -1) {
              _log$1("Need to create quorum bloom filter for: " + currentDay);
              let bloomFilterSize = 10000; // User is unlikely to visit more than 10000 URLs in day. Size is approx. 12 KB. per Bloom filter.
              let bloomFilter = new CliqzBloomFilter.BloomFilter(Array(bloomFilterSize).join('0'), bloomFilterNHashes);
              CliqzHumanWeb.quorumBloomFilters[currentDay] = bloomFilter;
            }

            let bf = CliqzHumanWeb.quorumBloomFilters[currentDay];
            resolve(bf);
          });

          return promise;
        },
        setPageVisitQuorumBloomFilter: function setPageVisitQuorumBloomFilter(hashedUrl) {
          CliqzHumanWeb.registerQuorumBloomFilters().then(bf => {
            if (bf) {
              bf.addSingle(hashedUrl);
              CliqzHumanWeb.dumpQuorumBloomFilter();
              Promise.resolve(true);
            }
          });
        },
        isPageVisitedQuorumBloomFilter: function isPageVisitedQuorumBloomFilter(hashedUrl) {
          let promise = new Promise((resolve, reject) => {
            Object.keys(CliqzHumanWeb.quorumBloomFilters).forEach(eachDay => {
              var status = CliqzHumanWeb.quorumBloomFilters[eachDay].testSingle(hashedUrl);
              if (status) {
                resolve(true);
              }
            });
            resolve(false);
          });
          return promise;
        },
        dumpQuorumBloomFilter: function dumpQuorumBloomFilter() {
          let quorumBF = {};

          Object.keys(CliqzHumanWeb.quorumBloomFilters).forEach(eachDay => {
            let _bf = [].slice.call(CliqzHumanWeb.quorumBloomFilters[eachDay].buckets);
            quorumBF[eachDay] = _bf.join("|");
          });
          CliqzHumanWeb.db.saveRecordTelemetry('quorumbf', JSON.stringify(quorumBF), result => {
            _log$1(result);
          });
        },
        loadQuorumBloomFilter: function loadQuorumBloomFilter() {
          CliqzHumanWeb.db.loadRecordTelemetry('quorumbf', function (data) {
            if (data) {
              let jData = JSON.parse(data);
              _log$1("Loading quorum bloom filter");
              Object.keys(jData).forEach(eachDay => {
                let _data = jData[eachDay].split("|").map(Number);
                let bloomFilter = new CliqzBloomFilter.BloomFilter(_data, bloomFilterNHashes);
                CliqzHumanWeb.quorumBloomFilters[eachDay] = bloomFilter;
              });
            }
          });
        },
        expireQuorumBloomFilter: function expireQuorumBloomFilter() {
          // Need to pass the string as YYYY, MM-1, DD to convert to date object.
          let currentDay = CliqzHumanWeb.getTime().slice(0, 8);
          let dateToday = new Date(currentDay.slice(0, 4), currentDay.slice(4, 6) - 1, currentDay.slice(6, 8));

          Object.keys(CliqzHumanWeb.quorumBloomFilters).forEach(eachDay => {
            let registerDate = new Date(eachDay.slice(0, 4), eachDay.slice(4, 6) - 1, eachDay.slice(6, 8));
            let diff = dateToday - registerDate;
            if (diff > CliqzHumanWeb.keyExpire) {
              delete CliqzHumanWeb.quorumBloomFilters[eachDay];
            }
          });
          CliqzHumanWeb.dumpQuorumBloomFilter();
        },
        fetchSafeQuorumConfig: function fetchSafeQuorumConfig() {
          return new Promise((resolve, reject) => {
            //Load latest config.
            CliqzUtils.httpGet(CliqzHumanWeb.SAFE_QUORUM_PROVIDER, function success(req) {
              if (CliqzHumanWeb) {
                try {
                  let resp = JSON.parse(req.response);
                  CliqzHumanWeb.keyExpire = resp.expiry * (24 * 60 * 60 * 1000); // Backend sends it in days;
                  CliqzHumanWeb.oc = resp.oc;
                  CliqzHumanWeb.quorumThreshold = resp.threshold;
                } catch (e) {}
              }
              resolve();
            }, function error(res) {
              _log$1('Error loading config. ');
              resolve();
            }, 5000);
          });
        },
        getCountryCode: function getCountryCode() {
          let ctryCode = CliqzUtils.getPref('config_location', null);
          return CliqzHumanWeb.sanitizeCounrtyCode(ctryCode);
        },
        getTS: function getTS() {
          try {
            let ts = CliqzUtils.getPref('config_ts', '--');
            return ts;
          } catch (ee) {
            return null;
          }
        },
        sanitizeCounrtyCode: function sanitizeCounrtyCode(ctryCode) {
          let _countryCode = ctryCode;
          if (allowedCountryCodes.indexOf(_countryCode) === -1) {
            _countryCode = '--';
          }
          return _countryCode;
        },
        getQuorumCheckOtherUrls: function getQuorumCheckOtherUrls(msg) {
          let urls = [];
          let urlPos = {};

          // Ony check canonical, when
          // It is not from qr.
          // If it is from qr then only type cl or othr.
          if (msg.payload.x.canonical_url && !msg.payload.qr || msg.payload.x.canonical_url && msg.payload.qr && (msg.payload.qr.t === 'cl' || msg.payload.qr.t === 'othr')) {
            let canURL = msg.payload.x.canonical_url;
            let parse_url = CliqzHumanWeb.parseURL(canURL);

            if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) {

              urlPos[urls.length] = { t: 'canonical', url: canURL };
              urls.push(canURL);
            }
          }
          if (msg.payload.ref) {
            let refURL = msg.payload.ref;
            let parse_url = CliqzHumanWeb.parseURL(refURL);

            if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) {

              urlPos[urls.length] = { t: 'ref', url: refURL };
              urls.push(refURL);
            }
          }

          if (msg.payload.red) {
            msg.payload.red.forEach((_redURL, idx) => {
              let redURL = _redURL;
              let parse_url = CliqzHumanWeb.parseURL(redURL);

              if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) {

                urlPos[urls.length] = { t: 'red:' + idx, url: redURL };
                urls.push(redURL);
              }
            });
          }

          return { u: urls, up: urlPos };
        },
        quorumCheckOtherUrls: function quorumCheckOtherUrls(msg) {
          /*
          Before sending the action page, we need to ensure
          that the URLs carried in canonical_url field, ref-
          rre and redirect chain are safe.
           To do a final sanity, we are going to check for safety-quorum
          of these URLs, if returned false then we will mask the domain
          with (PROTECTED).
           Not all URLs require a sanity check , we only send the URLs
          which either have a path/ or query string.
           Example:
          https://example.com/ will not be sent.
          https://example.com/?q=something will be sent.
           We do not need to check canonical url for quorum if it comes out of a search engine.
           */
          let promise = new Promise((resolve, reject) => {
            if (msg.action === 'page') {

              var urls;
              var urlPos;
              var allURLS = CliqzHumanWeb.getQuorumCheckOtherUrls(msg);
              urls = allURLS.u;
              urlPos = allURLS.up;
              _log$1('All urls in the message:' + JSON.stringify(urls));
              _log$1('All urls in the message:' + JSON.stringify(urlPos));

              Promise.all(urls.map(CliqzHumanWeb.sha1)).then(hashes => {
                _log$1(JSON.stringify(hashes));
                Promise.all(hashes.map(CliqzHumanWeb.getQuorumConsent)).then(results => {
                  _log$1(JSON.stringify(results));
                  results.forEach((r, idx) => {
                    let original = urlPos[idx];
                    if (original.t === 'canonical') {
                      if (!r) msg.payload.x.canonical_url = CliqzHumanWeb.maskURLStrict(original.url);
                    }

                    if (original.t === 'ref') {
                      if (!r) msg.payload.ref = CliqzHumanWeb.maskURLStrict(original.url);
                    }

                    if (original.t.startsWith('red')) {
                      let redPos = original.t.split(':')[1];
                      if (!r) msg.payload.red[redPos] = CliqzHumanWeb.maskURLStrict(original.url);
                    }
                  });
                  _log$1('All urls in the message:' + JSON.stringify(msg));
                  resolve(msg);
                }).catch(err => {
                  reject('Error in getQuorumConsent');
                });
              }).catch(err => reject('Error in sha1'));
            } else {
              resolve(msg);
            }
          });

          return promise;
        },
        addURLtoDB: function addURLtoDB(url, ref, paylobj) {
          /*
          1. Check if the given URL is a search URL,
          We do not want to save search URLs in the DB,
          for double-fetch.
           2. Then we want to check whether we have already marked the UpRL as private.
          If yes then we should return.
           3. Check if URL
            a. Not in the DB.
              i. Check if URL is fit to save
                x. paylobj['x'] == null
                y. CliqzHumanWeb.isSuspiciousURL(url)
                z. CliqzHumanWeb.httpCache401[url]
                 if any of the above condition is met, it is set as private.
                else it is inserted in the DB
             b. Already in the DB.
              i. Update the stats, like engagement metrics.
          */

          var tt = new Date().getTime();
          var se = CliqzHumanWeb.checkSearchURL(url);
          if (se > -1) {
            return;
          }

          //Check if url is in hashtable

          /*
          The key ft is obselete, should remove.
          */

          var ft = 1;
          var privateHash = false;

          CliqzHumanWeb.isAlreadyMarkedPrivate(url, function (_res) {
            if (_res) {
              if (_res['private'] == 1) {
                privateHash = true;
              } else {
                ft = 0;
              }
            } else {
              // we never seen it, let's add it
              paylobj['ft'] = true;
            }
          });

          // Need to add if canonical is seen before or not.
          // This is helpful, becuase now we replace the url with canonical incase of dropLongUrl(url) => true.
          // Hence, in the event log, lot of URL's look ft => true.

          CliqzHumanWeb.db.getURL(url, function (obj) {
            // If the url is already not in the DB or marked private, then we need save it.
            _log$1(">>>>> Add url to dbobj" + obj.length + privateHash);
            if (!privateHash && obj.length === 0) {
              // does not exist
              var setPrivate = false;

              var newObj = {};
              newObj.url = url;
              newObj.ref = ref;
              newObj.last_visit = tt;
              newObj.first_visit = tt;
              newObj.ft = ft;
              newObj.payload = paylobj || {}; // This needs to stringified before pushing to chrome storage.

              if (paylobj['x'] == null) {
                // page data structure is empty, so no need to double fetch, is private
                let reason = 'empty page data';
                setPrivate = true;
                _log$1("Setting private because empty page data");
              } else if (CliqzHumanWeb.isSuspiciousURL(url)) {
                // if the url looks private already add it already as checked and private
                let reason = 'susp. url';
                setPrivate = true;
                _log$1("Setting private because suspiciousURL");
              } else {
                if (CliqzHumanWeb.httpCache401[url]) {
                  let reason = '401';
                  setPrivate = true;
                  _log$1("Setting private because of 401");
                } else {
                  let reason = '';
                  setPrivate = false;
                }
              }
              _log$1(">>>>> lets save >>> " + JSON.stringify(newObj));

              // This needs to simplified, if it needs to set Private, why insert it in the first place.
              // Possibly because else the remove url would break in setAsPrivate.
              CliqzHumanWeb.db.saveURL(url, newObj, function () {

                if (CliqzHumanWeb.debug) {
                  _log$1("Insertion success add urltoDB");
                }

                if (setPrivate) CliqzHumanWeb.setAsPrivate(url);
              });
            } else if (obj.length === 1) {
              _log$1(">>>>> Add url to dbobj found record" + JSON.stringify(obj));
              let record = obj[0];
              // Looks like the URL is already there, we just need to update the stats.

              //Need to aggregate the engagement metrics.
              _log$1(record);
              var metricsBefore = JSON.parse(record.payload)['e']; // || {cp: 0, mm: 0, kp: 0, sc: 0, md: 0 };

              var metricsAfter = paylobj['e'];
              paylobj['e'] = CliqzHumanWeb.aggregateMetrics(metricsBefore, metricsAfter);

              var cloneObj = record;

              cloneObj.last_visit = tt;
              cloneObj.payload = paylobj || {};

              CliqzHumanWeb.db.updateURL(url, cloneObj, function () {
                _log$1("Record updated");
              });

              paylobj['e'] = { 'cp': 0, 'mm': 0, 'kp': 0, 'sc': 0, 'md': 0 };
            }
          });
        },
        setAsPrivate: function setAsPrivate(url) {
          if (CliqzHumanWeb.bloomFilter) {
            CliqzHumanWeb.bloomFilter.addSingle(cachedMD5(url).substring(0, 16));
          }

          CliqzHumanWeb.db.removeUnsafe(url, result => {
            _log$1(`Deleting ${url} : ${result}`);
          });

          if (CliqzHumanWeb.state['v'][url]) {
            delete CliqzHumanWeb.state['v'][url];
          }
          CliqzHumanWeb.dumpBloomFilter();

          // incr stats for private page, to see public vs private pages marked.
          // mp : when double fetch failed or url was marked private.
          CliqzHumanWeb.incrActionStats("mp");
        },
        setAsPublic: function setAsPublic(url) {
          CliqzHumanWeb.db.removeUnsafe(url, result => {
            _log$1(`Deleting ${url} : ${result}`);
          });

          if (CliqzHumanWeb.state['v'][url]) {
            delete CliqzHumanWeb.state['v'][url];
          }
        },
        listOfUnchecked: function listOfUnchecked(cap, sec_old, fixed_url, callback) {
          CliqzHumanWeb.db.getListOfUnchecked(cap, sec_old, fixed_url, (res, res2) => {
            callback(res);
          });
        },
        processUnchecks: function processUnchecks(listOfUncheckedUrls) {
          _log$1(">>> URLS UNPROCESSED >>> " + JSON.stringify(listOfUncheckedUrls));
          var url_pagedocPair = {};

          for (var i = 0; i < listOfUncheckedUrls.length; i++) {
            var url = listOfUncheckedUrls[i][0];
            var page_doc = listOfUncheckedUrls[i][1];
            var page_struct_before = page_doc['x'];
            url_pagedocPair[url] = page_doc;

            CliqzHumanWeb.log("Going for double fetch: " + url);
            CliqzHumanWeb.log("Going for double fetch2: " + page_doc);
            CliqzHumanWeb.log("Going for double fetch3: " + page_struct_before);
            CliqzHumanWeb.log("Going for double fetch3: " + JSON.stringify(page_struct_before));

            // only do doubleFetch for the same url 3 times in a row
            // (set up as this.humanWeb.MAX_NUMBER_DOUBLEFETCH_ATTEMPS).
            // If more attemps are tried then the url is marked as private.
            // Prevent infinite loop if the doubleFetch causes the browser
            // to crash (issue #2213)
            //
            CliqzHumanWeb.db.loadRecordTelemetry('last-double-fetch', function (data) {
              var obj = null;
              if (data == null) obj = { 'url': url, 'count': 1 };else {
                obj = JSON.parse(data);
                if (obj.url != url) obj = { 'url': url, 'count': 1 };else {
                  try {
                    obj['count'] += 1;
                  } catch (err) {
                    obj['count'] = 1;
                  }
                }
              }
              _log$1(">>>>> DOUBLE FETCH COUNT >>> " + JSON.stringify(obj));
              CliqzHumanWeb.db.saveRecordTelemetry('last-double-fetch', JSON.stringify(obj), result => {
                _log$1(result);
              });

              if (obj.count > CliqzHumanWeb.MAX_NUMBER_DOUBLEFETCH_ATTEMPS) {
                CliqzHumanWeb.setAsPrivate(url);
              } else {
                CliqzHumanWeb.doubleFetch(url, url_pagedocPair[url]);
              }
            });
          }
        },
        detectAdClick: function detectAdClick(targetURL) {
          // The first URL observed after clicking the ad has the pattern,
          // google and aclk? in it.
          if (targetURL.indexOf('google') > -1 && targetURL.indexOf('aclk?') > -1) {
            let clickedU = normalizeAclkUrl(targetURL);

            if (CliqzHumanWeb.adDetails[clickedU]) {
              let payload = {
                action: 'ad-ctr',
                'anti-duplicates': Math.floor(random() * 10000000),
                type: 'humanweb',
                channel: CliqzHumanWeb.CHANNEL,
                payload: {
                  ctry: CliqzHumanWeb.getCountryCode()

                }
              };

              let query = CliqzHumanWeb.adDetails[clickedU].query;
              if (CliqzHumanWeb.isSuspiciousQuery(query)) {
                query = ' (PROTECTED) ';
              }

              payload.payload.query = query;
              payload.payload.domain = cleanFinalUrl(CliqzHumanWeb.adDetails[clickedU].furl[0], CliqzHumanWeb.adDetails[clickedU].furl[1]);

              _log$1(`AD CTR Payload : ${JSON.stringify(payload)}`);
              CliqzHumanWeb.telemetry(payload);
            }
          }
        },
        purgeAdLookUp: function purgeAdLookUp() {
          // We should clean the ads in lookup table, keep it from growing too huge.
          // Cleaning ads which are older than 15 minutes seems reasonable right now.

          let ts = Date.now();
          Object.keys(CliqzHumanWeb.adDetails).forEach(item => {
            let adTS = CliqzHumanWeb.adDetails[item]['ts'];
            let diff = (ts - adTS) / (1000 * 60);
            if (diff > 15) {
              delete CliqzHumanWeb.adDetails[item];
            }
          });
        },
        addStrictQueries: function addStrictQueries(url, query) {
          // In some cases, we get query undefined.
          if (!query) {
            _log$1(">> Got an undefined query >>> " + url);
            return;
          }

          let anonSe = CliqzHumanWeb.checkAnonSearchURL(url);
          if (anonSe > -1) {
            try {
              let hostName = CliqzHumanWeb.parseURL(url)['hostname'];
              let qurl = "https://" + hostName + "/search?q=" + query;
              let qObj = {};
              qObj['qurl'] = qurl;
              qObj['ts'] = Date.now();
              qObj['tDiff'] = getRandomIntInclusive(1, 20);
              CliqzHumanWeb.strictQueries.push(qObj);
              CliqzHumanWeb.saveStrictQueries();
            } catch (ee) {}
          }
        }
      };

      var _slicedToArray$8 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const history$1 = Components.classes['@mozilla.org/browser/nav-history-service;1'].getService(Components.interfaces.nsINavHistoryService);

      class FirefoxLegacyHistory {
        constructor() {
          this.HISTORY_EVENTS = ['onBeginUpdateBatch', 'onEndUpdateBatch', 'onVisit', 'onTitleChanged', 'onBeforeDeleteURI', 'onDeleteURI', 'onClearHistory', 'onPageChanged', 'onDeleteVisits'];
          this._historyObserver = null;
        }

        addListener(eventName, callback) {
          if (!this.HISTORY_EVENTS.includes(eventName)) {
            throw new Error(`Unrecognized history event "${eventName}"`);
          }
          if (this._historyObserver && this._historyObserver.hasHandler(eventName, callback)) {
            throw new Error('Callback already registered');
          }

          // create observer on demand
          if (!this._historyObserver) {
            this._historyObserver = this._createHistoryObserver();
            history$1.addObserver(this._historyObserver, false);
          }

          this._historyObserver.addHandler(eventName, callback);
        }

        removeListener(eventName, callback) {
          if (!this._historyObserver) {
            throw new Error('Callback not registered');
          }

          this._historyObserver.removeHandler(eventName, callback);
          if (!this._historyObserver.hasHanders) {
            history$1.removeObserver(this._historyObserver);
            this._historyObserver = null;
          }
        }

        _createHistoryObserver() {
          const historyObserver = this.HISTORY_EVENTS.reduce((obs, eventName) => {
            /* eslint-disable no-param-reassign */
            obs[eventName] = function () {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              obs._handlers[eventName].forEach(handler => handler(...args));
            };

            obs._handlers[eventName] = new Set();
            /* eslint-enable no-param-reassign */
            return obs;
          }, {
            _handlers: {},
            addHandler(eventName, callback) {
              this._handlers[eventName].add(callback);
            },
            removeHandler(eventName, callback) {
              if (!this.hasHandler(eventName, callback)) {
                throw new Error('Callback not registered');
              }
              this._handlers[eventName].delete(callback);
            },
            hasHandler(eventName, callback) {
              return this._handlers[eventName].has(callback);
            },
            get hasHanders() {
              return Object.entries(this._handlers).reduce((total, _ref) => {
                var _ref2 = _slicedToArray$8(_ref, 2);

                let handlersList = _ref2[1];
                return total + handlersList.size;
              }, 0);
            },
            QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsINavHistoryObserver])
          });

          return historyObserver;
        }
      }

      const legacyHistory = new FirefoxLegacyHistory();

      function eventWrapper(_ref3) {
        let add = _ref3.add,
            remove = _ref3.remove;

        return {
          _callbacks: new Map(),

          addListener(callback) {
            if (this.hasListener(callback)) {
              throw new Error('Callback already registered');
            }
            const e = add(callback);
            this._callbacks.set(callback, e);
          },

          removeListener(callback) {
            if (!this.hasListener(callback)) {
              throw new Error('Callback not registered');
            }
            const e = this._callbacks.get(callback);
            this._callbacks.delete(callback);
            remove(e);
          },

          hasListener(callback) {
            return this._callbacks.has(callback);
          }
        };
      }

      var history$2 = {
        onVisited: eventWrapper({
          add(callback) {
            function c(aURI, id, aTime) {
              return callback({
                id,
                url: aURI.spec,
                lastVisitTime: aTime / 1000,
                // Avoid using next fields as they are
                // not supported in nsINavHistoryService:
                title: aURI.spec,
                visitCount: 1,
                typedCount: 0
              });
            }
            legacyHistory.addListener('onVisit', c);
            return c;
          },

          remove(c) {
            legacyHistory.removeListener('onVisit', c);
          }
        }),

        onVisitRemoved: eventWrapper({
          add(callback) {
            const evts = {
              onBeginUpdateBatch() {
                evts.batch = [];
              },
              onEndUpdateBatch() {
                callback({
                  urls: evts.batch,
                  allHistory: false
                });
                evts.batch = null;
              },
              onDeleteURI(aURI) {
                const url = aURI.spec;
                if (!evts.batch) {
                  callback({
                    urls: [url],
                    allHistory: false
                  });
                } else {
                  evts.batch.push(url);
                }
              },
              onClearHistory() {
                callback({
                  urls: [],
                  allHistory: true
                });
              }
            };

            legacyHistory.addListener('onBeginUpdateBatch', evts.onBeginUpdateBatch);
            legacyHistory.addListener('onEndUpdateBatch', evts.onEndUpdateBatch);
            legacyHistory.addListener('onDeleteURI', evts.onDeleteURI);
            legacyHistory.addListener('onClearHistory', evts.onClearHistory);
            return evts;
          },

          remove(evts) {
            legacyHistory.removeListener('onBeginUpdateBatch', evts.onBeginUpdateBatch);
            legacyHistory.removeListener('onEndUpdateBatch', evts.onEndUpdateBatch);
            legacyHistory.removeListener('onDeleteURI', evts.onDeleteURI);
            legacyHistory.removeListener('onClearHistory', evts.onClearHistory);
          }
        })
      };

      /* global Components WebRequest PrivateBrowsingUtils MatchPattern */
      Components.utils.import('resource://gre/modules/XPCOMUtils.jsm');
      Components.utils.import('resource://gre/modules/WebRequest.jsm');
      Components.utils.import('resource://gre/modules/Services.jsm');
      Components.utils.import('resource://gre/modules/PrivateBrowsingUtils.jsm');

      /**
       * Gets the tabId and windowId for a given browser instance
       * Partly based on tabTracker API implementation:
       * https://github.com/mozilla/gecko-dev/blob/473a1509eae87a911b339d20bbd396ef84ae2cbb/browser/components/extensions/ext-utils.js
       * @param  {Browser} browser
       * @return {Object}  with attributes tabId and windowId
       */
      function getBrowserData(_browser) {
        let browser = _browser;
        // When we're loaded into a <browser> inside about:addons, we need to go up
        // one more level.
        if (browser.ownerGlobal && browser.ownerGlobal.location.href === 'about:addons') {
          // legacy impl
          browser = browser.ownerGlobal.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDocShell).chromeEventHandler;
        } else if (browser.ownerDocument && browser.ownerDocument.documentURI === 'about:addons') {
          // new impl as of sept 2017
          browser = browser.ownerDocument.docShell.chromeEventHandler;
        }

        const result = {
          tabId: -1,
          windowId: -1
        };

        if (browser && browser.outerWindowID) {
          result.tabId = browser.outerWindowID;
        }

        return result;
      }

      /**
       * Generates a listener for data from WebRequest.jsm, which translates these calls
       * for the expected WebRequest API.
       * Based on ext-webRequest.js (https://github.com/mozilla/gecko-dev/blob/master/toolkit/components/extensions/ext-webRequest.js)
       * @param  {Function} listener which this function wrapes
       * @return {Function}          Function to be registered with WebRequest.jsm
       */
      function webRequestListenerWrapper(listener, topic) {
        const maybeCached = ['onResponseStarted', 'onBeforeRedirect', 'onCompleted', 'onErrorOccurred'].includes(topic);
        const optional = ['requestHeaders', 'responseHeaders', 'statusCode', 'statusLine', 'error', 'redirectUrl', 'requestBody', 'scheme', 'realm', 'isProxy', 'challenger', 'ip', 'frameAncestors'];
        return data => {
          // ignore system principal: OCSP, addon and other background requests
          if (data.isSystemPrincipal) {
            return {};
          }

          // ignore chrome urls
          if (['chrome://', 'resource://', 'data:', 'blob', 'about:'].some(proto => data.url.startsWith(proto))) {
            return {};
          }

          let browserData = { tabId: -1, windowId: -1 };
          if (data.browser) {
            browserData = getBrowserData(data.browser);
            if (data.browser.currentURI) {
              browserData.source = data.browser.currentURI.spec;
            }
            browserData.isPrivate = PrivateBrowsingUtils.isBrowserPrivate(data.browser);
          }
          let parentFrame = data.parentWindowId;
          if (data.type === 'main_frame' || data.windowId === data.parentWindowId) {
            parentFrame = -1;
          } else if (parentFrame === browserData.tabId) {
            parentFrame = 0;
          }

          const data2 = {
            requestId: data.requestId,
            url: data.url,
            originUrl: data.type === 'main_frame' ? undefined : data.originUrl || browserData.source,
            documentUrl: data.documentUrl,
            method: data.method,
            tabId: browserData.tabId || -1,
            type: data.type,
            timeStamp: Date.now(),
            frameId: data.type === 'main_frame' ? 0 : data.windowId,
            parentFrameId: parentFrame,
            // API additions
            isPrivate: browserData.isPrivate || false
          };
          // For Firefox 58+ we can use frameAncestors to find the source
          if (data.frameAncestors && data.frameAncestors.length > 0) {
            data2.sourceUrl = data.frameAncestors[data.frameAncestors.length - 1].url;
          } else if (!data.frameAncestors && data2.frameId !== data2.parentFrameId && data2.type === 'beacon') {
            // guess when not to use the tab source as sourceUrl
            data2.sourceUrl = data.originUrl;
          } else if (!data.frameAncestors && data.windowId === data.parentWindowId && data.originUrl !== browserData.source) {
            data2.sourceUrl = data.originUrl;
          } else {
            data2.sourceUrl = browserData.source;
          }

          if (maybeCached) {
            data2.fromCache = !!data.fromCache;
          }

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = optional[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const opt = _step.value;

              if (opt in data) {
                data2[opt] = data[opt];
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return listener(data2);
        };
      }

      function webRequestLegacyWrapper(listener) {
        return prevData => {
          const data = prevData;
          // originUrl === triggeringPrincipal
          // https://github.com/mozilla/gecko-dev/blob/master/toolkit/modules/addons/WebRequest.jsm#L748
          data.trigger = data.originUrl;

          // TODO: This comes on a later topic than we listen at the moment
          data.isCached = data.fromCache;

          data.responseStatus = data.statusCode;

          return listener(data);
        };
      }

      class WebRequestWrapper {
        constructor(topic) {
          this.topic = topic;
          this.listeners = {};
        }

        addListener(listener, filter, extraInfo) {
          const wrFilter = filter ? {
            types: filter.types
          } : undefined;
          if (filter && filter.urls && filter.urls.length > 0 && !filter.urls[0] === '<all_urls>') {
            wrFilter.urls = new MatchPattern(filter.urls);
          }
          this.listeners[listener] = webRequestListenerWrapper(webRequestLegacyWrapper(listener), this.topic);
          WebRequest[this.topic].addListener(this.listeners[listener], wrFilter, extraInfo);
        }

        removeListener(listener) {
          WebRequest[this.topic].removeListener(this.listeners[listener]);
          delete this.listeners[listener];
        }
      }

      var WebRequest$1 = {
        onBeforeRequest: new WebRequestWrapper('onBeforeRequest'),
        onBeforeSendHeaders: new WebRequestWrapper('onBeforeSendHeaders'),
        onSendHeaders: new WebRequestWrapper('onSendHeaders'),
        onHeadersReceived: new WebRequestWrapper('onHeadersReceived'),
        onAuthRequired: new WebRequestWrapper('onAuthRequired'),
        onBeforeRedirect: new WebRequestWrapper('onBeforeRedirect'),
        onResponseStarted: new WebRequestWrapper('onResponseStarted'),
        onErrorOccurred: new WebRequestWrapper('onErrorOccurred'),
        onCompleted: new WebRequestWrapper('onErrorOccurred')
      };

      const VALID_RESPONSE_PROPERTIES = {
        onBeforeRequest: ['cancel', 'redirectUrl'],
        onBeforeSendHeaders: ['cancel', 'requestHeaders'],
        onSendHeaders: [],
        onHeadersReceived: ['redirectUrl', 'responseHeaders'],
        onAuthRequired: ['cancel'],
        onResponseStarted: [],
        onBeforeRedirect: [],
        onCompleted: [],
        onErrorOccurred: []
      };

      // TODO - should this be in platform instead?
      // Firefox and Chrome still have differencies
      const EXTRA_INFO_SPEC = {
        onBeforeRequest: ['blocking'],
        onBeforeSendHeaders: ['blocking', 'requestHeaders'],
        onSendHeaders: ['requestHeaders'],
        onHeadersReceived: ['blocking', 'responseHeaders'],
        onAuthRequired: ['blocking', 'responseHeaders'],
        onResponseStarted: ['responseHeaders'],
        onBeforeRedirect: ['responseHeaders'],
        onCompleted: ['responseHeaders'],
        onErrorOccurred: []
      };

      /**
      * @namespace human-web
      * @class Background
      */
      var background$2 = background({
        requiresServices: ['cliqz-config'],

        hpn: inject.module('hpn'),
        /**
        * @method enabled
        * @return pref
        */
        enabled() {
          return CliqzUtils.getPref("humanWeb", true) && !CliqzUtils.getPref("humanWebOptOut", false);
        },

        /**
        * @method init
        */
        init(settings) {
          var _this = this;

          // Protection: By default, skip all human web listeners.
          // Only allow it if the user has not opted out
          // and if human web is fully initialized.
          //
          // (Note: Opt-out is clear, but the reason why it is also disabled
          //  during initialization is mainly to prevent any race conditions
          //  that we would otherwise had to deal with. Startup should
          //  not take too long, anyway.)
          this.collecting = false;

          this.humanWeb = CliqzHumanWeb;
          CliqzHumanWeb.hpn = this.hpn;

          const FF48_OR_ABOVE = isPlatformAtLeastInVersion('48.0');
          if (isFirefox && !FF48_OR_ABOVE) {
            this.active = false;
            return Promise.resolve();
          }

          return Promise.resolve().then(() => {

            if (!this.enabled()) {
              // The module is technically loaded, but human web will not collect any data.
              this.active = true;
              this.collecting = false;
              return;
            }

            return CliqzHumanWeb.init().then(() => {

              this.onHeadersReceivedListener = function () {
                return CliqzHumanWeb.httpObserver.observeActivity(...arguments);
              };
              WebRequest$1.onHeadersReceived.addListener(this.onHeadersReceivedListener, {
                urls: ['*://*/*']
              }, ['responseHeaders']);

              // If it's chrome, we need to add a domain2IP dict.
              // Need to move it to a more platform friendly place.
              if (WebRequest$1.onCompleted) {
                this.domain2IPListener = function () {
                  return _this.domain2IP(...arguments);
                };
                WebRequest$1.onCompleted.addListener(this.domain2IPListener, { urls: ['http://*/*', 'https://*/*'], tabId: -1 });
              }

              CliqzUtils.bindObjectFunctions(this.actions, this);

              if (history$2 && history$2.onVisitRemoved) {
                this.onVisitRemovedListener = function () {
                  return CliqzHumanWeb.onVisitRemoved(...arguments);
                };
                history$2.onVisitRemoved.addListener(this.onVisitRemovedListener);
              }

              this.active = true;
              this.collecting = true;
            });
          });
        },

        unload() {
          this.collecting = false;

          if (this.active) {
            this.active = false;

            if (this.onVisitRemovedListener) {
              history$2.onVisitRemoved.removeListener(this.onVisitRemovedListener);
              this.onVisitRemovedListener = undefined;
            }

            if (this.onHeadersReceivedListener) {
              WebRequest$1.onHeadersReceived.removeListener(this.onHeadersReceivedListener);
              this.onHeadersReceivedListener = undefined;
            }

            if (this.domain2IPListener) {
              WebRequest$1.onCompleted.removeListener(this.domain2IPListener);
              this.domain2IPListener = undefined;
            }

            CliqzHumanWeb.unload();
          }
        },

        beforeBrowserShutdown() {
          CliqzHumanWeb.unload();
        },

        domain2IP(requestDetails) {
          if (requestDetails && requestDetails.ip) {
            const domain = CliqzHumanWeb.parseURL(requestDetails.url).hostname;
            CliqzHumanWeb.domain2IP[domain] = { ip: requestDetails.ip, ts: Date.now() };
          }
        },

        events: {
          'human-web:sanitize-result-telemetry': function humanWebSanitizeResultTelemetry() {
            CliqzHumanWeb.sanitizeResultTelemetry(...arguments).then(_ref => {
              let query = _ref.query,
                  url = _ref.url,
                  data = _ref.data;
              return CliqzHumanWeb.sendResultTelemetry(query, url, data);
            }).catch(error => console.log(CliqzHumanWeb.LOG_KEY, error));
          },
          /**
          * @event ui:click-on-url
          */
          'ui:click-on-url': function uiClickOnUrl(data) {
            if (this.collecting) {
              CliqzHumanWeb.queryCache[data.url] = {
                d: 1,
                q: data.query,
                t: data.isPrivateResult ? 'othr' : 'cl',
                pt: data.positionType || ''
              };
            }
          },
          /**
          * @event control-center:toggleHumanWeb
          */
          'control-center:toggleHumanWeb': function controlCenterToggleHumanWeb() {
            // 1. we turn off HumanWeb module
            CliqzUtils.setPref('modules.human-web.enabled', false);

            // 2. change the pref
            CliqzUtils.setPref('humanWebOptOut', !CliqzUtils.getPref('humanWebOptOut', false));

            // we need to avoid the throttle on prefs
            CliqzUtils.setTimeout(function () {
              //3. start again the module
              CliqzUtils.setPref('modules.human-web.enabled', true);
            }, 0);
          },
          'core:mouse-down': function onMouseDown() {
            if (this.collecting) {
              CliqzHumanWeb.captureMouseClickPage.apply(CliqzHumanWeb, arguments);
            }
          },
          'core:key-press': function onKeyPress() {
            if (this.collecting) {
              CliqzHumanWeb.captureKeyPressPage.apply(CliqzHumanWeb, arguments);
            }
          },
          'core:mouse-move': function onMouseMove() {
            if (this.collecting) {
              CliqzHumanWeb.captureMouseMovePage.apply(CliqzHumanWeb, arguments);
            }
          },
          'core:scroll': function onScroll() {
            if (this.collecting) {
              CliqzHumanWeb.captureScrollPage.apply(CliqzHumanWeb, arguments);
            }
          },
          'core:copy': function onCopy() {
            if (this.collecting) {
              CliqzHumanWeb.captureCopyPage.apply(CliqzHumanWeb, arguments);
            }
          },
          'content:location-change': function onLocationChange(_ref2) {
            let isPrivate = _ref2.isPrivate,
                isLoadingDocument = _ref2.isLoadingDocument,
                url = _ref2.url,
                referrer = _ref2.referrer,
                frameId = _ref2.frameId;

            if (this.collecting) {
              // Only forward it to the onLocation change if the frameID is type 0.

              // We need to find a better way, to not trigger on-location change for requests which are not main_document.
              CliqzHumanWeb.listener.onLocationChange.apply(CliqzHumanWeb.listener, arguments);
            }
          }
        },

        actions: {

          /**
           * Check whether there is some state for this url.
           * @param  {String}  url
           * @return {Boolean}     true if a state object exists.
           */
          isProcessingUrl(url) {
            return CliqzHumanWeb.state.v[url] !== undefined;
          },

          /**
           * Add some data to the metadata for a url under the specified key. If data
           * already exists, we will merge it, overwriting any duplicates.
           *
           * @param {String} url
           * @param {String} key  object key under-which to add this data
           * @param {Object} data data to add
           * @returns {Promise} Resolves if data was added, rejects if we have no state
           * for this url.
           */
          addDataToUrl(url, key, data) {
            if (CliqzHumanWeb.state.v[url]) {
              CliqzHumanWeb.state.v[url][key] = Object.keys(data).reduce((acc, val) => {
                acc[val] = data[val];
                return acc;
              }, CliqzHumanWeb.state.v[url][key] || {});
              return Promise.resolve();
            }
            return Promise.reject();
          },

          telemetry(payload, instantPush) {
            CliqzHumanWeb.telemetry(payload, instantPush);
          },

          contentScriptTopAds(message) {
            // console.log('>>>>> HELLO 2 >>>> ');
          },

          contentScriptHTML(message) {
            // console.log('>>>>> HELLO HTML >>>> ');
          },

          jsRedirect(message) {
            CliqzHumanWeb.httpCache[message.message.url] = {
              status: 301,
              time: CliqzHumanWeb.counter,
              location: message.message.location
            };
          },

          adClick(message) {
            const ads = message.ads;
            Object.keys(ads).forEach(eachAd => {
              CliqzHumanWeb.adDetails[eachAd] = ads[eachAd];
            });
          }

        }
      });

      class Win$6 {
        constructor(settings) {
          this.window = settings.window;
          this.settings = settings.settings;
          this.window.CliqzHumanWeb = CliqzHumanWeb;
        }

        enabled() {
          return CliqzUtils.getPref("humanWeb", false) && !CliqzUtils.getPref("humanWebOptOut", false) && !CliqzUtils.isPrivate(this.window);
        }

        init() {
          if (!this.enabled() || !background$2.active) {
            return;
          }

          this._dataCollectionTimer = CliqzUtils.setTimeout(this.showDataCollectionMessage.bind(this), 1000);
        }

        unload() {
          if (this._dataCollectionTimer) {
            CliqzUtils.clearTimeout(this._dataCollectionTimer);
            this._dataCollectionTimer = undefined;
          }

          this.removeNotification();
          delete this.window.CliqzHumanWeb;
        }

        status() {
          if (background$2.active) {
            return {
              visible: true,
              state: !CliqzUtils.getPref('humanWebOptOut', false)
            };
          }
        }

        removeNotification() {
          if (this.notification) {
            this.notification.close();
            this.window.document.getElementById("global-notificationbox").removeNotification(this.notification);
            this.notification = null;
          }
        }

        /**
         * dataCollectionMessageState
         *   0 - not shown
         *   1 - shown
         *   2 - ignored
         *   3 - learn more
         */
        // TODO: migrate to message-manager
        showDataCollectionMessage() {
          if (!this.settings.showDataCollectionMessage || CliqzUtils.getPref('dataCollectionMessageState', 0) !== 0) {
            return;
          }

          function updateDataCollectionState(state) {
            CliqzUtils.telemetry({
              type: 'dataCollectionMessage',
              state: state
            });

            CliqzUtils.setPref('dataCollectionMessageState', state);
          }

          let box = this.window.document.getElementById("global-notificationbox"),
              buttons = [];

          buttons.push({
            label: CliqzUtils.getLocalizedString("learnMore"),
            callback: () => {
              let learnMoreUrl = 'chrome://cliqz/content/human-web/humanweb.html';
              this.window.gBrowser.selectedTab = this.window.gBrowser.addTab(learnMoreUrl);
              updateDataCollectionState(3);
              this.removeNotification();
            }
          });

          this.notification = box.appendNotification(CliqzUtils.getLocalizedString("dataCollection"), null, null, box.PRIORITY_INFO_HIGH, buttons, () => {
            // notification hides if the user closes it or presses learn more
            if (CliqzUtils.getPref('dataCollectionMessageState', 0) < 2) {
              updateDataCollectionState(2);
              this.removeNotification();
            }
          });

          updateDataCollectionState(1);
        }
      }

      var humanWebModule = {
        Background: background$2,
        Window: Win$6
      };

      const defaultTPace = 10 * 1000;

      class Pacemaker {
        constructor(tpace, twait) {
          this.tpace = tpace || defaultTPace;
          this.twait = new Date().getTime() + (twait || 0);
          this._id = null;
          this._tasks = new Set();
        }

        start() {
          if (this._id) {
            this.stop();
          }
          this._id = CliqzUtils.setInterval(this._tick.bind(this), this.tpace, null);
        }

        stop() {
          CliqzUtils.clearTimeout(this._id);
          this._id = null;
          this._tasks = new Set();
        }

        _tick() {
          const now = new Date().getTime();
          // initial waiting period
          if (this.twait > now) {
            CliqzUtils.log('tick wait', 'pacemaker');
            return;
          }

          // run registered tasks
          this._tasks.forEach(task => {
            if (now > task.last + task.freq) {
              CliqzUtils.setTimeout(() => {
                const taskName = task.fn.name || '<anon>';
                try {
                  // if task constraint is set, test it before running
                  if (!task.when || task.when(task)) {
                    CliqzUtils.log(`run task: ${taskName}`, 'pacemaker');
                    task.fn(now);
                  }
                  /* eslint-disable no-param-reassign */
                  task.last = now;
                  /* eslint-enable no-param-reassign */
                } catch (e) {
                  CliqzUtils.log(`Error executing task ${taskName}: ${e}`, 'pacemaker');
                }
              }, 0);
            }
          });
        }

        /** Register a function to be run periodically by the pacemaker.
              @param fn function to call
              @param frequency minimum interval between calls, in ms.
              @returns task object, which can be used with deregister to stop this task.
         */
        register(fn, frequency, constraint) {
          if (!fn) {
            throw new Error('fn cannot be undefined');
          }
          const task = {
            fn,
            freq: frequency || 0,
            last: 0,
            when: constraint
          };
          this._tasks.add(task);
          return task;
        }

        deregister(task) {
          this._tasks.delete(task);
        }
      }

      // export singleton pacemaker
      const pm = new Pacemaker(30000, 30000);

      Components.utils.import("resource://gre/modules/Services.jsm");
      Components.utils.import("resource://gre/modules/FileUtils.jsm");

      const connections = new Map();

      function open(databaseName) {
        let connection;
        if (!connections.has(databaseName)) {
          const filePath = FileUtils.getFile("ProfD", [databaseName]);
          connection = Services.storage.openDatabase(filePath);
          connections.set(databaseName, connection);
        } else {
          connection = connections.get(databaseName);
        }
        return connection;
      }

      function close(databaseName) {
        if (!connections.has(databaseName)) {
          return;
        }
        const connection = connections.get(databaseName);
        connections.delete(databaseName);
        // according to docs we should not use close because we use async statements
        // see https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/mozIStorageConnection#close()
        connection.asyncClose();
      }

      const LOG_KEY$1 = "storage-sqlite";
      let dbConn;

      function init$3() {
        dbConn = open('cliqz.dbattrack');
        var attrack_table = 'create table if not exists attrack(id VARCHAR(24) PRIMARY KEY NOT NULL, data VARCHAR(1000000))';
        (dbConn.executeSimpleSQLAsync || dbConn.executeSimpleSQL)(attrack_table);
      }

      function loadRecord$1(id, callback) {
        if (!dbConn) {
          init$3();
        }
        if (id.startsWith('cliqz.dbattrack.')) {
          id = id.substring('cliqz.dbattrack.'.length);
        }

        var stmt = dbConn.createAsyncStatement("SELECT id, data FROM attrack WHERE id = :id;");
        stmt.params.id = id;

        var fres = null;
        var res = [];
        stmt.executeAsync({
          handleResult: function handleResult(aResultSet) {
            for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
              if (row.getResultByName("id") == id) {
                res.push(row.getResultByName("data"));
              } else {
                CliqzUtils.log("There are more than one record", LOG_KEY$1);
                callback(null);
              }
              break;
            }
          },
          handleError: function handleError(aError) {
            CliqzUtils.log("SQL error: " + aError.message, LOG_KEY$1);
            callback(null);
          },
          handleCompletion: function handleCompletion(aReason) {
            if (res.length == 1) {
              CliqzUtils.log(`Load ${id}, data length = ${res[0].length}`, LOG_KEY$1);
              callback(res[0]);
            } else callback(null);
          }
        });
      }

      /** Save data to the attrack sqlite table.
          From CliqzAttrack.saveRecord
       */
      function saveRecord$1(id, data) {
        if (!dbConn) {
          init$3();
        }
        if (id.startsWith('cliqz.dbattrack.')) {
          id = id.substring('cliqz.dbattrack.'.length);
        }
        const stmt = dbConn.createAsyncStatement("INSERT OR REPLACE INTO attrack (id,data) VALUES (:id, :data)");
        stmt.params.id = id;
        stmt.params.data = data;

        // Warning: do not put any callbacks to Async queries,
        // they will blow if case Javascript contexed is terminated - for example
        // by user disabling extension.
        stmt.executeAsync();
      }

      function deleteRecord$1(id) {
        if (!dbConn) {
          init$3();
        }
        if (id.startsWith('cliqz.dbattrack.')) {
          id = id.substring('cliqz.dbattrack.'.length);
        }

        const stmt = dbConn.createAsyncStatement("DELETE FROM attrack WHERE id = :id");
        stmt.params.id = id;
        stmt.executeAsync();
      }

      var sto = {
        getItem: function getItem(id) {
          return new Promise((resolve, reject) => {
            loadRecord$1(id, resolve);
          });
        },
        setItem: function setItem(id, value) {
          saveRecord$1(id, value);
        },
        removeItem: function removeItem(id) {
          deleteRecord$1(id);
        },
        setObject(key, object) {
          this.setItem(key, JSON.stringify(object));
        },
        getObject(key) {
          let notFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          const o = this.getItem(key);
          if (o) {
            return JSON.parse(o);
          }
          return notFound;
        }
      };

      /* eslint-disable no-shadow, no-param-reassign */
      /** Load data from the attrack sqlite table.
          From CliqzAttrack.loadRecord
       */
      function loadRecord(id, callback) {
        sto.getItem(`cliqz.dbattrack.${id}`).then(callback);
      }

      /** Save data to the attrack sqlite table.
          From CliqzAttrack.saveRecord
       */
      function saveRecord(id, data) {
        sto.setItem(`cliqz.dbattrack.${id}`, data);
      }

      function deleteRecord(id) {
        return sto.removeItem(`cliqz.dbattrack.${id}`);
      }

      class PersistenceHandler {
        constructor(name, target, dirty) {
          this.name = name;
          this.target = target;
          this.dirty = dirty || false;
          // write dirty pages every minute
          pm.register(this.persistState.bind(this), 60000, this.isDirty.bind(this));

          // propegate proxy down object leaves
          Object.keys(this.target).forEach(k => {
            this.target[k] = this.proxyBranch(this.target[k]);
          });

          // trap for set operations
          this.set = function set(target, property, value) {
            // propegate proxy down object tree
            target[property] = this.proxyBranch(value);
            this.dirty = true;
            return true;
          };
          // trap for delete operations
          this.deleteProperty = function deleteProperty(target, property) {
            delete target[property];
            this.dirty = true;
            return true;
          };
        }

        persistState() {
          if (this.dirty) {
            saveRecord(this.name, JSON.stringify(this.target));
            this.dirty = false;
          }
        }

        proxyBranch(obj) {
          if (typeof obj === 'object') {
            Object.keys(obj).forEach(k => {
              obj[k] = this.proxyBranch(obj[k]);
            });
            return new Proxy(obj, this);
          }
          return obj;
        }

        isDirty() {
          return this.dirty;
        }
      }

      function getValue(key, defaultValue) {
        return CliqzUtils.getPref(`attrack.${key}`, defaultValue);
      }

      function setValue(key, value) {
        CliqzUtils.setPref(`attrack.${key}`, value);
      }

      class LazyPersistentObject {
        constructor(name) {
          this.name = name;
          this.value = {};
          this.dirty = false;
        }

        load() {
          return new Promise(resolve => {
            loadRecord(this.name, value => {
              try {
                this.value = JSON.parse(value || '{}');
              } catch (e) {
                this.value = {};
                this.dirty = true;
              }
              resolve(this.value);
            });
          });
        }

        save() {
          if (this.dirty) {
            saveRecord(this.name, JSON.stringify(this.value));
            this.dirty = false;
          }
        }

        setValue(v) {
          this.value = v;
          this.dirty = true;
          this.save();
        }

        setDirty() {
          this.dirty = true;
        }

        isDirty() {
          return this.dirty;
        }

        clear() {
          this.value = {};
          this.dirty = true;
          this.save();
        }
      }

      function deletePersistantObject(name) {
        return deleteRecord(name);
      }

      class PersistentObject {
        constructor(name, setter) {
          this.name = name;
          this.value = {};
          this.dirty = false;
          this.setter = setter;
          this.setter(this.value);
          this.load();
        }

        load() {
          loadRecord(this.name, value => {
            try {
              this.value = JSON.parse(value || '{}');
            } catch (e) {
              this.value = {};
              this.dirty = true;
            }
            this.setter(this.value);
          });
        }

        setValue(v) {
          this.value = v;
          this.dirty = true;
          this.setter(v);
          this.save();
        }

        save() {
          if (this.dirty) {
            saveRecord(this.name, JSON.stringify(this.value));
            this.dirty = false;
          }
        }

        setDirty() {
          this.dirty = true;
        }

        isDirty() {
          return this.dirty;
        }

        clear() {
          this.value = {};
          this.dirty = true;
          this.save();
          this.setter(this.value);
        }
      }

      class AutoPersistentObject extends PersistentObject {
        constructor(name, setter, saveInterval) {
          super(name, setter);
          pm.register(this.save.bind(this), saveInterval, this.isDirty.bind(this));
        }
      }

      // this is the sanitised timestamp retrieved from humanweb.
      let hwTs = null;

      function getConfigTs() {
        // lazy loading of pref
        if (hwTs === null) {
          hwTs = CliqzUtils.getPref('config_ts', null);
        }
        return hwTs;
      }

      function updateTimestamp(ts) {
        hwTs = ts;
      }

      /** Get datetime string of the current hour in the format YYYYMMDDHH
       */
      function getTime$1() {
        const date = new Date();
        var ts = hwTs;
        var _ts;
        if (!ts) {
          var d = null;
          var m = null;
          var y = null;
          var h = null;
          var hr = null;
          var _ts = null;
          d = (date.getDate() < 10 ? "0" : "") + date.getDate();
          m = (date.getMonth() < 9 ? "0" : "") + parseInt(date.getMonth() + 1);
          h = (date.getUTCHours() < 10 ? "0" : "") + date.getUTCHours();
          y = date.getFullYear();
          _ts = y + "" + m + "" + d + "" + h;
        } else {
          h = (date.getUTCHours() < 10 ? "0" : "") + date.getUTCHours();
          _ts = ts + "" + h;
        }
        return _ts;
      }

      function newUTCDate() {
        var dayHour = getTime$1();
        return new Date(Date.UTC(dayHour.substring(0, 4), parseInt(dayHour.substring(4, 6)) - 1, dayHour.substring(6, 8), dayHour.substring(8, 10)));
      }

      function hourString(date) {
        var hour = date.getUTCHours().toString();
        return dateString(date) + (hour[1] ? hour : '0' + hour[0]);
      }

      function dateString(date) {
        var yyyy = date.getFullYear().toString();
        var mm = (date.getMonth() + 1).toString(); // getMonth() is zero-based
        var dd = date.getDate().toString();
        return yyyy + (mm[1] ? mm : "0" + mm[0]) + (dd[1] ? dd : "0" + dd[0]); // padding
      }

      function getHourTimestamp() {
        return getTime$1().slice(0, 10);
      }

      var _slicedToArray$10 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      function queryHTML() {
        const core = inject.module('core');

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return core.action('queryHTML', ...args);
      }

      function getHTML$1() {
        const core = inject.module('core');

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return core.action('getHTML', ...args);
      }

      function addDataToUrl$1() {
        const hw = inject.module('human-web');

        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return hw.action('addDataToUrl', ...args);
      }

      function checkPassword(url, callback) {
        const suspicious = queryHTML(url, 'input', 'type,value,name').then(inputs => inputs.some(input => Object.keys(input).some(attr => attr === 'password' || attr === 'passwort')));

        if (suspicious) {
          callback(url, 'password');
        }
      }

      function checkSingleScript(script) {
        if (!script) {
          return false;
        }

        // if someone try to get the current date
        if (script.indexOf('getTime') > -1 && script.indexOf('getDay') > -1 && script.indexOf('getDate') > -1) {
          return true;
        }

        // if someone try to block exiting
        if (script.indexOf('onbeforeunload') > -1) {
          return true;
        }

        if (script.indexOf('downloadEXEWithName') > -1) {
          return true;
        }
        return false;
      }

      function checkHTML(url, callback) {
        getHTML$1(url).then(htmls => {
          const html = htmls[0];

          if (!html) {
            return;
          }

          if (html.indexOf('progress-bar-warning') > -1 && html.indexOf('progress-bar-success') > -1 || html.indexOf('play-progress') > -1 && html.indexOf('buffer-progress') > -1) {

            callback(url, 'cheat');
            return;
          }

          if (html.indexOf('security') > -1 && html.indexOf('update') > -1 && html.indexOf('account') > -1) {
            callback(url, 'password');
          }
        });
      }

      function checkScript(url, callback) {
        const domain = url.replace('http://', '').replace('https://', '').split('/')[0];

        queryHTML(url, 'script', 'src').then(srcs => {
          const suspicious = srcs.filter(src => src).some(src => {
            // if the script is from the same domain, fetch it
            const dm = src.replace('http://', '').replace('https://', '').split('/')[0];

            if (dm !== domain) {
              return null;
            }

            return fetch(src).then(response => response.text()).then(text => {
              return checkSingleScript(text);
            });
          });

          if (suspicious) {
            callback(url, 'script');
          }
        });

        queryHTML(url, 'script', 'innerHTML').then(scripts => {
          if (scripts.some(checkSingleScript)) {
            callback(url, 'script');
          }
        });
      }

      function checkSuspicious(url, callback) {
        checkScript(url, callback);
        checkHTML(url, callback);
        checkPassword(url, callback);
      }

      function getDomainMd5(url) {
        const domain = url.replace('http://', '').replace('https://', '').split('/')[0];
        return cachedMD5(domain);
      }

      /**
       * This module injects warning message when user visits a phishing site
       * @class AntiPhishing
       * @namespace anti-phishing
       */
      const CliqzAntiPhishing = {
        WHITELISTED_NONE: 0,
        WHITELISTED_SAFE: 1,
        WHITELISTED_TEMPORARY: 2,
        WHITELISTED_PERMANENTLY: 3,
        BW_URL: 'https://antiphishing.cliqz.com/api/bwlist?md5=',
        DELAY: 24,
        forceWhiteList: new LazyPersistentObject('anti-phishing-fw'),
        blackWhiteList: new LazyPersistentObject('anti-phishing-bw'),

        init() {
          CliqzAntiPhishing.blackWhiteList.load();
          CliqzAntiPhishing.clearBWList();
          CliqzAntiPhishing.forceWhiteList.load();
        },

        clearBWList() {
          const bwList = CliqzAntiPhishing.blackWhiteList.value;
          const hour = newUTCDate();
          hour.setHours(hour.getHours() - CliqzAntiPhishing.DELAY);
          const hourCutoff = hourString(hour);

          for (const prefix in bwList) {
            if ('h' in bwList[prefix]) {
              if (bwList[prefix].h < hourCutoff) {
                delete bwList[prefix];
                CliqzAntiPhishing.blackWhiteList.setDirty();
              }
            } else {
              // this one does not have a timestampe, suppose it's out of date
              delete bwList[prefix];
              CliqzAntiPhishing.blackWhiteList.setDirty();
            }
          }
        },

        unload() {
          CliqzAntiPhishing.saveLists();
        },

        clear() {
          CliqzAntiPhishing.clearBlackWhitelist();
          CliqzAntiPhishing.clearForceWhitelist();
        },

        saveLists() {
          CliqzAntiPhishing.blackWhiteList.save();
          CliqzAntiPhishing.forceWhiteList.save();
        },

        getSplitMd5(url) {
          const urlMd5 = getDomainMd5(url);
          const md5Prefix = urlMd5.substring(0, urlMd5.length - 16);
          const md5Surfix = urlMd5.substring(16, urlMd5.length);
          return [md5Prefix, md5Surfix];
        },

        onHwActiveURL(msg) {
          const url = msg.activeURL;

          var _CliqzAntiPhishing$ge = CliqzAntiPhishing.getSplitMd5(url),
              _CliqzAntiPhishing$ge2 = _slicedToArray$10(_CliqzAntiPhishing$ge, 2);

          const md5Prefix = _CliqzAntiPhishing$ge2[0],
                md5Surfix = _CliqzAntiPhishing$ge2[1];

          if (CliqzAntiPhishing.blackWhiteList[md5Prefix] && CliqzAntiPhishing.blackWhiteList[md5Prefix][md5Surfix]) {
            // don't update if the status is already set
            return;
          }
          checkSuspicious(url, CliqzAntiPhishing.updateSuspiciousStatus);
        },

        whitelist(url, tp) {
          tp = tp || CliqzAntiPhishing.WHITELISTED_PERMANENTLY;
          const md5Prefix = CliqzAntiPhishing.getSplitMd5(url)[0];
          const forceWhiteList = CliqzAntiPhishing.forceWhiteList.value;
          forceWhiteList[md5Prefix] = tp;
          CliqzAntiPhishing.forceWhiteList.setDirty();
        },

        whitelistTemporary(url) {
          CliqzAntiPhishing.whitelist(url, CliqzAntiPhishing.WHITELISTED_TEMPORARY);
        },

        markAsSafe(url) {
          CliqzAntiPhishing.whitelist(url, CliqzAntiPhishing.WHITELISTED_SAFE);
        },

        getUrlWhitelistStatus(url) {
          const md5Prefix = CliqzAntiPhishing.getSplitMd5(url)[0];
          const forceWhiteList = CliqzAntiPhishing.forceWhiteList.value;
          return forceWhiteList[md5Prefix] || CliqzAntiPhishing.WHITELISTED_NONE;
        },

        isInWhitelist(url) {
          return CliqzAntiPhishing.getUrlWhitelistStatus(url) !== CliqzAntiPhishing.WHITELISTED_NONE;
        },

        removeForceWhitelist(url) {
          const md5Prefix = CliqzAntiPhishing.getSplitMd5(url)[0];
          const forceWhiteList = CliqzAntiPhishing.forceWhiteList.value;
          if (md5Prefix in forceWhiteList) {
            delete forceWhiteList[md5Prefix];
            CliqzAntiPhishing.forceWhiteList.setDirty();
          }
        },

        clearForceWhitelist() {
          CliqzAntiPhishing.forceWhiteList.value = {};
          CliqzAntiPhishing.forceWhiteList.setDirty();
        },

        clearBlackWhitelist() {
          CliqzAntiPhishing.blackWhiteList.value = {};
          CliqzAntiPhishing.blackWhiteList.setDirty();
        },

        isInABTest() {
          return CliqzUtils.getPref('cliqz-anti-phishing', false);
        },

        isAntiPhishingActive() {
          return CliqzUtils.getPref('cliqz-anti-phishing-enabled', true);
        },

        updateSuspiciousStatus(url, status) {
          const blackWhiteList = CliqzAntiPhishing.blackWhiteList.value;

          var _CliqzAntiPhishing$ge3 = CliqzAntiPhishing.getSplitMd5(url),
              _CliqzAntiPhishing$ge4 = _slicedToArray$10(_CliqzAntiPhishing$ge3, 2);

          const md5Prefix = _CliqzAntiPhishing$ge4[0],
                md5Surfix = _CliqzAntiPhishing$ge4[1];

          if (blackWhiteList[md5Prefix] && blackWhiteList[md5Prefix][md5Surfix]) {
            // don't update if the status is already set
            return;
          }

          if (!blackWhiteList[md5Prefix]) {
            blackWhiteList[md5Prefix] = {};
          }

          blackWhiteList[md5Prefix][md5Surfix] = `suspicious:${status}`;
          CliqzAntiPhishing.blackWhiteList.setDirty();
          addDataToUrl$1(url, 'isMU', status).catch(() => console.log('failed to update url', url));
        }
      };

      var _slicedToArray$9 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      function addDataToUrl() {
        const hw = inject.module('human-web');

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return hw.action('addDataToUrl', ...args);
      }

      function updateBlackWhiteStatus(req, md5Prefix) {
        const hour = getTime$1();
        const response = req.response;
        const blacklist = JSON.parse(response).blacklist;
        const whitelist = JSON.parse(response).whitelist;
        const blackWhiteList = CliqzAntiPhishing.blackWhiteList.value;
        if (!blackWhiteList[md5Prefix]) {
          blackWhiteList[md5Prefix] = {
            h: hour
          };
        }
        for (let i = 0; i < blacklist.length; i++) {
          blackWhiteList[md5Prefix][blacklist[i][0]] = `black:${blacklist[i][1]}`;
        }
        for (let i = 0; i < whitelist.length; i++) {
          blackWhiteList[md5Prefix][whitelist[i]] = 'white';
        }
        CliqzAntiPhishing.blackWhiteList.setDirty();
      }

      function checkStatus(url, md5Prefix, md5Surfix) {
        const blackWhiteList = CliqzAntiPhishing.blackWhiteList.value;
        const bw = blackWhiteList[md5Prefix];
        const status = md5Surfix in bw && bw[md5Surfix].includes('black');
        if (status) {
          addDataToUrl(url, 'anti-phishing', 'block').catch(() => console.log('failed to update url', url));
        }
        return status;
      }

      var Background$8 = background({
        init() /* settitng */{
          CliqzAntiPhishing.init();
          this.CliqzAntiPhishing = CliqzAntiPhishing;
        },

        unload() {
          CliqzAntiPhishing.unload();
        },

        beforeBrowserShutdown() {
          CliqzAntiPhishing.unload();
        },

        actions: {
          isPhishingURL(url) {
            if (!CliqzAntiPhishing.isAntiPhishingActive()) {
              return {
                block: false,
                type: 'phishingURL'
              };
            }

            var _CliqzAntiPhishing$ge = CliqzAntiPhishing.getSplitMd5(url),
                _CliqzAntiPhishing$ge2 = _slicedToArray$9(_CliqzAntiPhishing$ge, 2);

            const md5Prefix = _CliqzAntiPhishing$ge2[0],
                  md5Surfix = _CliqzAntiPhishing$ge2[1];

            // check if whitelisted

            const forceWhiteList = CliqzAntiPhishing.forceWhiteList.value;
            if (md5Prefix in forceWhiteList) {
              if (forceWhiteList[md5Prefix] === CliqzAntiPhishing.WHITELISTED_TEMPORARY) {
                CliqzUtils.setTimeout(() => {
                  delete forceWhiteList[md5Prefix];
                }, 1000);
              }
              return {
                block: false,
                type: 'phishingURL'
              };
            }

            // check cache
            CliqzAntiPhishing.clearBWList();
            const blackWhiteList = CliqzAntiPhishing.blackWhiteList.value;
            if (blackWhiteList[md5Prefix] && blackWhiteList[md5Prefix][md5Surfix] && !blackWhiteList[md5Prefix][md5Surfix].startsWith('suspicious')) {
              return {
                block: checkStatus(url, md5Prefix, md5Surfix),
                type: 'phishingURL'
              };
            } else {
              return new Promise((resolve, reject) => {
                CliqzUtils.httpGet(CliqzAntiPhishing.BW_URL + md5Prefix, req => {
                  updateBlackWhiteStatus(req, md5Prefix);
                  resolve({
                    block: checkStatus(url, md5Prefix, md5Surfix),
                    type: 'phishingURL'
                  });
                }, e => {
                  reject(e);
                }, 3000);
              });
            }
          },

          activator(state, url) {
            switch (state) {
              case 'active':
                CliqzAntiPhishing.removeForceWhitelist(url);
                CliqzUtils.setPref('cliqz-anti-phishing-enabled', true);
                break;
              case 'off_website':
              case 'inactive':
                CliqzUtils.setPref('cliqz-anti-phishing-enabled', true);
                CliqzAntiPhishing.whitelist(url);
                break;
              case 'critical':
              case 'off_all':
                CliqzAntiPhishing.removeForceWhitelist(url);
                CliqzUtils.setPref('cliqz-anti-phishing-enabled', false);
                break;
              default:
                break;
            }
          }
        },

        events: {
          'human-web:active-url': function onActiveUrl() {
            return CliqzAntiPhishing.onHwActiveURL(...arguments);
          }
        }
      });

      var _slicedToArray$11 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      class Win$7 {
        constructor(settings) {
          this.window = settings.window;
        }

        init() {}

        unload() {}

        status() {
          const currentURL = this.window.gBrowser.currentURI.spec;

          var _CliqzAntiPhishing$ge = CliqzAntiPhishing.getSplitMd5(currentURL),
              _CliqzAntiPhishing$ge2 = _slicedToArray$11(_CliqzAntiPhishing$ge, 2);

          const md5Prefix = _CliqzAntiPhishing$ge2[0],
                md5Surfix = _CliqzAntiPhishing$ge2[1];

          const isWhitelisted = CliqzAntiPhishing.isInWhitelist(currentURL);
          const whitelistStatus = CliqzAntiPhishing.getUrlWhitelistStatus(currentURL);
          const active = CliqzUtils.getPref('cliqz-anti-phishing-enabled', true);
          let state = 'active';
          if (isWhitelisted && whitelistStatus !== CliqzAntiPhishing.WHITELISTED_TEMPORARY) {
            state = 'inactive';
          }
          if (!active) {
            state = 'critical';
          }
          return {
            visible: true,
            active,
            isWhitelisted,
            state
          };
        }
      }

      var antiPhishingModule = {
        Background: Background$8,
        Window: Win$7
      };

      var Background$9 = background({
        init() {},

        unload() {}
      });

      /**
      * @namespace context-menu
      */
      class ContextMenu$1 {
        /**
        * @class ContextMenu
        * @constructor
        */
        constructor(config, contextMenu, beforeElem) {
          this.window = config.window;
          this.contextMenu = contextMenu;
          this.beforeElem = beforeElem || this.contextMenu.firstChild;
          this.onPopupShowing = this.onPopupShowing.bind(this);
          this.onPopupHiding = this.onPopupHiding.bind(this);
          this.menuItems = [];
        }

        addMenuItem(_ref) {
          let label = _ref.label;
          var _ref$onclick = _ref.onclick;
          let onclick = _ref$onclick === undefined ? () => {} : _ref$onclick,
              icon = _ref.icon,
              beforeElem = _ref.beforeElem;
          var _ref$disabled = _ref.disabled;
          let disabled = _ref$disabled === undefined ? false : _ref$disabled;

          const elem = beforeElem || this.beforeElem;
          const menuItem = this.window.document.createElement('menuitem');
          menuItem.setAttribute('label', label);
          if (disabled) {
            menuItem.setAttribute('disabled', true);
          }
          menuItem.addEventListener('click', onclick);
          if (icon) {
            // TODO: not working for me...
            menuItem.setAttribute('style', `list-style-image: url("${icon}");`);
            menuItem.className = 'menuitem-iconic';
          }
          this.contextMenu.insertBefore(menuItem, elem);
          this.menuItems.push(menuItem);
        }

        addSeparator(_ref2) {
          let beforeElem = _ref2.beforeElem;

          const separator = this.window.document.createElement('menuseparator');
          this.contextMenu.insertBefore(separator, beforeElem);
          this.menuItems.push(separator);
        }

        /**
        * Adds listeners to the context menu
        * @method init
        */
        init() {
          this.contextMenu.addEventListener('popupshowing', this.onPopupShowing, false);
          this.contextMenu.addEventListener('popuphiding', this.onPopupHiding, false);
        }

        /**
        * Unloads context menu
        * @method unload
        */
        unload() {
          if (!this.unloaded) {
            this.unloaded = true;
            this.removeMenuItems();
            this.contextMenu.removeEventListener('popupshowing', this.onPopupShowing);
            this.contextMenu.removeEventListener('popuphiding', this.onPopupHiding);
          }
        }

        /**
        * @event onPopupShowing
        * @param ev
        */
        onPopupShowing(ev) {
          if (this._onPopupShowing) {
            this._onPopupShowing(ev);
          }
        }

        /**
        * @event onPopupHiding
        * @param ev
        */
        onPopupHiding(ev) {
          if (ev.target !== this.contextMenu) {
            return;
          }
          this.removeMenuItems();
        }

        removeMenuItems() {
          this.menuItems.forEach(x => this.contextMenu.removeChild(x));
          this.menuItems = [];
        }
      }

      function trim(text) {
        const _text = text.trim();
        if (_text.length > 15) {
          return `${_text.substring(0, 15)}...`;
        }
        return _text;
      }

      /**
      * @namespace context-menu
      */
      class Win$8 {
        /**
        * @class ContextMenu
        * @constructor
        */
        constructor(config$$1) {
          this.config = config$$1;
          this.window = config$$1.window;
          this.menus = [];
          this.actions = {
            makeContextMenu: this.makeContextMenu.bind(this)
          };
        }

        makeContextMenu() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          const menu = new ContextMenu$1(...args);
          this.menus.push(menu);
          return menu;
        }

        /**
        * Adds listeners to the context menu
        * @method init
        */
        init() {
          this.initPageMenu(); // Right-click on page content
        }

        /**
        * Unloads context menu
        * @method unload
        */
        unload() {
          this.unloadPageMenu();
          this.menus.forEach(menu => menu.unload());
          this.menus = [];
        }

        initPageMenu() {
          const config$$1 = this.config;
          const window = this.window;
          const contextMenu = window.document.getElementById('contentAreaContextMenu');
          this.builtInSearchItem = window.document.getElementById('context-searchselect');
          this.pageMenu = new ContextMenu$1(config$$1, contextMenu, this.builtInSearchItem);

          this.pageMenu._onPopupShowing = ev => {
            CliqzUtils.telemetry({
              type: 'context_menu',
              action: 'open',
              context: 'webpage'
            });
            if (ev.target !== contextMenu) {
              return;
            }

            if (this.window.gContextMenu === undefined) {
              // we need to find a solution for e10s
              return;
            }

            let selection = '';
            if (this.window.gContextMenu.selectionInfo.text) {
              selection = this.window.gContextMenu.selectionInfo.text;
            }

            // Can't do once in constructor, because it's dynamic.
            // Check if this is CLIQZ browser
            if (config$$1.settings.channel === '40') {
              // Hide default search option
              this.builtInSearchItem.setAttribute('hidden', 'true');
            }

            if (selection) {
              const isFreshtab = this.window.gBrowser.currentURI.spec === config$$1.settings.NEW_TAB_URL;
              this.pageMenu.addMenuItem({
                label: CliqzUtils.getLocalizedString('context-menu-search-item', trim(selection)),
                onclick: () => {
                  const query = selection;
                  const options = { openInNewTab: !isFreshtab };
                  CliqzUtils.telemetry({
                    type: 'context_menu',
                    action: 'search',
                    query_length: query.length
                  });
                  // opens a new empty tab
                  if (options.openInNewTab) {
                    CliqzUtils.openTabInWindow(this.window, '', true);
                  }

                  const urlbar = this.window.document.getElementById('urlbar');

                  urlbar.mInputField.focus();
                  urlbar.mInputField.setUserInput(query);
                }
              });
            }
          };
          this.pageMenu.init();
        }

        unloadPageMenu() {
          this.pageMenu.unload();
          this.builtInSearchItem.removeAttribute('hidden');
        }
      }

      var contextMenuModule = {
        Background: Background$9,
        Window: Win$8
      };

      /* global NewTabURL */

      const getNewTabService = () => Components.classes['@mozilla.org/browser/aboutnewtab-service;1'].getService(Components.interfaces.nsIAboutNewTabService);

      function setNewTabPage(url) {
        if (Components.classes['@mozilla.org/browser/aboutnewtab-service;1']) {
          const aboutNewTabService = getNewTabService();
          aboutNewTabService.newTabURL = url;
        } else {
          Components.utils.import('resource:///modules/NewTabURL.jsm');
          NewTabURL.override(url);
        }
      }

      function resetNewTabPage() {
        if (Components.classes['@mozilla.org/browser/aboutnewtab-service;1']) {
          const aboutNewTabService = getNewTabService();
          aboutNewTabService.resetNewTabURL();
        } else {
          Components.utils.import('resource:///modules/NewTabURL.jsm');
          NewTabURL.reset();
        }
      }

      function setHomePage(url) {
        prefs.set('browser.startup.homepage', url, '');
      }

      function getHomePage() {
        return prefs.get('browser.startup.homepage', null, '');
      }

      function migrate() {
        // migrate old homepage url to new one
        const currentHomepage = getHomePage();
        if (currentHomepage === 'about:cliqz' ||
        // we moved from the resource url to chrome url in X.21.0
        // we moved from chrome url to https url in X.21.3 and X.22.X
        currentHomepage === 'chrome://cliqz/content/freshtab/home.html' || currentHomepage === 'resource://cliqz/freshtab/home.html') {
          setHomePage(config.settings.NEW_TAB_URL);
        }
      }

      class AboutCliqz {
        get QueryInterface() {
          return XPCOMUtils.generateQI([Components.interfaces.nsIAboutModule]);
        }

        getURIFlags() {
          return Components.interfaces.nsIAboutModule.ALLOW_SCRIPT;
        }

        newChannel(aURI, aLoadInfo) {
          /* all this is plain bad, please fix me */
          /* the point is to have 'about:cliqz' that redirects to resource:// url */
          const fakePage = `data:text/html,
      <script>
        var wm = Components.classes['@mozilla.org/appshell/window-mediator;1']
          .getService(Components.interfaces.nsIWindowMediator);
        var w = wm.getMostRecentWindow('navigator:browser');
        var url = '${config.settings.NEW_TAB_URL}';
        w.gBrowser.addTab(url);
        window.close();
      </script>
    `;
          let channel;

          if (Services.vc.compare(Services.appinfo.version, '47.*') > 0) {
            const uri = Services.io.newURI(fakePage, null, null);
            channel = Services.io.newChannelFromURIWithLoadInfo(uri, aLoadInfo);
          } else {
            channel = Services.io.newChannel(fakePage, null, null);
          }

          channel.owner = Services.scriptSecurityManager.getSystemPrincipal();

          return channel;
        }

        static get classID() {
          /* eslint-disable */
          return Components.ID('{D5889F72-0F01-4aee-9B88-FEACC5038C34}');
          /* eslint-enable */
        }

        static get classDescription() {
          return 'CLIQZ New Tab Page';
        }

        static get contractID() {
          return '@mozilla.org/network/protocol/about;1?what=cliqz';
        }

        static get manager() {
          return Components.manager.QueryInterface(Components.interfaces.nsIComponentRegistrar);
        }

        static register() {
          if (!this.manager.isCIDRegistered(this.classID)) {
            this.manager.registerFactory(this.classID, this.classDescription, this.contractID, this);
          }
        }

        static unregister() {
          this.manager.unregisterFactory(this.classID, this);
        }

        static createInstance(outer, iid) {
          if (outer) {
            throw Components.results.NS_ERROR_NO_AGGREGATION;
          }

          return new AboutCliqz().QueryInterface(iid);
        }
      }

      const NEW_TAB_URL = config.settings.NEW_TAB_URL;
      const PREF_NEW_TAB_BUTTON_STATE = 'freshtab.state';
      const PREF_HOME_PAGE_BACKUP = 'backup.homepage';

      var NewTabPage = {

        get isActive() {
          if (isCliqzBrowser) {
            return true;
          }

          return prefs.get(PREF_NEW_TAB_BUTTON_STATE, false);
        },

        startup() {
          if (this.isActive) {
            this.enableNewTabPage();
          }

          AboutCliqz.register();

          migrate();
        },

        shutdown() {
          resetNewTabPage();

          AboutCliqz.unregister();

          // save current homepage to backup
          if (this.isActive) {
            prefs.set(PREF_HOME_PAGE_BACKUP, getHomePage());
          }
        },

        enableNewTabPage() {
          AboutCliqz.register();
          setNewTabPage(NEW_TAB_URL);
        },

        enableHomePage() {
          const homePageBackup = prefs.get(PREF_HOME_PAGE_BACKUP);
          AboutCliqz.register();
          // If Home Page was already set once, we don't everwrite it again
          if (homePageBackup) {
            return;
          }

          const currentHomePage = getHomePage();

          prefs.set(PREF_HOME_PAGE_BACKUP, currentHomePage);
          prefs.set(PREF_NEW_TAB_BUTTON_STATE, true);

          setHomePage(NEW_TAB_URL);
        },

        /**
         * Rollback to browser original settings
         */
        rollback() {
          const homePageBackup = prefs.get(PREF_HOME_PAGE_BACKUP);
          const currentHomePage = getHomePage();

          AboutCliqz.unregister();

          if (currentHomePage === NEW_TAB_URL && homePageBackup) {
            setHomePage(homePageBackup);
          } else if (currentHomePage !== NEW_TAB_URL) {
            prefs.set(PREF_HOME_PAGE_BACKUP, currentHomePage);
          }

          resetNewTabPage();
        },

        setPersistentState(state) {
          prefs.set(PREF_NEW_TAB_BUTTON_STATE, state);
        }
      };

      var NEWS_DOMAINS_LIST = { 10571409: true, 179333071: true, 178958752: true, 237739211: true, 147399383: true, 48892272: true, 240417088: true, 147724433: true, 108380849: true, 169904261: true, 14839075: true, 70195478: true, 71051945: true, 43745330: true, 5357951: true, 172434164: true, 101941303: true, 42094671: true, 46511969: true, 146672137: true, 72797110: true, 36104430: true, 147530643: true, 136594333: true, 33561804: true, 80384420: true, 5982326: true, 102857348: true, 43614181: true, 148890453: true, 74231485: true, 141454235: true, 245292361: true, 12722702: true, 13840217: true, 10929352: true, 75216604: true, 73453305: true, 148999872: true, 75409704: true, 42647411: true, 180898825: true, 140232211: true, 184542214: true, 82900549: true, 83508049: true, 209425120: true, 50214650: true, 76821306: true, 114075108: true, 136954268: true, 113436635: true, 9282076: true, 145917300: true, 175784971: true, 70630552: true, 139156437: true, 106463557: true, 75783985: true, 248962108: true, 9892497: true, 103752472: true, 16295799: true, 2997498: true, 34265112: true, 82809060: true, 209792714: true, 37794597: true, 15870603: true, 101941523: true, 242777366: true, 74542960: true, 48888990: true, 5445926: true, 238555909: true, 210639236: true, 112934951: true, 15923252: true, 82052855: true, 136713798: true, 78394015: true, 144696931: true, 107727411: true, 40762155: true, 136269672: true, 172455381: true, 45585948: true, 11737641: true, 168119182: true, 68773555: true, 134355940: true, 81889451: true, 12929557: true, 150613827: true, 72270683: true, 150584451: true, 12579447: true, 74963860: true, 78966730: true, 36616645: true, 107003152: true, 43523480: true, 174373373: true, 37350675: true, 112927802: true, 150804598: true, 5921576: true, 181374631: true, 147460736: true, 45490817: true, 39404899: true, 105504157: true, 4157585: true, 143002826: true, 43103236: true, 136180937: true, 111313536: true, 40196024: true, 237154361: true, 180198292: true, 44296786: true, 8639085: true, 142651775: true, 138715048: true, 5891625: true, 4454032: true, 109605547: true, 110344242: true, 144944349: true, 37848620: true, 44614606: true, 69266294: true, 149187007: true, 142675546: true, 113298437: true, 68531186: true, 68485914: true, 243041052: true, 75099086: true, 246602533: true, 104614242: true, 102881421: true, 113652989: true, 5759018: true, 238853758: true, 179468108: true, 180767455: true, 174500628: true, 113843141: true, 135470335: true, 140838989: true, 44175368: true, 16553575: true, 2487332: true, 108090229: true, 76965235: true, 115271636: true, 145526129: true, 248906303: true, 243524240: true, 169382283: true, 45285918: true, 3439569: true, 13995383: true, 175558969: true, 136808501: true, 141526403: true, 73353973: true, 171949145: true, 183218837: true, 71156889: true, 81471951: true, 2511443: true, 82065538: true, 141793488: true, 137667936: true, 108843334: true, 205558795: true, 80443423: true, 183318663: true, 13956180: true, 238566753: true, 145735407: true, 71039905: true, 6296201: true, 15363587: true, 104780054: true, 34591468: true, 10922616: true, 238098952: true, 106180769: true, 175305615: true, 174752059: true, 6407576: true, 203545094: true, 789884: true, 209713987: true, 105365837: true, 81150235: true, 140910568: true, 106652389: true, 79676979: true, 217546276: true, 33736488: true, 6161388: true, 76261549: true, 11853015: true, 243466225: true, 68105860: true, 37181072: true, 168156548: true, 108523534: true, 117319634: true, 74661948: true, 76644610: true, 113095973: true, 13942670: true, 76874335: true, 71790765: true, 82442170: true, 251365296: true, 71632735: true, 210718434: true, 6525262: true, 49548588: true, 10398446: true, 38607057: true, 77870507: true, 104278336: true, 241863379: true, 83475460: true, 79047610: true, 16063865: true, 147186497: true, 115867194: true, 182341254: true, 77201485: true, 215753401: true, 215753398: true, 38686913: true, 234985930: true, 80093344: true, 248077469: true, 143998729: true, 113796197: true, 115978914: true, 215437472: true, 79476327: true, 48178038: true, 108585199: true, 796680: true, 173484923: true, 100816321: true, 211123764: true, 79743113: true, 245440575: true, 247103814: true, 243466268: true, 216243619: true, 37827792: true, 179374898: true, 6529331: true, 72932762: true, 241696853: true, 100667580: true, 79963139: true, 82141174: true, 67904957: true, 239942081: true, 171233903: true, 4574823: true, 2189348: true, 201572094: true, 111149262: true, 148532105: true, 150066519: true, 145667094: true, 143689046: true, 111257651: true, 79660549: true, 39527122: true, 4592036: true, 101198513: true, 6397677: true, 44437765: true, 170749808: true, 250561709: true, 101589065: true, 202902407: true, 137825482: true, 206470712: true, 242422332: true, 34378709: true, 205726722: true, 149024640: true, 73348137: true, 67532110: true, 76948360: true, 106494023: true, 150921227: true, 149652911: true, 168693251: true, 243280788: true, 207458364: true, 247500342: true, 248734759: true, 236142977: true, 474600: true, 250101365: true, 79644861: true, 206528356: true, 7344833: true, 4384695: true, 8996919: true, 71759466: true, 112434967: true, 49945901: true, 40389129: true, 5807052: true, 245704031: true, 180095924: true, 45794709: true, 213331124: true, 143395708: true, 140810706: true, 3483613: true, 109662177: true, 216514350: true, 80690384: true, 138139369: true, 237492899: true, 76928335: true, 144770664: true, 5604551: true, 214714184: true, 80717687: true, 33802677: true, 136492807: true, 143261715: true, 251470487: true, 4504905: true, 182872720: true, 15971319: true, 114467095: true, 243466254: true, 241730435: true, 5972966: true, 217706451: true, 108568271: true, 81969172: true, 9583554: true, 4146807: true, 242204751: true, 69620493: true, 109152934: true, 76484655: true, 241173928: true, 77474825: true, 81658130: true, 139923274: true, 211939645: true, 171248693: true, 135719188: true, 74755100: true, 137978005: true, 168609785: true, 180948925: true, 3977446: true, 170718023: true, 44971794: true, 170940909: true, 140391363: true, 41314131: true, 113800544: true, 105372134: true, 4021948: true, 182576755: true, 105880115: true, 216124125: true, 244781366: true, 245082466: true, 150359424: true, 145555265: true, 14345939: true, 173065324: true, 148531919: true, 112652137: true, 68262644: true, 101314158: true, 106647141: true, 239119048: true, 205798148: true, 3462868: true, 179698917: true, 37775008: true, 207641190: true, 210161238: true, 182248312: true, 169904458: true, 167796712: true, 237422416: true, 15299156: true, 212983134: true, 42941135: true, 236458718: true, 34606719: true, 74516787: true, 76833867: true, 169904452: true, 110038646: true, 1857910: true, 36909212: true, 76045833: true, 178958795: true, 77515611: true, 201774982: true, 116229637: true, 42041884: true, 1794758: true, 111497759: true, 45142207: true, 1271721: true, 139715282: true, 238595002: true, 181502899: true, 215549392: true, 77781318: true, 8863722: true, 177387947: true, 75446711: true, 134453699: true, 243466315: true, 108671135: true, 168879163: true, 216598077: true, 142555356: true, 106030056: true, 174171886: true, 183456569: true, 4058606: true, 9179572: true, 75387708: true, 243084430: true, 134687466: true, 48573962: true, 248724254: true, 150613963: true, 147148965: true, 44025793: true, 247738870: true, 83094546: true, 80961546: true, 76971985: true, 6355568: true, 72264310: true, 78462725: true, 139925606: true, 79317962: true, 242811461: true, 114352614: true, 46500457: true, 70613528: true, 108577307: true, 73573547: true, 177635472: true };

      const ONE_MINUTE$3 = 60 * 1000;

      function log$6(s) {
        CliqzUtils.log(s, 'CliqzFreshTabNews - cache');
      }

      class NewsCache {
        constructor(cacheName, updateInterval, updateFunction, updateAsynchronously) {
          this.cacheName = cacheName;
          this.timerName = `${cacheName}_timer`;
          this.updateInterval = updateInterval;
          this.localStore = CliqzUtils.getLocalStorage(config.settings.NEW_TAB_URL);
          this.updateFunction = updateFunction;

          // remove old versions of the caches
          if (this.localStore.getItem('freshTab-data')) {
            this.localStore.removeItem('freshTab-data');
          }
          if (this.localStore.getItem('freshTab-news-cache')) {
            this.localStore.removeItem('freshTab-news-cache');
          }

          this.cacheWasRetrieved = false;
          if (updateAsynchronously) {
            this.updateTimer = CliqzUtils.setTimeout(this.asynchronousUpdate.bind(this), 5 * 1000);
          }
        }

        reset() {
          this.localStore.removeItem(this.cacheName);
          this.localStore.removeItem(this.timerName);
        }

        asynchronousUpdate() {
          if (!this.cacheWasRetrieved) {
            this.updateTimer = CliqzUtils.setTimeout(this.asynchronousUpdate.bind(this), 5 * ONE_MINUTE$3);
          } else {
            this.cacheWasRetrieved = false;
            Promise.resolve(this.isStale()).then(isStale => isStale ? this.updateCache() : Promise.resolve()).then(() => this.updateTimer = CliqzUtils.setTimeout(this.asynchronousUpdate.bind(this), Math.max(this.getTimeToNextUpdate(), 1000)));
          }
        }

        getNextUpdateTime() {
          return parseInt(this.localStore.getItem(this.timerName) || 0, 10) + this.updateInterval;
        }

        getTimeToNextUpdate() {
          return this.getNextUpdateTime() - Date.now();
        }

        updateLastUpdateTime() {
          this.localStore.setItem(this.timerName, `${Date.now()}`);
        }

        putDataToCache(data) {
          log$6('put data to cache ' + this.cacheName);
          this.localStore.setItem(this.cacheName, JSON.stringify(data));
          this.updateLastUpdateTime();
        }

        isStale() {
          if (CliqzUtils.getPref('freshTabByPassCache', false)) {
            log$6(`Bypass cache: ${this.cacheName}`);
            return true;
          }
          return this.getNextUpdateTime() < Date.now();
        }

        parseDataFromCache() {
          try {
            return JSON.parse(this.localStore.getItem(this.cacheName) || '{}');
          } catch (err) {
            log$6(`Error parsing cache ${this.cacheName} ${err}.`);
            return {};
          }
        }

        updateCache() {
          return this.updateFunction(this.parseDataFromCache()).then(this.putDataToCache.bind(this)).catch(e => log$6(`Error "${e}", cache ${this.cacheName} is not updated.`));
        }

        getData() {
          this.cacheWasRetrieved = true;
          let updatePromise;
          if (this.isStale()) {
            updatePromise = this.updateCache();
          } else {
            updatePromise = Promise.resolve();
          }
          return updatePromise.then(() => this.parseDataFromCache());
        }
      }

      var _slicedToArray$12 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const ONE_MINUTE$2 = 60 * 1000;
      const ONE_DAY$1 = 24 * 60 * ONE_MINUTE$2;
      const ONE_MONTH = 30 * ONE_DAY$1;
      const PRESS_CLIPPING_MAPPING = { 218038589: 'xing-pressespiegel_burda' };

      const HBASED_RECOM_CACHE_UPDATE_INTERVAL = ONE_DAY$1;
      const HABASED_NEWS_CACHE_UPDATE_INTERVAL = 30 * ONE_MINUTE$2;
      const TOP_NEWS_CACHE_UPDATE_INTERVAL = 30;

      const topNewsTypeKey = 'topnews';
      const hbasedNewsTypeKey = 'yournews';
      const prClBurdaNewsTypeKey = 'pr-cl-burda-news';
      const breakingNewsTypeKey = 'breaking-news';

      const NEWS_BACKENDS = ['de', 'fr'];
      const FRESHTAB_CONFIG_PREF$1 = 'freshtabConfig';

      function log$5(s) {
        CliqzUtils.log(s, 'CliqzFreshTabNews');
      }

      const hbasedRecommendCacheObject = new NewsCache('freshTab-recommend-cache', HBASED_RECOM_CACHE_UPDATE_INTERVAL, getHistoryBasedRecommendations, true);
      const topNewsCacheObject = new NewsCache('freshTab-topnews-cache', TOP_NEWS_CACHE_UPDATE_INTERVAL, getTopNewsList, false);
      const hbasedNewsCacheObject = new NewsCache('freshTab-hbased-cache', HABASED_NEWS_CACHE_UPDATE_INTERVAL, getHbasedNewsObject, true);

      function requestBackend(url, data) {
        log$5(`Request url: ${url}`);
        return CliqzUtils.promiseHttpHandler('PUT', url, data).then(response => {
          const resData = JSON.parse(response.response);
          if (!resData.results || resData.results.length === 0) {
            throw `Backend response from ${url} is not valid "${JSON.stringify(resData)}."`;
          }
          return {
            results: [resData.results[0].snippet.extra]
          };
        });
      }

      function checkNewsTypeForHbasedRequest(newsPlacingRecord) {
        return newsPlacingRecord.type === hbasedNewsTypeKey || newsPlacingRecord.type === prClBurdaNewsTypeKey;
      }

      function getNewsLanguage() {
        const locale = CliqzUtils.PREFERRED_LANGUAGE;

        for (var i = 0; i < NEWS_BACKENDS.length; i += 1) {
          if (locale.indexOf(NEWS_BACKENDS[i]) !== -1) {
            return NEWS_BACKENDS[i];
          }
        }

        // international news if the user uses and unsupported locale
        return 'intl';
      }

      function getNewsPreferedCountryParam() {
        var ftConfig = JSON.parse(CliqzUtils.getPref(FRESHTAB_CONFIG_PREF$1, '{}'));
        if (!ftConfig.news || !ftConfig.news.preferedCountry) {
          ftConfig.news = Object.assign({}, ftConfig.news, {
            preferedCountry: getNewsLanguage()
          });

          CliqzUtils.setPref(FRESHTAB_CONFIG_PREF$1, JSON.stringify(ftConfig));
        }

        return '&news_edition=' + ftConfig.news.preferedCountry;
      }

      function getTopNewsList() {
        var url = CliqzUtils.RICH_HEADER + CliqzUtils.getRichHeaderQueryString('') + getNewsPreferedCountryParam(),
            data = {
          q: '',
          results: [{
            url: 'rotated-top-news.cliqz.com',
            snippet: {}
          }]
        };
        return requestBackend(url, JSON.stringify(data));
      }

      function getHbasedNewsObject() {

        function filterNotRequiredDomains(reqData, hbasedRecom) {
          function getHbasedNewsDict(hbasedResults) {
            return hbasedResults && hbasedResults.results && hbasedResults.results[0] && hbasedResults.results[0].news || {};
          }

          return new Promise(resolve => {
            let hbNewsDict = getHbasedNewsDict(reqData);
            let newsPlacing = hbasedRecom.newsPlacing || [];

            const reqDomains = newsPlacing.filter(checkNewsTypeForHbasedRequest).map(r => r.domain.split('/')[0]);

            let cleanhbNewsDict = {};

            reqDomains.forEach(domain => {
              if (hbNewsDict.hasOwnProperty(domain)) {
                cleanhbNewsDict[domain] = hbNewsDict[domain];
              }
            });
            resolve(cleanhbNewsDict);
          });
        }

        function requestHbasedNewsList(hbasedRecom) {
          let requestPromise;

          if (hbasedRecom.hashList.length === 0) {
            requestPromise = Promise.resolve({});
          } else {
            var query = JSON.stringify(hbasedRecom.hashList),
                url = CliqzUtils.RICH_HEADER + CliqzUtils.getRichHeaderQueryString(query),
                data = {
              q: query,
              results: [{
                url: 'hb-news.cliqz.com',
                snippet: {}
              }]
            };

            requestPromise = requestBackend(url, JSON.stringify(data)).then(reqData => filterNotRequiredDomains(reqData, hbasedRecom));
          }

          return requestPromise;
        }

        return hbasedRecommendCacheObject.getData().then(requestHbasedNewsList);
      }

      /**
      * Process history to get recommendations for history based news
      * @method getHistoryBasedRecommendations
      */
      function getHistoryBasedRecommendations(oldCacheData) {
        function getGlobalVisitCountFromPref() {
          try {
            const globalVisitCount = CliqzUtils.getPref('globalVisitCount', false);
            if (globalVisitCount) {
              log$5('Global visit count is taken from the preference.');
            }
            return JSON.parse(globalVisitCount);
          } catch (err) {
            log$5(`Error parsing global visit count: ${err}`);
            return false;
          }
        }

        function checkIfDomainForCounting(domain) {
          const hash = parseInt(CliqzUtils.hash(domain), 10);
          return NEWS_DOMAINS_LIST[hash] || PRESS_CLIPPING_MAPPING[hash];
        }

        // take history visit count only for the exact domain and sub domains, not for articles' url
        function pathHasIndex(path) {
          const pathArray = path.split('/');
          const lastPathElement = pathArray[pathArray.length - 1];
          return !lastPathElement || pathArray.length === 1 || lastPathElement.indexOf('index') === 0;
        }

        function addHRecordToGlobalVisitCount(record, globalVisitCount) {
          const urlData = extractSimpleURI(record.url);
          if (checkIfDomainForCounting(urlData.cleanHost)) {
            let domainVisitCount;
            if (pathHasIndex(urlData.path)) {
              domainVisitCount = record.visit_count;
            } else {
              domainVisitCount = 1;
            }
            mergeToGlobalVisitCount(urlData, domainVisitCount, globalVisitCount);
          }
        }

        const sqlStatement = 'SELECT * FROM moz_places WHERE last_visit_date>:date';
        const sqlOutputParameters = ['url', 'last_visit_date', 'visit_count'];
        const sqlInputParameters = { date: (Date.now() - ONE_MONTH) * 1000 };

        let globalVisitCount = {};

        return new Promise(resolve => {
          CliqzHistoryManager.PlacesInterestsStorage._execute(sqlStatement, sqlOutputParameters, record => {
            addHRecordToGlobalVisitCount(record, globalVisitCount);
          }, sqlInputParameters).then(() => {
            globalVisitCount = normalizeGlobalVisitCount(globalVisitCount);
            log$5(globalVisitCount);

            globalVisitCount = getGlobalVisitCountFromPref() || globalVisitCount;

            const newsPlacing = composeHistoryBasedRecommendations(globalVisitCount);
            const historyBasedRecommendations = {
              newsPlacing,
              hashList: composeDomainHasheList(newsPlacing, oldCacheData)
            };

            log$5(historyBasedRecommendations);

            resolve(historyBasedRecommendations);
          });
        });
      }

      function mergeToGlobalVisitCount(urlDesc, visitCount, globalVisitCount) {
        function subUrlCheck(subUrl) {
          return subUrl && subUrl.indexOf('index') !== 0 && subUrl.length > 2 && subUrl.length < 15;
        }

        function ifCountSubLevel(urlPathList, recursionLevel) {
          return recursionLevel < 4 && recursionLevel < urlPathList.length && !(urlPathList.length !== 1 && recursionLevel >= urlPathList.length - 1) && subUrlCheck(urlPathList[recursionLevel]);
        }

        function countSubCategories(subVisitCount, urlPathList, vCount, recursionLevel) {
          if (ifCountSubLevel(urlPathList, recursionLevel)) {
            const subDomain = urlPathList[recursionLevel];

            if (!(subVisitCount[subDomain] && 'count' in subVisitCount[subDomain])) {
              subVisitCount[subDomain] = { count: 0, sub: {} };
            }

            subVisitCount[subDomain].count += vCount;

            recursionLevel += 1;
            subVisitCount[subDomain].sub = countSubCategories(subVisitCount[subDomain].sub, urlPathList, vCount, recursionLevel);
          }
          return subVisitCount;
        }

        let urlPathList = urlDesc.path.split('/');
        const domain = urlDesc.cleanHost;

        if (!(globalVisitCount[domain] && 'count' in globalVisitCount[domain])) {
          globalVisitCount[domain] = { count: 0, sub: {} };
        }

        globalVisitCount[domain].count += visitCount;

        // cut the first empty part
        if (!urlPathList[0]) {
          urlPathList = urlPathList.slice(1);
        }

        globalVisitCount[domain].sub = countSubCategories(globalVisitCount[domain].sub, urlPathList, visitCount, 0);
      }

      function composeDomainHasheList(newsPlacing, historyBasedRecommendationsCache) {
        function randomValueOf(obj) {
          const keys = Object.keys(obj);
          const rnd = Math.floor(Math.random() * keys.length);
          return parseInt(keys[rnd], 10);
        }

        function sortFunct(i, j) {
          return i < j;
        }

        function getDomainHash(record) {
          return parseInt(CliqzUtils.hash(record.domain.split('/')[0]), 10);
        }

        function subsRandomElement(cachedHashList, domainHashList, elementToAdd) {
          // filter out elements which should be in the hash list
          const randomHashes = cachedHashList.filter(i => domainHashList.indexOf(i) === -1);
          const randomeHashToReplace = randomHashes[randomValueOf(randomHashes)];

          cachedHashList[cachedHashList.indexOf(randomeHashToReplace)] = elementToAdd;
        }

        // extract domains' hashes for history based news
        const domainHashList = newsPlacing.filter(checkNewsTypeForHbasedRequest).map(getDomainHash);
        const cachedHashList = historyBasedRecommendationsCache && historyBasedRecommendationsCache.hashList || [];

        if (domainHashList.length !== 0) {
          const randomisedArraySize = 10;
          let numberOfAdditionalElementsToChange = 0;

          // fill array up to necessary number of hashes
          while (cachedHashList.length < randomisedArraySize) {
            cachedHashList.push(randomValueOf(NEWS_DOMAINS_LIST));
          }

          // fill array with necessary domain hashes
          domainHashList.forEach(domainHash => {
            if (cachedHashList.indexOf(domainHash) === -1) {
              // substitute the necessary element
              subsRandomElement(cachedHashList, domainHashList, domainHash);
              numberOfAdditionalElementsToChange += 1;
            }
          });

          // substitute additional rand. elements
          while (numberOfAdditionalElementsToChange > 0) {
            subsRandomElement(cachedHashList, domainHashList, randomValueOf(NEWS_DOMAINS_LIST));
            numberOfAdditionalElementsToChange -= 1;
          }

          cachedHashList.sort(sortFunct);
        }

        return cachedHashList;
      }

      function normalizeGlobalVisitCount(globalVisitCount) {
        function normalizeRecursion(subUrlCount, sum) {
          Object.keys(subUrlCount).forEach(k => {
            subUrlCount[k].ratio = subUrlCount[k].count / sum;
            subUrlCount[k].sub = normalizeRecursion(subUrlCount[k].sub, subUrlCount[k].count);
          });
          return subUrlCount;
        }

        const glVisit = globalVisitCount;
        let domainsSum = 0;

        Object.keys(glVisit).forEach(k => {
          domainsSum += glVisit[k].count;
        });

        Object.keys(glVisit).forEach(k => {
          glVisit[k].ratio = glVisit[k].count / domainsSum;
          glVisit[k].sub = normalizeRecursion(glVisit[k].sub, glVisit[k].count);
        });
        return glVisit;
      }

      function composeHistoryBasedRecommendations(globalVisitCount) {
        function sortFunct(i, j) {
          return i.count < j.count;
        }

        function getPressClipping(glVisitCount) {
          function getPressClipMapping(domain) {
            return PRESS_CLIPPING_MAPPING[parseInt(CliqzUtils.hash(domain), 10)] || false;
          }
          const glVisit = glVisitCount;
          const pressClipList = [];
          const prClipThreshold = 5;

          let pressClipMapping;
          Object.keys(glVisit).forEach(domain => {
            pressClipMapping = getPressClipMapping(domain);
            if (typeof pressClipMapping === 'string' && glVisit[domain].count > prClipThreshold) {
              glVisit[domain].key = pressClipMapping;
              pressClipList.push(glVisit[domain]);
            }
          });
          return pressClipList;
        }

        function getThreeTopNewsDomains(glVisitCount) {
          function checkIfNewsDomain(domain) {
            return NEWS_DOMAINS_LIST[parseInt(CliqzUtils.hash(domain), 10)] || false;
          }

          const domainCountThreshold = 20;
          const glVisit = glVisitCount;
          const topDomainsList = [];

          Object.keys(glVisit).forEach(domain => {
            if (glVisit.hasOwnProperty(domain) && glVisit[domain].count > domainCountThreshold && checkIfNewsDomain(domain)) {
              glVisit[domain].key = domain;
              topDomainsList.push(glVisit[domain]);
            }
          });

          topDomainsList.sort(sortFunct);
          return topDomainsList.slice(0, 3);
        }

        function addDomainBasedNews(domainCount, articlesToAdd) {
          const subDomainRatioThreshold = 0.6;
          const newsPlacing = [];
          let addedOnSubdomainLevel = 0;

          let numArtToAdd = articlesToAdd;

          // add news placement on sub domain level
          Object.keys(domainCount.sub).forEach(subDomain => {
            if (domainCount.sub[subDomain].ratio > subDomainRatioThreshold) {
              addedOnSubdomainLevel = Math.max(Math.floor(numArtToAdd * domainCount.sub[subDomain].ratio), 1);
              newsPlacing.push({ type: hbasedNewsTypeKey,
                domain: [domainCount.key, subDomain].join('/'),
                number: addedOnSubdomainLevel });
              numArtToAdd -= addedOnSubdomainLevel;
            }
          });

          // add placement for domain level
          if (numArtToAdd > 0) {
            newsPlacing.push({ type: hbasedNewsTypeKey,
              domain: domainCount.key,
              number: numArtToAdd });
          }

          return newsPlacing;
        }

        let newsPlacing = [];

        const pressCliping = getPressClipping(globalVisitCount);
        const topDomainsList = getThreeTopNewsDomains(globalVisitCount);

        // always add 3 general top news
        newsPlacing.push({ type: topNewsTypeKey, domain: topNewsTypeKey, number: 3 });

        // in case of press clipping add one article instead of one of top news articles
        if (pressCliping.length > 0) {
          newsPlacing[0].number = 2;
          newsPlacing.push({ type: prClBurdaNewsTypeKey, domain: pressCliping[0].key, number: 1 });
        }

        // add history based news depend from number of history based domains
        switch (topDomainsList.length) {
          // only top news
          case 0:
            newsPlacing.push({ type: topNewsTypeKey, domain: topNewsTypeKey, number: 9 });
            break;

          // 6 top news, 6 from history based domain
          case 1:
            newsPlacing.push({ type: topNewsTypeKey, domain: topNewsTypeKey, number: 3 });
            newsPlacing = newsPlacing.concat(addDomainBasedNews(topDomainsList[0], 6));
            break;

          // 3 top news, 5 for first history based domain, 4 for second
          case 2:
            newsPlacing = newsPlacing.concat(addDomainBasedNews(topDomainsList[0], 5));
            newsPlacing = newsPlacing.concat(addDomainBasedNews(topDomainsList[1], 4));
            break;

          // 3 top news, 3 from each of 3 history based domains
          case 3:
            topDomainsList.forEach(domainCount => {
              newsPlacing = newsPlacing.concat(addDomainBasedNews(domainCount, 3));
            });
            break;
          default:
            log$5('Wrong number top domains:${topDomainsList.length}.');
        }

        log$5(newsPlacing);
        return newsPlacing;
      }

      function getTopNewsArticles(topNCache) {
        return topNCache && topNCache.results && topNCache.results[0] && topNCache.results[0].articles || [];
      }

      function composeNewsList(historyObject, topNewsCache, hbasedResults) {
        function getTopNewsVersion(topNCache) {
          return topNCache.results && topNCache.results[0] && topNCache.results[0].news_version || 0;
        }

        function notAlreadyInList(url, freshtabArticlesList) {
          function urlCheck(art) {
            return url !== art.url;
          }
          return freshtabArticlesList.every(urlCheck);
        }

        function mergeToList(articlesToMerge, freshtabArticlesList, numberOfNewsToMerge, sourceArticleType, checkIfAlreadyInHistory, urlPatern) {
          function mergeCheck(article, checkHist, urlDomainPatern) {
            return !(!(article.breaking === true) && checkHist && article.isVisited) && notAlreadyInList(article.url, freshtabArticlesList) && article.url.indexOf(urlDomainPatern) !== -1;
          }
          function mergeArticle(article, returnList) {
            const artAdd = article;
            if (artAdd.breaking === true) {
              artAdd.type = breakingNewsTypeKey;
            } else {
              artAdd.type = sourceArticleType;
            }

            returnList.push(artAdd);
          }

          let numToMerge = numberOfNewsToMerge;
          const urlDomainPatern = urlPatern || '';

          articlesToMerge.some(article => {
            if (numToMerge !== 0) {
              if (mergeCheck(article, checkIfAlreadyInHistory, urlDomainPatern)) {
                mergeArticle(article, freshtabArticlesList);
                numToMerge -= 1;
              }
              return false;
            }
            // exit loop if all articles are added
            return true;
          });

          return numToMerge;
        }

        function mergeTopNews(topNewList, freshtabArticlesList, numberOfNewsToMerge) {
          let checkIfInHistory = true;

          const notMergedNewsNumber = mergeToList(topNewList, freshtabArticlesList, numberOfNewsToMerge, topNewsTypeKey, checkIfInHistory);

          // fill empty slots with articles without check with history
          checkIfInHistory = false;
          mergeToList(topNewList, freshtabArticlesList, notMergedNewsNumber, topNewsTypeKey, checkIfInHistory);

          return freshtabArticlesList;
        }

        function mergePressClippingNews(hbasedNewsDict, topNewList, freshtabArticlesList, newsPlacementRecord) {
          const pressClippingName = newsPlacementRecord.domain || '';
          const numberOfNewsToMerge = newsPlacementRecord.number || 0;
          const sourceArticleType = prClBurdaNewsTypeKey;
          const checkIfInHistory = true;

          const hbasedNewsList = hbasedNewsDict[pressClippingName] || [];

          let returnNewsList = freshtabArticlesList;

          const notMergedNewsNumber = mergeToList(hbasedNewsList, returnNewsList, numberOfNewsToMerge, sourceArticleType, checkIfInHistory);

          // if no press cliping can be merged, merge top news instead
          returnNewsList = mergeTopNews(topNewList, returnNewsList, notMergedNewsNumber);

          return returnNewsList;
        }

        function mergeHbasedNews(hbasedNewsDict, topNewList, freshtabArticlesList, newsPlacementRecord) {
          const domainUrlPath = newsPlacementRecord.domain || '';
          const numberOfNewsToMerge = newsPlacementRecord.number || 0;
          const checkIfInHistory = true;

          const domain = domainUrlPath.split('/')[0];
          const hbasedNewsList = hbasedNewsDict[domain] || [];

          let returnNewsList = freshtabArticlesList;
          // merge news according to url path
          let notMergedNewsNumber = mergeToList(hbasedNewsList, returnNewsList, numberOfNewsToMerge, hbasedNewsTypeKey, checkIfInHistory, domainUrlPath);

          // if not all news were mergen according to url path, merge news only from domain
          notMergedNewsNumber = mergeToList(hbasedNewsList, returnNewsList, notMergedNewsNumber, hbasedNewsTypeKey, checkIfInHistory);

          // if no hbased news can be merged, merge top news
          returnNewsList = mergeTopNews(topNewList, returnNewsList, notMergedNewsNumber);

          return returnNewsList;
        }

        function forceDividableByThreeFormat(list) {
          return list.slice(0, 3).concat(list.slice(3, list.length - list.length % 3));
        }

        function extendListIfOnlyTopNews(freshtabNewsList, topNewList) {
          function recordTypeCheck(record) {
            return record.type !== hbasedNewsTypeKey;
          }

          const notMergetTopNewsNumber = topNewList.length - freshtabNewsList.length;

          let returnNewsList = freshtabNewsList;
          if (notMergetTopNewsNumber > 0 && freshtabNewsList.every(recordTypeCheck)) {
            returnNewsList = mergeTopNews(topNewList, freshtabNewsList, notMergetTopNewsNumber);
          }
          return returnNewsList;
        }

        function sortByScore(list) {
          function sortFunct(i, j) {
            // if score is not presented put record on top
            return (i.score || Math.pow(10, 6)) < (j.score || Math.pow(10, 6));
          }
          // sort all news apart from first 3
          return list.slice(0, 3).concat(list.slice(3, 15).sort(sortFunct));
        }

        return new Promise(resolve => {
          let freshtabArticlesList = [];
          const newsPlacement = historyObject.newsPlacing || [{ type: topNewsTypeKey, domain: topNewsTypeKey, number: 9 }];

          const topNewsList = topNewsCache;
          const hbasedNewsDict = hbasedResults;

          // merge news according to news placing
          newsPlacement.forEach(record => {
            switch (record.type) {
              case topNewsTypeKey:
                freshtabArticlesList = mergeTopNews(topNewsList, freshtabArticlesList, record.number);
                break;
              case hbasedNewsTypeKey:
                freshtabArticlesList = mergeHbasedNews(hbasedNewsDict, topNewsList, freshtabArticlesList, record);
                break;
              case prClBurdaNewsTypeKey:
                freshtabArticlesList = mergePressClippingNews(hbasedNewsDict, topNewsList, freshtabArticlesList, record);
                break;
              default:
                log$5(`Not handled news type in news placing ${record.type}`);
            }
          });

          freshtabArticlesList = sortByScore(freshtabArticlesList);
          freshtabArticlesList = forceDividableByThreeFormat(freshtabArticlesList);
          freshtabArticlesList = extendListIfOnlyTopNews(freshtabArticlesList, topNewsList);

          log$5(freshtabArticlesList);
          resolve({
            newsList: freshtabArticlesList,
            topNewsVersion: getTopNewsVersion(topNewsCache)
          });
        });
      }

      function addVisitedFlagToArticles(articlesList) {
        const promiseList = articlesList.map(article => {
          return new Promise(resolve => {
            const URI = CliqzUtils.makeUri(article.url, '', null);
            PlacesUtils.asyncHistory.isURIVisited(URI, (aURI, isVisited) => {
              article.isVisited = isVisited;
              if (article.isVisited) {
                log$5(`Url is already in the histoy ${aURI.spec}.`);
              }
              resolve(article);
            });
          }).catch(err => {
            log$5(`Error checking url in history ${article.url} ${err}.`);
            return article;
          });
        });

        return Promise.all(promiseList);
      }

      function checkTopNewsIfInHistory(topNewsCache) {
        return addVisitedFlagToArticles(getTopNewsArticles(topNewsCache));
      }

      function checkHbasedNewsIfInHistory(hbNewsDict) {
        const promiseList = Object.keys(hbNewsDict).map(domain => {
          return new Promise(resolve => {
            addVisitedFlagToArticles(hbNewsDict[domain]).then(articlesList => {
              resolve([domain, articlesList]);
            });
          });
        });

        return Promise.all(promiseList).then(hbNewsChecked => {
          const hbDictResult = {};
          hbNewsChecked.forEach(r => {
            hbDictResult[r[0]] = r[1];
          });
          return hbDictResult;
        });
      }

      const CliqzFreshTabNews = {
        /**
        * @method init
        */
        init: () => {
          log$5('init');
        },
        /**
        * @method unload
        */
        unload: () => {
          log$5('unloaded');
        },
        getNews: () => {
          let topNewsL;
          let hbObject;

          return Promise.all([topNewsCacheObject.getData().then(checkTopNewsIfInHistory), hbasedNewsCacheObject.getData().then(checkHbasedNewsIfInHistory)]).then(_ref => {
            var _ref2 = _slicedToArray$12(_ref, 2);

            let topNewsList = _ref2[0],
                hbasedObject = _ref2[1];

            topNewsL = topNewsList;
            hbObject = hbasedObject;
            return hbasedRecommendCacheObject.getData();
          }).then(historyObject => composeNewsList(historyObject, topNewsL, hbObject));
        },
        resetTopNews: () => {
          topNewsCacheObject.reset();
        }
      };

      const CliqzFreshTabHistory = {
        /**
         * Returns the array of top visited URLs with their titles and number of visits
         * @returns {Array} Array of objects { url, title, total_count }
         */
        getTopUrls() {
          const result = [];
          const domains = {};
          return new Promise(resolve => {
            CliqzHistoryManager.PlacesInterestsStorage._execute(['select distinct rev_host as rev_host, title as title, url as url, max(total_count)  as total_count from (', 'select mzh.url as url, mzh.title as title, sum(mzh.days_count) as total_count, mzh.rev_host as rev_host', 'from (', 'select moz_places.url, moz_places.title, moz_places.rev_host, moz_places.visit_count,', 'moz_places.last_visit_date, moz_historyvisits.*,', "(moz_historyvisits.visit_date /(86400* 1000000) - (strftime('%s', date('now', '-6 months'))/86400) ) as days_count", 'from moz_historyvisits, moz_places', 'where moz_places.typed == 1', 'and moz_places.hidden == 0', "and moz_historyvisits.visit_date > (strftime('%s', date('now', '-6 months'))*1000000)", 'and moz_historyvisits.place_id == moz_places.id', 'and moz_places.visit_count > 1', 'and (moz_historyvisits.visit_type < 4 or moz_historyvisits.visit_type == 6)', ') as mzh', 'group by mzh.place_id', 'order by total_count desc, mzh.visit_count desc, mzh.last_visit_date desc', ') group by rev_host order by total_count desc limit 15'].join(' '), ['rev_host', 'url', 'title', 'total_count'], row => {
              const key = CliqzUtils.getDetailsFromUrl(row.url).cleanHost;
              if (!(key in domains)) {
                result.push(row);
                domains[key] = row;
              }
            }).then(() => {
              resolve(result);
            });
          });
        }
      };

      function getAlias(host, searchEngines) {
        const engine = searchEngines.find(_ref => {
          let urlDetails = _ref.urlDetails;

          return host === urlDetails.host || host === urlDetails.domain;
        }) || {};

        return engine.alias;
      }

      class SpeedDial {
        static getValidUrl(url) {
          const ALLOWED_SCHEMES = ['http', 'https', 'ftp'];
          let uri = CliqzUtils.makeUri(url);

          if (!uri) {
            url = url.replace(/^:?\/*/, '');
            url = `http://${url}`;
            uri = CliqzUtils.makeUri(url);
          }

          return uri && ALLOWED_SCHEMES.indexOf(uri.scheme) !== -1 && uri.spec || null;
        }

        constructor(url, searchEngines) {
          let isCustom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          var details = CliqzUtils.getDetailsFromUrl(url),
              logoDetails = CliqzUtils.getLogoDetails(details);
          this.title = url;
          var protocolPos = url.indexOf('://'),
              id = url;
          // removes protocol http(s), ftp, ...
          if (protocolPos != -1 && protocolPos <= 6) {
            id = url.split('://')[1];
          }
          this.id = id;
          this.url = url;
          this.displayTitle = details.cleanHost || details.friendly_url || url;
          this.custom = isCustom;
          this.logo = logoDetails;
          this.searchAlias = getAlias(details.host, searchEngines);
        }
      }

      var _slicedToArray$13 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const BITS_PER_BUCKET = 32;

      // |elementsOrSize| is either an array with initial values (numbers), or a
      // size for internal storage. You can calculate it, and |nHashes| using
      // |calculateFilterProperties|.
      function BloomFilter$1(elementsOrSize, nHashes) {
        if (elementsOrSize.constructor.name === 'ArrayBuffer') {
          this._buckets = new Int32Array(elementsOrSize);
        } else {
          let size = 0;
          let elements = [];
          if (typeof elementsOrSize === 'number') {
            size = elementsOrSize;
          } else if (typeof elementsOrSize === 'object' && elementsOrSize.constructor.name === 'Array') {
            elements = elementsOrSize;
            size = elements.length;
          } else {
            throw new TypeError('First argument must be either an integer, or array or ArrayBuffer');
          }
          let buckets = this._buckets = new Int32Array(size);
          // If |elementsOrSize| is an array we'll copy its elements:
          for (let i = 0; i < elements.length; i++) {
            buckets[i] = elements[i];
          }
        }

        this.m = this._buckets.length * BITS_PER_BUCKET;
        this.k = this.nHashes = nHashes; // TODO: make read-only
        this.rawData = this._buckets.buffer; // TODO: make read-only
      }

      BloomFilter$1.prototype.update = function (a) {
        var m = a.length * BITS_PER_BUCKET,
            n = a.length,
            i = -1;
        m = n * BITS_PER_BUCKET;
        if (this.m !== m) {
          throw new Error('Bloom filter can only be updated with same length');
        }
        while (++i < n) {
          this._buckets[i] |= a[i];
        }
      };

      BloomFilter$1.prototype.test = function (x) {
        var _a_b = this._a_b(x),
            _a_b2 = _slicedToArray$13(_a_b, 2);

        const a = _a_b2[0],
              b = _a_b2[1];

        return this._test(a, b);
      };

      BloomFilter$1.prototype.add = function (x) {
        var _a_b3 = this._a_b(x),
            _a_b4 = _slicedToArray$13(_a_b3, 2);

        const a = _a_b4[0],
              b = _a_b4[1];

        return this._add(a, b);
      };

      // Checks whether a value represented by its subhashes |a| and |b| is present in
      // current filter set.
      // |a| and |b| must be numbers.
      BloomFilter$1.prototype._test = function (a, b) {
        const buckets = this._buckets;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._bitIndexes(a, b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            let bitIndex = _step.value;

            const bucketIndex = Math.floor(bitIndex / BITS_PER_BUCKET);
            const bucketBitIndex = 1 << bitIndex % BITS_PER_BUCKET;
            if ((buckets[bucketIndex] & bucketBitIndex) === 0) {
              return false;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return true;
      };

      // Puts a value represented by its subhashes |a| and |b| into filter set.
      // |a| and |b| must be numbers.
      BloomFilter$1.prototype._add = function (a, b) {
        const buckets = this._buckets;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._bitIndexes(a, b)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            let bitIndex = _step2.value;

            const bucketIndex = Math.floor(bitIndex / BITS_PER_BUCKET);
            const bucketBitIndex = 1 << bitIndex % BITS_PER_BUCKET;
            buckets[bucketIndex] |= bucketBitIndex;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      };

      BloomFilter$1.prototype._a_b = function (x) {
        const md5Hex = cachedMD5(x);
        const a = parseInt(md5Hex.substring(0, 8), 16);
        const b = parseInt(md5Hex.substring(8, 16), 16);
        return [a, b];
      };

      // For a pair of given subhashes of a value yields a series of bit indexes to
      // read or write to.
      // |a| and |b| must be numbers.
      BloomFilter$1.prototype._bitIndexes = function* (a, b) {
        const k = this.k;
        const m = this.m;
        let x = a % m;

        for (let i = 0; i < k; ++i) {
          yield x < 0 ? x + m : x;
          x = (x + b) % m;
        }
      };

      Components.utils.import('resource://gre/modules/FileUtils.jsm');

      const HEAD_SIG = 0x43514246; // ASCII 'CQBF' - CliQz Bloom Filter
      const FORMAT_VERSION = 1;
      const FILE_MAX_SIZE = 20 * 1024 * 1024; // 20MB.
      const ERRORS = {
        WRONG_FORMAT: 'Unrecognized filter data format',
        FILE_TOO_BIG: 'File is too big',
        BUFF_UNDERFLOW: 'Buffer underflow'
      };

      const iOService = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces.nsIIOService);

      function openFileInputStream(file) {
        let inStream = Components.classes['@mozilla.org/network/file-input-stream;1'].createInstance(Components.interfaces.nsIFileInputStream);
        inStream.init(file, FileUtils.MODE_RDONLY, 0, inStream.CLOSE_ON_EOF);
        return inStream;
      }

      function openUriInputStream(aURI) {
        const uri = iOService.newURI(aURI, null, null);
        const principal = Services.scriptSecurityManager.getSystemPrincipal();
        const aSecurityFlags = Components.interfaces.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
        const aContentPolicyType = Components.interfaces.nsIContentPolicy.TYPE_OTHER;
        const channel = iOService.newChannelFromURI2(uri, null, // aLoadingNode
        principal, null, // aTriggeringPrincipal
        aSecurityFlags, aContentPolicyType);
        return channel.open2(); // Return input stream
      }

      let BloomFilterUtils = {
        /**
         * @param aInput: {nsIFile} file or {nsIURI} uri - pointer to the bloom filter data file.
         * @return {BloomFilter, version} filter with a given file.
         */
        loadFromInput(aInput, aType) {
          let fStream = null;
          if (aType === 'uri') {
            fStream = openUriInputStream(aInput);
          } else {
            //aType === file
            fStream = openFileInputStream(aInput);
          }

          try {
            const binStream = Components.classes['@mozilla.org/binaryinputstream;1'].createInstance(Components.interfaces.nsIBinaryInputStream);
            binStream.setInputStream(fStream);
            if (binStream.available() > FILE_MAX_SIZE) throw new Error(ERRORS.FILE_TOO_BIG);

            // Check file header:
            const typeSig = binStream.read32();
            if (typeSig != HEAD_SIG) throw new Error(ERRORS.WRONG_FORMAT);
            const version = binStream.read8();
            if (version != FORMAT_VERSION) throw new Error(ERRORS.WRONG_FORMAT);
            const dbVersion = binStream.read16();
            const nHashes = binStream.read8();

            // Read the rest of it into a buffer:
            const buffer = new ArrayBuffer(binStream.available());
            const read = binStream.readArrayBuffer(buffer.byteLength, buffer);
            if (read != buffer.byteLength) throw new Error(ERRORS.BUFF_UNDERFLOW);

            // Construct filter from buffer:
            return [new BloomFilter$1(buffer, nHashes), dbVersion];
          } finally {
            fStream.close();
          }
        },

        /**
         * @param {BloomFilter} filter - bloom filter to save to file.
         * @param {int} version - database version.
         * @param {nsIFile} file - pointer to the bloom filter data file.
         */
        saveToFile(filter, version, file) {
          let foStream = Components.classes['@mozilla.org/network/file-output-stream;1'].createInstance(Components.interfaces.nsIFileOutputStream);
          const openFlags = FileUtils.MODE_WRONLY | FileUtils.MODE_CREATE | FileUtils.MODE_TRUNCATE;
          const permFlags = parseInt('0666', 8);
          foStream.init(file, openFlags, permFlags, 0);
          try {
            let binStream = Components.classes['@mozilla.org/binaryoutputstream;1'].createInstance(Components.interfaces.nsIBinaryOutputStream);
            binStream.setOutputStream(foStream);

            // Write header:
            binStream.write32(HEAD_SIG);
            binStream.write8(FORMAT_VERSION);
            binStream.write16(version);
            binStream.write8(filter.nHashes);

            // Write filter data:
            const buffer = new Uint8Array(filter.rawData);
            binStream.writeByteArray(buffer, buffer.byteLength);
          } finally {
            foStream.close();
          }
        }

      }; // BloomFilterUtils

      const ADULT_DOMAINS_BF_FILE_URI = 'chrome://cliqz/content/freshtab/adult-domains.bin';

      class AdultDomain {
        constructor() {
          try {
            this.filter = BloomFilterUtils.loadFromInput(ADULT_DOMAINS_BF_FILE_URI, 'uri')[0];
          } catch (e) {
            console$1.log('Adult Domain List failed loading');
          }
        }
        isAdult(domain) {
          if (!this.filter) return false;
          return this.filter.test(domain);
        }
      }

      var _extends$9 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const saveMessageDismission = message => {
        prefs.setObject('dismissedAlerts', prevValue => {
          const oldMessage = prevValue[message.id] || {
            scope: 'freshtab',
            count: 0
          };
          return _extends$9({}, prevValue, {
            [message.id]: _extends$9({}, oldMessage, {
              count: oldMessage.count + 1
            })
          });
        });
      };

      function dismissMessage(messageId, handler) {
        try {
          saveMessageDismission({
            id: messageId,
            handler
          });

          CliqzEvents.pub('msg_center:hide_message', { id: messageId }, handler);

          CliqzUtils.telemetry({
            type: 'notification',
            topic: messageId,
            context: 'home',
            action: 'click',
            target: 'hide'
          });
        } catch (e) {
          console$1.log(e, `Freshtab error setting ${messageId} dismiss pref`);
        }
      }

      function countMessageClick(message) {
        const countPref = `modules.message-center.stats.${message.handler}.${message.id}.cta_count`;
        const count = prefs.get(countPref, 0);

        prefs.set(countPref, count + 1);

        if (count >= 3) {
          CliqzEvents.pub('msg_center:hide_message', { id: message.id }, message.handler);
          saveMessageDismission(message);
        }
      }

      var _extends$8 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const DIALUPS = 'extensions.cliqzLocal.freshtab.speedDials';
      const FRESHTAB_CONFIG_PREF = 'freshtabConfig';
      const BLUE_THEME_PREF = 'freshtab.blueTheme.enabled';
      const DEVELOPER_FLAG_PREF = 'developer';

      const blackListedEngines = ['Google Images', 'Google Maps'];

      const DEFAULT_COMPONENT_STATE = {
        visible: true
      };

      const historyWhitelist = [config.settings.NEW_TAB_URL, config.settings.HISTORY_URL];

      if (config.settings.frameScriptWhitelist) {
        historyWhitelist.push(...config.settings.frameScriptWhitelist);
      }

      function isHistoryDependentPage(url) {
        return historyWhitelist.some(u => url.indexOf(u) === 0);
      }

      /**
       * @module freshtab
       * @namespace freshtab
       * @class Background
       */
      var Background$10 = background({
        core: inject.module('core'),
        geolocation: inject.module('geolocation'),
        messageCenter: inject.module('message-center'),
        theme: inject.module('theme'),
        ui: inject.module('ui'),
        offersV2: inject.module('offers-v2'),
        requiresServices: ['logos'],

        /**
        * @method init
        */
        init(settings) {
          this.newTabPage = NewTabPage;

          this.newTabPage.startup();

          this.adultDomainChecker = new AdultDomain();
          this.settings = settings;
          this.messages = {};
          this.onVisitRemoved = this._onVisitRemoved.bind(this);

          history$2.onVisitRemoved.addListener(this.onVisitRemoved);
        },
        /**
        * @method unload
        */
        unload() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref$quick = _ref.quick;

          let quick = _ref$quick === undefined ? false : _ref$quick;

          CliqzFreshTabNews.unload();

          if (quick) {
            this.newTabPage.shutdown();
          } else {
            this.newTabPage.rollback();
          }

          history$2.onVisitRemoved.removeListener(this.onVisitRemoved);
        },

        _onVisitRemoved(removed) {
          if (removed.allHistory) {
            this.actions.refreshHistoryDependentPages();
          } else {
            const historyUrls = [...mapWindows(w => w).map(queryActiveTabs).reduce((aUrls, aTabs) => {
              return new Set([...removed.urls, ...aTabs.map(t => t.url)]);
            }, new Set())].filter(isHistoryDependentPage);

            historyUrls.forEach(url => {
              this.core.action('broadcastMessage', url, {
                action: 'updateHistoryUrls',
                message: { urls: removed.urls }
              });
            });
          }
        },

        isAdult(url) {
          return this.adultDomainChecker.isAdult(CliqzUtils.getDetailsFromUrl(url).domain);
        },

        get shouldShowNewBrandAlert() {
          const isInABTest = prefs.get('freshtabNewBrand', false);
          const isDismissed = prefs.get('freshtabNewBrandDismissed', false);
          return config.settings.showNewBrandAlert && isInABTest && !isDismissed;
        },

        get showOffers() {
          const offersEnabled = prefs.get('offers2FeatureEnabled', false) && prefs.get('offers2UserEnabled', true);
          const cliqzTabOfferEnabled = prefs.get('cliqzTabOffersNotification', false);
          return offersEnabled && cliqzTabOfferEnabled;
        },

        get blueTheme() {
          return prefs.get(BLUE_THEME_PREF, false);
        },

        /**
        * Blue theme is supported only for CLIQZ users above 1.16.0
        **/
        get isBlueThemeSupported() {
          const CLIQZ_1_16_OR_ABOVE = isCliqzAtLeastInVersion('1.16.0');
          return isCliqzBrowser && CLIQZ_1_16_OR_ABOVE || prefs.get(DEVELOPER_FLAG_PREF, false);
        },

        /*
        * Blue background is supported for all AMO users
        * and CLIQZ users above 1.16.0
        **/
        get isBlueBackgroundSupported() {
          let isSupported = true;
          if (isCliqzBrowser && !isCliqzAtLeastInVersion("1.16.0")) {
            isSupported = false;
          }
          return isSupported || prefs.get(DEVELOPER_FLAG_PREF, false);
        },

        getComponentsState() {
          const config$$1 = JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF, '{}'));
          const defaultBg = 'bg-winter';
          return {
            historyDials: Object.assign({}, DEFAULT_COMPONENT_STATE, config$$1.historyDials),
            customDials: Object.assign({}, DEFAULT_COMPONENT_STATE, config$$1.customDials),
            search: Object.assign({}, DEFAULT_COMPONENT_STATE, config$$1.search),
            news: Object.assign({}, DEFAULT_COMPONENT_STATE, config$$1.news),
            background: Object.assign({}, { image: defaultBg }, config$$1.background)
          };
        },

        actions: {

          toggleComponent(component) {
            const config$$1 = JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF, '{}'));
            // component might be uninitialized
            config$$1[component] = Object.assign({}, DEFAULT_COMPONENT_STATE, config$$1[component]);
            config$$1[component].visible = !config$$1[component].visible;
            prefs.set(FRESHTAB_CONFIG_PREF, JSON.stringify(config$$1));
          },

          saveBackgroundImage(name) {
            prefs.set(FRESHTAB_CONFIG_PREF, JSON.stringify(_extends$8({}, JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF, '{}')), {
              background: {
                image: name
              }
            })));
          },

          updateTopNewsCountry(country) {
            prefs.set(FRESHTAB_CONFIG_PREF, JSON.stringify(_extends$8({}, JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF, '{}')), {
              news: {
                preferedCountry: country
              }
            })));

            CliqzFreshTabNews.resetTopNews();
          },

          dismissMessage,
          countMessageClick,

          checkForHistorySpeedDialsToRestore() {
            const history = JSON.parse(prefs.get(DIALUPS, '{}', '')).history || {};
            return Object.keys(history).length > 0;
          },

          /**
          * Get history based & user defined speedDials
          * @method getSpeedDials
          */
          getSpeedDials() {
            var dialUps = prefs.has(DIALUPS, '') ? JSON.parse(prefs.get(DIALUPS, '', '')) : [],
                historyDialups = [],
                customDialups = dialUps.custom ? dialUps.custom : [];
            const searchEngines = CliqzUtils.getSearchEngines(blackListedEngines);

            historyDialups = CliqzFreshTabHistory.getTopUrls().then(results => {
              CliqzUtils.log("History", JSON.stringify(results));
              //hash history urls
              results = results.map(function (r) {
                return {
                  title: r.title,
                  url: r.url,
                  hashedUrl: CliqzUtils.hash(r.url),
                  total_count: r.total_count,
                  custom: false
                };
              });

              function isDeleted(url) {
                return dialUps.history && url in dialUps.history && dialUps.history[url].hidden === true;
              }

              function isCustom(url) {
                url = CliqzUtils.stripTrailingSlash(url);

                var isCustom = false;

                if (dialUps && dialUps.custom) {

                  dialUps.custom.some(function (dialup) {

                    if (CliqzUtils.stripTrailingSlash(CliqzUtils.tryDecodeURIComponent(dialup.url)) === url) {
                      isCustom = true;
                      return true;
                    }
                  });
                }
                return isCustom;
              }

              function isCliqz(url) {
                return url.indexOf('https://cliqz.com/search?q=') === 0;
              }

              function isMozUrl(url) {
                return url.startsWith("moz-extension://");
              }

              results = results.filter(history => {
                return !isDeleted(history.hashedUrl) && !isCustom(history.url) && !this.isAdult(history.url) && !isCliqz(history.url) && !isMozUrl(history.url);
              });

              return results.map(function (r) {
                return new SpeedDial(r.url, searchEngines, false);
              });
            });

            if (customDialups.length > 0) {
              CliqzUtils.log(customDialups, "custom dialups");
              customDialups = customDialups.map(function (dialup) {
                return new SpeedDial(CliqzUtils.tryDecodeURIComponent(dialup.url), searchEngines, true);
              });
            }

            //Promise all concatenate results and return
            return Promise.all([historyDialups, customDialups]).then(function (results) {
              // TODO EX-4276: uncomment when moving Freshtab to WebExtensions
              // const urls = new Set();

              // const history = results[0].filter((dial) => {
              //   if (urls.has(dial.id)) {
              //     return false;
              //   } else {
              //     urls.add(dial.id);
              //     return true;
              //   }
              // });

              return {
                history: results[0],
                custom: results[1]
              };
            });
          },

          /**
           * Remove a speedDial
           * @method removeSpeedDial
           * @param {item}  The item to be removed.
           */
          removeSpeedDial(item) {
            const isCustom = item.custom;
            const url = isCustom ? item.url : CliqzUtils.hash(item.url);
            const dialUps = JSON.parse(prefs.get(DIALUPS, '{}', ''));

            if (isCustom) {
              dialUps.custom = dialUps.custom.filter(dialup => {
                return CliqzUtils.tryDecodeURIComponent(dialup.url) !== url;
              });
            } else {
              if (!dialUps.history) {
                dialUps.history = {};
              }
              dialUps.history[url] = { hidden: true };
            }

            prefs.set(DIALUPS, JSON.stringify(dialUps), '');
          },

          /**
          * @return all visible speedDials
          */
          getVisibleDials(historyLimit) {
            return this.actions.getSpeedDials().then(results => {
              return results.history.slice(0, historyLimit);
            });
          },
          /**
          * Add a new speedDial to be appeared in the 2nd row
          * @method addSpeedDial
          * @param url {string}
          */
          addSpeedDial(url, index) {
            const urlToAdd = CliqzUtils.stripTrailingSlash(url);
            const validUrl = SpeedDial.getValidUrl(urlToAdd);
            const searchEngines = CliqzUtils.getSearchEngines(blackListedEngines);

            function makeErrorObject(reason) {
              return {
                error: true,
                reason: typeof reason === 'object' ? reason.toString() : reason
              };
            }

            if (!validUrl) {
              return Promise.resolve(makeErrorObject('invalid'));
            }

            //history returns most frequest 15 results, but we display up to 5
            //so we need to validate only against visible results
            return this.actions.getVisibleDials(5).then(result => {
              const isDuplicate = result.some(function (dialup) {
                return validUrl === CliqzUtils.stripTrailingSlash(dialup.url);
              });

              if (isDuplicate) {
                throw "duplicate";
              }
            }).then(function (obj) {
              var dialUps = JSON.parse(prefs.get(DIALUPS, '{}', '')),
                  details = CliqzUtils.getDetailsFromUrl(url);

              if (!dialUps.custom) {
                dialUps.custom = [];
              }

              /* before adding new dialup make sure it is not there already
              ** looks like concurrency issues of messaging framework could lead to race conditions
              */

              const isPresent = dialUps.custom.some(function (dialup) {
                return CliqzUtils.tryEncodeURIComponent(validUrl) === CliqzUtils.stripTrailingSlash(dialup.url);
              });

              if (isPresent) {
                throw "duplicate";
              } else {
                console.log(`valid url: ${validUrl}, original url: ${urlToAdd}`);
                var dialup = {
                  url: CliqzUtils.tryEncodeURIComponent(validUrl)
                };
                if (index !== null) {
                  dialUps.custom.splice(index, 0, dialup);
                } else {
                  dialUps.custom.push(dialup);
                }
                prefs.set(DIALUPS, JSON.stringify(dialUps), '');
                return new SpeedDial(validUrl, searchEngines, true);
              }
            }).catch(reason => ({ error: true, reason: typeof reason === 'object' ? reason.toString() : reason }));
          },

          /**
          * Parse speedDials
          * @method parseSpeedDials
          */
          parseSpeedDials() {
            return JSON.parse(prefs.get(DIALUPS, '{}', ''));
          },

          /**
          * Save speedDials
          * @method saveSpeedDials
          * @param dialUps object
          */
          saveSpeedDials(dialUps) {
            prefs.set(DIALUPS, JSON.stringify(dialUps), '');
          },

          /**
          * Revert history url
          * @method revertHistorySpeedDial
          * @param url string
          */
          revertHistorySpeedDial(url) {
            const dialUps = this.actions.parseSpeedDials();
            delete dialUps.history[CliqzUtils.hash(url)];
            this.actions.saveSpeedDials(dialUps);
          },

          /**
          * Reset all history speed dials
          * @method resetAllHistory
          */
          resetAllHistory() {
            const dialUps = this.actions.parseSpeedDials();
            dialUps.history = {};
            this.actions.saveSpeedDials(dialUps);
            return this.actions.getSpeedDials();
          },
          /**
          * Get list with top & personalized news
          * @method getNews
          */
          getNews() {
            //disables the whole news block if required by the config
            if (!this.settings.freshTabNews) {
              return {
                version: -1,
                news: []
              };
            }

            return CliqzFreshTabNews.getNews().then(function (news) {
              CliqzFreshTabNews.init();

              var newsList = news.newsList || [];
              var topNewsVersion = news.topNewsVersion || 0;

              return {
                version: topNewsVersion,
                news: newsList.map(r => ({
                  title: r.title_hyphenated || r.title,
                  description: r.description,
                  displayUrl: CliqzUtils.getDetailsFromUrl(r.url).cleanHost || r.title,
                  logo: CliqzUtils.getLogoDetails(CliqzUtils.getDetailsFromUrl(r.url)),
                  url: r.url,
                  type: r.type,
                  breaking_label: r.breaking_label
                }))
              };
            });
          },

          /**
          * Get offers
          * @method getOffers
          */
          getOffers() {
            if (!this.showOffers) {
              return;
            }
            const args = {
              filters: {
                by_rs_dest: 'cliqz-tab',
                ensure_has_dest: true
              }
            };

            return this.offersV2.action('getStoredOffers', args);
          },

          /**
          * Get configuration regarding locale, onBoarding and browser
          * @method getConfig
          */
          getConfig(sender) {
            const windowWrapper = Window.findByTabId(sender.tab.id);

            // cleanup urlbar value if it has visible url
            // and set it on focus if missing
            if (windowWrapper) {
              this.ui.windowAction(windowWrapper.window, 'setUrlbarValue', '', {
                match: config.settings.NEW_TAB_URL,
                focus: true
              });
            }

            return {
              locale: getLanguageFromLocale(CliqzUtils.PREFERRED_LANGUAGE),
              newTabUrl: config.settings.NEW_TAB_URL,
              isBrowser: isCliqzBrowser,
              blueTheme: this.blueTheme,
              isBlueThemeSupported: this.isBlueThemeSupported,
              isBlueBackgroundSupported: this.isBlueBackgroundSupported,
              showNewBrandAlert: this.shouldShowNewBrandAlert,
              messages: this.messages,
              isHistoryEnabled: prefs.get('modules.history.enabled', false) && config.settings.HISTORY_URL,
              componentsState: this.getComponentsState()
            };
          },

          /**
          * @method toggleBlueTheme
          */
          toggleBlueTheme() {
            // toggle blue class only on FF for testing.
            // Cliqz browser listens for pref change and takes care of toggling the class
            if (prefs.get(DEVELOPER_FLAG_PREF, false)) {
              this.actions.toggleBlueClassForFFTesting();
            }

            if (this.blueTheme) {
              prefs.set(BLUE_THEME_PREF, false);
            } else {
              prefs.set(BLUE_THEME_PREF, true);
            }
          },

          toggleBlueClassForFFTesting() {
            if (this.blueTheme) {
              this.theme.action('removeBlueClass');
            } else {
              this.theme.action('addBlueClass');
            }
          },

          /**
          * revert back to old "new tab"
          * @method revertBack
          */
          revertBack() {
            this.newTabPage.rollback();
          },

          getTabIndex() {
            return Promise.resolve(CliqzUtils.getWindow().gBrowser.tabContainer.selectedIndex);
          },

          shareLocation(decision) {
            CliqzEvents.pub('msg_center:hide_message', { 'id': 'share-location' }, 'MESSAGE_HANDLER_FRESHTAB');
            this.geolocation.action('setLocationPermission', decision);

            const target = decision === 'yes' ? 'always_share' : 'never_share';

            CliqzUtils.telemetry({
              type: 'notification',
              action: 'click',
              topic: 'share-location',
              context: 'home',
              target: target
            });
          },

          refreshFrontend() {
            forEachWindow(window => {
              const tabs = [...window.gBrowser.tabs];
              tabs.forEach(tab => {
                const browser = tab.linkedBrowser;
                if (browser.currentURI.spec === config.settings.NEW_TAB_URL) {
                  browser.reload();
                }
              });
            });
          },

          refreshHistoryDependentPages() {
            forEachWindow(window => {
              const tabs = [...window.gBrowser.tabs];
              tabs.forEach(tab => {
                const browser = tab.linkedBrowser;
                if (isHistoryDependentPage(browser.currentURI.spec)) {
                  browser.reload();
                }
              });
            });
          }

        },

        events: {
          "control-center:cliqz-tab": function controlCenterCliqzTab() {
            if (this.newTabPage.isActive) {
              this.newTabPage.rollback();
            } else {
              this.newTabPage.enableNewTabPage();
              this.newTabPage.enableHomePage();
            }

            this.newTabPage.setPersistentState(!this.newTabPage.isActive);
          },
          "message-center:handlers-freshtab:new-message": function onNewMessage(message) {
            if (!(message.id in this.messages)) {
              this.messages[message.id] = message;
              this.core.action('broadcastMessage', config.settings.NEW_TAB_URL, {
                action: 'addMessage',
                message: message
              });
            }
          },
          "message-center:handlers-freshtab:clear-message": function onMessageClear(message) {
            delete this.messages[message.id];
            this.core.action('broadcastMessage', config.settings.NEW_TAB_URL, {
              action: 'closeNotification',
              messageId: message.id
            });
          },
          "geolocation:wake-notification": function onWake(timestamp) {
            this.actions.getNews().then(() => {
              this.actions.refreshFrontend();
            });
          }
        }
      });

      const setupInitialPage = (window, url) => {
        const urls = [url, `${url}#`, `${url}#/`];
        const initialPages = window.gInitialPages || [];

        urls.forEach(u => {
          const isInitialPage = initialPages.indexOf(u) >= 0;

          if (!isInitialPage) {
            initialPages.push(u);
          }
        });
      };

      /**
      * @namespace freshtab
      */
      class Win$9 {
        /**
        * @class Window
        * @constructor
        */
        constructor(_ref) {
          let window = _ref.window,
              background = _ref.background;

          this.background = background;

          setupInitialPage(window, config.settings.NEW_TAB_URL);
        }

        /**
        *@method init
        *@return null
        */
        init() {
          this.showOnboarding();
        }

        unload() {}

        status() {
          return {
            visible: true,
            enabled: this.background.newTabPage.isActive
          };
        }

        showOnboarding() {
          this.showUnsupportedOsWarning();
        }

        showUnsupportedOsWarning() {
          const dismissedAlerts = JSON.parse(prefs.get('dismissedAlerts', '{}'));
          const messageType = 'windows-xp-vista-end-of-support';
          const isDismissed = dismissedAlerts[messageType] && dismissedAlerts[messageType].count >= 1;

          if (isDismissed || !isWindows()) {
            return;
          }

          if (isCliqzBrowser && isPlatformAtLeastInVersion('7.0')) {
            return;
          }

          this.background.messageCenter.action('showMessage', 'MESSAGE_HANDLER_FRESHTAB', {
            id: messageType,
            template: messageType
          });
        }
      }

      var freshtabModule = {
        Background: Background$10,
        Window: Win$9
      };

      class UrlWhitelist {
        constructor(whitelistName, legacyPref) {
          this.whitelist = new Set();
          this.whitelistPersist = new LazyPersistentObject(whitelistName);
          this.logger = Logger({
            prefix: `url-whitelist:${whitelistName}`
          });
          if (legacyPref) {
            this.migrate(legacyPref);
          }
        }

        init() {
          return this.whitelistPersist.load().then(value => {
            if (value.urls !== undefined) {
              this.whitelist = new Set(value.urls);
              if (value.urls.some(url => url.charAt(1) !== ':')) {
                this.upgrade();
              }
            }
          });
        }

        clear() {
          this.whitelist.clear();
          this.persistWhitelist();
        }

        persistWhitelist() {
          this.whitelistPersist.setValue({
            urls: [...this.whitelist.values()]
          });
        }

        upgrade() {
          const w = new Set();
          this.whitelist.forEach(value => {
            let newValue;
            if (value === getGeneralDomain(value)) {
              newValue = `g:${value}`;
            } else if (value === _extractHostname(value)) {
              newValue = `h:${value}`;
            } else {
              newValue = `u:${value}`;
            }
            w.add(newValue);
          });
          this.whitelist = w;
          this.persistWhitelist();
        }

        migrate(prefName) {
          const existingList = prefs.get(prefName, null);
          if (existingList) {
            this.whitelist = new Set(existingList);
          }
          prefs.clearPref(prefName);
          this.persistWhitelist();
        }

        isWhitelisted(url) {
          return this.whitelist.has(`u:${CliqzUtils.cleanUrlProtocol(url, true)}`) || this.whitelist.has(`h:${_extractHostname(url)}`) || this.whitelist.has(`g:${getGeneralDomain(url)}`);
        }

        getState(url) {
          return {
            url: this.whitelist.has(`u:${CliqzUtils.cleanUrlProtocol(url, true)}`),
            hostname: this.whitelist.has(`h:${_extractHostname(url)}`),
            generalDomain: this.whitelist.has(`g:${getGeneralDomain(url)}`)
          };
        }

        clearState(url) {
          this.changeState(url, 'url', 'remove', true);
          this.changeState(url, 'hostname', 'remove', true);
          this.changeState(url, 'generalDomain', 'remove', true);
          this.persistWhitelist();
        }

        changeState(url, type, action, deferPersist) {
          this.logger.log(url, type, action, 'changeState');
          let processed;
          switch (type) {
            case 'url':
              processed = `u:${CliqzUtils.cleanUrlProtocol(url, true)}`;
              break;
            case 'hostname':
              processed = `h:${_extractHostname(url)}`;
              break;
            case 'generalDomain':
              processed = `g:${getGeneralDomain(url)}`;
              break;
            default:
              throw new Error('Supported types: url, hostname, generalDomain', type);
          }

          if (!processed) {
            this.logger.log('Not valid', type, url);
            return;
          }

          switch (action) {
            case 'add':
              this.whitelist.add(processed);
              break;
            case 'remove':
              this.whitelist.delete(processed);
              break;
            case 'toggle':
              if (this.whitelist.has(processed)) {
                this.whitelist.delete(processed);
              } else {
                this.whitelist.add(processed);
              }
              break;
            default:
              this.logger.error('Supprted actions: add, remove, toggle', action);
              return;
          }
          if (!deferPersist) {
            this.persistWhitelist();
          }
        }
      }

      var logger$1 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[WebRequestPipeline]'
      });

      /**
       * Handles a set of function pipelines. These pipelines start with an initial state
       * and empty object return-value, then flow these arguments through the functions in
       * the pipeline until one returns false.
       *
       * @class Pipeline
       * @namespace antitracking
       */
      class Pipeline {
        /**
         * Pipeline constructor. Creates an empty pipeline with the default
         * stages (open, modify and response).
         */
        constructor(name) {
          let steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          let isBreakable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          this.name = name;
          this.isBreakable = isBreakable;

          // Optional timing collection
          this.collectTimings = false;
          this.timings = Object.create(null);
          logger$1.debug('timings', this.name, this.timings);

          // Init empty pipeline
          this.unload();

          this.addAll(steps);
        }

        get length() {
          return this.pipeline.length;
        }

        unload() {
          this.pipeline = [];
          this.stepFns = new Map();
        }

        /**
         * Add a function to the pipeline
         * @param {Function} fn     function to add
         * @param {String}   name   (optional) infered from function if undefined
         */
        add(_ref) {
          let fn = _ref.fn,
              name = _ref.name,
              spec = _ref.spec;

          if (!name) {
            throw new Error(`Every step of the pipeline should be given a name in ${this.name}`);
          }

          if (!spec) {
            throw new Error(`Every step of the pipeline should be given a spec ${name} in ${this.name}`);
          }

          if (spec === 'break' && !this.isBreakable) {
            throw new Error(`Cannot add a break step '${name}' to an unbreakable pipline`);
          }

          return this.addPipelineStep({
            name,
            fn, // TODO: needed? this.stepFns.get(name) || fn, // Relax function duplication constraint
            spec: spec || 'all'
          });
        }

        /**
         * Bulk add functions to stages
         * @param {Array.<Function>} fns
         */
        addAll(steps) {
          for (let i = 0; i < steps.length; i += 1) {
            this.add(steps[i]);
          }
        }

        /**
         * Adds a step to the pipeline with the given constraints.
         *
         * By default the step is placed at the end of the pipeline. If after or before
         * are specified, the step is placed at the first available position which satisfies
         * these constraints.
         *
         * @param {String} options.name   the name of the function. Must be unique.
         * @param {Array.<String>}  options.stages The pipeline stages to which this function should
         * be added
         * @param {Function} options.fn     the step function
         * @param {Array.<String>} options.after  array of step names for which this step should be
         * put afterwards
         * @param {Array.<String>} options.before array of step names for which this step should be
         * put before
         */
        addPipelineStep(_ref2) {
          let name = _ref2.name,
              fn = _ref2.fn,
              after = _ref2.after,
              before = _ref2.before,
              spec = _ref2.spec;

          // check if step already exists
          if (this.stepFns.has(name)) {
            throw new Error(`trying to overwrite existing stepFn ${name} in ${this.name}`);
          }

          this.stepFns.set(name, { fn, spec });
          const afterArr = after || [];
          const beforeArr = before || [];

          const emptyPipeline = this.pipeline.length === 0;
          const hasAfter = afterArr.length > 0;
          const hasBefore = beforeArr.length > 0;

          if (!hasAfter && !hasBefore || emptyPipeline) {
            // just put it at the end
            this.pipeline.push(name);
          } else if (hasAfter && !hasBefore) {
            // find where the dependencies are in the pipeline
            const afterIndices = afterArr.map(s => this.pipeline.indexOf(s));
            const insertMin = Math.max(...afterIndices);
            if (afterIndices.indexOf(-1) >= 0) {
              throw new Error(`missing steps from 'after' list, after=${afterArr}, pipeline=${this.pipeline}`);
            }

            this.pipeline.splice(insertMin + 1, 0, name);
          } else if (hasBefore && !hasAfter) {
            const beforeIndices = beforeArr.map(s => this.pipeline.indexOf(s)).filter(i => i !== -1);
            const insertMax = Math.min(...beforeIndices);
            this.pipeline.splice(insertMax, 0, name);
          } else {
            throw new Error('cannot take both before and after constraints');
          }
        }

        /**
         * Removes the given step name from the pipeline
         * @param  {String} name of the step
         */
        removePipelineStep(name) {
          const index = this.pipeline.indexOf(name);
          if (index !== -1) {
            this.pipeline.splice(index, 1);
          }

          // remove from function map
          this.stepFns.delete(name);
        }

        /**
         * Runs the pipeline for the name stage, using the specified initial state
         * @param  {Object} initialState State passed to the pipeline
         */
        execute(webRequestContext, response) {
          let canAlterRequest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          for (let i = 0; i < this.pipeline.length; i += 1) {
            const name = this.pipeline[i];

            var _stepFns$get = this.stepFns.get(name);

            const fn = _stepFns$get.fn,
                  spec = _stepFns$get.spec;

            const t0 = Date.now();
            let cont;

            // Execute step
            try {
              switch (spec) {
                case 'break':
                  cont = fn(webRequestContext);
                  break;
                case 'annotate':
                  cont = fn(webRequestContext);
                  break;
                case 'collect':
                  CliqzUtils.setTimeout(() => fn(webRequestContext), 0);
                  break;
                case 'blocking':
                  if (canAlterRequest) {
                    cont = fn(webRequestContext, response);
                  }
                  break;
                default:
                  throw new Error(`Invalid spec for step ${name} in pipeline ${this.name}`);
              }
            } catch (e) {
              logger$1.error(this.name, webRequestContext.url, 'Step exception', e, e.stack);
              break;
            }

            // [Optional] Keep track of timings for pipeline steps
            if (this.collectTimings) {
              const total = Date.now() - t0;
              if (this.timings[name] === undefined) {
                this.timings[name] = Object.create(null);
              }

              this.timings[name][total] = (this.timings[name][total] || 0) + 1;
            }

            // Handle early termination of the pipeline
            if (cont === false) {
              if (this.isBreakable) {
                logger$1.debug(this.name, webRequestContext.url, 'Break at', name);
                break;
              }
              // we only reach here if the pipeline is not breakable:
              // show a warning that we ignored the break
              logger$1.debug(this.name, webRequestContext.url, 'ignoring attempted break of unbreakable pipeline at', name);
            }
          }
        }
      }

      let parseValue;

      class Position {
        constructor() {
          this.i = 0;
        }

        inc() {
          this.i += 1;
        }

        getPos() {
          return this.i;
        }

        decr() {
          this.i -= 1;
        }
      }

      const reserved = new Set(['{', '}', '[', ']', ':', ',']);

      function skipWhitespace(data, counter) {
        while (data.charAt(counter.getPos()) === ' ') {
          counter.inc();
        }
      }

      function parseObject(data) {
        let counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Position();

        let state = 'start';
        const obj = {};
        let key = '';

        for (let i = counter; i.getPos() < data.length; i.inc()) {
          const ch = data.charAt(i.getPos());
          if (ch === '{') {
            switch (state) {
              case 'start':
                state = 'key';
                break;
              default:
                throw new Error(`unexpected ${ch} when in ${state} at position ${i.i}`);
            }
          } else if (ch === '}') {
            if (key) {
              obj[key] = true;
              key = '';
            }
            return obj;
          } else if (ch === ':') {
            switch (state) {
              case 'key':
                i.inc();
                key = key.trim();
                obj[key] = parseValue(data, i);
                state = 'key';
                key = '';
                break;
              default:
                throw new Error(`unexpected ${ch} when in ${state} at position ${i.i}`);
            }
          } else if (ch === ',') {
            switch (state) {
              case 'key':
                key = '';
                state = 'key';
                break;
              default:
                throw new Error(`unexpected ${ch} when in ${state} at position ${i.i}`);
            }
          } else {
            switch (state) {
              case 'key':
                key += ch;
                break;
              default:
                throw new Error(`unexpected ${ch} when in ${state} at position ${i.i}`);
            }
          }
        }

        return obj;
      }

      function parseArray(data, counter) {
        skipWhitespace(data, counter);
        const value = [];
        for (let i = counter; i.getPos() < data.length; i.inc()) {
          const ch = data.charAt(i.getPos());

          if (ch === '[' || ch === ',') {
            i.inc();
          } else if (ch === ']') {
            break;
          }
          value.push(parseValue(data, counter));
        }
        return value;
      }

      parseValue = function parseVal(data, counter) {
        skipWhitespace(data, counter);
        const firstChar = data.charAt(counter.getPos());
        if (firstChar === '{') {
          return parseObject(data, counter);
        } else if (firstChar === '[') {
          return parseArray(data, counter);
        }

        let val = '';
        for (let i = counter; i.getPos() < data.length; i.inc()) {
          const ch = data.charAt(i.getPos());

          if (reserved.has(ch)) {
            break;
          }
          val += ch;
        }
        counter.decr();
        return val.trim();
      };

      var _slicedToArray$14 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /*  Parse a URL string into a set of sub-components, namely:
       - protocol
       - username
       - password
       - hostname
       - port
       - path
       - parameters (semicolon separated key-values before the query string)
       - query (? followed by & separated key-values)
       - fragment (after the #)
       Given a valid string url, this function returns an object with the above
       keys, each with the value of that component, or empty string if it does not
       appear in the url.
       */
      function parseURL$1(url) {
        const urlobj = fastUrlParser.parse(url, false, false, true);
        if (!urlobj._protocol || !urlobj.slashes || !urlobj.host && urlobj._port < 0 && !urlobj.auth) {
          return null;
        }
        const port = urlobj._port < 0 ? 80 : urlobj._port;
        let username = '',
            password = '';
        if (urlobj.auth) {
          var _urlobj$auth$split = urlobj.auth.split(':');

          var _urlobj$auth$split2 = _slicedToArray$14(_urlobj$auth$split, 2);

          username = _urlobj$auth$split2[0];
          password = _urlobj$auth$split2[1];
        }
        let path = urlobj.pathname || '/';
        let query = urlobj.search !== null ? urlobj.search.slice(1) : '';
        let parameters = '';
        if (urlobj.pathname !== null) {
          const parametersIndex = urlobj.pathname.indexOf(';');
          if (parametersIndex !== -1) {
            path = path.slice(0, parametersIndex);
            parameters = urlobj.pathname.slice(parametersIndex + 1);
          }
        }
        let fragment = urlobj.hash !== null ? urlobj.hash.slice(1) : '';
        return {
          urlString: url,
          protocol: urlobj._protocol,
          hostname: urlobj.hostname,
          port: port,
          username: username,
          password: password,
          path: path,
          query: query,
          parameters: parameters,
          fragment: fragment
        };
      }

      function isMaybeJson(v) {
        if (typeof v !== 'string') {
          return false;
        }
        const trimmed = v.trim();
        const first = trimmed[0];
        const last = trimmed[trimmed.length - 1];
        return first === '{' && last === '}' || first === '[' && last === ']';
      }

      const complexParsers = [JSON.parse, parseObject];

      function getJson(v) {
        if (isMaybeJson(v)) {
          let obj = v;
          for (let i = 0; i < complexParsers.length; i++) {
            try {
              obj = complexParsers[i](v);
              break;
            } catch (e) {}
          }
          return _flattenJson(obj);
        }
        return false;
      }

      function getParametersQS$1(qs) {
        var res = {};
        const keysMultiValue = new Set();
        let state = 'key';
        let k = '';
        let v = '';

        var _updateQS = function _updateQS(k, v) {
          // check for JSON in value
          const jsonParts = getJson(v);
          if (jsonParts) {
            Object.keys(jsonParts).forEach(jk => {
              res[k + jk] = jsonParts[jk];
            });
          } else {
            if (keysMultiValue.has(k)) {
              res[k].push(v);
            } else if (k in res) {
              keysMultiValue.add(k);
              res[k] = [res[k], v];
            } else {
              res[k] = v;
            }
          }
        };

        var quotes = '';
        for (let i = 0; i < qs.length; i++) {
          let c = qs.charAt(i);
          if (c === '"' || c === "'") {
            if (quotes.slice(-1) === c) {
              quotes = quotes.slice(0, quotes.length - 1);
            } else {
              quotes += c;
            }
          }
          if (c === '=' && state === 'key' && k.length > 0) {
            state = 'value';
            continue;
          } else if ((c === '&' || c === ';') && quotes === '') {
            if (state === 'value') {
              state = 'key';
              // in case the same key already exists
              v = dURIC(v);
              _updateQS(k, v);
            } else if (state === 'key' && k.length > 0) {
              // key with no value, set value='true'
              res[k] = 'true';
            }
            k = '';
            v = '';
            continue;
          }
          switch (state) {
            case 'key':
              k += c;
              break;
            case 'value':
              v += c;
              break;
          }
        }
        if (state === 'value') {
          state = 'key';
          v = dURIC(v);
          _updateQS(k, v);
        } else if (state === 'key' && k.length > 0) {
          res[k] = 'true';
        }

        // for keys with multiple values, check for '=' in value, and use that to build a unique key
        keysMultiValue.forEach(mvKey => {
          const doubleKeys = res[mvKey].filter(v => v.indexOf('=') > -1);
          if (doubleKeys.length > 0) {
            // add new keys to res object
            doubleKeys.forEach(v => {
              var items = v.split('=');
              const k2 = mvKey + '_' + items[0];
              const v2 = items.splice(1).join('=');
              _updateQS(k2, v2);
            });
            // delete old duplicate values
            if (doubleKeys.length === res[mvKey].length) {
              delete res[mvKey];
            } else {
              res[mvKey] = res[mvKey].filter(v => v.indexOf('=') === -1);
              // special case: only one element left, unpack array
              if (res[mvKey].length === 1) {
                res[mvKey] = res[mvKey][0];
              }
            }
          }
        });

        return res;
      }

      // The value in query strings can be a json object, we need to extract the key-value pairs out
      function _flattenJson(obj) {
        if (typeof obj === 'string' && (obj.indexOf('{') > -1 || obj.indexOf('[') > -1)) {
          try {
            obj = JSON.parse(obj);
            if (typeof obj !== 'object' && typeof obj !== 'array') {
              obj = JSON.stringify(obj);
            }
          } catch (e) {}
        }
        var res = {};
        switch (typeof obj) {
          case 'object':
            for (var key in obj) {
              var r = _flattenJson(obj[key]);
              for (var _key in r) {
                res[key + _key] = r[_key];
              }
            }
            break;
          case 'number':
            obj = JSON.stringify(obj);
          default:
            res[''] = obj;
        }
        return res;
      }

      function dURIC(s) {
        // avoide error from decodeURIComponent('%2')
        try {
          return decodeURIComponent(s);
        } catch (e) {
          return s;
        }
      }

      /**
       URLInfo class: holds a parsed URL.
       */

      function urlGetFromCache(url) {
        return urlCache.get(url);
      }

      const urlCache = new FixedSizeCache(function (url) {
        return new Url(url);
      }, 100);

      /** Factory getter for URLInfo. URLInfo are cached in a LRU cache. */
      const URLInfo = {
        get: function get(url) {
          if (!url) return "";
          try {
            return urlGetFromCache(url);
          } catch (e) {
            return null;
          }
        }
      };

      class Url {

        constructor(urlString) {
          this.urlString = urlString;
          // add attributes from parseURL to this object
          const parsed = parseURL$1(urlString);
          if (parsed) {
            Object.assign(this, parsed);
          } else {
            throw new Error(`invalid url: ${urlString}`);
          }
        }

        get generalDomain() {
          if (!this._generalDomain) {
            this._generalDomain = getGeneralDomain(this.hostname);
          }
          return this._generalDomain;
        }

        get generalDomainHash() {
          return cachedMD5(this.generalDomain).substring(0, 16);
        }

        toString() {
          return this.urlString;
        }

        get query_keys() {
          if (this._query_keys) {
            return this._query_keys;
          }
          this._query_keys = getParametersQS$1(this.query);
          return this._query_keys;
        }

        get parameter_keys() {
          if (this._parameter_keys) {
            return this._parameter_keys;
          }
          this._parameter_keys = getParametersQS$1(this.parameters);
          return this._parameter_keys;
        }

        get fragment_keys() {
          if (this._fragment_keys) {
            return this._fragment_keys;
          }
          this._fragment_keys = getParametersQS$1(this.fragment);
          return this._fragment_keys;
        }

        getKeyValues() {
          if (this._kvList) {
            return this._kvList;
          }
          var kvList = [];
          var _arr = [this.query_keys, this.parameter_keys];
          for (var _i = 0; _i < _arr.length; _i++) {
            let kv = _arr[_i];
            for (let key in kv) {
              // iterate each array element separately
              if (Array.isArray(kv[key])) {
                kv[key].forEach(val => {
                  kvList.push({ k: key, v: val });
                });
              } else {
                kvList.push({ k: key, v: kv[key] });
              }
            }
          }
          this._kvList = kvList;
          return kvList;
        }

        getKeyValuesMD5() {
          if (this._kvMD5List) {
            return this._kvMD5List;
          }
          const kvList = this.getKeyValues().map(function (kv) {
            // ensure v is stringy
            const vStr = '' + kv.v;
            return {
              k_len: kv.k.length,
              v_len: vStr.length,
              k: cachedMD5(kv.k),
              v: cachedMD5(vStr)
            };
          });
          this._kvMD5List = kvList;
          return kvList;
        }

      }

      function shuffle(s) {
        var a = s.split(""),
            n = a.length;

        for (var i = n - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a.join("");
      }

      function parseQuery(qstr) {
        var query = {};
        var a = qstr.split('&');
        for (var i in a) {
          var b = a[i].split('=');
          query[dURIC(b[0])] = dURIC(b[1]);
        }
        return query;
      }

      const TYPE_LOOKUP = {
        // maps string (web-ext) to int (FF cpt)
        other: 1,
        script: 2,
        image: 3,
        stylesheet: 4,
        object: 5,
        main_frame: 6,
        sub_frame: 7,
        xbl: 9,
        ping: 10,
        xmlhttprequest: 11,
        object_subrequest: 12,
        xml_dtd: 13,
        font: 14,
        media: 15,
        websocket: 16,
        csp_report: 17,
        xslt: 18,
        beacon: 19,
        imageset: 21,
        web_manifest: 22
      };

      const TYPE_LOOKUP_REVERSE = Object.keys(TYPE_LOOKUP).reduce((obj, key) => Object.assign(obj, { [TYPE_LOOKUP[key]]: key }), {});

      function createHeadersGetter(headers) {
        const headersMap = new Map();

        for (let i = 0; i < headers.length; i += 1) {
          const header = headers[i];
          headersMap.set(header.name.toLowerCase(), header.value);
        }

        return headersMap;
      }

      /**
       * Implements WebRequest Context API
       */
      class WebRequestContext {
        constructor(details) {
          // The following are NOT supported in bootstrap extension
          this.requestId = details.requestId;
          this.timeStamp = details.timeStamp;
          this.method = details.method;
          this.ip = details.ip;
          this.error = details.error;
          this.proxyInfo = details.proxyInfo; // FF web-ext only

          // Frame ids: tabId -> parentFrameId -> frameId
          this.frameId = details.frameId;
          this.parentFrameId = details.parentFrameId;
          this.tabId = details.tabId;

          // Urls:  sourceUrl -> originUrl -> url
          this.url = details.url;
          this._urlParts = null;
          this.originUrl = details.originUrl;
          this._originUrlParts = null;
          this.sourceUrl = details.sourceUrl;
          this._sourceUrlParts = null;

          this.trigger = details.trigger || details.originUrl;

          // Content type
          // We should still use the interger type (cpt) from LegacyContext
          this.type = details.type;
          if (typeof details.type === 'string') {
            this.typeInt = TYPE_LOOKUP[details.type];
          } else {
            this.typeInt = this.type;
            this.type = TYPE_LOOKUP_REVERSE[details.type];
          }

          // Headers
          this.requestHeaders = details.requestHeaders;
          this._requestHeadersMap = null;
          this.responseHeaders = details.responseHeaders;
          this._responseHeadersMap = null;

          // Extra metadata
          this.isRedirect = details.isRedirect;
          this.statusCode = details.statusCode;
          this.fromCache = details.fromCache;
          this.isPrivate = details.isPrivate || false;
        }

        get urlParts() {
          if (this._urlParts === null) {
            this._urlParts = URLInfo.get(this.url);
          }

          return this._urlParts;
        }

        get originUrlParts() {
          if (this._originUrlParts === null) {
            this._originUrlParts = URLInfo.get(this.originUrl);
          }

          return this._originUrlParts;
        }

        get sourceUrlParts() {
          if (this._sourceUrlParts === null) {
            this._sourceUrlParts = URLInfo.get(this.sourceUrl);
          }

          return this._sourceUrlParts;
        }

        getRequestHeader(name) {
          if (this.requestHeaders) {
            if (this._requestHeadersMap === null) {
              this._requestHeadersMap = createHeadersGetter(this.requestHeaders);
            }

            return this._requestHeadersMap.get(name.toLowerCase());
          }

          return undefined;
        }

        getResponseHeader(name) {
          if (this.responseHeaders) {
            if (this._responseHeadersMap === null) {
              this._responseHeadersMap = createHeadersGetter(this.responseHeaders);
            }

            return this._responseHeadersMap.get(name.toLowerCase());
          }

          return undefined;
        }

        isFullPage() {
          return this.type === 'main_frame';
        }

        getCookieData() {
          return this.getRequestHeader('Cookie');
        }

        getReferrer() {
          return this.getRequestHeader('Referer');
        }

        getWindowDepth() {
          let windowDepth = 0;
          if (this.frameId !== this.tabId) {
            if (this.frameId === this.parentFrameId) {
              // frame in document
              windowDepth = 1;
            } else {
              // deeper than 1st level iframe
              windowDepth = 2;
            }
          }
          return windowDepth;
        }
      }

      /**
       * Implements Legacy API on top of WebRequestContext
       */
      class LegacyContext extends WebRequestContext {
        get cpt() {
          return this.typeInt;
        }

        get tabUrl() {
          return this.sourceUrl;
        }

        get responseStatus() {
          return this.statusCode;
        }

        get isCached() {
          return this.fromCache;
        }
      }

      var tabs = {
        onCreated: {
          addListener() {},
          removeListener() {}
        },
        onUpdated: {
          addListener() {},
          removeListener() {}
        },
        onRemoved: {
          addListener() {},
          removeListener() {}
        }
      };

      var windows = {
        onCreated: {
          addListener() {},
          removeListener() {}
        },
        onRemoved: {
          addListener() {},
          removeListener() {}
        }
      };

      class PageStore {
        constructor() {
          this.tabs = {};
          this.windows = {};

          this.onTabCreated = this.onTabCreated.bind(this);
          this.onTabUpdated = this.onTabUpdated.bind(this);
          this.onTabRemoved = this.onTabRemoved.bind(this);
          this.onWindowCreated = this.onWindowCreated.bind(this);
          this.onWindowRemoved = this.onWindowRemoved.bind(this);
        }

        init() {
          tabs.onCreated.addListener(this.onTabCreated);
          tabs.onUpdated.addListener(this.onTabUpdated);
          tabs.onRemoved.addListener(this.onTabRemoved);

          // windows API may be undefined on Firefox for Android.
          if (windows) {
            windows.onCreated.addListener(this.onWindowCreated);
            windows.onRemoved.addListener(this.onWindowRemoved);
          }
        }

        unload() {
          tabs.onCreated.removeListener(this.onTabCreated);
          tabs.onUpdated.removeListener(this.onTabUpdated);
          tabs.onRemoved.removeListener(this.onTabRemoved);

          if (windows) {
            windows.onCreated.removeListener(this.onWindowCreated);
            windows.onRemoved.removeListener(this.onWindowRemoved);
          }
        }

        onFullPage(_ref) {
          let tabId = _ref.tabId,
              url = _ref.url,
              isPrivate = _ref.isPrivate,
              requestId = _ref.requestId;

          // update last request id from the tab
          if (this.tabs[tabId] === undefined) {
            this.tabs[tabId] = {
              url,
              isPrivate
            };
          }

          this.tabs[tabId].lastRequestId = requestId;
        }

        isRedirect(details) {
          if (details.type === 'main_frame' && details.parentFrameId === -1) {
            if (details.tabId && this.tabs[details.tabId] !== undefined) {
              if (details.requestId === this.tabs[details.tabId].lastRequestId) {
                return true;
              }
            }
          }

          return false;
        }

        getWindowStatus(windowId) {
          let isPrivate = null;
          if (windowId) {
            if (!this.windows[windowId]) {
              chrome$1.windows.get(windowId, window$$1 => {
                this.windows[window$$1.id] = {
                  isPrivate: window$$1.incognito
                };
              });
            } else {
              isPrivate = this.windows[windowId].isPrivate;
            }
          }
          return isPrivate;
        }

        onTabCreated(tab) {
          console$1.log('add new tab', tab.id);
          if (tab.id) {
            this.tabs[tab.id] = {
              url: tab.url,
              isPrivate: tab.incognito
            };
          }
        }

        onTabUpdated(tabId, changeInfo, tab) {
          console$1.log('update tab', tabId);
          if (tabId && tab.url) {
            if (this.tabs[tabId]) {
              this.tabs[tabId].url = tab.url;
              this.tabs[tabId].isPrivate = tab.incognito;
            } else {
              this.tabs[tabId] = {
                url: tab.url,
                isPrivate: tab.incognito
              };
            }
            console$1.log('tab updated', tabId, tab.url);
          }
          console$1.log(this.tabs);
        }

        onTabRemoved(tabId) {
          if (tabId) {
            delete this.tabs[tabId];
          }
        }

        onWindowCreated(window$$1) {
          this.windows[window$$1.id] = {
            isPrivate: window$$1.incognito
          };
        }

        onWindowRemoved(windowId) {
          delete this.windows[windowId];
        }

        getSourceURL(details) {
          if (details.type === 'main_frame' && details.parentFrameId === -1) {
            return details.url;
          }

          const tabId = details.tabId;
          if (tabId && tabId in this.tabs) {
            return this.tabs[tabId].url;
          } else if (tabId !== -1) {
            console$1.log(tabId, this.tabs, 'Cannot locate tabId');
          }

          return null;
        }
      }

      /**
       *
       */
      function sanitizeResponse(response, event) {
        // make sure when response.cancel is true, no other properties are set
        if (response.cancel === true) {
          return { cancel: true };
        }

        const allowedProperties = VALID_RESPONSE_PROPERTIES[event];

        if (allowedProperties.length === 0) {
          return {};
        }

        const result = Object.create(null);

        for (let i = 0; i < allowedProperties.length; i += 1) {
          const prop = allowedProperties[i];
          if (response[prop] !== undefined) {
            result[prop] = response[prop];
          }
        }

        return result;
      }

      function createResponse(details) {
        return {
          redirectTo(url) {
            this.redirectUrl = url;
          },
          block() {
            this.cancel = true;
          },
          modifyHeader(name, value) {
            if (!this.requestHeaders) {
              this.requestHeaders = [...(details.requestHeaders || [])];
            }
            const headerIndex = this.requestHeaders.findIndex(h => h.name === name);
            if (isChromium && !value) {
              // empty value on chromium: remove header
              if (headerIndex > -1) {
                this.requestHeaders.splice(headerIndex, 1);
              }
            } else if (headerIndex > -1) {
              this.requestHeaders[headerIndex] = { name, value };
            } else {
              this.requestHeaders.push({ name, value });
            }
          }
        };
      }

      function createWebRequestContext(details, pageStore) {
        const context = details;

        // Check if we have a URL
        if (!context.url || context.url === '') {
          logger$1.error('createWebRequestContext no url', details);
          return null;
        }

        // **Chromium addition**
        // In Chromium, we do not know if the tab is Private from the webrequest
        // object, so we need to get this information from `pageStore`.
        if (context.isPrivate === null || context.isPrivate === undefined) {
          const tabId = context.tabId;
          if (tabId !== -1 && pageStore.tabs[tabId]) {
            context.isPrivate = pageStore.tabs[tabId].isPrivate;
          }
        }

        // **Chromium addition**
        // We do not get the `sourceUrl` in Chrome, so we keep track of the mapping
        // tabId/sourceUrl in `pageStore`.
        try {
          if (!context.sourceUrl && chrome && chrome.tabs) {
            context.sourceUrl = pageStore.getSourceURL(context);
          }
        } catch (ex) {}
        /* Not defined on firefox yet */

        // **Chromium addition**
        // Tag redirects
        if (context.isRedirect === null || context.isRedirect === undefined) {
          context.isRedirect = pageStore.isRedirect(context);
        }

        // **Chromium addition**
        if (context.type === 'main_frame') {
          pageStore.onFullPage(context);
        }

        return new LegacyContext(context);
      }

      var Background$11 = background({
        initialized: false,

        enabled() {
          return true;
        },

        init() {
          if (this.initialized) {
            return;
          }

          this.whitelist = new UrlWhitelist('webRequestPipeline-whitelist');
          this.pipelines = new Map();
          this.pageStore = new PageStore();
          this.pageStore.init();

          this.initialized = true;
        },

        unload() {
          if (!this.initialized) {
            return;
          }

          // Remove webrequest listeners
          this.pipelines.forEach((pipeline, event) => {
            this.unloadPipeline(event);
          });

          this.pageStore.unload();
          this.initialized = false;
        },

        unloadPipeline(event) {
          if (this.pipelines.has(event)) {
            const pipeline = this.pipelines.get(event);
            this[event] = undefined;
            WebRequest$1[event].removeListener(pipeline.listener);
            this.pipelines.delete(event);
          }
        },

        getPipeline(event) {
          if (this.pipelines.has(event)) {
            return this.pipelines.get(event).pipeline;
          }

          // It might be that the platform does not support all listeners:
          if (WebRequest$1[event] === undefined) {
            return null;
          }

          // Get allowed options for this event (e.g.: 'blocking', 'requestHeaders',
          // etc.)
          const extraInfoSpec = EXTRA_INFO_SPEC[event];

          // Create pipeline step
          const pipeline = new Pipeline(`webRequestPipeline.${event}`, [], false);

          // Register listener for this event
          const listener = details => {
            const response = createResponse(details);

            const webRequestContext = createWebRequestContext(details, this.pageStore);

            // Request is not supported, so do not alter
            if (webRequestContext === null) {
              return {};
            }

            // TODO - handle domain whitelisting
            pipeline.execute(webRequestContext, response, !this.whitelist.isWhitelisted(webRequestContext.url));
            if (isChromium) {
              return sanitizeResponse(response, event);
            }
            return response;
          };

          this.pipelines.set(event, {
            pipeline,
            listener
          });

          // Register the event listener as an attribute of background so that we
          // can call it: `webRequestPipeline.background.onBeforeRequest(details)`.
          this[event] = listener;

          WebRequest$1[event].addListener(listener, { urls: ['<all_urls>'] }, extraInfoSpec);

          return pipeline;
        },

        events: {},

        actions: {
          isWhitelisted(url) {
            return this.whitelist.isWhitelisted(url);
          },

          changeWhitelistState(url, type, action) {
            return this.whitelist.changeState(url, type, action);
          },

          getWhitelistState(url) {
            return this.whitelist.getState(url);
          },

          addPipelineStep(stage, opts) {
            if (this.initialized) {
              const pipeline = this.getPipeline(stage);
              if (pipeline === null) {
                logger$1.error('WebRequest pipeline (add) does not have stage', stage);
              } else {
                pipeline.addPipelineStep(opts);
              }
            }
          },

          removePipelineStep(stage, name) {
            if (this.initialized) {
              const pipeline = this.getPipeline(stage);

              if (pipeline === null) {
                logger$1.error('WebRequest pipeline (remove) does not have stage', stage);
              } else {
                pipeline.removePipelineStep(name);
                if (pipeline.length === 0) {
                  this.unloadPipeline(stage);
                }
              }
            }
          }
        }
      });

      class Win$10 {
        init() {}

        unload() {}
      }

      var webrequestPipelineModule = {
        Background: Background$11,
        Window: Win$10
      };

      const domainInfo = {
        domainOwners: {},
        apps: {},
        bugs: {},
        domains: {}
      };

      function parseDomainOwners(companyList) {
        const apps = companyList.apps,
              bugs = companyList.bugs,
              domains = companyList.domains;

        domainInfo.apps = apps;
        domainInfo.bugs = bugs;
        domainInfo.domains = domains;

        const revList = {};
        Object.keys(domains).forEach(domain => {
          revList[domain] = apps[domains[domain]].name;
        });

        domainInfo.domainOwners = revList;
      }

      manager.addResourceLoader(new ResourceLoader(['antitracking', 'tracker_db_v2.json'], {
        remoteURL: `${config.settings.CDN_BASEURL}/anti-tracking/tracker_db_v2.json`,
        cron: 24 * 60 * 60 * 1000
      }), parseDomainOwners);

      function getAppOwner(appId) {
        return domainInfo.apps[appId] || { name: 'Unknown', cat: 'unknown' };
      }

      function getBugOwner(bugId) {
        const appId = domainInfo.bugs[bugId];
        return getAppOwner(appId);
      }

      function _getDomainOwner(dom) {
        if (dom in domainInfo.domains) {
          return domainInfo.apps[domainInfo.domains[dom]];
        }
        if (dom.indexOf('.') === -1) {
          return false;
        }
        return _getDomainOwner(dom.substring(dom.indexOf('.') + 1));
      }

      function getDomainOwner(dom) {
        return _getDomainOwner(dom) || {
          name: getGeneralDomain(dom),
          cat: 'unknown'
        };
      }

      const VERSIONCHECK_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/versioncheck.json`;
      const CONFIG_URL = `${config.settings.CDN_BASEURL}/anti-tracking/config.json`;

      const VERSION = '0.101';
      const MIN_BROWSER_VERSION = 35;

      const TELEMETRY = {
        DISABLED: 0,
        TRACKERS_ONLY: 1,
        ALL: 2
      };

      const DEFAULTS = {
        safekeyValuesThreshold: 4,
        shortTokenLength: 6,
        placeHolder: 'cliqz.com/tracking',
        cliqzHeader: 'CLIQZ-AntiTracking',
        enabled: true,
        cookieEnabled: true,
        qsEnabled: true,
        bloomFilterEnabled: true,
        telemetryMode: TELEMETRY.ALL,
        sendAntiTrackingHeader: true
      };

      const PREFS = {
        enabled: 'modules.antitracking.enabled',
        cookieEnabled: 'attrackBlockCookieTracking',
        qsEnabled: 'attrackRemoveQueryStringTracking',
        fingerprintEnabled: 'attrackCanvasFingerprintTracking',
        referrerEnabled: 'attrackRefererTracking',
        trackerTxtEnabled: 'trackerTxt',
        bloomFilterEnabled: 'attrackBloomFilter',
        forceBlockEnabled: 'attrackForceBlock',
        overrideUserAgent: 'attrackOverrideUserAgent',
        cookieTrustReferers: 'attrackCookieTrustReferers',
        telemetryMode: 'attrackTelemetryMode',
        sendAntiTrackingHeader: 'attrackSendHeader'
      };

      /**
       * These are attributes which are loaded from the remote CONFIG_URL
       * @type {Array}
       */
      const REMOTELY_CONFIGURED = ['blockRules', 'reportList', 'cookieWhitelist', 'subdomainRewriteRules'];

      class Config {
        constructor(_ref) {
          var _ref$defaults = _ref.defaults;
          let defaults = _ref$defaults === undefined ? DEFAULTS : _ref$defaults;
          var _ref$versionUrl = _ref.versionUrl;
          let versionUrl = _ref$versionUrl === undefined ? VERSIONCHECK_URL : _ref$versionUrl;

          this.debugMode = false;
          this.versionCheckUrl = versionUrl;

          this.tokenDomainCountThreshold = 2;
          this.safeKeyExpire = 7;
          this.localBlockExpire = 24;

          Object.assign(this, defaults);

          this.safekeyValuesThreshold = parseInt(getValue('safekeyValuesThreshold'), 10) || this.safekeyValuesThreshold;
          this.shortTokenLength = parseInt(getValue('shortTokenLength'), 10) || this.shortTokenLength;
          this.placeHolder = getValue('placeHolder') || this.placeHolder;
          this.cliqzHeader = getValue('cliqzHeader') || this.cliqzHeader;

          this.paused = false;

          this.loadPrefs();
        }

        loadPrefs() {
          Object.keys(PREFS).forEach(conf => {
            this[conf] = CliqzUtils.getPref(PREFS[conf], this[conf] || false);
          });
        }

        setPref(name, value) {
          if (!PREFS[name]) {
            throw new Error(`pref ${name} not known`);
          }
          CliqzUtils.setPref(PREFS[name], value);
        }

        onPrefChange(pref) {
          if (Object.keys(PREFS).map(n => PREFS[n]).indexOf(pref) > -1) {
            this.loadPrefs();
          }
        }

        init() {
          const versionCheckLoader = new ResourceLoader(['antitracking', 'versioncheck.json'], {
            remoteURL: this.versionCheckUrl,
            cron: 1000 * 60 * 60 * 12,
            remoteOnly: true
          });
          manager.addResourceLoader(versionCheckLoader, this._updateVersionCheck.bind(this));

          const configLoader = new ResourceLoader(['antitracking', 'config.json'], {
            remoteURL: CONFIG_URL,
            cron: 1000 * 60 * 60 * 12
          });
          manager.addResourceLoader(configLoader, this._updateConfig.bind(this));
          return Promise.resolve();
        }

        unload() {}

        _updateVersionCheck(versioncheck) {
          // config in versioncheck
          if (versioncheck.placeHolder) {
            setValue('placeHolder', versioncheck.placeHolder);
            this.placeHolder = versioncheck.placeHolder;
          }

          if (versioncheck.shortTokenLength) {
            setValue('shortTokenLength', versioncheck.shortTokenLength);
            this.shortTokenLength = parseInt(versioncheck.shortTokenLength, 10) || this.shortTokenLength;
          }

          if (versioncheck.safekeyValuesThreshold) {
            setValue('safekeyValuesThreshold', versioncheck.safekeyValuesThreshold);
            this.safekeyValuesThreshold = parseInt(versioncheck.safekeyValuesThreshold, 10) || this.safekeyValuesThreshold;
          }

          if (versioncheck.cliqzHeader) {
            setValue('cliqzHeader', versioncheck.cliqzHeader);
            this.cliqzHeader = versioncheck.cliqzHeader;
          }

          // fire events for list update
          CliqzEvents.pub('attrack:updated_config', versioncheck);
        }

        _updateConfig(conf) {
          REMOTELY_CONFIGURED.forEach(key => {
            this[key] = conf[key];
          });
        }
      }

      // Class to hold a page load and third party urls loaded by this page.
      class PageLoadData {

        constructor(url, isPrivate, reloaded) {
          this.url = url.toString();
          this.hostname = url.hostname;
          this.path = this._shortHash(url.path);
          this.scheme = url.protocol;
          this.private = isPrivate;
          this.c = 1;
          this.s = Date.now();
          this.e = this.s;
          this.tps = {};
          this.redirects = [];
          this.ra = reloaded;
          this.annotations = {};

          this.triggeringTree = {};
          this._plainObject = null;
          this._tpStatCounter = _newStatCounter;
        }

        // Create a short md5 hash of the input string s
        _shortHash(s) {
          if (!s) return '';
          return cachedMD5(s).substring(0, 16);
        }

        // Get a stat counter object for the given third party host and path in
        // this page load.
        getTpUrl(tp_host, tp_path) {
          // reset cached plain object
          this._plainObject = null;
          var path_key = tp_path; // TODO hash it?
          if (!(tp_host in this.tps)) {
            this.tps[tp_host] = {};
          }
          if (!(path_key in this.tps[tp_host])) {
            this.tps[tp_host][path_key] = this._tpStatCounter();
          }
          return this.tps[tp_host][path_key];
        }

        // Returns true if the given referrer matches this page load.
        // This can be either a direct referral (referrer matches page load url),
        // or nth degree (referrer is somewhere in the graph of referrals originating
        // from the original page load url).
        isReferredFrom(ref_parts) {
          if (!ref_parts) return false;
          if (sameGeneralDomain(ref_parts.hostname, this.hostname)) {
            return true;
          }
          // not a direct referral, but could be via a third party
          if (ref_parts.hostname in this.tps) {
            return true;
          }
          return false;
        }

        // Creates a plain, aggregated version of this object, suitable for converting
        // to JSON, and sending as telemetry.
        asPlainObject() {
          return this._plainObject || this._buildPlainObject();
        }

        addTrigger(host, triggeredBy) {
          if (triggeredBy.indexOf('://') > 0) {
            let triggerDomain = triggeredBy.split('://')[1];
            // if trigger is same as page, hide as 'first party'
            if (sameGeneralDomain(triggerDomain, this.hostname)) {
              triggerDomain = 'first party';
            }
            // if triggered by self, don't add
            if (sameGeneralDomain(triggerDomain, host)) {
              return;
            }
            if (!this.triggeringTree[triggerDomain]) {
              this.triggeringTree[triggerDomain] = new Set();
            }
            this.triggeringTree[triggerDomain].add(host);
          }
          this._plainObject = null;
        }

        setAsStaged() {
          this.e = Date.now();
          this._plainObject = null;
        }

        _buildPlainObject() {
          var self = this,
              obj = {
            hostname: this._shortHash(this.hostname),
            path: this.path,
            scheme: this.scheme,
            c: this.c,
            t: this.e - this.s,
            ra: this.ra || 0,
            tps: {},
            redirects: this.redirects.filter(function (hostname) {
              return !sameGeneralDomain(hostname, self.hostname);
            }),
            triggeringTree: {}
          };
          if (!obj.hostname) return obj;

          for (let tp_domain in this.tps) {
            var tp_domain_data = this.tps[tp_domain],
                tp_paths = Object.keys(tp_domain_data);
            // skip same general domain
            if (sameGeneralDomain(self.hostname, tp_domain)) {
              continue;
            }
            if (tp_paths.length > 0) {
              // aggregate stats per tp domain.
              const path_data = tp_paths.map(k => tp_domain_data[k]);
              obj['tps'][tp_domain] = path_data.reduce(this._sumStats);

              // Remove the keys which have value == 0;
              stats.forEach(function (eachKey) {
                if (obj['tps'][tp_domain] && obj['tps'][tp_domain][eachKey] == 0) delete obj['tps'][tp_domain][eachKey];
              });
            }
          }

          Object.keys(this.triggeringTree).forEach(trigger => {
            // convert set to list
            obj.triggeringTree[trigger] = [...this.triggeringTree[trigger]];
          });

          // This was added to collect data for experiment, safe to stop collecting it now.
          // checkBlackList(this.url, obj);
          // checkFingerPrinting(this.url, obj);
          this._plainObject = obj;
          return obj;
        }

        _sumStats(a, b) {
          var c = {},
              stats_keys = new Set(Object.keys(a).concat(Object.keys(b)));
          stats_keys.forEach(function (s) {
            c[s] = (a[s] || 0) + (b[s] || 0);
          });
          return c;
        }
      }

      var stats = ['c'];

      class PageEventTracker {

        constructor(telemetryCallback, config) {
          this.debug = false;
          this._active = {};
          this._old_tab_idx = {};
          this._staged = [];
          this._last_clean = 0;
          this._clean_interval = 1000 * 10; // 10s
          this._push_interval = 1000 * 60 * 20; // 20 minutes decreasing the frequency from 5 minutes to 20 minutes.
          this._last_push = 0;
          this.ignore = new Set(['self-repair.mozilla.org']);
          this.pushTelemetry = telemetryCallback;
          this.config = config;
          this.listeners = new Map();
        }
        // Called when a url is loaded on windowID source.
        // Returns the PageLoadData object for this url.
        //  or returns null if the url is malformed or null.
        onFullPage(url, tab_id, isPrivate) {
          // previous request finished. Move to staged
          const prevPage = this.stage(tab_id);
          // create new page load entry for tab
          if (url && url.hostname && Number(tab_id) > 0 && !this.ignore.has(url.hostname)) {
            // check if it is a reload of the same page
            const reloaded = prevPage && url.toString() === prevPage.url && Date.now() - prevPage.s < 30000 || false;

            this._active[tab_id] = new PageLoadData(url, isPrivate || false, reloaded || false);
            return this._active[tab_id];
          } else {
            return null;
          }
        }

        onRedirect(url, tab_id, isPrivate) {
          if (tab_id in this._active) {
            let prev = this._active[tab_id];
            this._active[tab_id] = new PageLoadData(url, isPrivate || false, prev.ra || false);
            this._active[tab_id].redirects = prev.redirects;
            this._active[tab_id].redirects.push(prev.hostname);
          } else {
            this.onFullPage(url, tab_id, isPrivate);
          }
        }

        // Get a stats object for the request to url, referred from ref, on tab source.
        // url_parts and ref_parts contain the decomposed parts (from parseURL) of url and ref respectively.
        // returns an object containing keys specified in tp_events._stats representing the running stats
        // for the requesting third party on the source page.
        // Returns null if the referrer is not valid.
        get(url, url_parts, ref, ref_parts, source) {
          if (source <= 0 || source === null || source === undefined) {
            if (this.debug) CliqzUtils.log("No source for request, not logging!", "tp_events");
            return null;
          }

          if (!(source in this._active)) {
            if (!ref || !ref_parts || !ref_parts.hostname) {
              return null;
            }
            if (this.debug) CliqzUtils.log("No fullpage request for referrer: " + ref + " -> " + url, "tp_events");
            return null;
          }

          var page_graph = this._active[source];
          if (!page_graph.isReferredFrom(ref_parts)) {
            if (!ref || !ref_parts || !ref_parts.hostname) return null;
            if (source in this._old_tab_idx) {
              var prev_graph = this._staged[this._old_tab_idx[source]];
              if (prev_graph && prev_graph.isReferredFrom(ref_parts)) {
                if (this.debug) CliqzUtils.log("Request for expired tab " + ref_parts.hostname + " -> " + url_parts.hostname + " (" + prev_graph['hostname'] + ")", 'tp_events');
                return prev_graph.getTpUrl(url_parts.hostname, url_parts.path);
              }
            }
            if (this.debug) CliqzUtils.log("tab/referrer mismatch " + ref_parts.hostname + " -> " + url_parts.hostname + " (" + page_graph['hostname'] + ")", 'tp_events');
            return null;
          }

          return page_graph.getTpUrl(url_parts.hostname, url_parts.path);
        }

        // Move the PageLoadData object for windowID to the staging area.
        // returns the staged PageLoadData object
        stage(windowID) {
          if (windowID in this._active) {
            this._active[windowID].setAsStaged();
            // push object to staging and save its id
            this._old_tab_idx[windowID] = this._staged.push(this._active[windowID]) - 1;
            delete this._active[windowID];
            // return the staged object
            const stagedPage = this._staged[this._old_tab_idx[windowID]];
            // call stage listeners
            (this.listeners.get('stage') || []).forEach(cb => cb(windowID, stagedPage));
            return stagedPage;
          }
        }

        // Periodically stage any tabs which are no longer active.
        // Will run at a period specifed by tp_events._clean_interval, unless force_clean is true
        // If force_stage is true, will stage all tabs, otherwise will only stage inactive.
        commit() {
          let force_clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          let force_stage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          var now = new Date().getTime();
          if (now - this._last_clean > this._clean_interval || force_clean === true) {
            this._last_clean = now;
            return Promise.all(Object.keys(this._active).map(tabId => checkIsWindowActive(tabId).then(active => {
              if (!active || force_stage === true) {
                if (this.debug) CliqzUtils.log(`Stage tab ${tabId}`, 'tp_events');
                this.stage(tabId);
              }
            })));
          }

          return Promise.resolve();
        }

        // Push staged PageLoadData to human web.
        // Will run at a period specified by tp_events._push_interval, unless force_push is true.
        push(forcePush) {
          const now = new Date().getTime();
          if (this._staged.length > 0 && (now - this._last_push > this._push_interval || forcePush === true)) {
            // convert staged objects into simple objects, and aggregate.
            // then filter out ones with bad data (undefined hostname or no third parties)
            const payloadData = this._staged.filter(pl => !pl.private).map(item => item.asPlainObject()).filter(item => item.hostname.length > 0 && Object.keys(item.tps).length > 0);

            // if we still have some data, send the telemetry
            // if telemetryMode is 0, don't actually send it
            if (payloadData.length > 0 && this.config.telemetryMode !== TELEMETRY.DISABLED) {
              if (this.debug) CliqzUtils.log(`Pushing data for ${payloadData.length} requests`, 'tp_events');
              this.pushTelemetry(payloadData);
            }
            this._staged = [];
            this._old_tab_idx = {};
            this._last_push = now;
          }
        }

        incrementStat(req_log, stat_key, n) {
          if (req_log != null) {
            if (!(stat_key in req_log)) {
              req_log[stat_key] = 0;
            }
            if (!Number.isInteger(n)) {
              n = 1;
            }
            req_log[stat_key] += n;
          }
        }

        getPageForTab(tabId) {
          return this._active[tabId];
        }

        addEventListener(event, callback) {
          if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
          }
          const listeners = this.listeners.get(event);
          listeners.push(callback);
        }

        getOpenPages(cb) {
          return Object.keys(this._active).map(id => this._active[id]);
        }

        getAnnotations(tab) {
          if (this._active[tab]) {
            return this._active[tab].annotations;
          }
          return {};
        }
      }

      function _newStatCounter() {
        var ctr = {},
            stats_keys = stats;
        for (var s in stats_keys) {
          ctr[stats_keys[s]] = 0;
        }
        return ctr;
      }

      function getCountryCode$1() {
        return CliqzUtils.getPref('config_location', '--');
      }

      function compressionAvailable$1() {
        return compress$$1 !== false;
      }

      function compressJSONToBase64(obj) {
        const bytes = compress$$1(JSON.stringify(obj));
        return toBase64(bytes);
      }

      function splitTelemetryData(data, bucketSize) {
        let acc = 0;
        let bucket = {};
        const splitData = [];
        for (const k in data) {
          const length = JSON.stringify(data[k]).length;
          // full bucket
          if (acc != 0 && acc + length > bucketSize) {
            // full bucket, push it
            splitData.push(bucket);
            bucket = {};
            acc = 0;
          }
          acc += length;
          bucket[k] = data[k];
        }
        if (Object.keys(bucket).length > 0) {
          splitData.push(bucket);
        }
        return splitData;
      }

      function generatePayload(data, ts, instant, attachAttrs) {
        var payl = {
          'data': data,
          'ts': ts
        };
        if (instant) payl['instant'] = true;
        if (attachAttrs) {
          for (const k in attachAttrs) {
            payl[k] = attachAttrs[k];
          }
        }
        return payl;
      }

      function cleanTimestampCache(cacheObj, timeout, currTime) {
        const keys = Object.keys(cacheObj);
        keys.forEach(function (k) {
          if (currTime - cacheObj[k] || 0 > timeout) {
            delete cacheObj[k];
          }
        });
      }

      function generateAttrackPayload(data, ts, qsVersion) {
        const extraAttrs = qsVersion;
        extraAttrs.ver = VERSION;
        extraAttrs.ctry = getCountryCode$1();
        ts = ts || getHourTimestamp();
        return generatePayload(data, ts, false, extraAttrs);
      }

      var platformTelemetry = {};

      function msgSanitize$1(msg, channel) {
        if (CliqzUtils.getPref('ff-experiment', null)) {
          msg.channel = 'ff-experiment';
        } else {
          msg.channel = channel;
        }
        try {
          msg.ts = getConfigTs();
        } catch (ee) {
          return;
        }

        if (!msg.ts) {
          return;
        }

        msg['anti-duplicates'] = Math.floor(random() * 10000000);
        return msg;
      }

      var telemetry$1 = {
        telemetry: function telemetry(payl) {
          if (!this.provider) {
            CliqzUtils.log("No telemetry provider loaded", "attrack");
            return;
          }

          if (this.providerName === 'hpn') {
            // sending payload directly through hpn,
            // this is used in ghostery since humanweb is not always there
            // and we need to do add meta data that humanweb added
            payl = msgSanitize$1(payl, this.channel);
            if (payl) {
              ifModuleEnabled(this.provider.action('sendTelemetry', payl));
            }
          } else {
            ifModuleEnabled(this.provider.action('telemetry', payl));
          }
        },

        provider: null,
        providerName: null,
        msgType: 'humanweb',
        channel: null,

        loadFromProvider: function loadFromProvider(provider, channel) {
          CliqzUtils.log("Load telemetry provider: " + provider, "attrack");
          this.providerName = provider;
          this.channel = channel;
          if (provider === 'platform') {
            this.telemetry = platformTelemetry.telemetry.bind(platformTelemetry);
            this.msgType = platformTelemetry.msgType;
            return Promise.resolve(this);
          } else {
            this.provider = inject.module(provider);
          }
        }
      };

      const safeKeyExpire = 7;

      /** Base QS Whitelist
       *  Contains only local safekeys, extra safekeys and safe tokens are left to sub-class.
       */
      class QsWhitelistBase {

        constructor(config) {
          this.config = config;
          this.safeKeys = new LazyPersistentObject('safeKey');
        }

        init() {
          // local safekeys are optional, don't block loading remote lists
          const win = CliqzUtils.getWindow();
          if (win && win.requestIdleCallback) {
            win.requestIdleCallback(() => this.safeKeys.load(), { timeout: 2000 });
          } else {
            CliqzUtils.setTimeout(this.safeKeys.load.bind(this.safeKeys), 2000);
          }
          pm.register(this._hourlyPruneAndSend.bind(this), 60 * 60 * 1000);
          return Promise.resolve();
        }

        destroy() {}

        get _safeKeysLastSent() {
          let lastSent = getValue('safeKeysLastSent');
          if (!lastSent) {
            lastSent = getTime$1();
            this._safeKeysLastSent = lastSent;
          }
          return lastSent;
        }

        set _safeKeysLastSent(value) {
          setValue('safeKeysLastSent', value);
        }

        _hourlyPruneAndSend() {
          // every hour, prune and send safekeys
          var now = getTime$1();
          this._pruneSafeKeys();

          if (this._safeKeysLastSent < now) {
            this._sendSafeKeys();
            this._safeKeysLastSent = now;
          }
        }

        isSafeKey(domain, key) {
          return domain in this.safeKeys.value && key in this.safeKeys.value[domain];
        }
        addSafeKey(domain, key, valueCount) {
          let today = dateString(newUTCDate());
          if (!(domain in this.safeKeys.value)) {
            this.safeKeys.value[domain] = {};
          }
          this.safeKeys.value[domain][key] = [today, 'l', valueCount];
          this.safeKeys.setDirty();
        }

        /** Annotate safekey entries with count of tokens seen, from requestKeyValue data.
         *  This will add data on how many values were seen for each key by individual users.
         */
        annotateSafeKeys(requestKeyValue) {
          for (let domain in this.safeKeys.value) {
            for (let key in this.safeKeys.value[domain]) {
              let tuple = this.safeKeys.value[domain][key];
              // check if we have key-value data for this domain, key pair
              if (requestKeyValue[domain] && requestKeyValue[domain][key]) {
                // remote and old safekeys may be in old pair format
                if (tuple.length === 2) {
                  tuple.push(0);
                }

                let valueCount = Object.keys(requestKeyValue[domain][key]).length;
                tuple[2] = Math.max(tuple[2], valueCount);
              }
            }
          }
          this.safeKeys.setDirty();
          this.safeKeys.save();
        }

        _pruneSafeKeys() {
          var day = newUTCDate();
          day.setDate(day.getDate() - safeKeyExpire);
          var dayCutoff = dateString(day);
          for (var s in this.safeKeys.value) {
            for (var key in this.safeKeys.value[s]) {
              if (this.safeKeys.value[s][key][0] < dayCutoff) {
                delete this.safeKeys.value[s][key];
              }
            }
            if (Object.keys(this.safeKeys.value[s]).length === 0) {
              delete this.safeKeys.value[s];
            }
          }
          this.safeKeys.setDirty();
          this.safeKeys.save();
        }

        _sendSafeKeys() {
          // check if we should send telemetry
          if (this.config.telemetryMode === TELEMETRY.DISABLED) {
            return;
          }
          // get only keys from local key
          var hour = getTime$1(),
              day = hour.substring(0, 8);
          var dts = {},
              local = {},
              localE = 0,
              s,
              k;
          var safeKey = this.safeKeys.value;
          for (s in safeKey) {
            for (k in safeKey[s]) {
              if (safeKey[s][k][1] === 'l') {
                if (!local[s]) {
                  local[s] = {};
                  localE++;
                }
                local[s] = safeKey[s][k];
                if (safeKey[s][k][0] === day) {
                  if (!dts[s]) {
                    dts[s] = {};
                  }
                  dts[s][k] = safeKey[s][k][0];
                }
              }
            }
          }
          if (Object.keys(dts).length > 0) {
            var payl = generateAttrackPayload(dts, hour, this.getVersion());
            telemetry$1.telemetry({ 'type': telemetry$1.msgType, 'action': 'attrack.safekey', 'payload': payl });
          }
        }
      }

      const updateExpire = 48;

      class QSWhitelist extends QsWhitelistBase {

        constructor(config$$1) {
          super(config$$1);
          this.safeTokens = new LazyPersistentObject('tokenExtWhitelist');
          this.trackerDomains = new LazyPersistentObject('trackerDomains');
          this.unsafeKeys = new LazyPersistentObject('unsafeKey');
          this.lastUpdate = ['0', '0', '0', '0'];

          this.TOKEN_WHITELIST_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/whitelist_tokens.json`;
          this.TRACKER_DM_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/tracker_domains.json`;
          this.SAFE_KEY_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/domain_safe_key.json`;
          this.UNSAFE_KEY_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/domain_unsafe_key.json`;
        }

        init() {

          try {
            this.lastUpdate = JSON.parse(getValue('lastUpdate'));
            if (this.lastUpdate.length !== 4) {
              throw 'invalid lastUpdate value';
            }
          } catch (e) {
            this.lastUpdate = ['0', '0', '0', '0'];
          }

          // list update events
          this.onConfigUpdate = config$$1 => {
            var currentSafeKey = getValue('safeKeyExtVersion', ''),
                currentToken = getValue('tokenWhitelistVersion', ''),
                currentUnsafeKey = getValue('unsafeKeyExtVersion', ''),
                currentTracker = getValue('trackerDomainsversion', '');
            // check safekey
            CliqzUtils.log('Safe keys: ' + config$$1.safekey_version + ' vs ' + currentSafeKey, 'attrack');
            if (config$$1.safekey_version && currentSafeKey !== config$$1.safekey_version) {
              this._loadRemoteSafeKey(config$$1.force_clean === true);
            }
            CliqzUtils.log('Token whitelist: ' + config$$1.whitelist_token_version + ' vs ' + currentToken, 'attrack');
            if (config$$1.token_whitelist_version && currentToken !== config$$1.whitelist_token_version) {
              this._loadRemoteTokenWhitelist();
            }
            CliqzUtils.log('Tracker Domain: ' + config$$1.tracker_domain_version + ' vs ' + currentTracker, 'attrack');
            if (config$$1.tracker_domain_version && currentTracker !== config$$1.tracker_domain_version) {
              this._loadRemoteTrackerDomainList();
            }
            CliqzUtils.log('Unsafe keys: ' + config$$1.unsafekey_version + ' vs ' + currentUnsafeKey, 'attrack');
            if (config$$1.token_whitelist_version && currentToken !== config$$1.token_whitelist_version) {
              this._loadRemoteUnsafeKey();
            }
          };

          return Promise.all([super.init(), this.safeTokens.load(), this.unsafeKeys.load(), this.trackerDomains.load()]).then(() => {
            this._configEventListener = CliqzEvents.subscribe('attrack:updated_config', this.onConfigUpdate);
          });
        }

        destroy() {
          super.destroy();
          if (this._configEventListener) {
            this._configEventListener.unsubscribe();
            this._configEventListener = null;
          }
        }

        isUpToDate() {
          var delay = updateExpire,
              hour = newUTCDate();
          hour.setHours(hour.getHours() - delay);
          var hourCutoff = hourString(hour);
          return this.lastUpdate.every(t => {
            return t > hourCutoff;
          });
        }

        isReady() {
          // just check they're not null
          return this.safeTokens.value && this.safeKeys.value && this.unsafeKeys.value && this.trackerDomains.value;
        }

        isSafeKey(domain, key) {
          if (!this.isReady()) {
            return true;
          }
          return !this.isUnsafeKey(domain, key) && domain in this.safeKeys.value && key in this.safeKeys.value[domain];
        }

        isUnsafeKey(domain, key) {
          if (!this.isReady()) {
            return false;
          }
          return this.isTrackerDomain(domain) && domain in this.unsafeKeys.value && key in this.unsafeKeys.value[domain];
        }

        addSafeKey(domain, key, valueCount) {
          if (!this.isReady()) {
            return;
          }
          if (this.isUnsafeKey(domain, key)) {
            return; // keys in the unsafekey list should not be added to safekey list
          }
          let today = dateString(newUTCDate());
          if (!(domain in this.safeKeys.value)) {
            this.safeKeys.value[domain] = {};
          }
          this.safeKeys.value[domain][key] = [today, 'l', valueCount];
          this.safeKeys.setDirty();
        }

        isTrackerDomain(domain) {
          if (!this.isReady()) {
            return false;
          }
          return domain in this.trackerDomains.value;
        }

        isSafeToken(domain, token) {
          if (!this.isReady()) {
            return true;
          }
          return this.isTrackerDomain(domain) && token in this.safeTokens.value;
        }

        addSafeToken(domain, token) {
          if (!this.isReady()) {
            return;
          }
          this.trackerDomains.value[domain] = true;
          if (token && token !== '') {
            this.safeTokens.value[token] = true;
          }
        }

        addUnsafeKey(domain, key) {
          if (!this.isReady()) {
            return;
          }
          if (!(domain in this.unsafeKeys.value)) {
            this.unsafeKeys.value[domain] = {};
          }
          this.unsafeKeys.value[domain][key] = true;
        }

        getVersion() {
          return {
            whitelist: getValue('tokenWhitelistVersion', ''),
            safeKey: getValue('safeKeyExtVersion', ''),
            unsafeKey: getValue('unsafeKeyExtVersion', ''),
            trackerDomains: getValue('trackerDomainsVersion', '')
          };
        }

        _loadRemoteTokenWhitelist() {
          var today = getTime$1().substring(0, 10);
          CliqzUtils.httpGet(this.TOKEN_WHITELIST_URL + '?' + today, function (req) {
            var rList = JSON.parse(req.response),
                rListMd5 = cachedMD5(req.response);
            this.safeTokens.setValue(rList);
            setValue('tokenWhitelistVersion', rListMd5);
            this.lastUpdate[1] = getTime$1();
            setValue('lastUpdate', JSON.stringify(this.lastUpdate));
            CliqzEvents.pub('attrack:token_whitelist_updated', rListMd5);
          }.bind(this), function () {}, 100000);
        }

        _loadRemoteTrackerDomainList() {
          var today = getTime$1().substring(0, 10);
          CliqzUtils.httpGet(this.TRACKER_DM_URL + '?' + today, function (req) {
            var rList = JSON.parse(req.response),
                rListMd5 = cachedMD5(req.response);
            this.trackerDomains.setValue(rList);
            setValue('trackerDomainsversion', rListMd5);
            this.lastUpdate[3] = getTime$1();
            setValue('lastUpdate', JSON.stringify(this.lastUpdate));
          }.bind(this), function () {}, 100000);
        }

        _loadRemoteSafeKey(forceClean) {
          var today = getTime$1().substring(0, 10);
          if (forceClean) {
            this.safeKeys.clear();
          }
          CliqzUtils.httpGet(this.SAFE_KEY_URL + '?' + today, function (req) {
            var safeKey = JSON.parse(req.response),
                s,
                k,
                safeKeyExtVersion = cachedMD5(req.response);
            for (s in safeKey) {
              for (k in safeKey[s]) {
                // r for remote keys
                safeKey[s][k] = [safeKey[s][k], 'r'];
              }
            }
            for (s in safeKey) {
              if (!(s in this.safeKeys.value)) {
                this.safeKeys.value[s] = safeKey[s];
              } else {
                for (var key in safeKey[s]) {
                  if (this.safeKeys.value[s][key] == null || this.safeKeys.value[s][key][0] < safeKey[s][key][0]) {
                    this.safeKeys.value[s][key] = safeKey[s][key];
                  }
                }
              }
            }
            this._pruneSafeKeys();
            this.lastUpdate[0] = getTime$1();
            setValue('lastUpdate', JSON.stringify(this.lastUpdate));
            this.safeKeys.setDirty();
            this.safeKeys.save();
            setValue('safeKeyExtVersion', safeKeyExtVersion);
            CliqzEvents.pub('attrack:safekeys_updated', safeKeyExtVersion, forceClean);
          }.bind(this), function () {
            // on error
          }, 60000);
        }

        _loadRemoteUnsafeKey() {
          let today = getTime$1().substring(0, 10);
          CliqzUtils.log(this.UNSAFE_KEY_URL);
          CliqzUtils.httpGet(this.UNSAFE_KEY_URL + '?' + today, function (req) {
            let unsafeKeys = JSON.parse(req.response),
                unsafeKeyExtVersion = cachedMD5(req.response);
            this.unsafeKeys.setValue(unsafeKeys);
            this.lastUpdate[2] = getTime$1();
            setValue('lastUpdate', JSON.stringify(this.lastUpdate));
            setValue('unsafeKeyExtVesion', unsafeKeyExtVersion);
            this.unsafeKeys.setDirty();
            this.unsafeKeys.save();
          }.bind(this), function () {}, 100000);
        }

      }

      /** Set like class whose members are removed after a specific amount of time
      */
      class TempSet {

        constructor() {
          this._items = new Set();
          this._timeouts = new Set();
        }

        contains(item) {
          return this._items.has(item);
        }

        has(item) {
          return this.contains(item);
        }

        add(item, ttl) {
          this._items.add(item);
          var timeout = CliqzUtils.setTimeout(function () {
            this.delete(item);
            this._timeouts.delete(timeout);
          }.bind(this), ttl || 0);
          this._timeouts.add(timeout);
        }

        delete(item) {
          this._items.delete(item);
        }

        clear() {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this._timeouts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              let t = _step.value;

              CliqzUtils.clearTimeout(t);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this._timeouts.clear();
          this._items.clear();
        }
      }

      /* global PouchDB */
      let windowAPI = {
        IDBKeyRange: null
      };

      // https://loune.net/2015/02/pouchdb-for-firefox-addon-sdk/
      const global$1 = {
        indexedDB,
        get IDBKeyRange() {
          if (typeof IDBKeyRange !== 'undefined') {
            return IDBKeyRange;
          } else {
            // in FF 57 IDBKeyRange is undefined in the bootstrapped context
            // we should use a getter as the window() might not be initialized
            // early in the browser startup process
            return windowAPI.IDBKeyRange;
          }
        },
        btoa, //global anyway, exporting to be sure
        atob, //global anyway, exporting to be sure
        escape, //global anyway, exporting to be sure
        XMLHttpRequest,
        clearTimeout: CLIQZEnvironment.clearTimeout,
        setTimeout: CLIQZEnvironment.setTimeout,
        console: {
          log: console.log.bind(console),
          error: console.error.bind(console),
          warn: (console.warn || console.error).bind(console),
          info: (console.info || console.log).bind(console)
        },
        global: {
          // placeholder for PouchDB object
        }
      };

      let pouchPromise;
      const PROXY_WHITELIST = ['put', 'post', 'get', 'remove', 'bulkDocs', 'allDocs', 'putAttachment', 'getAttachment', 'removeAttachment', 'createIndex', 'find', 'explain', 'getIndexes', 'deleteIndex', 'findIndexes', 'query', 'viewCleanup', 'info', 'compact', 'revsDiff', 'bulkGet', 'close', 'destroy'];

      function Database() {
        for (var _len = arguments.length, props = Array(_len), _key = 0; _key < _len; _key++) {
          props[_key] = arguments[_key];
        }

        if (!pouchPromise) {
          pouchPromise = getWindowAPIAsync().then(wAPI => {
            windowAPI = wAPI;

            const pouchUrl = 'chrome://cliqz/content/vendor/pouchdb.js';
            Services.scriptloader.loadSubScriptWithOptions(pouchUrl, {
              target: global$1,
              ignoreCache: true
            });

            return global$1.global.PouchDB;
          });
        }

        let pouch;
        const pouchInstance = pouchPromise.then(Pouch => {
          pouch = new Pouch(...props);
        });

        const pouchProxy = new Proxy({}, {
          get(target, name) {
            if (PROXY_WHITELIST.indexOf(name) !== -1) {
              return function () {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                return pouchInstance.then(() => pouch[name](...args));
              };
            }
            return (pouch || target)[name];
          }
        });

        return pouchProxy;
      }

      const dbs = new Map();

      function DB(name) {
        const info = dbs.get(name) || {
          name,
          createdAt: Date.now(),
          instances: 0
        };
        info.instances += 1;
        dbs.set(name, info);

        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }

        return Database(name, ...rest);
      }

      /*
       * Prints report on currently used databases
       */

      function printReport(r) {
        console$1.log('Db report', JSON.stringify(r, null, 2));
      }

      /*
       * Sets interval that will generate database report every given interval.
       *
       * Report will be printed in browser console along with information on the
       * changes from last interval and from the first report.
       *
       * This helps to identify databases that grow too fast.
       *
       */

      /**
       * Remove any old database entries which are no longer needed
       */
      var cleanLegacyDb = function () {
        deletePersistantObject('requestKeyValue');
        deletePersistantObject('checkedToken');
        deletePersistantObject('blockedToken');
        deletePersistantObject('loadedPage');
        if (CliqzUtils.getPref('attrack.tokenDbState', 0) === 0) {
          const db = new DB('cliqz-attrack-tokens', { auto_compaction: true });
          db.destroy();
          CliqzUtils.setPref('attrack.tokenDbState', 1);
        }
      };

      function migrateTokenDomain(tokenDomain) {
        const dbName = 'tokenDomain';
        const oldTokenDomain = new LazyPersistentObject(dbName);
        return oldTokenDomain.load().then(tokens => {
          // tokens format:
          // {token: {firstparty: date}}
          const tokenArrayTuples = Object.keys(tokens).map(token =>
          // get array of (token, firstParty, day) tuples for this tuple
          Object.keys(tokens[token]).map(firstParty => [token, firstParty, tokens[token][firstParty]]));
          // flatten array of arrays of tuples into array of tuples
          const tokenTuples = [].concat(...tokenArrayTuples);
          console$1.log('migrate', tokenTuples.length, 'tokenDomain tuples');
          // insert all the tuples into the new token db
          return Promise.all(tokenTuples.map(tup => tokenDomain.addTokenOnFirstParty(...tup))).then(() => {
            deletePersistantObject(dbName);
          });
        });
      }

      function BloomFilter$2(a, k) {
        // a the array, k the number of hash function
        var m = a.length * 32,

        // 32 bits for each element in a
        n = a.length,
            i = -1;
        this.m = m = n * 32;
        this.k = k;
        // choose data type
        var kbytes = 1 << Math.ceil(Math.log(Math.ceil(Math.log(m) / Math.LN2 / 8)) / Math.LN2),
            array = kbytes === 1 ? Uint8Array : kbytes === 2 ? Uint16Array : Uint32Array,
            kbuffer = new ArrayBuffer(kbytes * k),
            buckets = this.buckets = new Int32Array(n);
        while (++i < n) {
          buckets[i] = a[i]; // put the elements into their bucket
        }
        this._locations = new array(kbuffer); // stores location for each hash function
      }

      BloomFilter$2.prototype.locations = function (a, b) {
        // we use 2 hash values to generate k hash values
        var k = this.k,
            m = this.m,
            r = this._locations;
        a = parseInt(a, 16);
        b = parseInt(b, 16);
        var x = a % m;

        for (var i = 0; i < k; ++i) {
          r[i] = x < 0 ? x + m : x;
          x = (x + b) % m;
        }
        return r;
      };

      BloomFilter$2.prototype.test = function (a, b) {
        // since MD5 will be calculated before hand,
        // we allow using hash value as input to
        var l = this.locations(a, b),
            k = this.k,
            buckets = this.buckets;
        for (var i = 0; i < k; ++i) {
          var bk = l[i];
          if ((buckets[Math.floor(bk / 32)] & 1 << bk % 32) === 0) {
            return false;
          }
        }
        return true;
      };

      BloomFilter$2.prototype.testSingle = function (x) {
        var md5Hex = cachedMD5(x);
        var a = md5Hex.substring(0, 8),
            b = md5Hex.substring(8, 16);
        return this.test(a, b);
      };

      BloomFilter$2.prototype.add = function (a, b) {
        // Maybe used to add local safeKey to bloom filter
        var l = this.locations(a, b),
            k = this.k,
            buckets = this.buckets;
        for (var i = 0; i < k; ++i) {
          buckets[Math.floor(l[i] / 32)] |= 1 << l[i] % 32;
        }
      };

      BloomFilter$2.prototype.addSingle = function (x) {
        var md5Hex = cachedMD5(x);
        var a = md5Hex.substring(0, 8),
            b = md5Hex.substring(8, 16);
        return this.add(a, b);
      };

      BloomFilter$2.prototype.update = function (a) {
        // update the bloom filter, used in minor revison for every 10 min
        var m = a.length * 32,

        // 32 bit for each element
        n = a.length,
            i = -1;
        m = n * 32;
        if (this.m !== m) {
          throw 'Bloom filter can only be updated with same length';
        }
        while (++i < n) {
          this.buckets[i] |= a[i];
        }
      };

      const BLOOMFILTER_BASE_URL = `${config.settings.CDN_BASEURL}/anti-tracking/bloom_filter/`;
      const BLOOMFILTER_CONFIG = `${config.settings.CDN_BASEURL}/anti-tracking/bloom_filter/config`;
      const BLOOMFILTER_VERSION_PREF = 'antitracking.bloomfilter.version';
      const UPDATE_EXPIRY_HOURS = 48;

      function getDayHypenated(day) {
        const dt = day || getTime$1();
        return `${dt.substr(0, 4)}-${dt.substr(4, 2)}-${dt.substr(6, 2)}`;
      }

      class AttrackBloomFilter extends QsWhitelistBase {

        constructor(config$$1) {
          let configURL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BLOOMFILTER_CONFIG;
          let baseURL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BLOOMFILTER_BASE_URL;

          super(config$$1);
          this.bloomFilter = null;
          this.version = {
            major: '0000-00-00',
            minor: 0
          };
          this.configURL = configURL;
          this.baseURL = baseURL;
          this._config = new Resource(['antitracking', 'bloom_config.json'], {
            remoteURL: configURL
          });
        }

        init() {
          // check every 60min
          this._updateTask = pm.register(this.update.bind(this), 60 * 60 * 1000);
          const initPromises = [];
          initPromises.push(super.init());
          // if we already have a bloomFilter, leave the update to this.update
          if (!this.bloomFilter) {
            // load from file
            const bfLoading = this.loadFromFile();
            initPromises.push(bfLoading);
            // if the cached file is out of date, or non existed, trigger an update
            bfLoading.then(() => {
              if (!this.isUpToDate()) {
                this.update();
              }
            });
          }

          return Promise.all(initPromises);
        }

        destroy() {
          super.destroy();
          if (this._updateTask) {
            pm.deregister(this._updateTask);
          }
        }

        loadFromFile() {
          const bloomFile = new Resource(['antitracking', 'bloom_filter.json'], {
            remoteOnly: true // ignore chrome url
          });
          return bloomFile.load().then(bf => ({
            bf,
            major: CliqzUtils.getPref(BLOOMFILTER_VERSION_PREF, '0000-00-00'),
            minor: 0
          })).then(_ref => {
            let bf = _ref.bf,
                major = _ref.major,
                minor = _ref.minor;
            return this.updateFilter(bf, major, minor);
          }).catch(() => console$1.log('bloom filter', 'load from file failed'));
        }

        update() {
          const dt = getDayHypenated();
          if (this.version.major < dt) {
            return this._getFilterForDay(dt) // fast update (guessing the url)
            .catch(() => this._config.updateFromRemote() // fast failed, pull the config too
            .then(conf => this._getFilterForDay(conf.major)))
            // process the fetched file, or suppress the error if we weren't able to fetch
            .then(_ref2 => {
              let bf = _ref2.bf,
                  major = _ref2.major,
                  minor = _ref2.minor;
              return this.updateFilter(bf, major, minor);
            }).catch(err => console$1.log('bloom filter', 'update failed', err));
          }
          return Promise.resolve();
        }

        _getFilterForDay(day) {
          const minor = 0;
          const bloomFile = new Resource(['antitracking', 'bloom_filter.json'], {
            remoteOnly: true,
            remoteURL: `${this.baseURL}${day}/${minor}.gz`
          });
          return bloomFile.updateFromRemote().then(bf => ({
            bf,
            major: day,
            minor
          }));
        }

        updateFilter(bf, major, minor) {
          if (minor !== 0) {
            this.bloomFilter.update(bf.bkt);
          } else {
            this.bloomFilter = new BloomFilter$2(bf.bkt, bf.k);
          }
          this.version = {
            major,
            minor
          };
          CliqzUtils.setPref(BLOOMFILTER_VERSION_PREF, this.version.major);
          return Promise.resolve();
        }

        isUpToDate() {
          const delay = UPDATE_EXPIRY_HOURS;
          const hour = newUTCDate();
          hour.setHours(hour.getHours() - delay);
          const cutoff = hour.toISOString().substring(0, 10);
          return this.version.major > cutoff;
        }

        isReady() {
          return this.bloomFilter !== null;
        }

        isTrackerDomain(domain) {
          if (!this.isReady()) {
            return false;
          }
          return this.bloomFilter.testSingle('d' + domain);
        }

        isSafeKey(domain, key) {
          if (!this.isReady()) {
            return true;
          }
          return !this.isUnsafeKey(domain, key) && (this.bloomFilter.testSingle('k' + domain + key) || super.isSafeKey(domain, key));
        }

        isSafeToken(domain, token) {
          if (!this.isReady()) {
            return true;
          }
          return this.bloomFilter.testSingle('t' + domain + token);
        }

        isUnsafeKey(domain, token) {
          if (!this.isReady()) {
            return false;
          }
          return this.bloomFilter.testSingle('u' + domain + token);
        }

        addDomain(domain) {
          if (!this.isReady()) {
            return;
          }
          this.bloomFilter.addSingle('d' + domain);
        }

        addSafeKey(domain, key, valueCount) {
          if (!this.isReady()) {
            return;
          }
          if (this.isUnsafeKey(domain, key)) {
            return;
          }
          this.bloomFilter.addSingle('k' + domain + key);
          super.addSafeKey(domain, key, valueCount);
        }

        addUnsafeKey(domain, token) {
          if (!this.isReady()) {
            return;
          }
          this.bloomFilter.addSingle('u' + domain + token);
        }

        addSafeToken(domain, token) {
          if (!this.isReady()) {
            return;
          }
          if (token === '') {
            this.addDomain(domain);
          } else {
            this.bloomFilter.addSingle('t' + domain + token);
          }
        }

        getVersion() {
          return {
            bloomFilterversion: this.bloomFilter ? this.bloomFilter.version : null
          };
        }

      }

      class HashProb {
        constructor() {
          this.probHashLogM = null;
          this.probHashThreshold = null;
          this.probHashChars = {};
          'abcdefghijklmnopqrstuvwxyz1234567890.- '.split('').forEach((e, idx) => {
            this.probHashChars[e] = idx;
          });

          this.probLoader = new ResourceLoader(['antitracking', 'prob.json'], {
            remoteURL: `${config.settings.CDN_BASEURL}/anti-tracking/prob.json`,
            cron: 24 * 60 * 60 * 1000 // daily
          });
        }

        _update(data) {
          this.probHashLogM = data.logM;
          this.probHashThreshold = data.thresh;
        }

        init() {
          this.probLoader.onUpdate(this._update.bind(this));
          return this.probLoader.load().then(this._update.bind(this));
        }

        unload() {
          this.probLoader.stop();
        }

        isHashProb(str) {
          if (!this.probHashLogM || !this.probHashThreshold) {
            return 0;
          }
          let logProb = 0.0;
          let transC = 0;
          str = str.toLowerCase().replace(/[^a-z0-9\.\- ]/g, '');
          for (var i = 0; i < str.length - 1; i++) {
            const pos1 = this.probHashChars[str[i]];
            const pos2 = this.probHashChars[str[i + 1]];

            logProb += this.probHashLogM[pos1][pos2];
            transC += 1;
          }
          if (transC > 0) {
            return Math.exp(logProb / transC);
          }
          return Math.exp(logProb);
        }

        isHash(str) {
          const p = this.isHashProb(str);
          return p < this.probHashThreshold;
        }
      }

      const numberThreshold = 0.8;

      function isMostlyNumeric(str) {
        let numbers = 0;
        const length = str.length;
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (code >= 48 && code < 58) {
            numbers += 1;
          }
        }
        return numbers / length > numberThreshold;
      }

      /**
      TrackerTXT: caching rules for tracker.txt
       */

      var trackerTxtActions = new Set(['placeholder', 'block', 'empty', 'replace']);

      const DEFAULT_ACTION_PREF = 'attrackDefaultAction';

      var defaultTrackerTxtRule = null;

      function getDefaultTrackerTxtRule() {
        if (defaultTrackerTxtRule === null) {
          defaultTrackerTxtRule = CliqzUtils.getPref(DEFAULT_ACTION_PREF, 'same');
        }
        return defaultTrackerTxtRule;
      }

      function updateDefaultTrackerTxtRule() {
        let ruleFromPref = CliqzUtils.getPref('attrackDefaultAction', 'same');
        // default rule may be either a tracking.txt action, or 'same'
        if (trackerTxtActions.has(ruleFromPref) || ruleFromPref === 'same') {
          defaultTrackerTxtRule = ruleFromPref;
        } else {
          // bad pref value, reset it
          CliqzUtils.clearPref('attrackDefaultAction');
        }
      }

      var trackerRuleParser = function trackerRuleParser(str, rules) {
        /* Tracker format:
         one rule per line: "R tracker action"
         */
        str.split('\n').map(function (x) {
          return x.trim();
        }).filter(function (x) {
          return x[0] == 'R';
        }).forEach(function (element, index, array) {
          var siteRule = element.split(/\s+/).map(function (x) {
            return x.trim().toLowerCase();
          });
          if (siteRule.length == 3 && trackerTxtActions.has(siteRule[2])) {
            rules.push({
              site: siteRule[1],
              rule: siteRule[2]
            });
          }
        });
      };

      var TrackerTXT = function TrackerTXT(baseurl) {
        this.baseurl = baseurl;
        this.rules = [];
        this.status = null;
        this.last_update = null;
      };

      TrackerTXT._cache = new FixedSizeCache(function (baseurl) {
        return new TrackerTXT(baseurl);
      }, 1000);

      TrackerTXT.get = function (url_parts) {
        var baseurl = url_parts.protocol + '://' + url_parts.hostname + (url_parts.port !== 80 ? ':' + url_parts.port : '');
        return TrackerTXT._cache.get(baseurl);
      };

      TrackerTXT.prototype = {
        update: function update() {
          if (this.status == 'updating' || this.last_update == getTime$1()) return; // try max once per hour
          this.status = 'updating';
          var self = this;
          CliqzUtils.httpGet(self.baseurl + '/tracking.txt', function success(req) {
            if (req.responseText.length < 4 * 1024) {
              self.rules = [];
              trackerRuleParser(req.responseText, self.rules);
            }
            self.status = 'updated';
            self.last_update = getTime$1();
          }, function error() {
            self.status = 'error';
            self.last_update = getTime$1();
          });
        },
        getRule: function getRule(tp) {
          for (let i = 0; i < this.rules.length; i++) {
            let rule = this.rules[i];
            if (tp.endsWith(rule.site)) {
              return rule.rule;
            }
          }
          return getDefaultTrackerTxtRule();
        }
      };

      Components.utils.import("resource://gre/modules/AddonManager.jsm");

      const genericPrefs = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefBranch);

      const similarAddonNames = new Set(["Adblock Plus", "AdBlock", "Ghostery", "Lightbeam", "Disconnect", "BetterPrivacy", "NoScript", "Privacy Badger", "uBlock Origin"]);

      /**
       * Gets an indicator of the privacy addons installed on this profile.
       * @return {Promise.<String,Boolean>} if just one of the shortlisted addons
       * is installed, returns its name. if two or more are installed, returns true
       * otherwise, returns false.
       */
      function checkInstalledPrivacyAddons() {
        return auditInstalledAddons().then(addons => {
          const privacyAddons = addons.filter(a => similarAddonNames.has(a.name));
          if (privacyAddons.length === 1) {
            return privacyAddons[0].name;
          } else {
            return privacyAddons.length > 1;
          }
        });
      }

      /**
       * Get a list of installed and active extensions for this browser.
       * @return {Promise.<Array>} Promise resolves to an array of objects,
       * each with the id and name of an extension
       */
      function auditInstalledAddons() {
        return new Promise(resolve => {
          AddonManager.getAddonsByTypes(['extension'], addons => resolve(addons));
        }).then(addons => {
          return addons.filter(addon => addon.isActive).map(addon => ({
            id: addon.id,
            name: addon.name
          }));
        });
      }

      class BlockRules {

        constructor(config) {
          this.config = config;
        }

        get qsBlockRule() {
          return this.config.blockRules || [];
        }

        shouldBlock(host, sourceHost) {
          for (var i = 0; i < this.qsBlockRule.length; i++) {
            var sRule = this.qsBlockRule[i][0],
                uRule = this.qsBlockRule[i][1];
            if (sourceHost.endsWith(sRule) && host.endsWith(uRule)) {
              return true;
            }
          }
          return false;
        }

        applyBlockRules(state, response) {
          if (this.shouldBlock(state.urlParts.hostname, state.sourceUrlParts.hostname)) {
            state.incrementStat('req_rule_aborted');
            response.cancel = true;
            return false;
          }
          return true;
        }
      }

      class CookieContext {
        constructor(config, pageMeta, qsWhitelist) {
          this.config = config;
          this.pageMeta = pageMeta;
          this.qsWhitelist = qsWhitelist;
          this.visitCache = {};
          this.contextFromEvent = null;
          this.timeAfterLink = 5 * 1000;
          this.timeCleaningCache = 180 * 1000;
          this.timeActive = 20 * 1000;
          this.trustedThirdParties = new Map();
          // how long to keep trust entries which have not been triggered
          this.UNUSED_TRUST_TIMEOUT = 120000; // 2 minutes
          // how long to keep trust entries which have been used
          this.USED_TRUST_TIMEOUT = 900000; // 15 minutes
        }

        init() {
          this._pmclean = pm.register(this.cleanCookieCache.bind(this), 2 * 60 * 1000);
        }

        unload() {
          pm.deregister(this._pmclean);
        }

        cleanCookieCache(currTime) {
          // visit cache
          cleanTimestampCache(this.visitCache, this.timeCleaningCache, currTime);
          // trusted domain pairs
          const now = Date.now();
          this.trustedThirdParties.forEach((counter, key) => {
            const timeoutAt = counter.ts + (counter.c > 0 ? this.USED_TRUST_TIMEOUT : this.UNUSED_TRUST_TIMEOUT);
            if (now > timeoutAt) {
              this.trustedThirdParties.delete(key);
            }
          });
        }

        _addTrustLink(fromFirstParty, toThirdParty) {
          if (sameGeneralDomain(fromFirstParty, toThirdParty)) {
            return;
          }
          // don't trust trackers
          if (this.qsWhitelist.isTrackerDomain(cachedMD5(getGeneralDomain(toThirdParty)).substring(0, 16))) {
            return;
          }
          const key = `${fromFirstParty}:${toThirdParty}`;
          if (!this.trustedThirdParties.has(key)) {
            this.trustedThirdParties.set(key, { c: 0 });
          }
          this.trustedThirdParties.get(key).ts = Date.now();
        }

        assignCookieTrust(state) {
          if (state.isFullPage() && state.getReferrer()) {
            const referrer = URLInfo.get(state.getReferrer());
            const trustedHost = state.urlParts.hostname;
            const trustedOn = referrer.hostname;

            // this domain is now trusted by the referrer
            this._addTrustLink(trustedOn, trustedHost);

            // check redirect chain for this page to see if we should back-propagate the trust chain
            if (this.pageMeta._active[state.tabId]) {
              this.pageMeta._active[state.tabId].redirects.forEach(domain => {
                this._addTrustLink(domain, trustedHost);
              });
            }
          }
          return true;
        }

        checkCookieTrust(state) {
          const stage = state.responseStatus !== undefined ? 'set_cookie' : 'cookie';
          const sourceHost = state.sourceUrlParts.hostname;
          const requestHost = state.urlParts.hostname;
          const key = `${sourceHost}:${requestHost}`;
          if (this.config.cookieTrustReferers && this.trustedThirdParties.has(key)) {
            const trustCounter = this.trustedThirdParties.get(key);
            trustCounter.c += 1;
            trustCounter.ts = Date.now();

            state.incrementStat(`${stage}_allow_trust`);
            return false;
          }
          return true;
        }

        checkVisitCache(state) {
          // check if the response has been received yet
          const stage = state.responseStatus !== undefined ? 'set_cookie' : 'cookie';
          const tabId = state.tabId;
          const diff = Date.now() - (this.visitCache[`${tabId}:${state.hostGD}`] || 0);
          if (diff < this.timeActive && this.visitCache[`${tabId}:${state.sourceGD}`]) {
            state.incrementStat(`${stage}_allow_visitcache`);
            return false;
          }
          return true;
        }

        checkContextFromEvent(state) {
          if (this.contextFromEvent) {
            const stage = state.responseStatus !== undefined ? 'set_cookie' : 'cookie';
            const time = Date.now();
            const url = state.url;
            const tabId = state.tabId;
            const urlParts = state.urlParts;
            const sourceGD = state.sourceUrlParts.generalDomain;
            const hostGD = state.urlParts.generalDomain;

            var diff = time - (this.contextFromEvent.ts || 0);
            if (diff < this.timeAfterLink) {

              if (hostGD === this.contextFromEvent.cGD && sourceGD === this.contextFromEvent.pageGD) {
                this.visitCache[`${tabId}:${hostGD}`] = time;
                state.incrementStat(`${stage}_allow_userinit_same_context_gd`);
                return false;
              }
              var pu = url.split(/[?&;]/)[0];
              if (this.contextFromEvent.html.indexOf(pu) != -1) {
                // the url is in pu
                if (urlParts && urlParts.hostname && urlParts.hostname != '') {
                  this.visitCache[`${tabId}:${hostGD}`] = time;
                  state.incrementStat(`${stage}_allow_userinit_same_gd_link`);
                  return false;
                }
              }
              // last try, guess the possible domain from script src;
              if (!this.contextFromEvent.cGD && this.contextFromEvent.possibleCGD.has(hostGD)) {
                this.visitCache[`${tabId}:${hostGD}`] = time;
                state.incrementStat(`${stage}_allow_userinit_same_script_gd`);
                return false;
              }
            }
          }
          return true;
        }

        extractPossilbeContextGD(links) {
          return new Set(links.map(link => URLInfo.get(link).generalDomain));
        }

        setContextFromEvent(ev, contextHTML, herf, sender) {
          let cGD = null;
          let pageGD = null;
          let html = contextHTML || '';

          try {
            pageGD = URLInfo.get(sender.tab.url).generalDomain;
            cGD = URLInfo.get(ev.target.baseURI).generalDomain;
          } catch (ee) {}
          if (!pageGD || cGD === pageGD) {
            return;
          }
          // Try to guess the possible domain from scripts src
          const possibleCGD = this.extractPossilbeContextGD(ev.target.linksSrc);
          this.contextFromEvent = {
            html,
            ts: Date.now(),
            cGD,
            pageGD,
            possibleCGD
          };
        }
      }

      const DOM_CHECK_PERIOD = 1000;

      // from CliqzAttrack.getCookieValues
      function getCookieValues(c, url) {
        if (c === null) {
          return {};
        }
        var v = 0,
            cookies = {};
        if (c.match(/^\s*\$Version=(?:"1"|1);\s*(.*)/)) {
          c = RegExp.$1;
          v = 1;
        }
        if (v === 0) {
          c.split(/[,;]/).map(function (cookie) {
            var parts = cookie.split(/=/);
            if (parts.length > 1) parts[1] = parts.slice(1).join('=');
            var name = dURIC(parts[0].trimLeft()),
                value = parts.length > 1 ? dURIC(parts[1].trimRight()) : null;
            cookies[name] = value;
          });
        } else {
          c.match(/(?:^|\s+)([!#$%&'*+\-.0-9A-Z^`a-z|~]+)=([!#$%&'*+\-.0-9A-Z^`a-z|~]*|"(?:[\x20-\x7E\x80\xFF]|\\[\x00-\x7F])*")(?=\s*[,;]|$)/g).map(function ($0, $1) {
            var name = $0,
                value = $1.charAt(0) === '"' ? $1.substr(1, -1).replace(/\\(.)/g, "$1") : $1;
            cookies[name] = value;
          });
        }
        // return cookies;
        var cookieVal = {};
        for (var key in cookies) {
          if (url.indexOf(cookies[key]) == -1) {
            // cookies save as part of the url is allowed
            cookieVal[cookies[key]] = true;
          }
        }
        return cookieVal;
      }

      class DomChecker {

        constructor() {
          this.loadedTabs = {};
          this.linksRecorded = {}; // cache when we recorded links for each url
          this.linksFromDom = {};
          this.cookiesFromDom = {};
        }

        init() {
          this._pmTask = pm.register(function cleanCaches(currTime) {
            const cacheObj = this.linksRecorded;
            const timeout = 1000;
            const keys = Object.keys(cacheObj);
            keys.forEach(function (k) {
              if (currTime - cacheObj[k] || 0 > timeout) {
                delete cacheObj[k];
              }
            });
          }.bind(this), 2 * 60 * 1000);
        }

        unload() {
          pm.deregister(this._pmTask);
        }

        checkDomLinks(state) {
          this.recordLinksForURL(state.sourceUrl);

          // check if this url appears in the source's links
          const reflinks = this.linksFromDom[state.sourceUrl] || {};
          if (state.incrementStat && state.url in reflinks) {
            state.incrementStat('url_in_reflinks');
          }
          return true;
        }

        parseCookies(state) {
          const sourceUrl = state.sourceUrl;
          let cookievalue = {};
          // parse cookies from DOM
          if (this.cookiesFromDom[sourceUrl]) {
            cookievalue = getCookieValues(this.cookiesFromDom[sourceUrl], state.url);
          }
          // merge with cookies in the header of this request
          try {
            for (var c in getCookieValues(state.getRequestHeader('Cookie'), state.url)) {
              cookievalue[c] = true;
            }
          } catch (e) {}
          state.cookieValues = cookievalue;

          return true;
        }

        recordLinksForURL(url) {
          const self = this;
          if (this.loadedTabs[url]) {
            return;
          }
          const now = Date.now();
          const lastQuery = this.linksRecorded[url] || 0;
          if (now - lastQuery < DOM_CHECK_PERIOD) {
            return;
          }
          this.linksRecorded[url] = now;
          return Promise.all([core.actions.getCookie(url).then(cookie => {
            self.cookiesFromDom[url] = cookie;
          }), Promise.all([core.actions.queryHTML(url, 'a[href]', 'href'), core.actions.queryHTML(url, 'link[href]', 'href'), core.actions.queryHTML(url, 'script[src]', 'src').then(function (hrefs) {
            return hrefs.filter(href => href.indexOf('http') === 0);
          })]).then(function (reflinks) {
            var hrefSet = reflinks.reduce((hrefSet, hrefs) => {
              hrefs.forEach(href => hrefSet[href] = true);
              return hrefSet;
            }, {});

            self.linksFromDom[url] = hrefSet;
          })]).catch(() => {});
        }

        clearDomLinks() {
          for (var url in this.linksFromDom) {
            if (!isTabURL(url)) {
              delete this.linksFromDom[url];
              delete this.cookiesFromDom[url];
              delete this.loadedTabs[url];
            }
          }
        }
      }

      class PageLogger {

        constructor(tpEvents) {
          this.tpEvents = tpEvents;
        }

        logMainDocument(state) {
          if (state.isFullPage()) {
            this.tpEvents.onFullPage(state.urlParts, state.tabId, state.isPrivate);
            // if (CliqzAttrack.isTrackerTxtEnabled()) {
            //   TrackerTXT.get(url_parts).update();
            // }
            return false;
          }
          return true;
        }

        attachStatCounter(state) {
          const urlParts = state.urlParts;
          const request = this.tpEvents.get(state.url, urlParts, state.sourceUrl, state.sourceUrlParts, state.tabId);
          state.reqLog = request;
          const incrementStat = (statName, c) => {
            this.tpEvents.incrementStat(request, statName, c || 1);
          };
          state.incrementStat = incrementStat;
          state.getPageAnnotations = this.tpEvents.getAnnotations.bind(this.tpEvents, state.tabId);

          // add triggeringPrinciple info
          const pageLoad = this.tpEvents._active[state.tabId];
          if (pageLoad && state.trigger) {
            pageLoad.addTrigger(urlParts.hostname, state.trigger);
          }

          return true;
        }

        logRequestMetadata(state) {
          const urlParts = state.urlParts;
          const incrementStat = state.incrementStat;

          // add metadata for this request
          incrementStat('c');
          if (urlParts.query.length > 0) {
            incrementStat('has_qs');
          }
          if (urlParts.parameters.length > 0) {
            incrementStat('has_ps');
          }
          if (urlParts.fragment.length > 0) {
            incrementStat('has_fragment');
          }
          if (state.method === 'POST') {
            incrementStat('has_post');
          }
          const displayContentType = contentType => !contentType ? 'unknown' : '' + contentType;
          incrementStat('type_' + displayContentType(state.cpt));

          // log protocol (secure or not)
          const isHTTP = protocol => protocol === "http" || protocol === "https";
          const scheme = isHTTP(urlParts.protocol) ? urlParts.protocol : "other";
          incrementStat('scheme_' + scheme);

          // find frame depth
          incrementStat('window_depth_' + state.getWindowDepth());

          return true;
        }

      }

      /**
       * Caches 302 redirects so that we can ensure that the resulting request is properly
       * passed through the token logic.
       */
      class RedirectTagger {
        constructor() {
          this.redirectCache = new TempSet();
          this.cacheTimeout = 10000;
          this.redirectTaggerCache = new TempSet();
        }

        isFromRedirect(url) {
          return this.redirectCache.has(url);
        }

        checkRedirectStatus(state) {
          if (state.responseStatus === 302) {
            const location = state.getResponseHeader('Location');
            if (!location) {
              // 302 without "Location" in header?
              console$1.log(state, '302 without "Location" in header?');
              return true;
            }
            if (location.startsWith('/')) {
              // relative redirect
              const redirectUrl = `${state.urlParts.protocol}://${state.urlParts.hostname}${location}`;
              this.redirectCache.add(redirectUrl, this.cacheTimeout);
            } else if (location.startsWith('http://') || location.startsWith('https://')) {
              // absolute redirect
              this.redirectCache.add(location, this.cacheTimeout);
            }
          }
          return true;
        }

        checkRedirect(details) {
          if (details.isRedirect && details.requestId !== undefined) {
            this.redirectTaggerCache.add(details.requestId, this.cacheTimeout);
            return false;
          }
          return true;
        }

        confirmRedirect(details) {
          if (details.requestId !== undefined && this.redirectTaggerCache.has(details.requestId)) {
            return false;
          }

          if (details.isFullPage() && details.isRedirect) {
            return false;
          }

          return true;
        }
      }

      class SubdomainCheck {
        constructor(config) {
          this.config = config;
        }

        checkBadSubdomain(state, response) {
          const subdomainRewriteRules = this.config.subdomainRewriteRules || {};
          const requestHost = state.urlParts.hostname;
          const rules = Object.keys(subdomainRewriteRules);
          for (let i = 0; i < rules.length; i += 1) {
            const rule = rules[i];
            if (requestHost.endsWith(rule)) {
              const newUrl = state.url.replace(requestHost, subdomainRewriteRules[rule]);
              response.redirectTo(newUrl);
              return false;
            }
          }
          return true;
        }
      }

      const DAYS_EXPIRE = 7;
      const DB_NAME = 'cliqz-attrack-token-domain';

      class TokenDomain {
        constructor(config) {
          this.config = config;
          this.db = new DB(DB_NAME, { auto_compaction: true });
          this.blockedTokens = new Set();
          this.stagedTokenDomain = new Map();
          // cache of currentDay string (YYYYMMDD)
          this._currentDay = null;
          this._dbAvailable = true;

          this.subjectTokens = new Rx.Subject();
        }

        init() {
          // migrate from old db
          const init = migrateTokenDomain(this);
          // load current tokens over threshold
          const startup = this._wrapDbOperation(init.then(() => this.loadBlockedTokens()));

          // listen to the token tuples and update staged token data
          // emit when a new token is added to the blockedTokens set
          this._tokenSubscription = this.subjectTokens.subscribe(v => {
            this._addTokenOnFirstParty(v);
          });

          // sample token events to trigger database persist a most
          // once per minute.
          // While a previous persist is running these messages will be suppressed.
          const persistWhen = this.subjectTokens.observeOn(Rx.Scheduler.async).filter(() => this._dbAvailable).auditTime(60000);

          // Persist to disk controlled by the persistWhen Observable
          this._persistSubscription = persistWhen.subscribe(() => {
            this._wrapDbOperation(this._persist());
          });

          // when cleanup is due: after startup, or when day changes
          this._cleanupSubscription = Rx.Observable.merge(Rx.Observable.fromPromise(startup).map(() => this.currentDay), this.subjectTokens.observeOn(Rx.Scheduler.async).pluck('day')).distinctUntilChanged().delay(5000).subscribe(() => {
            this.clean();
          });
          return this._wrapDbOperation(init);
        }

        unload() {
          [this._persistSubscription, this._cleanupSubscription, this._tokenSubscription].forEach(sub => {
            if (sub) {
              sub.unsubscribe();
            }
          });
        }

        get currentDay() {
          if (!this._currentDay || Date.now() > this._nextDayCheck) {
            const day = getTime$1().substr(0, 8);
            if (day !== this._currentDay) {
              this._nextDayCheck = Date.now() + 3600 * 1000;
            }
            this._currentDay = day;
          }
          return this._currentDay;
        }

        /**
         * Wraps an operation on the db with a _dbAvailable flag. This flag can then be used to prevent
         * concurrent heavy operations on the db.
         * @param promise
         */
        _wrapDbOperation(promise) {
          this._dbAvailable = false;
          const unlockDb = () => {
            this._dbAvailable = true;
          };
          return promise.then(unlockDb, unlockDb);
        }

        loadBlockedTokens() {
          return this.db.allDocs({ include_docs: true }).then(docs => docs.rows.filter(row => Object.keys(row.doc.fps).length >= this.config.tokenDomainCountThreshold).map(doc => doc.id)).then(toks => {
            if (this.config.debugMode) {
              console$1.log('tokenDomain', 'blockedTokens:', toks.length);
            }
            toks.forEach(tok => this.blockedTokens.add(tok));
          });
        }

        /**
         * Mark that the given token was seen on this firstParty. Optionally specify a past day to insert
         * for, otherwise the current day is used
         * @param {String} token      token value
         * @param {String} firstParty first party domain
         * @param {String} day        (optional) day string (YYYYMMDD format)
         */
        addTokenOnFirstParty(token, firstParty, day) {
          const tokenDay = day || this.currentDay;
          // Pass the token tuples to the Rx Subject. Processing is handled via the _tokenSubscription
          // subscription (synchronously), and data persistance by the _persistSubscription
          // (asynchronously).
          this.subjectTokens.next({
            token,
            firstParty,
            day: tokenDay
          });
        }

        _addTokenOnFirstParty(_ref) {
          let token = _ref.token,
              firstParty = _ref.firstParty,
              day = _ref.day;

          if (!this.stagedTokenDomain.has(token)) {
            this.stagedTokenDomain.set(token, { fps: {} });
          }
          const tokens = this.stagedTokenDomain.get(token);
          tokens.mtime = this.currentDay > day ? this.currentDay : day;
          tokens.fps[firstParty] = day;
          return this._checkThresholdReached(token, tokens);
        }

        _checkThresholdReached(token, tokens) {
          if (Object.keys(tokens.fps).length >= this.config.tokenDomainCountThreshold) {
            if (this.config.debugMode) {
              console$1.log('tokenDomain', 'will be blocked:', token);
            }
            this.blockedTokens.add(token);
          }
          return this.blockedTokens.has(token);
        }

        isTokenDomainThresholdReached(token) {
          return this.config.tokenDomainCountThreshold < 2 || this.blockedTokens.has(token);
        }

        _persist() {
          const upserts = [];
          const unstageTokens = new Set();
          this.stagedTokenDomain.forEach((newDoc, token) => {
            const op = this.db.get(token).catch(err => {
              if (err.name === 'not_found') {
                return {
                  _id: token,
                  fps: {}
                };
              }
              throw err;
            }).then(_doc => {
              // merge existing doc with updated cached version
              const doc = _doc;
              doc.mtime = newDoc.mtime;
              Object.keys(newDoc.fps).forEach(firstParty => {
                doc.fps[firstParty] = newDoc.fps[firstParty];
              });
              if (this._checkThresholdReached(token, doc)) {
                // if this token reached the threshold we don't need to keep it staged
                unstageTokens.add(token);
              }
              return doc;
            }).then(doc => this.db.put(doc));
            upserts.push(op);
          });
          return Promise.all(upserts).then(() => {
            unstageTokens.forEach(key => {
              this.stagedTokenDomain.delete(key);
            });
            console$1.log('tokenDomain', 'persist successful', this.stagedTokenDomain.size, 'tokens,', unstageTokens.size, 'removed from staging');
          });
        }

        clean() {
          const day = newUTCDate();
          day.setDate(day.getDate() - DAYS_EXPIRE);
          const dayCutoff = dateString(day);

          const cleanPrefix = prefix => this.db.allDocs({
            include_docs: true,
            startkey: prefix,
            endkey: `${prefix}\ufff0`
          }).then(docs => {
            const modifiedDocs = docs.rows.reduce((acc, item) => {
              const doc = item.doc;
              if (doc.mtime < dayCutoff) {
                // no hits for token
                doc._deleted = true;
                acc.push(doc);
                this.blockedTokens.delete(doc._id);
              } else {
                // first parties to be removed
                const oldFps = Object.keys(doc.fps).filter(fp => doc.fps[fp] < dayCutoff);
                if (oldFps.length > 0) {
                  oldFps.forEach(fp => delete doc.fps[fp]);
                  acc.push(doc);
                  // check if this token still is over the threshold
                  if (Object.keys(doc.fps).length < this.config.tokenDomainCountThreshold) {
                    this.blockedTokens.delete(doc._id);
                  }
                }
              }
              return acc;
            }, []);
            if (this.config.debugMode) {
              console$1.log('tokenDomain', 'cleaning', modifiedDocs.length);
            }
            return this.db.bulkDocs(modifiedDocs);
          });

          // keys are all md5 hashes, so prefixes are hex digits
          const prefixes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];

          // Create a chain of clean operations for each of the 16 possible key prefixes in the database
          // Each operation waits for the previous promise to return, then waits another 1 second before
          // starting.
          return prefixes.reduce((prev, prefix) => prev.then(() => new Promise(resolve => {
            setTimeout(() => {
              resolve(cleanPrefix(prefix));
            }, 1000);
          })), Promise.resolve()).then(() => {
            const expiredTokens = new Set();
            this.stagedTokenDomain.forEach((value, key) => {
              if (value.mtime < dayCutoff) {
                expiredTokens.add(key);
              }
            });
            expiredTokens.forEach(key => {
              this.stagedTokenDomain.delete(key);
            });
            if (this.config.debugMode) {
              console$1.log('tokenDomain', 'cleaning cache', expiredTokens.size);
            }
          });
        }

        clear() {
          this.blockedTokens.clear();
          this.stagedTokenDomain.clear();
          this.db.destroy().then(() => {
            this.db = new DB(DB_NAME, { auto_compaction: true });
          });
        }
      }

      class BlockLog {

        constructor(telemetry, config) {
          this.telemetry = telemetry;
          this.config = config;
          this.blocked = new LazyPersistentObject('blocked');
          this.localBlocked = new LazyPersistentObject('localBlocked');
        }

        get blockReportList() {
          return this.config.reportList || {};
        }

        init() {
          this.blocked.load();
          this.localBlocked.load();

          this.onHourChanged = () => {
            const delay = 24;
            const hour = newUTCDate();
            hour.setHours(hour.getHours() - delay);
            const hourCutoff = hourString(hour);

            this._cleanLocalBlocked(hourCutoff);
            this.sendTelemetry();
          };
          this._hourChangedListener = CliqzEvents.subscribe('attrack:hour_changed', this.onHourChanged);
        }

        unload() {
          if (this._hourChangedListener) {
            this._hourChangedListener.unsubscribe();
            this._hourChangedListener = null;
          }
        }

        /**
         * Add an entry to the block log
         * @param {String} sourceUrl domain name of where this block happened
         * @param {String} tracker   the 3rd party tracker hostname which was blocked
         * @param {String} key       the key for the blocked value
         * @param {String} value     the blocked value
         * @param {String} type      the type of blocked value
         */
        add(sourceUrl, tracker, key, value, type) {
          const hour = getTime$1();

          this.offerToReporter(sourceUrl, tracker, key, value, type);

          // local logging of blocked tokens
          this._addLocalBlocked(sourceUrl, tracker, key, value, hour);
        }

        clear() {
          this.blocked.clear();
          this.localBlocked.clear();
        }

        _addBlocked(tracker, key, value, type) {
          const bl = this.blocked.value;
          if (!(tracker in bl)) {
            bl[tracker] = {};
          }
          if (!(key in bl[tracker])) {
            bl[tracker][key] = {};
          }
          if (!(value in bl[tracker][key])) {
            bl[tracker][key][value] = {};
          }
          if (!(type in bl[tracker][key][value])) {
            bl[tracker][key][value][type] = 0;
          }
          bl[tracker][key][value][type]++;
          this.blocked.setDirty();
        }

        _addLocalBlocked(source, s, k, v, hour) {
          const lb = this.localBlocked.value;
          if (!(source in lb)) {
            lb[source] = {};
          }
          if (!(s in lb[source])) {
            lb[source][s] = {};
          }
          if (!(k in lb[source][s])) {
            lb[source][s][k] = {};
          }
          if (!(v in lb[source][s][k])) {
            lb[source][s][k][v] = {};
          }
          if (!(hour in lb[source][s][k][v])) {
            lb[source][s][k][v][hour] = 0;
          }
          lb[source][s][k][v][hour]++;
          this.localBlocked.setDirty();
        }

        _cleanLocalBlocked(hourCutoff) {
          // localBlocked
          for (const source in this.localBlocked.value) {
            for (const s in this.localBlocked.value[source]) {
              for (const k in this.localBlocked.value[source][s]) {
                for (const v in this.localBlocked.value[source][s][k]) {
                  for (const h in this.localBlocked.value[source][s][k][v]) {
                    if (h < hourCutoff) {
                      delete this.localBlocked.value[source][s][k][v][h];
                    }
                  }
                  if (Object.keys(this.localBlocked.value[source][s][k][v]).length === 0) {
                    delete this.localBlocked.value[source][s][k][v];
                  }
                }
                if (Object.keys(this.localBlocked.value[source][s][k]).length === 0) {
                  delete this.localBlocked.value[source][s][k];
                }
              }
              if (Object.keys(this.localBlocked.value[source][s]).length === 0) {
                delete this.localBlocked.value[source][s];
              }
            }
            if (Object.keys(this.localBlocked.value[source]).length === 0) {
              delete this.localBlocked.value[source];
            }
          }
          this.localBlocked.setDirty(true);
          this.localBlocked.save();
        }

        /**
         * Check if this block event should be reported via telemetry, and if so, add to the
         * block log
         * @param  {String} sourceUrl
         * @param  {String} tracker
         * @param  {String} key
         * @param  {String} value
         * @param  {String} type
         */
        offerToReporter(sourceUrl, tracker, key, value, type) {
          if (this.isInBlockReportList(tracker, key, value)) {
            this._addBlocked(tracker, key, cachedMD5(value), type);
          }
        }

        isInBlockReportList(tracker, key, value) {
          if (tracker in this.blockReportList) {
            const keyList = this.blockReportList[tracker];
            if (keyList === '*') {
              return true;
            } else if (key in keyList || cachedMD5(key) in keyList) {
              const valueList = keyList[k] || keyList[cachedMD5(key)];
              if (valueList === '*') {
                return true;
              } else if (value in valueList || cachedMD5(value) in valueList) {
                return true;
              }
            }
          }
          return false;
        }

        sendTelemetry() {
          if (Object.keys(this.blocked.value).length > 0) {
            this.telemetry({
              message: {
                action: 'attrack.blocked',
                payload: this.blocked.value
              }
            });
            // reset the state
            this.blocked.clear();
          }
        }
      }

      function decodeToken(token) {
        let decodedToken = dURIC(token);
        let doubleDecoded = dURIC(decodedToken);
        while (decodedToken !== doubleDecoded) {
          decodedToken = doubleDecoded;
          doubleDecoded = dURIC(decodedToken);
        }
        return decodedToken;
      }

      function b64Encode(token) {
        var b64 = null;
        try {
          b64 = atob(token);
        } catch (e) {}
        return b64;
      }

      /**
       * This class checks url components for UIDs and exposes any 'badTokens' found.
       *
       * @class TokenChecker
       * @namespace antitracking.steps
       */
      class TokenChecker {

        constructor(qsWhitelist, privateValues, hashProb, config, telemetry) {
          this.qsWhitelist = qsWhitelist;
          this.config = config;
          this.debug = false;
          this.privateValues = privateValues;
          this.hashProb = hashProb;
          this.tokenDomain = new TokenDomain(config);
          this.blockLog = new BlockLog(telemetry, config);
        }

        init() {
          return Promise.all([this.tokenDomain.init(), this.blockLog.init()]);
        }

        unload() {
          this.tokenDomain.unload();
          this.blockLog.unload();
        }

        /**
         * Checks for uids in the request url and adds them to the pipeline state `badTokens`
         * attribute
         * @param  {Object} state Pipeline state object
         * @return {Boolean} true
         */
        findBadTokens(state) {
          const stats = {};
          state.isTracker = this.qsWhitelist.isTrackerDomain(state.urlParts.generalDomainHash);
          state.badTokens = this.checkTokens(state.urlParts, state.sourceUrl, state.cookieValues, stats, state.sourceUrlParts, state.isTracker);
          // set stats
          if (state.incrementStat) {
            Object.keys(stats).forEach(function (key) {
              if (stats[key] > 0) {
                state.incrementStat('token.has_' + key);
                state.incrementStat('token.' + key, stats[key]);
              }
            });
            if (state.badTokens.length > 0) {
              state.incrementStat('bad_qs');
              state.incrementStat('bad_tokens', state.badTokens.length);
            }
          }
          return true;
        }

        /**
         * Check all tokens of the url for uids.
         *
         * A token is a uid one of the following apply:
         *  - it matches the user's cookie for this page
         *  - it matches a private value from JS (from this.privateValues)
         *  - it is not on the global safe value list, and its key is not in local nor global
         *  safe key lists
         *
         * It must also meet that condition that the same value has been seen on multiple first
         * party domains (this.config.tokenDomainCountThreshold).
         *
         * @param  {Object} url_parts        Parts of the request url, as parsed by parseURL
         * @param  {String} source_url       The first party url for this request
         * @param  {Object} cookievalue      A map of cookie values in the first party page - keys are values
         * @param  {Object} stats            An object to write stats to
         * @param  {Object} source_url_parts Parts of the source url, as parsed by parseURL
         * @param  {Boolean} tracker         True if the request host is a tracker
         * @return {Array}                   Array of values which we think are uids and should be removed.
         */
        checkTokens(url_parts, source_url, cookievalue, stats, source_url_parts, tracker) {
          // This check is only done for trackers
          if (!tracker) {
            return [];
          }

          // if there are no query parameters, there is nothing to check
          if (url_parts.query.length === 0 && url_parts.parameters.length === 0) {
            return [];
          }

          const trackerDomain = url_parts.generalDomainHash;
          const sourceDomain = source_url_parts.generalDomainHash;
          const badTokens = [];

          const longCookies = Object.keys(cookievalue).filter(c => c.length >= this.config.shortTokenLength);
          const privateValues = Object.keys(this.privateValues);

          // check for each kv in the url
          const tokenStatus = url_parts.getKeyValues().map(kv => {
            const key = kv.k;
            const tok = '' + kv.v;

            // ignore short values
            if (tok.length < this.config.shortTokenLength) {
              return 'short';
            }

            // if the value is in the main url, ignore
            if (source_url.indexOf(tok) > -1) {
              return 'source_url';
            }

            // make different possible encodings of the token
            const decodedToken = decodeToken(tok);
            const tokenVariants = [tok, decodedToken, b64Encode(tok), b64Encode(decodedToken)].filter(t => t && t.length > 0);

            function tokenMatches(val) {
              // check if the value is in the cookie or the value is in the token
              return tokenVariants.some(t => t.indexOf(val) > -1 || val.indexOf(t) > -1);
            }

            // check for cookie or private values - presence of these override the global
            // safe key and token lists
            const cookieMatch = longCookies.some(tokenMatches);
            const privateMatch = privateValues.some(tokenMatches);
            const overrideGlobalLists = cookieMatch || privateMatch;

            // if we didn't already match a cookie or private value, do these steps
            if (!overrideGlobalLists) {
              if (this.qsWhitelist.isSafeKey(trackerDomain, cachedMD5(key))) {
                return 'safekey';
              }

              if (this.qsWhitelist.isSafeToken(trackerDomain, cachedMD5(tok))) {
                return 'whitelisted';
              }

              // check for short non-hashes
              if (decodedToken.length < 12 && !isMostlyNumeric(decodedToken) && !this.hashProb.isHash(decodedToken)) {
                return 'short_no_hash';
              }
            }

            const tokenType = cookieMatch ? 'cookie' : privateMatch ? 'private' : 'qs';

            // count thresholds for token values
            if (!overrideGlobalLists) {
              // increment that this token has been seen on this site
              this.tokenDomain.addTokenOnFirstParty(cachedMD5(tok), sourceDomain);
              // check if the threshold for cross-domain tokens has been reached
              if (!this.tokenDomain.isTokenDomainThresholdReached(cachedMD5(tok))) {
                return `${tokenType}_newToken`;
              }
            }

            // push to block log and bad tokens list
            this.blockLog.add(source_url_parts.generalDomain, url_parts.hostname, key, tok, tokenType);
            badTokens.push(tok);
            return `${tokenType}_countThreshold`;
          });

          if (this.debug) {
            // debug message: labeled key values
            const tokenReport = url_parts.getKeyValues().map((kv, i) => Object.assign(kv, { class: tokenStatus[i] }));
            console.log('tokens', url_parts.hostname, tokenReport);
          }

          tokenStatus.forEach(s => {
            if (!stats[s]) {
              stats[s] = 0;
            }
            stats[s] += 1;
          });

          return badTokens;
        }
      }

      /**
       * @module core
       * @namespace core
       */

      /**
       * Executor which consumes asynchronous (Promise) tasks serially.
       *
       * @class SerialExecutor
       */
      class SerialExecutor {
        constructor() {
          let autostart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          this._tasks = [];
          this._running = false;
          this._autostart = autostart;
        }

        /**
         * Add a task to the queue. The task will be executed as soon as all preceding tasks in the
         * queue have completed (i.e. `then` or `catch` on the Promise has been called).
         * @param {Function} task - function to run. Should return a {Promise}
         */
        enqueue(task) {
          if (typeof task !== 'function') {
            throw new Error('task must be a function');
          }
          this._tasks.push(task);

          if (!this._running && this._autostart) {
            CliqzUtils.setTimeout(this.start.bind(this), 0);
          }
        }

        /**
         *  Start the executor. By default this is done automatically on task submission.
         *
         *  @method start
         */
        start() {
          if (this._running) {
            return;
          }
          this._running = true;
          this._consumeQueue().then(() => {
            this._running = false;
          });
        }

        /**
         * Execute all the tasks in the queue. This is called recursively to consume all queue elements
         * from beginning to end.
         *
         * @method _consumeQueue
         * @private
         */
        _consumeQueue() {
          if (this._tasks.length === 0) {
            return Promise.resolve();
          }
          // grab the first task and get the result. We expect this to be a Promise
          const task = this._tasks.shift();
          let result;
          try {
            result = task();
          } catch (e) {
            console$1.error('Exception running task', e);
            result = Promise.resolve();
          }
          // if result is not a Promise just put a warning in the console and then continue
          if (!result || typeof result.then !== 'function' || typeof result.catch !== 'function') {
            console$1.error(`Task ${task.name} didn't return a promise`);
            result = Promise.resolve();
          }
          // run _consumeQueue recursively to empty the queue
          const consumeNext = this._consumeQueue.bind(this);
          return result.catch(e => {
            console$1.error('Error running async task', e);
          }).then(consumeNext);
        }
      }

      class TokenSet {

        constructor() {
          this.items = new Map();
          this.dirty = false;
        }

        add(tok, value) {
          this.items.set(tok, value);
          this.dirty = true;
        }

        size() {
          return this.items.size;
        }

        toObject() {
          const obj = {};
          this.items.forEach((value, key) => {
            obj[key] = value;
          });
          return obj;
        }

        setDirty(val) {
          this.dirty = val;
        }
      }

      /**
       * Manages the local safekey list
       */
      class TokenExaminer {

        constructor(qsWhitelist, config) {
          this.qsWhitelist = qsWhitelist;
          this.config = config;
          this.db = new DB('cliqz-attrack-request-key-value', { auto_compaction: true });
          this.hashTokens = true;
          this.queue = new SerialExecutor();
          this.requestKeyValue = new Map();
          this._syncTimer = null;
          this.lastLoad = null;
          this._pmReload = null;
        }

        init() {
          return this.loadAndPrune().then(() => {
            this._pmReload = pm.register(() => {
              if (this.lastLoad < dateString(newUTCDate())) {
                this.reloadCache();
              }
            }, 3600 * 1000);
          });
        }

        unload() {
          if (this._syncTimer) {
            CliqzUtils.clearTimeout(this._syncTimer);
          }
          if (this._pmReload) {
            pm.deregister(this._pmReload);
          }
        }

        clearCache() {
          this.requestKeyValue.clear();
          this.queue.enqueue(() => {
            return this.db.destroy().then(() => {
              this.db = new DB('cliqz-attrack-request-key-value', { auto_compaction: true });
            });
          });
        }

        reloadCache() {
          if (this._syncTimer) {
            CliqzUtils.clearTimeout(this._syncTimer);
            this._syncTimer = null;
          }
          this._syncDb();
          this.queue.enqueue(() => {
            this.requestKeyValue.clear();
            return this.loadAndPrune();
          });
        }

        addRequestKeyValueEntry(tracker, key, tokens) {
          if (!this.requestKeyValue.has(tracker)) {
            this.requestKeyValue.set(tracker, new Map());
          }
          const trackerMap = this.requestKeyValue.get(tracker);
          if (!trackerMap.has(key)) {
            trackerMap.set(key, new TokenSet());
          }
          const toks = trackerMap.get(key);
          Object.keys(tokens).forEach(tok => {
            toks.add(tok, tokens[tok]);
          });
          return toks;
        }

        removeRequestKeyValueEntry(tracker, key) {
          const trackerMap = this.requestKeyValue.get(tracker);
          if (trackerMap) {
            trackerMap.delete(key);
          }
          if (trackerMap && trackerMap.size === 0) {
            this.requestKeyValue.delete(tracker);
          }
        }

        examineTokens(state) {
          // do not do anything for private tabs and non-tracker domains
          if (!state.isPrivate && this.qsWhitelist.isTrackerDomain(state.urlParts.generalDomainHash)) {
            const day = newUTCDate();
            const today = dateString(day);

            const tracker = state.urlParts.generalDomainHash;

            // create a Map of key => set(values) from the url data
            const cachedKvs = this.requestKeyValue.get(tracker) || new Map();
            const reachedThreshold = new Set();
            const kvs = state.urlParts.getKeyValues().reduce((hash, kv) => {
              if (kv.v.length < this.config.shortTokenLength || this.qsWhitelist.isSafeKey(tracker, cachedMD5(kv.k))) {
                return hash;
              }
              const key = this.hashTokens ? cachedMD5(kv.k) : kv.k;
              const tok = this.hashTokens ? cachedMD5(kv.v) : kv.v;
              if (!hash.has(key)) {
                hash.set(key, new TokenSet());
              }
              hash.get(key).add(tok, today);
              // whitelist any keys which reached the threshold
              if (!reachedThreshold.has(key) && hash.get(key).size() > this.config.safekeyValuesThreshold) {
                reachedThreshold.add(key);
                if (this.config.debugMode) {
                  console$1.log('Add safekey', state.urlParts.generalDomain, key, hash.get(key));
                }
                this.qsWhitelist.addSafeKey(tracker, this.hashTokens ? key : cachedMD5(key), this.config.safekeyValuesThreshold);
              }
              return hash;
            }, cachedKvs);

            // push updated cache
            this.requestKeyValue.set(tracker, kvs);
            this._scheduleSync();
            return true;
          }
          return true;
        }

        getPruneCutoff() {
          const day = newUTCDate();
          day.setDate(day.getDate() - this.config.safeKeyExpire);
          return dateString(day);
        }

        /**
         * Prune old tokens and limit object to max 10 keys
         * @param  {Object} tokens
         * @param  {String} cutoff
         * @return {Object}
         */
        pruneTokens(tokens, cutoff) {
          let counter = 0;
          Object.keys(tokens).forEach(tok => {
            if (counter > 10 || tokens[tok] < cutoff) {
              delete tokens[tok];
            } else {
              counter++;
            }
          });
          return tokens;
        }

        loadAndPrune() {
          this.lastLoad = dateString(newUTCDate());
          return this.db.allDocs({
            include_docs: true
          }).then(results => {
            const cutoff = this.getPruneCutoff();
            const docs = results.rows.map(row => row.doc).map(_d => {
              const doc = _d;
              doc.tokens = this.pruneTokens(doc.tokens || {}, cutoff);
              if (Object.keys(doc.tokens).length === 0) {
                doc._deleted = true;
              }
              return doc;
            });

            // pre-cache entries which are almost at the safekey threshold
            docs.filter(doc => Object.keys(doc.tokens).length === this.config.safekeyValuesThreshold - 1).forEach(doc => {
              const tracker = doc._id.substring(0, 16);
              const key = doc.key;
              this.addRequestKeyValueEntry(tracker, key, doc.tokens).setDirty(false);
            });
            // return updated docs
            return docs;
          }).then(docs => this.db.bulkDocs(docs));
        }

        _scheduleSync() {
          if (this._syncTimer) {
            return;
          }
          this._syncTimer = CliqzUtils.setTimeout(() => {
            this._syncDb();
            this._syncTimer = null;
          }, 10000);
        }

        _syncDb() {
          const trackers = [...this.requestKeyValue.keys()];
          trackers.map(tracker => [...this.requestKeyValue.get(tracker).entries()].filter(pair => pair[1].dirty)).forEach((kvs, i) => {
            const tracker = trackers[i];
            if (kvs.length === 0) return;

            this._updateTrackerKeyValues(tracker, kvs);
            kvs.forEach(pair => pair[1].setDirty(false));
          });
        }

        _updateTrackerKeyValues(tracker, keyValuePairs) {
          const pruneCutoff = this.getPruneCutoff();
          const trackerHashLength = tracker.length;
          const unsafeKeysSeen = new Set(keyValuePairs.map(pair => pair[0]));
          const kvs = new Map();
          keyValuePairs.forEach(pair => kvs.set(pair[0], pair[1]));
          // Add upsert function to serial queue
          // this ensures multiple upserts do not conflict.
          this.queue.enqueue(() =>
          // query the db for keys for this tracker domain
          this.db.allDocs({
            include_docs: true,
            startkey: tracker,
            endkey: `${tracker}\uffff`
          })
          // get rows for the keys we saw in this request
          .then(results => results.rows.map(row => row.doc).filter(row => unsafeKeysSeen.has(row._id.substring(trackerHashLength))))
          // update rows with new data
          .then(rows => {
            const existingRowKeys = new Set(rows.map(doc => doc.key));
            // create documents for keys which weren't already in db
            const newDocs = Array.from(kvs.keys()).filter(key => !existingRowKeys.has(key)).map(key => ({
              _id: `${tracker}${key}`,
              key,
              tokens: kvs.get(key).toObject()
            }));
            // update existing documents with new tokens
            const updatedDocs = rows.map(_doc => {
              const doc = _doc;
              doc.tokens = Object.assign(doc.tokens || {}, kvs.get(doc.key).toObject());
              // also prune while we're here
              doc.tokens = this.pruneTokens(doc.tokens, pruneCutoff);
              return doc;
            });

            const docs = newDocs.concat(updatedDocs);
            // get docs over threshold which should be added to safekey list
            docs.forEach(doc => {
              const tokenCount = Object.keys(doc.tokens).length;

              if (tokenCount > this.config.safekeyValuesThreshold) {
                if (this.config.debugMode) {
                  console$1.log('Add safekey', tracker, doc.key, doc.tokens);
                }
                this.qsWhitelist.addSafeKey(tracker, this.hashTokens ? doc.key : cachedMD5(doc.key), Object.keys(doc.tokens).length);
                // remove cached entry - it is not in safekey list
                this.removeRequestKeyValueEntry(tracker, doc.key);
              } else if (tokenCount > this.config.safekeyValuesThreshold - 1) {
                this.addRequestKeyValueEntry(tracker, doc.key, doc.tokens).setDirty(false);
              } else {
                this.removeRequestKeyValueEntry(tracker, doc.key);
              }
            });
            // upsert into the db
            return this.db.bulkDocs(docs);
          }).catch(e => console$1.error('requestKeyValue update error', e)));
        }

      }

      /**
       * Add padding characters to the left of the given string.
       *
       * @param {string} str  - original string.
       * @param {string} char - char used for padding the string.
       * @param {number} size - desired size of the resulting string (after padding)
      **/
      function leftpad(str, char, size) {
        // This function only makes sens if `char` is a character.
        if (char.length != 1) {
          throw new Error("`char` argument must only contain one character");
        }

        if (str.length >= size) {
          return str;
        } else {
          return char.repeat(size - str.length) + str;
        }
      }

      /**
       * Remove any trace of source domains, or hashes of source domains
       * from the data to be sent to the backend. This is made to ensure
       * there is no way to backtrack to user's history using data sent to
       * the backend.
       *
       * Replace all the keys of `trackerData` (which are 16-chars prefixes of
       * hash of the source domain) by unique random strings of size 16 (which is
       * expected by backend). We don't have to make them unique among all data,
       * it is enough to ensure unicity on a per-tracker basis.
       *
       * @param {Object} trackerData - associate source domains to key/value pairs.
      **/
      function anonymizeTrackerTokens(trackerData) {
        let index = 1;
        // Anonymize the given tracker data
        const anonymizedTrackerData = {};

        for (let originalKey in trackerData) {
          const newRandomKey = leftpad(index.toString().substr(0, 16), '0', 16);
          index += 1;
          anonymizedTrackerData[newRandomKey] = trackerData[originalKey];
        }

        return anonymizedTrackerData;
      }

      class TokenTelemetry {

        constructor(telemetry, qsWhitelist, config) {
          this.telemetry = telemetry;
          this.qsWhitelist = qsWhitelist;
          this.config = config;
          this.tokens = {};
          this._tokens = new AutoPersistentObject("tokens", v => this.tokens = v, 60000);
        }

        init() {
          this._pmsend = pm.register(this.sendTokens.bind(this), 5 * 60 * 1000);
        }

        unload() {
          this._tokens.save();
          pm.deregister(this._pmsend);
        }

        extractKeyTokens(state) {
          // ignore private requests
          if (state.isPrivate) return true;

          const keyTokens = state.urlParts.getKeyValuesMD5();
          if (keyTokens.length > 0) {
            const domain = cachedMD5(state.urlParts.hostname).substr(0, 16);
            const firstParty = cachedMD5(state.sourceUrlParts.hostname).substr(0, 16);
            const generalDomain = cachedMD5(state.urlParts.generalDomain).substr(0, 16);
            this._saveKeyTokens(domain, keyTokens, firstParty, generalDomain);
          }
          return true;
        }

        _touchToken(key, firstParty) {
          if (!(key in this.tokens)) {
            this.tokens[key] = {
              lastSent: getTime$1()
            };
          }
          if (!(firstParty in this.tokens[key])) {
            this.tokens[key][firstParty] = {
              c: 0,
              kv: {}
            };
          }
        }

        _saveKeyTokens(domain, keyTokens, firstParty, generalDomain) {
          // anything here should already be hash
          const dkSafe = domain;
          const dkUnsafe = `${domain}_unsafe`;
          const isTracker = this.qsWhitelist.isTrackerDomain(generalDomain);

          // telemetryMode 0: collect nothing, telemetryMode 1: collect only for tracker domains
          if (this.config.telemetryMode === TELEMETRY.DISABLED || this.config.telemetryMode === TELEMETRY.TRACKERS_ONLY && !isTracker) {
            return;
          }

          keyTokens.forEach(kv => {
            const tok = kv.v;
            const k = kv.k;
            // put token in safe bucket if: value is short, domain is not a tracker,
            // or key or value is whitelisted
            const safe = kv.v_len < this.config.shortTokenLength || !isTracker || this.qsWhitelist.isSafeKey(generalDomain, k) || this.qsWhitelist.isSafeToken(generalDomain, tok);
            const dk = safe ? dkSafe : dkUnsafe;
            this._touchToken(dk, firstParty);
            if (this.tokens[dk][firstParty].kv[k] == null) {
              this.tokens[dk][firstParty].kv[k] = {};
            }
            if (this.tokens[dk][firstParty].kv[k][tok] == null) {
              this.tokens[dk][firstParty].kv[k][tok] = {
                c: 0,
                k_len: kv.k_len,
                v_len: kv.v_len
              };
            }
            this.tokens[dk][firstParty].kv[k][tok].c += 1;
          });
          this._tokens.setDirty();
        }

        sendTokens() {
          // send a batch for safe tokens, and one for unsafe
          const domainKeyIsSafe = key => !key.endsWith('_unsafe');
          this._sendTokenBatch(domainKeyIsSafe);
          this._sendTokenBatch(key => !domainKeyIsSafe(key));
        }

        _sendTokenBatch(keyFilter) {
          const data = {};
          const hour = getTime$1();
          const domainKeys = Object.keys(this.tokens).filter(keyFilter);
          const limit = Math.floor(domainKeys.length / 12) || 1;

          // sort tracker keys by lastSent, i.e. send oldest data first
          const sortedTrackers = domainKeys.sort((a, b) => parseInt(this.tokens[a].lastSent || 0, 10) - parseInt(this.tokens[b].lastSent || 0, 10));

          for (let i in sortedTrackers) {
            const dk = sortedTrackers[i];
            const tokenData = this.tokens[dk];
            // remove the suffix (i.e. '_unsafe')
            const domain = dk.substring(0, 16);

            if (limit > 0 && Object.keys(data).length > limit) {
              break;
            }

            if (!(domain in data) && (!tokenData.lastSent || tokenData.lastSent < hour)) {
              delete tokenData.lastSent;
              const dataPayload = anonymizeTrackerTokens(tokenData);
              delete this.tokens[dk];
              if (Object.keys(dataPayload).length > 0) {
                data[domain] = dataPayload;
              }
            }
          }

          if (Object.keys(data).length > 0) {
            splitTelemetryData(data, 20000).forEach(d => {
              const msg = {
                type: this.telemetry.msgType,
                action: 'attrack.tokens',
                payload: d
              };
              this.telemetry({
                message: msg,
                compress: true
              });
            });
          }
          this._tokens.setDirty();
        }
      }

      const internalProtocols = new Set(['chrome', 'resource', 'moz-extension', 'chrome-extension']);

      function skipInvalidSource(state) {
        return state.sourceUrlParts !== null;
      }

      function skipInternalProtocols(state) {
        if (!state.urlParts) {
          // url must be parseable
          return false;
        }
        if (state.sourceUrlParts && internalProtocols.has(state.sourceUrlParts.protocol)) {
          return false;
        }
        if (state.urlParts && internalProtocols.has(state.urlParts.protocol)) {
          return false;
        }
        return true;
      }

      function checkSameGeneralDomain(state) {
        const gd1 = state.urlParts.generalDomain;
        const gd2 = state.sourceUrlParts.generalDomain;
        return gd1 !== undefined && gd1 !== null && gd2 !== undefined && gd2 !== null && gd1 !== gd2 && gd1.split('.')[0] !== gd2.split('.')[0];
      }

      /* eslint-disable no-param-reassign */

      /*
       * This module prevents user from 3rd party tracking
       */
      class CliqzAttrack {
        constructor() {
          this.VERSION = VERSION;
          this.MIN_BROWSER_VERSION = MIN_BROWSER_VERSION;
          this.LOG_KEY = 'attrack';
          this.debug = false;
          this.msgType = 'attrack';
          this.similarAddon = false;
          this.tp_events = null;
          this.recentlyModified = new TempSet();
          this.DISABLED_SITES_PREF = 'attrackSourceDomainWhitelist';
          this.urlWhitelist = new UrlWhitelist('attrack-url-whitelist');

          // Web request pipelines
          this.webRequestPipeline = inject.module('webrequest-pipeline');
          this.pipelineSteps = {};
          this.pipelines = {};
        }

        obfuscate(s, method) {
          // used when action != 'block'
          // default is a placeholder
          switch (method) {
            case 'empty':
              return '';
            case 'replace':
              return shuffle(s);
            case 'same':
              return s;
            case 'placeholder':
              return this.config.placeHolder;
            default:
              return this.config.placeHolder;
          }
        }

        getPrivateValues(window) {
          // creates a list of return values of functions may leak private info
          const p = {};
          // var navigator = utils.getWindow().navigator;
          const navigator = window.navigator;
          // plugins
          for (let i = 0; i < navigator.plugins.length; i += 1) {
            const name = navigator.plugins[i].name;
            if (name.length >= 8) {
              p[name] = true;
            }
          }
          this.privateValues = p;
        }

        getDefaultRule() {
          if (this.isForceBlockEnabled()) {
            return 'block';
          }

          return getDefaultTrackerTxtRule();
        }

        isEnabled() {
          return this.config.enabled;
        }

        isCookieEnabled(url) {
          if (url !== undefined && this.urlWhitelist.isWhitelisted(url)) {
            return false;
          }
          return this.config.cookieEnabled;
        }

        isQSEnabled() {
          return this.config.qsEnabled;
        }

        isFingerprintingEnabled() {
          return this.config.fingerprintEnabled;
        }

        isReferrerEnabled() {
          return this.config.referrerEnabled;
        }

        isTrackerTxtEnabled() {
          return this.config.trackerTxtEnabled;
        }

        isBloomFilterEnabled() {
          return this.config.bloomFilterEnabled;
        }

        isForceBlockEnabled() {
          return this.config.forceBlockEnabled;
        }

        initPacemaker() {
          const twoMinutes = 2 * 60 * 1000;

          // create a constraint which returns true when the time changes at the specified fidelity
          const timeChangeConstraint = (name, fidelity) => {
            if (fidelity === 'day') fidelity = 8;else if (fidelity === 'hour') fidelity = 10;
            return () => {
              const timestamp = getTime$1().slice(0, fidelity);
              const lastHour = getValue(`${name}lastRun`) || timestamp;
              setValue(`${name}lastRun`, timestamp);
              return timestamp !== lastHour;
            };
          };

          // pacemaker.register(this.updateConfig, 3 * 60 * 60 * 1000);

          // if the hour has changed
          pm.register(this.hourChanged.bind(this), twoMinutes, timeChangeConstraint('hourChanged', 'hour'));

          pm.register(() => {
            this.tp_events.commit().then(() => {
              this.tp_events.push();
            });
          }, twoMinutes);
        }

        telemetry(_ref) {
          let message = _ref.message;
          var _ref$raw = _ref.raw;
          let raw = _ref$raw === undefined ? false : _ref$raw;
          var _ref$compress = _ref.compress;
          let compress = _ref$compress === undefined ? false : _ref$compress;
          var _ref$ts = _ref.ts;
          let ts = _ref$ts === undefined ? undefined : _ref$ts;

          if (!message.type) {
            message.type = telemetry$1.msgType;
          }
          if (raw !== true) {
            message.payload = generateAttrackPayload(message.payload, ts, this.qs_whitelist.getVersion());
          }
          if (compress === true && compressionAvailable$1()) {
            message.compressed = true;
            message.payload = compressJSONToBase64(message.payload);
          }
          telemetry$1.telemetry(message);
        }

        /** Global module initialisation.
        */
        init(config) {
          const initPromises = [];
          this.config = config;
          // disable for older browsers
          if (getBrowserMajorVersion() < this.MIN_BROWSER_VERSION) {
            return Promise.resolve();
          }

          // Replace getWindow functions with window object used in init.
          if (this.debug) console$1.log('Init function called:', this.LOG_KEY);

          if (!this.hashProb) {
            this.hashProb = new HashProb();
            initPromises.push(this.hashProb.init());
          }

          // load all caches:
          // Large dynamic caches are loaded via the persist module, which will
          // lazily propegate changes back to the browser's sqlite database.
          // Large static caches (e.g. token whitelist) are loaded from sqlite
          // Smaller caches (e.g. update timestamps) are kept in prefs

          this.qs_whitelist = this.isBloomFilterEnabled() ? new AttrackBloomFilter(this.config) : new QSWhitelist(this.config);

          initPromises.push(this.qs_whitelist.init());
          initPromises.push(this.urlWhitelist.init());

          // force clean requestKeyValue
          CliqzEvents.sub('attrack:safekeys_updated', (version, forceClean) => {
            if (forceClean && this.pipelineSteps.tokenExaminer) {
              this.pipelineSteps.tokenExaminer.clearCache();
            }
          });

          this.checkInstalledAddons();

          this.initPacemaker();
          pm.start();

          this.tp_events = new PageEventTracker(payloadData => {
            // take telemetry data to be pushed and add module metadata
            const enabled = {
              qs: this.isQSEnabled(),
              cookie: this.isCookieEnabled(),
              bloomFilter: this.isBloomFilterEnabled(),
              trackTxt: this.isTrackerTxtEnabled(),
              forceBlock: this.isForceBlockEnabled()
            };
            const updateInTime = this.qs_whitelist.isUpToDate();
            payloadData.forEach(pageload => {
              const payl = generateAttrackPayload([pageload], undefined, {
                conf: enabled,
                addons: this.similarAddon,
                updateInTime
              });
              this.telemetry({
                message: { type: telemetry$1.msgType, action: 'attrack.tp_events', payload: payl },
                raw: true
              });
            });
          }, this.config);

          initPromises.push(this.initPipeline());

          // cleanup legacy database
          cleanLegacyDb();

          return Promise.all(initPromises);
        }

        initPipeline() {
          var _this = this;

          return this.unloadPipeline().then(() => {
            // Initialise classes which are used as steps in listeners
            const steps = {
              pageLogger: new PageLogger(this.tp_events),
              tokenExaminer: new TokenExaminer(this.qs_whitelist, this.config),
              tokenTelemetry: new TokenTelemetry(this.telemetry.bind(this), this.qs_whitelist, this.config),
              domChecker: new DomChecker(),
              tokenChecker: new TokenChecker(this.qs_whitelist, {}, this.hashProb, this.config, this.telemetry),
              blockRules: new BlockRules(this.config),
              cookieContext: new CookieContext(this.config, this.tp_events, this.qs_whitelist),
              redirectTagger: new RedirectTagger(),
              subdomainChecker: new SubdomainCheck(this.config)
            };

            this.pipelineSteps = steps;

            // initialise step objects
            Object.keys(steps).forEach(key => {
              const step = steps[key];
              if (step.init) {
                step.init();
              }
            });

            // ----------------------------------- \\
            // create pipeline for onBeforeRequest \\
            // ----------------------------------- \\
            this.pipelines.onBeforeRequest = new Pipeline('antitracking.onBeforeRequest', [{
              name: 'redirectTagger.checkRedirect',
              spec: 'break',
              fn: state => steps.redirectTagger.checkRedirect(state)
            }, {
              name: 'pageLogger.logMainDocument',
              spec: 'break',
              fn: state => steps.pageLogger.logMainDocument(state)
            }, {
              name: 'skipInvalidSource',
              spec: 'break',
              fn: skipInvalidSource
            }, {
              name: 'skipInternalProtocols',
              spec: 'break',
              fn: skipInternalProtocols
            }, {
              name: 'checkSameGeneralDomain',
              spec: 'break',
              fn: checkSameGeneralDomain
            }, {
              name: 'cancelRecentlyModified',
              spec: 'blocking',
              fn: (state, response) => this.cancelRecentlyModified(state, response)
            }, {
              name: 'subdomainChecker.checkBadSubdomain',
              spec: 'blocking',
              fn: (state, response) => steps.subdomainChecker.checkBadSubdomain(state, response)
            }, {
              name: 'pageLogger.attachStatCounter',
              spec: 'annotate',
              fn: state => steps.pageLogger.attachStatCounter(state)
            }, {
              name: 'pageLogger.logRequestMetadata',
              spec: 'collect', // TODO - global state
              fn: state => steps.pageLogger.logRequestMetadata(state)
            }, {
              name: 'checkExternalBlocking',
              spec: 'blocking',
              fn: (state, response) => {
                if (response.cancel === true || response.redirectUrl) {
                  state.incrementStat('blocked_external');
                  response.shouldIncrementCounter = true;
                  return false;
                }
                return true;
              }
            }, {
              name: 'tokenExaminer.examineTokens',
              spec: 'collect', // TODO - global state
              fn: state => steps.tokenExaminer.examineTokens(state)
            }, {
              name: 'tokenTelemetry.extractKeyTokens',
              spec: 'collect', // TODO - global state
              fn: state => steps.tokenTelemetry.extractKeyTokens(state)
            }, {
              name: 'domChecker.checkDomLinks',
              spec: 'collect', // TODO - global state
              fn: state => steps.domChecker.checkDomLinks(state)
            }, {
              name: 'domChecker.parseCookies',
              spec: 'annotate',
              fn: state => steps.domChecker.parseCookies(state)
            }, {
              name: 'tokenChecker.findBadTokens',
              spec: 'annotate',
              fn: state => steps.tokenChecker.findBadTokens(state)
            }, {
              name: 'checkSourceWhitelisted',
              spec: 'break',
              fn: state => {
                if (this.urlWhitelist.isWhitelisted(state.sourceUrlParts.hostname)) {
                  state.incrementStat('source_whitelisted');
                  return false;
                }
                return true;
              }
            }, {
              name: 'checkShouldBlock',
              spec: 'break',
              fn: state => state.badTokens.length > 0 && this.qs_whitelist.isUpToDate() && !this.config.paused
            }, {
              name: 'isQSEnabled',
              spec: 'break',
              fn: () => this.isQSEnabled()
            }, {
              name: 'blockRules.applyBlockRules',
              spec: 'blocking',
              fn: (state, response) => steps.blockRules.applyBlockRules(state, response)
            }, {
              name: 'applyBlock',
              spec: 'blocking',
              fn: (state, response) => this.applyBlock(state, response)
            }]);

            // --------------------------------------- \\
            // create pipeline for onBeforeSendHeaders \\
            // --------------------------------------- \\
            this.pipelines.onBeforeSendHeaders = new Pipeline('antitracking.onBeforeSendHeaders', [{
              name: 'cookieContext.assignCookieTrust',
              spec: 'collect', // TODO - global state
              fn: state => steps.cookieContext.assignCookieTrust(state)
            }, {
              name: 'redirectTagger.confirmRedirect',
              spec: 'break',
              fn: state => steps.redirectTagger.confirmRedirect(state)
            }, {
              name: 'checkIsMainDocument',
              spec: 'break',
              fn: state => !state.isFullPage()
            }, {
              name: 'skipInvalidSource',
              spec: 'break',
              fn: skipInvalidSource
            }, {
              name: 'skipInternalProtocols',
              spec: 'break',
              fn: skipInternalProtocols
            }, {
              name: 'checkSameGeneralDomain',
              spec: 'break',
              fn: checkSameGeneralDomain
            }, {
              name: 'subdomainChecker.checkBadSubdomain',
              spec: 'blocking',
              fn: (state, response) => steps.subdomainChecker.checkBadSubdomain(state, response)
            }, {
              name: 'pageLogger.attachStatCounter',
              spec: 'annotate',
              fn: state => steps.pageLogger.attachStatCounter(state)
            }, {
              name: 'catchMissedOpenListener',
              spec: 'blocking',
              fn: (state, response) => {
                if (state.reqLog && state.reqLog.c === 0 || steps.redirectTagger.isFromRedirect(state.url)) {
                  // take output from 'open' pipeline and copy into our response object
                  this.pipelines.onBeforeRequest.execute(state, response);
                }
              }
            }, {
              name: 'overrideUserAgent',
              spec: 'blocking',
              fn: (state, response) => {
                if (this.config.overrideUserAgent === true) {
                  const domainHash = state.urlParts.generalDomainHash;
                  if (this.qs_whitelist.isTrackerDomain(domainHash)) {
                    response.modifyHeader('User-Agent', 'CLIQZ');
                    state.incrementStat('override_user_agent');
                  }
                }
              }
            }, {
              name: 'checkHasCookie',
              spec: 'break',
              fn: state => {
                state.cookieData = state.getCookieData();
                const hasCookie = state.cookieData && state.cookieData.length > 5;
                if (hasCookie) {
                  state.incrementStat('cookie_set');
                }
                return hasCookie === true;
              }
            }, {
              name: 'checkIsCookieWhitelisted',
              spec: 'break',
              fn: state => this.checkIsCookieWhitelisted(state)
            }, {
              name: 'cookieContext.checkCookieTrust',
              spec: 'break',
              fn: state => steps.cookieContext.checkCookieTrust(state)
            }, {
              name: 'cookieContext.checkVisitCache',
              spec: 'break',
              fn: state => steps.cookieContext.checkVisitCache(state)
            }, {
              name: 'cookieContext.checkContextFromEvent',
              spec: 'break',
              fn: state => steps.cookieContext.checkContextFromEvent(state)
            }, {
              name: 'shouldBlockCookie',
              spec: 'break',
              fn: state => {
                const shouldBlock = this.isCookieEnabled(state.sourceUrlParts.hostname) && !this.config.paused;
                if (!shouldBlock) {
                  state.incrementStat('bad_cookie_sent');
                }
                return shouldBlock;
              }
            }, {
              name: 'blockCookie',
              spec: 'blocking',
              fn: (state, response) => {
                state.incrementStat('cookie_blocked');
                state.incrementStat('cookie_block_tp1');
                response.modifyHeader('Cookie', '');
                if (this.config.sendAntiTrackingHeader) {
                  response.modifyHeader(this.config.cliqzHeader, ' ');
                }
              }
            }]);

            // ------------------------------------- \\
            // create pipeline for onHeadersReceived \\
            // ------------------------------------- \\
            this.pipelines.onHeadersReceived = new Pipeline('antitracking.onHeadersReceived', [{
              name: 'checkMainDocumentRedirects',
              spec: 'break',
              fn: state => {
                if (state.isFullPage()) {
                  if ([300, 301, 302, 303, 307].indexOf(state.responseStatus) !== -1) {
                    // redirect, update location for tab
                    // if no redirect location set, stage the tab id so we don't get false data
                    const redirectUrl = state.getResponseHeader('Location');
                    let redirectUrlParts = URLInfo.get(redirectUrl) || {};
                    // if redirect is relative, use source domain
                    if (!redirectUrlParts.hostname) {
                      redirectUrlParts = URLInfo.get(`${state.urlParts.toString()}${redirectUrl}`);
                    }
                    this.tp_events.onRedirect(redirectUrlParts, state.tabId, state.isPrivate);
                  }
                  return false;
                }
                return true;
              }
            }, {
              name: 'skipInvalidSource',
              spec: 'break',
              fn: skipInvalidSource
            }, {
              name: 'skipInternalProtocols',
              spec: 'break',
              fn: skipInternalProtocols
            }, {
              name: 'skipBadSource',
              spec: 'break',
              fn: state => state.sourceUrl && state.sourceUrl !== '' && state.sourceUrl.indexOf('about:') === -1
            }, {
              name: 'checkSameGeneralDomain',
              spec: 'break',
              fn: checkSameGeneralDomain
            }, {
              name: 'redirectTagger.checkRedirectStatus',
              spec: 'break',
              fn: state => steps.redirectTagger.checkRedirectStatus(state)
            }, {
              name: 'pageLogger.attachStatCounter',
              spec: 'annotate',
              fn: state => steps.pageLogger.attachStatCounter(state)
            }, {
              name: 'logResponseStats',
              spec: 'collect',
              fn: state => {
                if (state.incrementStat) {
                  state.incrementStat('resp_ob');
                  state.incrementStat('content_length', parseInt(state.getResponseHeader('Content-Length'), 10) || 0);
                  state.incrementStat(`status_${state.responseStatus}`);
                  state.incrementStat(state.isCached ? 'cached' : 'not_cached');
                }
              }
            }, {
              name: 'checkSetCookie',
              spec: 'break',
              fn: state => {
                // if there is a set-cookie header, continue
                const setCookie = state.getResponseHeader('Set-Cookie');
                if (setCookie) {
                  state.incrementStat('set_cookie_set');
                  return true;
                }
                return false;
              }
            }, {
              name: 'shouldBlockCookie',
              spec: 'break',
              fn: state => this.isCookieEnabled(state.sourceUrlParts.hostname)
            }, {
              name: 'checkIsCookieWhitelisted',
              spec: 'break',
              fn: state => this.checkIsCookieWhitelisted(state)
            }, {
              name: 'cookieContext.checkCookieTrust',
              spec: 'break',
              fn: state => steps.cookieContext.checkCookieTrust(state)
            }, {
              name: 'cookieContext.checkVisitCache',
              spec: 'break',
              fn: state => steps.cookieContext.checkVisitCache(state)
            }, {
              name: 'cookieContext.checkContextFromEvent',
              spec: 'break',
              fn: state => steps.cookieContext.checkContextFromEvent(state)
            }, {
              name: 'blockSetCookie',
              spec: 'blocking',
              fn: (state, response) => {
                response.modifyHeader('Set-Cookie', '');
                state.incrementStat('set_cookie_blocked');
              }
            }]);

            // Add steps to the global web request pipeline
            return Promise.all(Object.keys(this.pipelines).map(stage => this.webRequestPipeline.action('addPipelineStep', stage, {
              name: `antitracking.${stage}`,
              spec: 'blocking',
              fn: function fn() {
                return _this.pipelines[stage].execute(...arguments);
              }
            })));
          });
        }

        unloadPipeline() {
          Object.keys(this.pipelineSteps || {}).forEach(key => {
            const step = this.pipelineSteps[key];
            if (step.unload) {
              step.unload();
            }
          });

          Object.keys(this.pipelines).forEach(stage => {
            this.pipelines[stage].unload();
          });

          // Remove steps to the global web request pipeline
          // NOTE: this is async but the result can be ignored when the extension is
          // unloaded. This is because the background from webrequest-pipeline has
          // a synchronous `unload` method which will clean up everything anyway.
          // But if we reload only the antitracking module, we need to be sure we
          // removed the steps before we try to add them again.
          return Promise.all(Object.keys(this.pipelines).map(stage => ifModuleEnabled(this.webRequestPipeline.action('removePipelineStep', stage, `antitracking.${stage}`)))).then(() => {
            this.pipelines = {};
          });
        }

        /** Per-window module initialisation
        */
        initWindow(window) {
          if (getBrowserMajorVersion() < this.MIN_BROWSER_VERSION) {
            return;
          }
          this.getPrivateValues(window);
        }

        unload() {
          // don't need to unload if disabled
          if (getBrowserMajorVersion() >= this.MIN_BROWSER_VERSION) {
            // Check is active usage, was sent
            this.hashProb.unload();
            this.qs_whitelist.destroy();

            // force send tab telemetry data
            // NOTE - this is an async operation
            this.tp_events.commit(true, true);
            this.tp_events.push(true);

            pm.stop();

            this.unloadPipeline();

            CliqzEvents.clean_channel('attrack:safekeys_updated');
          }
        }

        checkInstalledAddons() {
          checkInstalledPrivacyAddons().then(adds => {
            this.similarAddon = adds;
          }).catch(() => {
            // rejection expected on platforms which do not support addon check
          });
        }

        hourChanged() {
          // trigger other hourly events
          CliqzEvents.pub('attrack:hour_changed');
        }

        isInWhitelist(domain) {
          if (!this.config.cookieWhitelist) return false;
          const keys = this.config.cookieWhitelist;
          for (let i = 0; i < keys.length; i += 1) {
            const ind = domain.indexOf(keys[i]);
            if (ind >= 0) {
              if (ind + keys[i].length === domain.length) return true;
            }
          }
          return false;
        }

        cancelRecentlyModified(state, response) {
          const sourceTab = state.tabId;
          const url = state.url;
          if (this.recentlyModified.contains(sourceTab + url)) {
            this.recentlyModified.delete(sourceTab + url);
            response.block();
            return false;
          }
          return true;
        }

        applyBlock(state, _response) {
          const response = _response;
          const badTokens = state.badTokens;
          let rule = this.getDefaultRule();
          const trackerTxt = TrackerTXT.get(state.sourceUrlParts);

          if (!this.isForceBlockEnabled() && this.isTrackerTxtEnabled()) {
            if (trackerTxt.last_update === null) {
              // The first update is not ready yet for this first party, allow it
              state.incrementStat(`tracker.txt_not_ready${rule}`);
              return false;
            }
            rule = trackerTxt.getRule(state.urlParts.hostname);
          }

          if (this.debug) {
            console$1.log('ATTRACK', rule, 'URL:', state.urlParts.hostname, state.urlParts.path, 'TOKENS:', badTokens);
          }

          if (rule === 'block') {
            state.incrementStat(`token_blocked_${rule}`);
            response.block();
            response.shouldIncrementCounter = true;
            return false;
          }

          let tmpUrl = state.url;
          for (let i = 0; i < badTokens.length; i += 1) {
            if (tmpUrl.indexOf(badTokens[i]) === -1) {
              badTokens[i] = encodeURIComponent(badTokens[i]);
            }
            tmpUrl = tmpUrl.replace(badTokens[i], this.obfuscate(badTokens[i], rule));
          }

          // In case unsafe tokens were in the hostname, the URI is not valid
          // anymore and we can cancel the request.
          if (!tmpUrl.startsWith(`${state.urlParts.protocol}://${state.urlParts.hostname}`)) {
            response.block();
            return false;
          }

          state.incrementStat(`token_blocked_${rule}`);

          // TODO: do this nicer
          // if (this.pipelineSteps.trackerProxy && this.pipelineSteps.trackerProxy.shouldProxy(tmpUrl)) {
          //     state.incrementStat('proxy');
          // }
          this.recentlyModified.add(state.tabId + state.url, 30000);
          this.recentlyModified.add(state.tabId + tmpUrl, 30000);

          response.redirectTo(tmpUrl);
          response.modifyHeader(this.config.cliqzHeader, ' ');
          return true;
        }

        checkIsCookieWhitelisted(state) {
          if (this.isInWhitelist(state.urlParts.hostname)) {
            const stage = state.responseStatus !== undefined ? 'set_cookie' : 'cookie';
            state.incrementStat(`${stage}_allow_whitelisted`);
            return false;
          }
          return true;
        }

        /** Get info about trackers and blocking done in a specified tab.
         *
         *  Returns an object describing anti-tracking actions for this page, with keys as follows:
         *    cookies: 'allowed' and 'blocked' counts.
         *    requests: 'safe' and 'unsafe' counts. 'Unsafe' means that unsafe data
         *      was seen in a request to a tracker.
         *    trackers: more detailed information about each tracker. Object with
         *      keys being tracker domain and values more detailed blocking data.
         */
        getTabBlockingInfo(tabId, url) {
          const result = {
            url,
            tab: tabId,
            hostname: '',
            path: '',
            cookies: { allowed: 0, blocked: 0 },
            requests: { safe: 0, unsafe: 0 },
            trackers: {},
            companies: {},
            companyInfo: {},
            ps: null
          };

          // ignore special tabs
          if (url && (url.startsWith('about') || url.startsWith('chrome') || url.startsWith('resource'))) {
            result.error = 'Special tab';
            return Promise.resolve(result);
          }

          if (!(tabId in this.tp_events._active)) {
            // no tp event, but 'active' tab = must reload for data
            // otherwise -> system tab
            return checkIsWindowActive(tabId).then(active => {
              if (active) {
                result.reload = true;
              }

              result.error = 'No Data';
              return result;
            });
          }

          const tabData = this.tp_events._active[tabId];
          const plainData = tabData.asPlainObject();
          const trackers = Object.keys(plainData.tps).filter(domain => Promise.resolve(this.qs_whitelist.isTrackerDomain(cachedMD5(getGeneralDomain(domain)).substring(0, 16)) || plainData.tps[domain].blocked_blocklist > 0));

          // const firstPartyCompany = domainInfo.domainOwners[getGeneralDomain(tabData.hostname)];
          result.hostname = tabData.hostname;
          result.path = tabData.path;

          trackers.forEach(dom => {
            result.trackers[dom] = {};
            ['c', 'cookie_set', 'cookie_blocked', 'bad_cookie_sent', 'bad_qs', 'set_cookie_blocked', 'blocked_blocklist'].forEach(k => {
              result.trackers[dom][k] = plainData.tps[dom][k] || 0;
            });

            // actual block count can be in several different signals, depending on
            // configuration. Aggregate them into one.
            result.trackers[dom].tokens_removed = ['empty', 'replace', 'placeholder', 'block'].reduce((cumsum, action) => cumsum + (plainData.tps[dom][`token_blocked_${action}`] || 0), 0);
            result.trackers[dom].tokens_removed += plainData.tps[dom].blocked_blocklist || 0 + plainData.tps[dom].blocked_external || 0;

            result.cookies.allowed += result.trackers[dom].cookie_set - result.trackers[dom].cookie_blocked;
            result.cookies.blocked += result.trackers[dom].cookie_blocked + result.trackers[dom].set_cookie_blocked;
            result.requests.safe += result.trackers[dom].c - result.trackers[dom].tokens_removed;
            result.requests.unsafe += result.trackers[dom].tokens_removed;

            // add set cookie blocks to cookie blocked count
            result.trackers[dom].cookie_blocked += result.trackers[dom].set_cookie_blocked;

            const company = getDomainOwner(dom);
            result.companyInfo[company.name] = company;

            if (!(company.name in result.companies)) {
              result.companies[company.name] = [];
            }
            result.companies[company.name].push(dom);
          });

          return Promise.resolve(result);
        }

        getCurrentTabBlockingInfo(window) {
          return getActiveTab(window).then(_ref2 => {
            let id = _ref2.id,
                url = _ref2.url;
            return this.getTabBlockingInfo(id, url);
          });
        }

        getTrackerListForTab(tabId) {
          return this.getTabBlockingInfo(tabId).then(info => {
            const revComp = {};
            Object.keys(info.companies).forEach(comp => {
              info.companies[comp].forEach(domain => {
                revComp[domain] = comp;
              });
            });
            return Object.keys(info.trackers).map(domain => {
              const name = revComp[domain] || getGeneralDomain(domain);
              const count = info.trackers[domain].tokens_removed || 0;
              return { name, count };
            }).reduce((acc, val) => {
              acc[val.name] = (acc[val.name] || 0) + val.count;
              return acc;
            }, {});
          });
        }

        /**
         * Returns bugIds for a tab (based on Ghostery schema)
         */
        getAppsForTab(tabId) {
          const tabData = this.tp_events._active[tabId];
          if (!tabData) {
            return Promise.reject();
          }
          const apps = {
            known: {},
            unknown: {}
          };

          function actionName(blocked, unsafe) {
            if (blocked) {
              return 'blocked';
            }
            if (unsafe) {
              return 'unsafe';
            }
            return 'safe';
          }

          // blocked by antitracking blocker
          if (tabData.annotations.apps) {
            tabData.annotations.apps.forEach((action, app) => {
              apps.known[getBugOwner(app)] = actionName(action === 'BLOCK', action === 'ALLOW_UNSAFE');
            });
          }
          // blocked/seen by antitracking
          return this.getTabBlockingInfo(tabId).then(info => {
            Object.keys(info.trackers).forEach(domain => {
              const tld = getGeneralDomain(domain);
              const id = domainInfo.domains[tld];
              const blocked = info.trackers[domain].tokens_removed > 0 || info.trackers[domain].blocked_blocklist > 0;
              const unsafe = info.trackers[domain].bad_qs > 0 || info.trackers[domain].cookie_blocked > 0 || info.trackers[domain].set_cookie_blocked > 0;
              if (id) {
                apps.known[id] = actionName(blocked || apps.known[id] === true, unsafe);
              } else {
                apps.unknown[tld] = actionName(blocked, unsafe);
              }
            });

            return apps;
          });
        }

        /** Enables Attrack module with cookie, QS and referrer protection enabled.
         *  if module_only is set to true, will not set preferences for cookie, QS
         *  and referrer protection (for selective loading in AB tests)
         */
        enableModule(moduleOnly) {
          if (this.isEnabled()) {
            return;
          }

          this.config.setPref('enabled', true);
          if (!moduleOnly) {
            this.config.setPref('cookieEnabled', true);
            this.config.setPref('qsEnabled', true);
          }
        }

        /** Disables anti-tracking immediately.
        */
        disableModule() {
          CliqzUtils.setPref(this.config.PREFS.enabled, false);
        }

        logWhitelist(payload) {
          this.telemetry({
            message: {
              type: telemetry$1.msgType,
              action: 'attrack.whitelistDomain',
              payload
            },
            raw: true
          });
        }

        clearCache() {
          if (this.pipelineSteps.tokenExaminer) {
            this.pipelineSteps.tokenExaminer.clearCache();
          }
          if (this.pipelineSteps.tokenChecker) {
            this.pipelineSteps.tokenChecker.tokenDomain.clear();
          }
        }
      }

      /**
      * @namespace antitracking
      * @class Background
      */
      var AttrackBG = background({
        // Injected in window.es
        // controlCenter: inject.module('control-center'),

        requiresServices: ['cliqz-config'],

        /**
        * @method init
        * @param settings
        */
        init(settings) {
          // Create new attrack class
          this.settings = settings;
          this.attrack = new CliqzAttrack();

          if (getBrowserMajorVersion() < MIN_BROWSER_VERSION) {
            return Promise.resolve();
          }

          // fix for users without pref properly set: set to value from build config
          if (!CliqzUtils.hasPref('attrackRemoveQueryStringTracking')) {
            CliqzUtils.setPref('attrackRemoveQueryStringTracking', true);
          }

          // indicates if the antitracking background is initiated
          this.enabled = true;
          this.clickCache = {};

          CliqzUtils.bindObjectFunctions(this.popupActions, this);

          // inject configured telemetry module
          // do not initiate if disabled from config
          if (!settings.DISABLE_ATTRACK_TELEMETRY) {
            telemetry$1.loadFromProvider(settings.ATTRACK_TELEMETRY_PROVIDER || 'human-web', settings.HW_CHANNEL);
          }

          // load config
          this.config = new Config({});
          return this.config.init().then(() => this.attrack.init(this.config));
        },

        /**
        * @method unload
        */
        unload() {
          if (getBrowserMajorVersion() < MIN_BROWSER_VERSION) {
            this.enabled = false;
            return;
          }

          if (this.attrack !== null) {
            this.attrack.unload();
            this.attrack = null;
          }

          this.enabled = false;
        },

        actions: {
          getCurrentTabBlockingInfo() {
            return this.attrack.getCurrentTabBlockingInfo();
          },
          addPipelineStep(stage, opts) {
            if (!this.attrack.pipelines || !this.attrack.pipelines[stage]) {
              return Promise.reject(`Could not add pipeline step: ${stage}, ${opts.name}`);
            }

            return this.attrack.pipelines[stage].addPipelineStep(opts);
          },
          removePipelineStep(stage, name) {
            if (this.attrack && this.attrack.pipelines && this.attrack.pipelines[stage]) {
              this.attrack.pipelines[stage].removePipelineStep(name);
            }
          },
          telemetry(opts) {
            return this.attrack.telemetry(opts);
          },
          getWhitelist() {
            return this.attrack.qs_whitelist;
          },
          getTabTracker() {
            return this.attrack.tp_events;
          },
          getTrackerListForTab(tab) {
            return this.attrack.getTrackerListForTab(tab);
          },
          aggregatedBlockingStats(tabId) {
            return this.attrack.getAppsForTab(tabId).then(info => {
              const stats = {};

              Object.keys(info.known || {}).forEach(appId => {
                const company = getAppOwner(appId);
                if (!company) {
                  return;
                }
                if (!stats[company.cat]) {
                  stats[company.cat] = {};
                }
                stats[company.cat][company.name] = info.known[appId];
              });

              Object.keys(info.unknown).forEach(tld => {
                if (!stats.unknown) {
                  stats.unknown = {};
                }
                stats.unknown[tld] = info.unknown[tld];
              });

              return stats;
            });
          },
          isEnabled() {
            return this.enabled;
          },
          disable() {
            this.unload();
          },
          enable() {
            this.init(this.settings);
          },

          isWhitelisted(url) {
            return this.attrack.urlWhitelist.isWhitelisted(url);
          },

          changeWhitelistState(url, type, action) {
            return this.attrack.urlWhitelist.changeState(url, type, action);
          },

          getWhitelistState(url) {
            return this.attrack.urlWhitelist.getState(url);
          },

          // legacy api for mobile
          isSourceWhitelisted(domain) {
            return this.actions.isWhitelisted(domain);
          },

          addSourceDomainToWhitelist(domain) {
            return this.actions.changeWhitelistState(domain, 'hostname', 'add');
          },

          removeSourceDomainFromWhitelist(domain) {
            return this.actions.changeWhitelistState(domain, 'hostname', 'remove');
          },

          setConfigOption(prefName, value) {
            this.config.setPref(prefName, value);
          },

          pause() {
            this.config.paused = true;
          },

          resume() {
            this.config.paused = false;
          }
        },

        popupActions: {
          /**
          * @method popupActions.toggleAttrack
          * @param args
          * @param cb Callback
          */
          toggleAttrack(args, cb) {
            var currentState = CliqzUtils.getPref('modules.antitracking.enabled', true);

            if (currentState) {
              this.attrack.disableModule();
            } else {
              this.attrack.enableModule();
            }

            cb();

            this.popupActions.telemetry({ action: 'click', 'target': currentState ? 'deactivate' : 'activate' });
          },
          /**
          * @method popupActions.closePopup
          */
          closePopup(_, cb) {
            cb();
          },
          /**
          * @method popupActions.toggleWhiteList
          * @param args
          * @param cb Callback
          */
          toggleWhiteList(args, cb) {
            var hostname = args.hostname;
            if (this.attrack.urlWhitelist.isWhitelisted(hostname)) {
              this.popupActions.telemetry({ action: 'click', target: 'unwhitelist_domain' });
            } else {
              this.popupActions.telemetry({ action: 'click', target: 'whitelist_domain' });
            }
            this.attrack.urlWhitelist.changeState(hostname, 'hostname', 'toggle');
            cb();
          },

          _isDuplicate(info) {
            const now = Date.now();
            const key = info.tab + info.hostname + info.path;

            // clean old entries
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = Object.keys(this.clickCache)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                let k = _step.value;

                if (now - this.clickCache[k] > 60000) {
                  delete this.clickCache[k];
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            if (key in this.clickCache) {
              return true;
            } else {
              this.clickCache[key] = now;
              return false;
            }
          },

          telemetry(msg) {
            if (msg.includeUnsafeCount) {
              delete msg.includeUnsafeCount;
              const info = this.attrack.getCurrentTabBlockingInfo();
              // drop duplicated messages
              if (info.error || this.popupActions._isDuplicate(info)) {
                return;
              }
              msg.unsafe_count = info.cookies.blocked + info.requests.unsafe;
              msg.special = info.error !== undefined;
            }
            msg.type = 'antitracking';
            CliqzUtils.telemetry(msg);
          }
        },

        status() {
          const enabled = CliqzUtils.getPref('modules.antitracking.enabled', true);
          return {
            visible: true,
            strict: CliqzUtils.getPref('attrackForceBlock', false),
            state: enabled ? 'active' : 'critical',
            totalCount: 0
          };
        },

        events: {
          "prefchange": function onPrefChange(pref) {
            if (pref === DEFAULT_ACTION_PREF) {
              updateDefaultTrackerTxtRule();
            } else if (pref === 'config_ts') {
              // update date timestamp set in humanweb
              updateTimestamp(CliqzUtils.getPref('config_ts', null));
            }
            this.config.onPrefChange(pref);
          },
          "content:dom-ready": function onDomReady(url) {
            const domChecker = this.attrack.pipelineSteps.domChecker;

            if (!domChecker) {
              return;
            }

            domChecker.loadedTabs[url] = true;
            domChecker.recordLinksForURL(url);
            domChecker.clearDomLinks();
          },
          "antitracking:whitelist:add": function antitrackingWhitelistAdd(hostname) {
            this.attrack.urlWhitelist.changeState(hostname, 'hostname', 'add');
            this.attrack.logWhitelist(hostname);
            this.popupActions.telemetry({
              action: 'click',
              target: 'whitelist_domain'
            });
          },
          "antitracking:whitelist:remove": function antitrackingWhitelistRemove(hostname) {
            this.attrack.urlWhitelist.changeState(hostname, 'hostname', 'remove');
            this.popupActions.telemetry({
              action: 'click',
              target: 'unwhitelist_domain'
            });
          },
          "control-center:antitracking-strict": function controlCenterAntitrackingStrict() {
            CliqzUtils.setPref('attrackForceBlock', !CliqzUtils.getPref('attrackForceBlock', false));
          },
          "core:mouse-down": function coreMouseDown() {
            if (this.attrack.pipelineSteps.cookieContext) {
              this.attrack.pipelineSteps.cookieContext.setContextFromEvent.apply(this.attrack.pipelineSteps.cookieContext, arguments);
            }
          },
          "control-center:antitracking-clearcache": function controlCenterAntitrackingClearcache() {
            this.attrack.clearCache();
            this.popupActions.telemetry({
              action: 'click',
              target: 'clearcache'
            });
          }
        }
      });

      function onLocationChange$1(_ref) {
        let url = _ref.url,
            windowId = _ref.windowId,
            tabId = _ref.tabId;

        if (this.windowId !== windowId) {
          return;
        }

        if (this.interval) {
          CliqzUtils.clearInterval(this.interval);
        }

        var counter = 8;

        this.updateBadge({ tabId, url });

        this.interval = CliqzUtils.setInterval(function () {
          this.updateBadge({ tabId, url });

          counter -= 1;
          if (counter <= 0) {
            CliqzUtils.clearInterval(this.interval);
          }
        }.bind(this), 2000);
      }

      class Win$11 {

        constructor(_ref2) {
          let window = _ref2.window,
              windowId = _ref2.windowId;

          this.window = window;
          this.windowId = windowId;
          this.controlCenter = inject.module('control-center');

          this.onLocationChange = onLocationChange$1.bind(this);
          this.enabled = false;
        }

        init() {
          if (this.controlCenter.isEnabled()) {
            this.onLocationChangeSubscription = CliqzEvents.subscribe("content:location-change", _ref3 => {
              let windowId = _ref3.windowId,
                  url = _ref3.url,
                  tabId = _ref3.windowTreeInformation.tabId;
              return this.onLocationChange({ windowId, url, tabId });
            });
            this.onTabSelect = CliqzEvents.subscribe('core:tab_select', this.onLocationChange);
          }
        }

        unload() {
          if (this.onLocationChangeSubscription) {
            this.onLocationChangeSubscription.unsubscribe();
          }
          if (this.onTabSelect) {
            this.onTabSelect.unsubscribe();
          }
          CliqzUtils.clearInterval(this.interval);
        }

        getBadgeData(info) {
          if (AttrackBG.attrack.urlWhitelist.isWhitelisted(info.hostname)) {
            // do not display number if site is whitelisted
            return 0;
          } else {
            return info.cookies.blocked + info.requests.unsafe;
          }
        }

        updateBadge(_ref4) {
          let tabId = _ref4.tabId,
              url = _ref4.url;

          AttrackBG.attrack && AttrackBG.attrack.getTabBlockingInfo(tabId, url).then(info => {
            this.controlCenter.windowAction(this.window, 'setBadge', this.getBadgeData(info));
          });
        }

        status() {
          return AttrackBG.attrack.getCurrentTabBlockingInfo(this.window).then(info => {
            const url = URLInfo.get(info.url);
            const ps = info.ps;
            const hostname = url ? url.hostname : '';
            const isWhitelisted = AttrackBG.attrack.urlWhitelist.isWhitelisted(hostname);
            const enabled = CliqzUtils.getPref('modules.antitracking.enabled', true) && !isWhitelisted;

            return {
              visible: true,
              strict: CliqzUtils.getPref('attrackForceBlock', false),
              hostname,
              cookiesCount: info.cookies.blocked,
              requestsCount: info.requests.unsafe,
              totalCount: info.cookies.blocked + info.requests.unsafe,
              badgeData: this.getBadgeData(info),
              enabled,
              isWhitelisted: isWhitelisted || enabled,
              reload: info.reload || false,
              trackersList: info,
              ps,
              state: enabled ? 'active' : isWhitelisted ? 'inactive' : 'critical'
            };
          });
        }
      }

      var antitrackingModule = {
        Background: AttrackBG,
        Window: Win$11
      };

      const regexGoogleRef = /\.google\..*?\/(?:url|aclk)\?/;
      const regexGoogleQuery = /\.google\..*?[#?&;]q=[^$&]+/;
      const regexGoogleAdRef = /\.google\..*?\/aclk\?/;
      const regexGoogleRefUrl = /url=(.+?)&/;

      var Background$12 = background({
        enabled() {
          return true;
        },

        init() {},

        unload() {},

        beforeBrowserShutdown() {},

        events: {
          'content:location-change': function onTabLocationChange(_ref) {
            let url = _ref.url;

            // create a telemetry signal for each location change
            CliqzUtils.telemetry({
              'type': 'navigation',
              'action': 'location_change'
            });

            if (url === this.currentUrl || !this.lastResult) {
              return;
            }

            this.currentUrl = url;
            // here we check if user ignored our results and went to google and landed on the same url
            if (regexGoogleQuery.test(this.currentUrl) && !regexGoogleRef.test(this.currentUrl)) {
              this.afterQueryCount += 1;
            }
          },

          'core.tab_state_change': function onTabStateChange(_ref2) {
            let url = _ref2.url,
                isValid = _ref2.isValid;

            const isGoogleRef = regexGoogleRef.test(url);

            if (!isValid || !isGoogleRef) {
              return;
            }

            const isGoogleAd = regexGoogleAdRef.test(url);
            const googleUrlMatch = !isGoogleAd && url.match(regexGoogleRefUrl);
            const cliqzResults = this.lastResult && this.lastResult._results;

            let cliqzResultType = null;
            let cliqzResultIndex = null;
            let isSameResult = false;

            if (!isGoogleAd && this.isLastPopupOpen && googleUrlMatch) {
              const googleUrl = CliqzUtils.generalizeUrl(decodeURIComponent(googleUrlMatch[1]));

              isSameResult = cliqzResults && cliqzResults.some((r, i) => {
                const cliqzUrl = CliqzUtils.generalizeUrl(r.val);

                if (cliqzUrl === googleUrl) {
                  cliqzResultType = CliqzUtils.encodeResultType(r.style || r.type);
                  cliqzResultIndex = i;
                  return true;
                }
                return false;
              });
            }

            this.sendCompSignal('result_compare', {
              isRedirect: true,
              isGoogleAd,
              isSameResult,
              cliqzResultType,
              cliqzResultIndex
            });
          },

          'autocomplete.new_result': function onNewResult(_ref3) {
            let result = _ref3.result,
                isPopupOpen = _ref3.isPopupOpen;

            this.afterQueryCount = 0;
            this.lastResult = result;
            this.isLastPopupOpen = isPopupOpen;
          }
        },

        sendCompSignal(actionName, options) {
          const action = {
            type: 'performance',
            redirect: options.isRedirect,
            action: actionName,
            query_made: this.afterQueryCount,
            popup: this.isLastPopupOpen,
            same_result: options.isSameResult,
            result_type: options.cliqzResultType,
            result_position: options.cliqzResultIndex,
            is_ad: options.isGoogleAd,
            v: 1
          };
          CliqzUtils.telemetry(action);
        }

      });

      class Win$12 {
        constructor() {}

        init() {}

        unload() {}
      }

      var performanceModule = {
        Background: Background$12,
        Window: Win$12
      };

      var Storage$3 = class {
        constructor(CliqzSecureMessage) {
          this.CliqzSecureMessage = CliqzSecureMessage;
          this.dbName = 'cliqz.dbhumanweb';

          if (fileExists$1(this.dbName)) {
            this.connection = open(this.dbName);
          } else {
            this.connection = open(this.dbName);
          }

          // Need to check for create table, even if the DB already exists.
          this.createTable();
        }

        createTable() {
          const localcheck = `create table if not exists localcheck(
      id VARCHAR(24) PRIMARY KEY NOT NULL,
      data VARCHAR(1000000)
    )`;
          (this.connection.executeSimpleSQLAsync || this.connection.executeSimpleSQL)(localcheck);
        }

        close() {
          close(this.dbName);
          this.connnection = null;
        }

        saveRecord(id, data) {
          if (!this.connection) {
            return;
          }
          const st = this.connection.createStatement('INSERT OR REPLACE INTO localcheck (id,data) VALUES (:id, :data)');
          st.params.id = id;
          st.params.data = data;

          st.executeAsync({
            handleError: aError => {
              if (this.CliqzSecureMessage && this.CliqzSecureMessage.debug) {
                console$1.log(`SQL error: ${aError.message}`, this.CliqzSecureMessage.LOG_KEY);
              }
            },
            handleCompletion: () => {
              if (this.CliqzSecureMessage && this.CliqzSecureMessage.debug) {
                console$1.log('Insertion success', this.CliqzSecureMessage.LOG_KEY);
              }
            }
          });
        }

        loadRecord(id, callback) {
          const stmt = this.connection.createAsyncStatement('SELECT id, data FROM localcheck WHERE id = :id;');
          stmt.params.id = id;

          const res = [];
          stmt.executeAsync({
            handleResult: aResultSet => {
              if (!this.CliqzSecureMessage) {
                return;
              }
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                if (row.getResultByName('id') === id) {
                  res.push(row.getResultByName('data'));
                } else {
                  if (this.CliqzSecureMessage.debug) {
                    console$1.log('There are more than one record', this.CliqzSecureMessage.LOG_KEY);
                  }
                  callback(null);
                }
                break;
              }
            },
            handleError: aError => {
              if (!this.CliqzSecureMessage) return;
              if (this.CliqzSecureMessage.debug) {
                console$1.log(`SQL error: ${aError.message}`, this.CliqzSecureMessage.LOG_KEY);
              }
              callback(null);
            },
            handleCompletion: () => {
              if (!this.CliqzSecureMessage) {
                return;
              }
              if (res.length === 1) {
                callback(res[0]);
              } else {
                callback(null);
              }
            }
          });
        }

        loadKeys() {
          return new Promise(resolve => {
            this.loadRecord('userKey', data => {
              if (!data) {
                if (this.CliqzSecureMessage.debug) {
                  console$1.log('There was no key for the user', this.CliqzSecureMessage.LOG_KEY);
                }
                resolve(null);
              } else {
                try {
                  resolve(JSON.parse(data));
                } catch (ee) {
                  resolve(null);
                }
              }
            });
          });
        }

        saveKeys(_data) {
          return new Promise(resolve => {
            if (!this.connection) {
              return;
            }
            const st = this.connection.createStatement('INSERT OR REPLACE INTO localcheck (id,data) VALUES (:id, :data)');
            st.params.id = 'userKey';
            st.params.data = JSON.stringify(_data);

            st.executeAsync({
              handleError: aError => {
                if (this.CliqzSecureMessage && this.CliqzSecureMessage.debug) {
                  if (this.CliqzSecureMessage.debug) {
                    console$1.log(`SQL error: ${aError.message}`, this.CliqzSecureMessage.LOG_KEY);
                  }
                  resolve({ status: false, data: _data });
                }
              },
              handleCompletion: () => {
                if (this.CliqzSecureMessage && this.CliqzSecureMessage.debug) {
                  if (this.CliqzSecureMessage.debug) {
                    console$1.log('Insertion success', this.CliqzSecureMessage.LOG_KEY);
                  }
                  resolve({ status: true, data: _data });
                }
              }
            });
          });
        }

        loadLocalCheckTable() {
          this.loadRecord('localTemporalUniq', data => {
            if (!data) {
              if (this.CliqzSecureMessage.debug) {
                console$1.log('There was no data on action stats', this.CliqzSecureMessage.LOG_KEY);
              }
              this.CliqzSecureMessage.localTemporalUniq = {};
            } else {
              try {
                this.CliqzSecureMessage.localTemporalUniq = JSON.parse(data);
              } catch (ee) {
                console$1.log(`Loading local uniq: ${ee}`, this.CliqzSecureMessage.LOG_KEY);
                this.CliqzSecureMessage.localTemporalUniq = {};
              }
            }
          });
        }

        saveLocalCheckTable() {
          if (this.CliqzSecureMessage.localTemporalUniq) {
            this.saveRecord('localTemporalUniq', JSON.stringify(this.CliqzSecureMessage.localTemporalUniq));
          }
        }
      };

      class CryptoWorker {
        // the name is optional (it is only relevant for debugging)
        constructor(name) {
          this.worker = new Worker(`${config.baseURL}hpn/worker.bundle.js?name=${name || ''}`, { name });
        }

        set onmessage(fn) {
          this.worker.onmessage = fn;
        }

        postMessage() {
          this.worker.postMessage(...arguments);
        }

        terminate() {
          this.worker.terminate();
        }
      }

      class MessageSender {
        constructor() {
          let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.hpnv2 = inject.module('hpnv2');
          // by default, use CryptoWorker and the global CliqzSecureMessage
          // (unless overwritten by tests)
          const CryptoWorkerImpl = args.CryptoWorker || CryptoWorker;
          this._CliqzSecureMessage = args._CliqzSecureMessage || CliqzSecureMessage;

          this.log('MessageSender: starting crypto worker');
          this.cryptoWorker = new CryptoWorkerImpl('message-sender');

          // in the beginning, there are no pending communications
          this.pendingCommunications = Promise.resolve();
        }

        stop() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { quick: false };

          let quick = _ref.quick;

          const killWorker = () => {
            const worker = this.cryptoWorker;
            if (worker) {
              this.log('MessageSender: stopping crypto worker');
              delete this.cryptoWorker;
              worker.terminate();
            }
          };

          if (quick) {
            killWorker();
            return Promise.resolve();
          }
          return this.pendingCommunications.then(killWorker, killWorker);
        }

        /**
         * This will sequentially send all given messages.
         *
         * Returns a promise that allows to wait for the operation
         * to complete.
         */
        send(messages) {
          messages.forEach(_msg => {
            const msg = _msg;
            if (this.hpnv2.isEnabled()) {
              if (msg && typeof msg === 'object') {
                msg.hpnv2 = true;
              }
              this.hpnv2.action('send', msg).catch(() => {});
            }
            this._sendSingleMessage(msg);
          });

          // There is no real error handling, so we ignore rejected
          // promises. Also avoid Promise.all, as we do not want
          // fail-fast behavior.
          return this.pendingCommunications.then(() => {}, () => {});
        }

        _sendSingleMessage(message) {
          const prevPendingSends = this.pendingCommunications;
          this.pendingCommunications = new Promise((resolve, reject) => {
            const _CliqzSecureMessage = this._CliqzSecureMessage;
            const postMessage = () => {
              if (!this.cryptoWorker) {
                this.log('Discarding message, as the web worker is already stopped.');
                reject();
                return;
              }

              // At this point, we know that the worker is idle,
              // so we can overwrite "onmessage".
              this.cryptoWorker.onmessage = e => {
                if (e.data.type === 'telemetry') {
                  _CliqzSecureMessage.localTemporalUniq = e.data.localTemporalUniq;
                  _CliqzSecureMessage.storage.saveLocalCheckTable();
                }

                resolve();
              };

              // Passes one message to the web worker, which does the actual sending.
              try {
                this.cryptoWorker.postMessage({
                  msg: message,
                  type: 'telemetry',
                  sourcemap: _CliqzSecureMessage.sourceMap,
                  upk: _CliqzSecureMessage.uPK,
                  dspk: _CliqzSecureMessage.dsPK,
                  sspk: _CliqzSecureMessage.secureLogger,
                  routetable: _CliqzSecureMessage.routeTable,
                  localTemporalUniq: _CliqzSecureMessage.localTemporalUniq
                });
              } catch (e) {
                this.log('Failed to send message', e);
                reject(e);
              }
            };

            // Wait until all pending messages are sent. Here, it does not
            // matter if sending was successful or not. In both cases,
            // continue with sending the message to the web worker, which
            // will do the actual work (cryptography + HTTP request).
            return prevPendingSends.then(postMessage).catch(postMessage);
          });
          return this.pendingCommunications;
        }

        log() {
          if (this._CliqzSecureMessage.debug) {
            console$1.log(...arguments);
          }
        }
      }

      /*
      Converts given array to generator like object.
      */

      function prunelocalTemporalUniq() {
        if (CliqzSecureMessage.localTemporalUniq && Object.keys(CliqzSecureMessage.localTemporalUniq).length > 0) {
          const currTime = Date.now();
          let pi = 0;
          Object.keys(CliqzSecureMessage.localTemporalUniq).forEach(e => {
            const d = CliqzSecureMessage.localTemporalUniq[e].ts;
            const diff = currTime - d;
            if (diff >= 24 * 60 * 60 * 1000) {
              delete CliqzSecureMessage.localTemporalUniq[e];
              pi += 1;
            }
          });
          /*
          if(CliqzHumanWeb.actionStats) {
              const itemsLocalValidation = Object.keys(CliqzSecureMessage.localTemporalUniq).length;
              CliqzHumanWeb.actionStats.itemsLocalValidation = itemsLocalValidation;
          }
          */
        }
      }

      function getRandomIntInclusive$1(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      const OFFER_TELEMETRY_PREFIX = 'https://offers-api.cliqz.com';

      let proxyHttpHandler = null;
      function overRideCliqzResults() {
        if (CliqzUtils.getPref('proxyNetwork', true) === false) return;

        if (!proxyHttpHandler) proxyHttpHandler = defaultHttpHandler;

        function httpHandler$$1(method, url, callback, onerror, timeout, data, sync) {
          if (url.startsWith(CliqzUtils.RESULTS_PROVIDER) && CliqzUtils.getPref('hpn-queryv2', false)) {
            const query = url.replace(CliqzUtils.RESULTS_PROVIDER, '');
            const uid = Math.floor(Math.random() * 10000000);
            CliqzSecureMessage.queriesID[uid] = callback;
            CliqzSecureMessage.wCrypto.postMessage({
              msg: { action: 'instant',
                type: 'cliqz',
                ts: '',
                ver: '1.5',
                payload: query,
                rp: CliqzUtils.RESULTS_PROVIDER
              },
              uid: uid,
              type: 'instant',
              sourcemap: CliqzSecureMessage.sourceMap,
              upk: CliqzSecureMessage.uPK,
              dspk: CliqzSecureMessage.dsPK,
              sspk: CliqzSecureMessage.secureLogger,
              queryProxyUrl: CliqzSecureMessage.queryProxyIP
            });
            return null;
          } else if (url.startsWith(CliqzUtils.RESULTS_PROVIDER_LOG)) {
            const query = url.replace(CliqzUtils.RESULTS_PROVIDER_LOG, '');
            const uid = Math.floor(Math.random() * 10000000);
            CliqzSecureMessage.queriesID[uid] = callback;
            CliqzSecureMessage.wCrypto.postMessage({
              msg: { action: 'extension-result-telemetry',
                type: 'cliqz',
                ts: '',
                ver: '1.5',
                payload: query
              },
              uid: uid,
              type: 'instant',
              sourcemap: CliqzSecureMessage.sourceMap,
              upk: CliqzSecureMessage.uPK,
              dspk: CliqzSecureMessage.dsPK,
              sspk: CliqzSecureMessage.secureLogger,
              queryProxyUrl: CliqzSecureMessage.queryProxyIP
            });
            return null;
          } else if (url === CliqzUtils.SAFE_BROWSING) {
            const batch = JSON.parse(data);
            if (batch.length > 0) {
              batch.forEach(eachMsg => {
                CliqzSecureMessage.telemetry(eachMsg);
              });
            }
            callback && callback({ 'response': '{"success":true}' });
          } else if (url.startsWith(OFFER_TELEMETRY_PREFIX)) {

            // Make sure that that CliqzSecureMessage.queryProxyIP exists,
            // otherwise, sending the message will silently fail.
            //
            // The queryProxyIP contains the proxy's verify endpoint
            // (e.g., "http://<proxy-ip>/verify").
            const queryProxyUrl = CliqzSecureMessage.proxyIP();
            if (!queryProxyUrl) {
              throw new Error('Failed to send message, as the list of proxies is empty');
            }

            const query = url.replace(OFFER_TELEMETRY_PREFIX, '');
            const uid = Math.floor(Math.random() * 10000000);
            CliqzSecureMessage.queriesID[uid] = callback;

            const message = {
              msg: { action: 'offers-api',
                type: 'cliqz',
                ts: '',
                ver: '1.5',
                payload: query,
                rp: OFFER_TELEMETRY_PREFIX,
                body: data
              },
              uid: uid,
              type: 'instant',
              sourcemap: CliqzSecureMessage.sourceMap,
              upk: CliqzSecureMessage.uPK,
              dspk: CliqzSecureMessage.dsPK,
              sspk: CliqzSecureMessage.secureLogger,
              queryProxyUrl: queryProxyUrl
            };
            CliqzSecureMessage.wCrypto.postMessage(message);
            return null;
          } else {
            return proxyHttpHandler.apply(undefined, arguments);
          }
          return null;
        }

        overrideHttpHandler(httpHandler$$1);
        addCompressionExclusion(CliqzUtils.SAFE_BROWSING);
      }

      var ProxyFilterBase = class {
        constructor() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { position: 0 };

          let position = _ref.position;

          this.position = position;
          this.pps = Components.classes['@mozilla.org/network/protocol-proxy-service;1'].getService(Components.interfaces.nsIProtocolProxyService);
        }

        init() {
          this.pps.registerFilter(this, this.position);
        }

        /**
         * Disable all proxy rules provided by this instance
         * @method destroy
         */
        unload() {
          this.pps.unregisterFilter(this);
        }

        /**
         * See https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIProtocolProxyService
         */
        newProxy(args) {
          // Do not perform DNS lookups on the client, but on the proxy (server-side).
          // Otherwise, it is hard to whitelist our services.
          // (This option is equivalent to 'socks5h://' in curl).
          const flags = Components.interfaces.nsIProxyInfo.TRANSPARENT_PROXY_RESOLVES_HOST;

          return this.pps.newProxyInfo(args.type, args.host, args.port, flags, args.failoverTimeout, args.failoverProxy);
        }

        /**
         * Firefox proxy API entry point - called on new http(s) connection.
         * @method applyFilter
         * @param pps
         * @param url {string}
         * @param defaultProxy
         * @returns aProxy
         */
        applyFilter(pps, url, defaultProxy, cb) {
          const proxy = this.shouldProxy(url) ? this.proxy() : defaultProxy;
          // On Firefox 60+ we need to use the callback
          if (cb && cb.onProxyFilterResult) {
            cb.onProxyFilterResult(proxy);
          } else {
            return proxy;
          }
          return undefined;
        }
      };

      /*
      Picked up from unblock proxy.es
      */

      class ProxyFilter extends ProxyFilterBase {
        /**
        * Wrapper for rule-based url proxying: implementation for Firefox
        * @class Proxy
        * @namespace unblock
        * @constructor
        */
        constructor() {
          super();
          this.method = "socks";
          this.port = 9004;
        }

        shouldProxy(url) {
          const window = CliqzUtils.getWindow();
          return url.scheme === "https" && CliqzSecureMessage.servicesToProxy.indexOf(url.host) > -1 && (CliqzUtils.getPref('hpn-query', false) || CliqzUtils.isOnPrivateTab(window));
        }

        proxy() {
          if (!CliqzSecureMessage.proxyList) {
            return;
          }
          const proxyIdx = getRandomIntInclusive$1(0, CliqzSecureMessage.proxyList.length - 1);
          const proxyHost = CliqzSecureMessage.proxyList[proxyIdx].dns;
          if (CliqzSecureMessage.debug) {
            CliqzUtils.log("Proxying Query: " + proxyHost, CliqzSecureMessage.LOG_KEY);
          }

          if (CliqzSecureMessage.proxyInfoObj[proxyHost]) {
            return CliqzSecureMessage.proxyInfoObj[proxyHost];
          } else {
            const ob = this.newProxy({
              type: this.method,
              host: proxyHost,
              port: this.port,
              failoverTimeout: 1000,
              failoverProxy: null
            });
            CliqzSecureMessage.proxyInfoObj[proxyHost] = ob;
            return ob;
          }
        }
      }

      /**
       * @param routingTable  array of proxy information (keys: dns, ip, ssl)
       * @returns the proxy list (unique proxies in the routing table)
       */
      function createProxyList(routeTable) {
        const proxyList = [];
        const seenProxies = new Set();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = routeTable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            const proxy = _step.value;

            const key = [proxy.dns, proxy.ip];
            if (!seenProxies[key]) {
              seenProxies[key] = proxy;
              proxyList.push(proxy);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return proxyList;
      }

      function getProxyVerifyUrl(args) {
        const schema = args.supportsHttps ? 'https' : 'http';
        const host = args.host || args.ip;
        return `${schema}://${host}/v2/verify`;
      }

      /*
       This module is used for sending the events for purpose of
       human-web, anti-tracking via a secure channel.
      */

      /* Global variables
      */
      let proxyCounter = 0;

      const CliqzSecureMessage = {
        CHANNEL: config.settings.HPN_CHANNEL,
        VERSION: '0.1',
        LOG_KEY: 'securemessage',
        debug: false,
        counter: 0,
        secureLogger: {},
        uPK: {},
        dsPK: {},
        routeTable: null,
        routeTableLoader: null,
        RSAKey: '',
        eventID: {},
        sourceMap: null,
        sourceMapLoader: null,
        tmult: 4,
        tpace: 250,
        SOURCE_MAP_PROVIDER: config.settings.ENDPOINT_SOURCE_MAP_PROVIDER,
        LOOKUP_TABLE_PROVIDER: config.settings.ENDPOINT_LOOKUP_TABLE_PROVIDER,
        KEYS_PROVIDER: config.settings.ENDPOINT_KEYS_PROVIDER,
        proxyList: null,
        proxyStats: {},
        PROXY_LIST_PROVIDER: config.settings.ENDPOINT_PROXY_LIST_PROVIDER,
        BLIND_SIGNER: config.settings.ENDPOINT_BLIND_SIGNER,
        USER_REG: config.settings.ENDPOINT_USER_REG,
        localTemporalUniq: null,
        wCrypto: null,
        queriesID: {},
        servicesToProxy: ["api.cliqz.com", "antiphishing.cliqz.com"],
        proxyInfoObj: {},
        queryProxyFilter: null,
        pacemaker: function pacemaker() {
          CliqzSecureMessage.counter += 1;

          if (CliqzSecureMessage.counter / CliqzSecureMessage.tmult % 10 === 0) {
            if (CliqzSecureMessage.debug) {
              CliqzUtils.log('Pacemaker: ' + CliqzSecureMessage.counter / CliqzSecureMessage.tmult, CliqzSecureMessage.LOG_KEY);
            }
          }

          if (CliqzSecureMessage.counter / CliqzSecureMessage.tmult % 5 === 0) {
            const currentTime = Date.now();

            if (!CliqzUtils.getWindow() || !CliqzUtils.getWindow().CLIQZ || !CliqzUtils.getWindow().CLIQZ.UI) return;
            const tDiff = currentTime - CliqzUtils.getWindow().CLIQZ.UI.lastInputTime;

            if (tDiff > 0 && tDiff > 1000 * 2 * 1) {
              CliqzSecureMessage.proxyIP();
            }

            if (!CliqzSecureMessage.uPK.publicKeyB64 || !CliqzSecureMessage.uPK.privateKey) {
              CliqzSecureMessage.registerUser();
            }
          }

          if (CliqzSecureMessage.counter / CliqzSecureMessage.tmult % (60 * 15 * 1) === 0) {
            if (CliqzSecureMessage.debug) {
              CliqzUtils.log('Clean local temp queue', CliqzSecureMessage.LOG_KEY);
            }
            prunelocalTemporalUniq();
          }
        },
        // ****************************
        // telemetry, PREFER NOT TO SHARE WITH CliqzUtils for safety, blatant rip-off though
        // ****************************
        trk: [],
        trkTimer: null,
        telemetry: function telemetry(msg, instantPush) {
          if (!CliqzSecureMessage || // might be called after the module gets unloaded
          CliqzUtils.getPref('humanWebOptOut', false)) return;

          if (msg) CliqzSecureMessage.trk.push(msg);
          CliqzUtils.clearTimeout(CliqzSecureMessage.trkTimer);
          if (instantPush || CliqzSecureMessage.trk.length % 20 === 0) {
            CliqzSecureMessage.pushTelemetry();
          } else {
            CliqzSecureMessage.trkTimer = CliqzUtils.setTimeout(CliqzSecureMessage.pushTelemetry, 10000);
          }
        },
        _telemetry_req: null,

        telemetry_MAX_SIZE: 500,
        previousDataPost: null,
        pushMessage: [],
        routeHashTable: null,
        queryProxyIP: null,
        performance: null,

        pushTelemetry: function pushTelemetry() {
          // Take all available messages from the "trk" queue and send them.
          //
          // It is crucial that messages are sent sequentially, otherwise, we
          // will have race conditions due to the use of global variables
          // in CliqzSecureMessage messages sequentially, too.
          const unprocessedMessages = CliqzSecureMessage.trk.splice(0);
          return CliqzSecureMessage.messageSender.send(unprocessedMessages);
        },
        initAtWindow: function initAtWindow(window) {},
        init: function init() {
          // Doing it here, because this lib. uses navigator and window objects.
          // Better method appriciated.

          if (CliqzSecureMessage.pacemakerId == null) {
            CliqzSecureMessage.pacemakerId = CliqzUtils.setInterval(CliqzSecureMessage.pacemaker.bind(this), CliqzSecureMessage.tpace, null);
          }

          // TODO: do not pass this to storage
          this.storage = new Storage$3(this);

          if (!CliqzSecureMessage.localTemporalUniq) this.storage.loadLocalCheckTable();

          // Load source map. Update it once an hour.
          this.sourceMapLoader = new ResourceLoader(["hpn", "sourcemap.json"], {
            remoteURL: CliqzSecureMessage.SOURCE_MAP_PROVIDER
          });

          this.sourceMapLoader.load().then(e => {
            CliqzSecureMessage.sourceMap = e;
          });

          this.sourceMapLoader.onUpdate(e => CliqzSecureMessage.sourceMap = e);

          // Load lookuptable, which also contains the list of proxy list.
          // Update every 5 minutes.
          this.routeTableLoader = new ResourceLoader(["hpn", "routeTableV2.json"], {
            remoteURL: CliqzSecureMessage.LOOKUP_TABLE_PROVIDER,
            cron: 1 * 5 * 60 * 1000,
            updateInterval: 1 * 5 * 60 * 1000
          });

          this.routeTableLoader.load().then(fullRouteTable => {
            CliqzSecureMessage._updateRoutingInfo(fullRouteTable);
          }).catch(e => {
            if (CliqzSecureMessage.debug) {
              console$1.error('Failed to update initial routeTable', e);
            }
          });

          this.routeTableLoader.onUpdate(fullRouteTable => {
            CliqzSecureMessage._updateRoutingInfo(fullRouteTable);
          });

          CliqzSecureMessage.dsPK.pubKeyB64 = config.settings.KEY_DS_PUBKEY;
          CliqzSecureMessage.secureLogger.publicKeyB64 = config.settings.KEY_SECURE_LOGGER_PUBKEY;

          if (CliqzUtils.getPref('proxyNetwork', true)) {
            overRideCliqzResults();
          }
          // Check user-key present or not.
          CliqzSecureMessage.registerUser();

          // Register proxy fr query.

          CliqzSecureMessage.queryProxyFilter = new ProxyFilter();
          CliqzSecureMessage.queryProxyFilter.init();

          this.messageSender = new MessageSender();
        },
        unload: function unload() {
          CliqzSecureMessage.queryProxyFilter.unload();
          this.storage.saveLocalCheckTable();

          // TODO: Sending messages like this does not work
          // as the shutdown will be faster than sending the
          // messages. As a result, messages are not sent
          // the web worker is not closed.
          //
          // const messageSender_ = this.messageSender;
          // CliqzSecureMessage.pushTelemetry().then(() => {
          //   messageSender_.stop();
          // }).catch((e) => {
          //   messageSender_.stop({ quick: true });
          // });
          //
          // As a workaround, make no attempt to send messages
          // (as it will not succeed anyway) but at least
          // terminate the worker.
          this.messageSender.stop({ quick: true });

          this.sourceMapLoader.stop();
          this.routeTableLoader.stop();
          CliqzUtils.clearTimeout(CliqzSecureMessage.pacemakerId);
          this.storage.close();
        },
        proxyIP: function proxyIP() {
          if (!CliqzSecureMessage.proxyList) return;

          if (proxyCounter >= CliqzSecureMessage.proxyList.length) {
            proxyCounter = 0;
          }
          const proxy = CliqzSecureMessage.proxyList[proxyCounter];
          const proxyUrl = getProxyVerifyUrl({
            host: proxy.dns,
            ip: proxy.ip,
            supportsHttps: proxy.ssl
          });
          CliqzSecureMessage.queryProxyIP = proxyUrl;
          proxyCounter += 1;
          return proxyUrl;
        },
        registerUser: function registerUser() {
          this.storage.loadKeys().then(userKey => {
            if (!userKey) {
              const userCrypto = new CryptoWorker();

              userCrypto.onmessage = e => {
                if (e.data.status) {
                  const uK = {};
                  uK.privateKey = e.data.privateKey;
                  uK.publicKey = e.data.publicKey;
                  uK.ts = Date.now();
                  this.storage.saveKeys(uK).then(response => {
                    if (response.status) {
                      CliqzSecureMessage.uPK.publicKeyB64 = response.data.publicKey;
                      CliqzSecureMessage.uPK.privateKey = response.data.privateKey;
                    }
                  });
                }
                userCrypto.terminate();
              };

              userCrypto.postMessage({
                type: 'user-key'
              });
            } else {
              CliqzSecureMessage.uPK.publicKeyB64 = userKey.publicKey;
              CliqzSecureMessage.uPK.privateKey = userKey.privateKey;
            }
          });
        },

        _updateRoutingInfo: function _updateRoutingInfo(fullRouteTable) {
          CliqzSecureMessage.routeTable = fullRouteTable[CliqzSecureMessage.CHANNEL];
          CliqzSecureMessage.proxyList = createProxyList(CliqzSecureMessage.routeTable);

          CliqzUtils.log('Updated proxy list and routing table', CliqzSecureMessage.LOG_KEY);
        }
      };

      /**
      * @namespace hpn
      * @class Background
      */
      var Background$13 = background({
        /**
        * @method init
        */
        init() {
          const FF48_OR_ABOVE = isPlatformAtLeastInVersion('48.0');

          if (FF48_OR_ABOVE) {
            // We need to use this function, 'load' events do not seem to be firing...
            this.enabled = true;
            this.CliqzSecureMessage = CliqzSecureMessage;
            CliqzSecureMessage.init();
            CliqzSecureMessage.wCrypto = new CryptoWorker('httpHandler');
            CliqzSecureMessage.wCrypto.onmessage = function (e) {
              if (e.data.type === 'instant') {
                const callback = CliqzSecureMessage.queriesID[e.data.uid];
                delete CliqzSecureMessage.queriesID[e.data.uid];
                callback && callback({ response: e.data.res });
              }
            };
          }
        },
        /**
        * @method unload
        */
        unload() {
          if (this.enabled) {
            CliqzSecureMessage.wCrypto.terminate();
            CliqzSecureMessage.unload();
          }
        },

        actions: {
          sha1(s) {
            let promise = new Promise((resolve, reject) => {
              let wCrypto = new CryptoWorker();

              wCrypto.onmessage = function (e) {
                let result = e.data.result;
                wCrypto.terminate();
                resolve(result);
              };

              wCrypto.postMessage({
                "msg": s,
                "type": "hw-sha1"
              });
            });
            return promise;
          },
          sendTelemetry(msg) {
            return CliqzSecureMessage.telemetry(msg);
          },

          sendInstantMessage(rp, payload) {
            CliqzSecureMessage.proxyIP();
            return new Promise((resolve, reject) => {
              const wCrypto = new CryptoWorker();

              wCrypto.onmessage = function (e) {
                try {
                  const result = JSON.parse(e.data.res).result;
                  wCrypto.terminate();
                  resolve(result);
                } catch (ee) {
                  wCrypto.terminate();
                  reject();
                }
              };
              wCrypto.postMessage({
                msg: {
                  action: 'instant',
                  type: 'cliqz',
                  ts: '',
                  ver: '1.5',
                  payload: payload,
                  rp: rp
                },
                uid: '',
                type: 'instant',
                sourcemap: CliqzSecureMessage.sourceMap,
                upk: CliqzSecureMessage.uPK,
                dspk: CliqzSecureMessage.dsPK,
                sspk: CliqzSecureMessage.secureLogger,
                queryProxyUrl: CliqzSecureMessage.queryProxyIP
              });
            });
          },

          sendPostMessage(rp, payload, action, data, callback) {
            const uid = Math.floor(Math.random() * 10000000);
            CliqzSecureMessage.queriesID[uid] = callback;
            CliqzSecureMessage.wCrypto.postMessage({
              msg: { action: action,
                type: 'cliqz',
                ts: '',
                ver: '1.5',
                payload: payload,
                rp: rp,
                body: data
              },
              uid: '',
              type: 'instant',
              sourcemap: CliqzSecureMessage.sourceMap,
              upk: CliqzSecureMessage.uPK,
              dspk: CliqzSecureMessage.dsPK,
              sspk: CliqzSecureMessage.secureLogger,
              queryProxyUrl: CliqzSecureMessage.queryProxyIP
            });
          }
        }
      });

      var Window$2 = class {

        constructor(_ref) {
          let window = _ref.window,
              background = _ref.background;

          this.background = background;
          this.window = window;
        }

        init() {
          if (this.background.CliqzSecureMessage) {
            this.background.CliqzSecureMessage.initAtWindow(this.window);
            this.window.CliqzSecureMessage = this.background.CliqzSecureMessage;
            Object.assign(this.window.CliqzSecureMessage, this.background.actions);
          }
        }

        unload() {
          delete this.window.CliqzSecureMessage;
        }

        status() {
          if (this.background.CliqzSecureMessage) {
            return {
              visible: true,
              state: CliqzUtils.getPref('hpn-query')
            };
          }
        }
      };

      var hpnModule = {
        Background: Background$13,
        Window: Window$2
      };

      function getContainer(document) {
        return document.querySelector('#appMenu-viewCache, #PanelUI-multiView');
      }

      var _Components$utils$imp = Components.utils.import('resource:///modules/CustomizableUI.jsm', null);

      const CustomizableUI$1 = _Components$utils$imp.CustomizableUI;

      const XUL_NS = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';

      class BrowserAction {
        constructor() {
          let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          let isPageAction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          this.id = `${options.widgetId}-browser-action`;
          this.viewId = `PanelUI-webext-${options.widgetId}-browser-action-view`;
          this.widget = null;
          this.isPageAction = isPageAction;

          this.defaults = {
            enabled: true,
            title: options.default_title,
            badgeText: options.badgeText || '',
            badgeBackgroundColor: options.badgeBackgroundColor,
            icon: options.default_icon,
            popup: options.default_popup || '',
            area: CustomizableUI$1.AREA_NAVBAR,
            width: options.defaultWidth || (() => 390),
            height: options.defaultHeight || (() => 250)
          };

          this.windows = new WeakMap();

          this.telemetryType = options.widgetId;
          this.telemetryVersion = 1;
        }

        build() {
          const widget = CustomizableUI$1.createWidget({
            id: this.id,
            label: this.defaults.title || this.extension.name,
            viewId: this.viewId,
            type: 'view',
            removable: true,
            tooltiptext: this.defaults.title || '',
            defaultArea: this.defaults.area,

            onBeforeCreated: document => {
              const view = document.createElementNS(XUL_NS, 'panelview');
              view.id = this.viewId;
              view.setAttribute('flex', '1');

              getContainer(document).appendChild(view);
            },

            onDestroyed: document => {
              const view = document.getElementById(this.viewId);
              if (view) {
                CustomizableUI$1.hidePanelForNode(view);
                view.remove();
              }
            },

            onCreated: aNode => {
              aNode.classList.add('badged-button');
              aNode.classList.add('webextension-browser-action');
              aNode.setAttribute('constrain-size', 'true');

              this.updateButton(aNode, this.defaults);

              if (this.isPageAction) {
                // we hide the page action by default
                // and make it visible only after it gets
                // moved inside the urlbar
                aNode.style.setProperty('display', 'none');
              }
            },

            onViewShowing: event => {
              this.startShowingAt = Date.now();
              CliqzUtils.telemetry({
                type: this.telemetryType,
                version: this.telemetryVersion,
                action: 'show'
              });

              const doc = event.target.ownerDocument;
              const win = doc.defaultView;
              const windowProxy = this.getWindowProxy(win);

              if (windowProxy.hooks.onViewShowing) {
                windowProxy.hooks.onViewShowing(event);
              }

              const view = doc.getElementById(this.viewId);
              const iframe = win.document.createElement('iframe');
              iframe.setAttribute('id', `${this.id}-iframe`);
              iframe.setAttribute('type', 'content');
              iframe.setAttribute('src', `${this.defaults.popup}?pageAction=${this.isPageAction}`);

              const onMessage = ev => {
                const data = JSON.parse(ev.data);

                if (data.origin !== 'iframe') {
                  return;
                }

                this.dispatchAction(win, data);
              };

              windowProxy.onMessage = onMessage;

              iframe.addEventListener('DOMContentLoaded', function onReady() {
                iframe.removeEventListener('DOMContentLoaded', onReady, true);
                iframe.contentWindow.addEventListener('message', onMessage);
              }, true);

              view.appendChild(iframe);

              // start with a decent size which should be close to the final one
              this.resizePopup(win, {
                width: this.defaults.width(),
                height: this.defaults.height()
              });
            },

            onViewHiding: event => {
              this.shownDurationTime = Date.now() - this.startShowingAt;
              CliqzUtils.telemetry({
                type: this.telemetryType,
                version: this.telemetryVersion,
                action: 'hide',
                show_duration: this.shownDurationTime
              });

              const doc = event.target.ownerDocument;
              const win = doc.defaultView;
              const windowProxy = this.getWindowProxy(win);

              if (windowProxy.hooks.onViewHiding) {
                windowProxy.hooks.onViewHiding(event);
              }

              const view = doc.getElementById(this.viewId);
              const iframe = view.querySelector('iframe');

              const onMessage = windowProxy.onMessage;

              iframe.contentWindow.removeEventListener('message', onMessage);
              view.removeChild(iframe);
            },

            onClick: event => {
              const doc = event.target.ownerDocument;
              const win = doc.defaultView;
              const windowProxy = this.getWindowProxy(win);

              if (windowProxy.hooks.onClick) {
                windowProxy.hooks.onClick(event);
              }

              CliqzUtils.telemetry({
                type: this.telemetryType,
                version: this.telemetryVersion,
                target: 'icon',
                action: 'click'
              });
            }
          });

          this.widget = widget;
        }

        setPositionBeforeElement(nextElementId) {
          const nextDetails = CustomizableUI$1.getPlacementOfWidget(nextElementId) || { position: -1 };

          if (nextDetails.position > 0) {
            // we take over the position of the target next Element
            CustomizableUI$1.moveWidgetWithinArea(this.id, nextDetails.position);
          }
        }

        showPopup(window$$1) {
          const node = window$$1.document.getElementById(this.id);
          window$$1.PanelUI.showSubView(this.viewId, node, this.defaults.area);
        }

        hidePopup(window$$1) {
          const node = window$$1.document.querySelector(`[viewId=${this.viewId}]`);
          if (node) {
            node.hidePopup();
          }
        }

        shutdown() {
          CustomizableUI$1.destroyWidget(this.id);
        }

        getWindowProxy(window$$1) {
          return this.windows.get(window$$1);
        }

        addWindow(window$$1, actions) {
          let hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          this.windows.set(window$$1, {
            actions,
            hooks
          });
        }

        removeWindow(window$$1) {
          this.windows.delete(window$$1);
        }

        dispatchAction(window$$1, data) {
          const windowProxy = this.getWindowProxy(window$$1);
          const message = data.message;
          windowProxy.actions[message.action](message.data);
        }

        sendMessage(window$$1, message) {
          const iframe = window$$1.document.getElementById(`${this.id}-iframe`);
          if (iframe) {
            iframe.contentWindow.postMessage(JSON.stringify(message), '*');
          }
        }

        resizePopup(window$$1, _ref) {
          let width = _ref.width,
              height = _ref.height;

          let newHeight = height;
          const iframe = window$$1.document.getElementById(`${this.id}-iframe`);
          if (iframe) {
            const widgetPlacement = CustomizableUI$1.getPlacementOfWidget(this.id) || {};
            const view = iframe.parentElement;
            if (widgetPlacement.area === 'PanelUI-contents') {
              newHeight += 17; // 17px for scrollbar;
            } else if (widgetPlacement.area === 'widget-overflow-fixed-list') {
              newHeight += 40; // 40px for the panel-header;
            } else if (!view.hasAttribute('mainview')) {
              // not placed explicitly in the widget overflow area but displayed here
              // forced by the width of the window
              newHeight += 40; // 40px for the panel-header;
            }

            iframe.style.width = `${width}px`;
            iframe.style.height = `${newHeight}px`;
            view.setAttribute('style', `height: ${newHeight}px; max-height: ${newHeight}px;`);
          }
        }

        setBadgeText(window$$1, value) {
          const node = window$$1.document.getElementById(this.id);
          if (node) {
            this.updateButton(node, {
              badgeText: value,
              enabled: true
            });
          }
        }

        setBadgeBackgroundColor(window$$1, value) {
          const node = window$$1.document.getElementById(this.id);
          if (node) {
            this.updateButton(node, {
              badgeBackgroundColor: value,
              enabled: true
            });
          }
        }

        setIcon(window$$1, value) {
          const node = window$$1.document.getElementById(this.id);
          if (node) {
            this.updateButton(node, {
              icon: value,
              enabled: true
            });
          }
        }

        // Update the toolbar button |node| with the custom data.
        updateButton(node, tabData) {
          const title = tabData.title || this.defaults.title;
          node.setAttribute('tooltiptext', title);
          node.setAttribute('label', title);

          const badgeText = tabData.badgeText || node.getAttribute('badge');

          if (badgeText) {
            node.setAttribute('badge', badgeText);
          } else {
            node.removeAttribute('badge');
          }

          if (tabData.enabled) {
            node.removeAttribute('disabled');
          } else {
            node.setAttribute('disabled', 'true');
          }

          const badgeNode = node.ownerDocument.getAnonymousElementByAttribute(node, 'class', 'toolbarbutton-badge');
          if (badgeNode) {
            const color = tabData.badgeBackgroundColor || badgeNode.style.backgroundColor || this.defaults.badgeBackgroundColor;
            if (color) {
              badgeNode.style.backgroundColor = color;
            }
          }

          if (tabData.icon) {
            node.setAttribute('style', `
        list-style-image: url(${tabData.icon});
        --webextension-menupanel-image: url(${tabData.icon});
        --webextension-menupanel-image-2x: url(${tabData.icon});
        --webextension-toolbar-image: url(${tabData.icon});
        --webextension-toolbar-image-2x: url(${tabData.icon});
      `);
          }
        }
      }

      const DD_HEIGHT = {
        '04': () => 413, // amo
        '40': () => 496 // Q browser
      };

      function getBrowserActionIcon() {
        const icons = config.settings.PAGE_ACTION_ICONS;
        return config.baseURL + (icons[getThemeStyle()] || icons.default);
      }

      var Background$14 = background({
        init(settings) {
          this.settings = settings;

          // we need to hide the toolbarBuuton in the FunnelCake build
          if (this.settings.id !== 'funnelcake@cliqz.com') {
            this.toolbarButton = new BrowserAction({
              widgetId: 'control-center',
              default_title: getMessage('control-center-icon-tooltip'),
              default_popup: `${config.baseURL}control-center/index.html`,
              default_icon: `${config.baseURL}${settings.ICONS.active.default}`,
              badgeBackgroundColor: '#471647',
              badgeText: '0',
              defaultHeight: DD_HEIGHT[this.settings.channel] || (() => 246)
            });
            this.toolbarButton.build();
          }

          if (this.settings.id === 'funnelcake@cliqz.com' || this.settings.id === 'description_test@cliqz.com') {
            this.pageAction = new BrowserAction({
              widgetId: 'page-action',
              default_title: getMessage('control-center-icon-tooltip'),
              default_popup: `${config.baseURL}control-center/index.html`,
              default_icon: getBrowserActionIcon(),
              defaultHeight: () => 251
            }, true);
            this.pageAction.build();
          }
        },

        unload() {
          if (this.toolbarButton) {
            this.toolbarButton.shutdown();
          }

          if (this.pageAction) {
            this.pageAction.shutdown();
          }
        },

        beforeBrowserShutdown() {},
        events: {
          "hostthemechange": function onThemeChange(themeStyle) {
            forEachWindow(win => {
              this.pageAction.setIcon(win, getBrowserActionIcon());
            });
          }
        },
        actions: {}
      });

      const BTN_ID = 'cliqz-cc-btn';
      const TELEMETRY_TYPE = 'control_center';
      const TRIQZ_URL = 'https://cliqz.com/tips';

      class Win$13 {
        constructor(_ref) {
          let window = _ref.window,
              background = _ref.background,
              settings = _ref.settings;

          this.window = window;
          this.background = background;

          this.controlCenter = inject.module('control-center');
          this.settings = settings;
          this.channel = settings.channel;
          this.ICONS = settings.ICONS;
          this.BACKGROUNDS = settings.BACKGROUNDS;
          this.createFFhelpMenu = this.createFFhelpMenu.bind(this);
          this.helpMenu = window.document.getElementById('menu_HelpPopup');
          this.geolocation = inject.module('geolocation');
          this.core = inject.module('core');
          this.actions = {
            setBadge: this.setBadge.bind(this),
            getData: this.getData.bind(this),
            getEmptyFrameAndData: this.getEmptyFrameAndData.bind(this),
            openURL: this.openURL.bind(this),
            updatePref: this.updatePref.bind(this),
            updateState: this.updateState.bind(this),
            refreshState: this.refreshState.bind(this),
            locationChange: this.locationChange.bind(this),
            resize: this.resizePopup.bind(this),
            'adb-optimized': this.adbOptimized.bind(this),
            'antitracking-activator': this.antitrackingActivator.bind(this),
            'anti-phishing-activator': this.antiphishingActivator.bind(this),
            'adb-activator': this.adbActivator.bind(this),
            'antitracking-strict': this.antitrackingStrict.bind(this),
            'antitracking-clearcache': this.antitrackingClearCache.bind(this),
            sendTelemetry: this.sendTelemetry.bind(this),
            openPopUp: this.openPopUp.bind(this),
            openMockPopUp: this.openMockPopUp.bind(this),
            setMockBadge: this.setMockBadge.bind(this),
            'cliqz-tab': this.cliqzTab.bind(this),
            'complementary-search': this.complementarySearch.bind(this),
            'search-index-country': this.searchIndexCountry.bind(this),
            'type-filter': this.typeFilter.bind(this)
          };

          this.hasAntitracking = new Set(config.modules).has('antitracking');
        }

        init() {
          this.toolbarButton = this.background.toolbarButton;
          this.pageAction = this.background.pageAction;

          this.locChangeEvent = CliqzEvents.subscribe('core.location_change', this.actions.locationChange);
          this.themeChangeEvent = CliqzEvents.subscribe('hostthemechange', this.actions.refreshState);

          if (CliqzUtils.getPref('toolbarButtonPositionSet', false) === false && this.toolbarButton) {
            this.toolbarButton.setPositionBeforeElement('bookmarks-menu-button');
            CliqzUtils.setPref('toolbarButtonPositionSet', true);
          }

          this.updateFFHelpMenu();

          if (this.toolbarButton) {
            this.toolbarButton.addWindow(this.window, this.actions);
          }
          if (this.pageAction) {
            this.pageAction.addWindow(this.window, this.actions);

            const pageActionBtn = this.window.document.getElementById(this.pageAction.id);
            const pageActionButtons =
            // Firefox 56 and bellow
            this.window.document.getElementById('urlbar-icons') ||
            // Firefox 57 and above
            this.window.document.getElementById('page-action-buttons');

            pageActionButtons.appendChild(pageActionBtn);

            // by default the pageActionBtn is hidden with display:none
            pageActionBtn.style.removeProperty('display');
          }

          setTimeout(this.setState.bind(this), 0, 'active');
        }

        updateFFHelpMenu() {
          if (this.helpMenu && this.settings.helpMenus) {
            this.helpMenu.addEventListener('popupshowing', this.createFFhelpMenu);
          }
        }

        createFFhelpMenu() {
          if (this.window.document.querySelectorAll('#menu_HelpPopup>.cliqz-item').length > 0) return;

          this.helpMenu.insertBefore(this.tipsAndTricks(this.window), this.helpMenu.firstChild);
          this.helpMenu.insertBefore(this.feedback(this.window), this.helpMenu.firstChild);
        }

        simpleBtn(doc, txt, func, action) {
          const item = doc.createElement('menuitem');
          item.setAttribute('label', txt);
          item.setAttribute('action', action);
          item.classList.add('cliqz-item');

          if (func) {
            item.addEventListener('command', () => {
              CliqzUtils.telemetry({
                type: 'activity',
                action: 'cliqz_menu_button',
                button_name: action
              });
              func();
            }, false);
          } else {
            item.setAttribute('disabled', 'true');
          }

          return item;
        }

        tipsAndTricks(win) {
          return this.simpleBtn(win.document, CliqzUtils.getLocalizedString('btnTipsTricks'), () => CliqzUtils.openTabInWindow(win, TRIQZ_URL), 'triqz');
        }

        feedback(win) {
          return this.simpleBtn(win.document, CliqzUtils.getLocalizedString('btnFeedbackFaq'), () => {
            // TODO - use the original channel instead of the current one (it will be changed at update)
            CliqzUtils.openTabInWindow(win, CliqzUtils.FEEDBACK_URL);
          }, 'feedback');
        }

        unload() {
          this.toolbarButton && this.toolbarButton.removeWindow(this.window);
          this.pageAction && this.pageAction.removeWindow(this.window);

          this.locChangeEvent.unsubscribe();
          this.themeChangeEvent.unsubscribe();

          // remove custom items from the Help Menu
          const nodes = this.helpMenu.querySelectorAll('.cliqz-item');

          Array.prototype.slice.call(nodes, 0).forEach(node => this.helpMenu.removeChild(node));

          this.helpMenu.removeEventListener('popupshowing', this.createFFhelpMenu);
        }

        locationChange(url) {
          // wait for tab content to load
          if (!url || url === 'about:blank' ||
          // do not try to prepare the date while loading control center
          url.indexOf('chrome://cliqz/content/control-center') === 0) {
            return;
          }
          this.refreshState();
        }

        refreshState() {
          this.prepareData().then(data => {
            this.setState(data.generalState);
          });
        }

        adbOptimized(data) {
          CliqzEvents.pub('control-center:adb-optimized');
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'adblock_fair',
            action: 'click',
            state: data.status === true ? 'on' : 'off'
          });
        }

        antitrackingStrict(data) {
          CliqzEvents.pub('control-center:antitracking-strict');
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'attrack_fair',
            action: 'click',
            state: data.status === true ? 'on' : 'off'
          });
        }

        antitrackingClearCache() {
          CliqzEvents.pub('control-center:antitracking-clearcache');
        }

        cliqzTab(data) {
          CliqzEvents.pub('control-center:cliqz-tab');
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'cliqz_tab',
            action: 'click',
            state: data.status === true ? 'on' : 'off'
          });
        }

        typeFilter(data) {
          CliqzUtils.setPref(`type_filter_${data.target}`, data.status);
          CliqzEvents.pub('type_filter:change', { target: data.target, status: data.status });
        }

        antitrackingActivator(data) {
          switch (data.status) {
            case 'active':
              this.core.action('enableModule', 'antitracking').then(() => {
                CliqzEvents.pub('antitracking:whitelist:remove', data.hostname);
              });
              break;
            case 'inactive':
              this.core.action('enableModule', 'antitracking').then(() => {
                CliqzEvents.pub('antitracking:whitelist:add', data.hostname);
              });
              break;
            case 'critical':
              CliqzEvents.pub('antitracking:whitelist:remove', data.hostname);
              CliqzEvents.nextTick(() => {
                this.core.action('disableModule', 'antitracking');
              });
              // reset the badge when the anti tracking module gets offline
              this.updateBadge('0');
              break;
            default:
              break;
          }

          let state;
          if (data.type === 'switch') {
            state = data.state === 'active' ? 'on' : 'off';
          } else {
            state = data.state;
          }

          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: `attrack_${data.type}`,
            state,
            action: 'click'
          });
        }

        complementarySearch(data) {
          CliqzEvents.pub('control-center:setDefault-search', data.defaultSearch);
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'complementary_search',
            state: `search_engine_change_${data.defaultSearch}`,
            action: 'click'
          });
        }

        searchIndexCountry(data) {
          CliqzEvents.pub('control-center:setDefault-indexCountry', data.defaultCountry);

          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'search-index-country',
            state: `search_index_country_${data.defaultCountry}`,
            action: 'click'
          });
        }

        adbActivator(data) {
          CliqzEvents.pub('control-center:adb-activator', data);
          let state;
          if (data.type === 'switch') {
            state = data.state === 'active' ? 'on' : 'off';
          } else {
            state = data.state;
          }
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: `adblock_${data.type}`,
            state,
            action: 'click'
          });
        }

        antiphishingActivator(data) {
          const ph = inject.module('anti-phishing');
          ph.action('activator', data.state, data.url);

          let state;
          if (data.type === 'switch') {
            state = data.state === 'active' ? 'on' : 'off';
          } else {
            state = data.state;
          }
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: `antiphishing_${data.type}`,
            state,
            action: 'click'
          });
        }

        setMockBadge(info) {
          this.updateBadge(info);
        }

        updateBadge(info) {
          if (this.toolbarButton && info !== undefined) {
            this.toolbarButton.setBadgeText(this.window, `${info}`);
          }
        }

        setBadge(info) {
          this.updateBadge(info);
        }

        updateState(state) {
          // set the state of the current window
          this.setState(state);

          // go to all the other windows and refresh the state
          const enumerator = Services.wm.getEnumerator('navigator:browser');
          while (enumerator.hasMoreElements()) {
            const win = enumerator.getNext();
            if (win !== this.window) {
              setTimeout(win => {
                this.controlCenter.windowAction(win, 'refreshState');
              }, 3000 /* some modules need time to start eg: antitracking */, win);
            }
          }
        }

        setState(state) {
          if (this.toolbarButton) {
            const icon = config.baseURL + (this.ICONS[state][getThemeStyle()] || this.ICONS[state].default);
            this.toolbarButton.setIcon(this.window, icon);
            this.toolbarButton.setBadgeBackgroundColor(this.window, this.BACKGROUNDS[state]);
          }
        }

        updatePref(data) {
          switch (data.pref) {
            case 'extensions.cliqz.humanWebOptOut':
              CliqzEvents.pub('control-center:toggleHumanWeb');
              break;
            case 'extensions.cliqz.share_location':
              this.geolocation.action('setLocationPermission', data.value);

              CliqzEvents.pub('message-center:handlers-freshtab:clear-message', {
                id: 'share-location',
                template: 'share-location'
              });
              break;
            case 'extensions.https_everywhere.globalEnabled':
              CliqzEvents.pub('control-center:toggleHttpsEverywhere', {
                newState: data.value
              });
              break;
            default:
              {
                let prefValue = data.value;
                if (data.prefType === 'boolean') {
                  prefValue = prefValue === 'true';
                }
                if (data.prefType === 'integer') {
                  prefValue = parseInt(prefValue);
                }
                CliqzUtils.setPref(data.pref, prefValue, '' /* full pref name required! */);
              }
          }

          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: data.target,
            state: data.value,
            action: 'click'
          });
        }

        openURL(data) {
          switch (data.url) {
            case 'history':
              {
                // use firefox command to ensure compatibility
                this.window.document.getElementById('Browser:ShowAllHistory').click();
                break;
              }
            case 'forget_history':
              {
                // use firefox command to ensure compatibility
                this.window.document.getElementById('Tools:Sanitize').click();
                break;
              }
            case 'moncomp':
              {
                try {
                  const murl = CliqzUtils.getPref('moncomp_endpoint', '') + this.window.gBrowser.selectedBrowser.currentURI.spec;
                  CliqzUtils.openTabInWindow(this.window, murl);
                } catch (err) {
                  console$1.log(err);
                }
                break;
              }
            default:
              {
                const tab = CliqzUtils.openLink(this.window, data.url, true);
                this.window.gBrowser.selectedTab = tab;
              }
          }

          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: data.target,
            action: 'click',
            index: data.index
          });
        }
        // creates the static frame data without any module details
        // re-used for fast first render and onboarding
        getFrameData() {
          let url = this.window.gBrowser.currentURI.spec;
          let friendlyURL = url;
          let isSpecialUrl = false;
          let urlDetails = CliqzUtils.getDetailsFromUrl(url);

          if (url.indexOf('about:') === 0) {
            friendlyURL = url;
            isSpecialUrl = true;
          } else if (url.indexOf(config.settings.NEW_TAB_URL) === 0) {
            friendlyURL = 'Cliqz Tab';
            isSpecialUrl = true;
          } else if (url.indexOf(CliqzUtils.CLIQZ_ONBOARDING_URL) === 0) {
            friendlyURL = 'Cliqz';
            isSpecialUrl = true;
          } else if (url.startsWith('chrome://cliqz/content/anti-phishing/phishing-warning.html')) {
            // in case this is a phishing site (and a warning is displayed),
            // we need to get the actual url instead of the warning page
            url = url.split('chrome://cliqz/content/anti-phishing/phishing-warning.html?u=')[1];
            url = decodeURIComponent(url);
            urlDetails = CliqzUtils.getDetailsFromUrl(url);
            isSpecialUrl = true;
            friendlyURL = getMessage('anti-phishing-txt0');
          }

          return {
            activeURL: url,
            friendlyURL,
            isSpecialUrl,
            domain: urlDetails.domain,
            extraUrl: urlDetails.extra === '/' ? '' : urlDetails.extra,
            hostname: urlDetails.host,
            module: {}, // will be filled later
            generalState: 'active',
            feedbackURL: CliqzUtils.FEEDBACK_URL,
            debug: CliqzUtils.getPref('showConsoleLogs', false),
            amo: this.settings.channel === '04',
            funnelCake: this.settings.id === 'funnelcake@cliqz.com' || this.settings.id === 'description_test@cliqz.com'
          };
        }

        prepareData() {
          return this.core.action('getWindowStatus', this.window).then(mData => {
            const moduleData = mData;
            const ccData = this.getFrameData();
            // If antitracking module is included, show critical when we get no antitracking state.
            // Otherwise show active.
            ccData.generalState = this.hasAntitracking ? moduleData.antitracking && moduleData.antitracking.state || 'critical' : 'active';

            moduleData.adult = { visible: true, state: CliqzUtils.getAdultFilterState() };
            if (CliqzUtils.hasPref('browser.privatebrowsing.apt', '') && this.settings.channel === '40') {
              moduleData.apt = { visible: true, state: CliqzUtils.getPref('browser.privatebrowsing.apt', false, '') };
            }

            moduleData.humanWebOptOut = CliqzUtils.getPref('humanWebOptOut', false);
            moduleData.searchProxy = { enabled: CliqzUtils.getPref('hpn-query', false) };

            ccData.module = moduleData;

            return ccData;
          });
        }

        numberAnimation() {}

        _getMockData() {
          const self = this;
          let numberCounter = 0;
          const ccDataMocked = this.getFrameData();

          ccDataMocked.module = this.mockedData;
          // we also need to override some of the frame Data
          ccDataMocked.activeURL = 'examplepage.de/webpage';
          ccDataMocked.isSpecialUrl = false;
          ccDataMocked.domain = 'examplepage.de';
          ccDataMocked.extraUrl = '/webpage';
          ccDataMocked.onboarding = true;

          const numberAnimation = function numberAnimation() {
            if (numberCounter === 27) {
              return;
            }

            if (numberCounter < 18) {
              ccDataMocked.module.antitracking.totalCount = numberCounter;
            }

            ccDataMocked.module.adblocker.totalCount = numberCounter;

            self.sendMessageToPopup({
              action: 'pushData',
              data: ccDataMocked
            });

            numberCounter += 1;
            setTimeout(numberAnimation, 40);
          };
          numberAnimation();
        }

        openMockPopUp(data) {
          this.mockedData = data;
          this.openPopUp();
        }

        getData() {
          this.prepareData().then(data => {
            this.sendMessageToPopup({
              action: 'pushData',
              data
            });
            this.updateBadge(data.module.antitracking ? data.module.antitracking.badgeData : 0);
          }).catch(e => CliqzUtils.log(e.toString(), 'getData error'));
        }

        // used for a first faster rendering
        getEmptyFrameAndData() {
          this.sendMessageToPopup({
            action: 'pushData',
            data: this.getFrameData()
          });

          this.getData();
        }

        sendMessageToPopup(message) {
          const msg = {
            target: 'cliqz-control-center',
            origin: 'window',
            message
          };
          this.toolbarButton && this.toolbarButton.sendMessage(this.window, msg);
          this.pageAction && this.pageAction.sendMessage(this.window, msg);
        }

        resizePopup(_ref2) {
          let width = _ref2.width,
              height = _ref2.height;

          this.toolbarButton && this.toolbarButton.resizePopup(this.window, { width, height });
          this.pageAction && this.pageAction.resizePopup(this.window, { width, height });
        }

        sendTelemetry(data) {
          const signal = {
            type: TELEMETRY_TYPE,
            target: data.target,
            action: 'click'
          };
          const state = data.state;
          if (state) {
            signal.state = state;
          }
          if (data.index) {
            signal.index = data.index;
          }
          CliqzUtils.telemetry(signal);
        }

        openPopUp() {
          this.window.document.querySelector(`toolbarbutton#${BTN_ID}`).click();
        }
      }

      var controlCenterModule = {
        Background: Background$14,
        Window: Win$13
      };

      var OffersConfigs = {

        //////////////////////////////////////////////////////////////////////////////
        // GLOBAL
        MINUTE: 60,
        HOUR: 60 * 60,
        DAY: 60 * 60 * 24,

        CURRENT_VERSION: 2.0,

        LOG_LEVEL: 'off',
        LOG_ENABLED: false,

        //////////////////////////////////////////////////////////////////////////////
        // trigger backend endpoint
        BACKEND_URL: 'https://offers-api.cliqz.com',

        // the redirect url to where we should point to when the user sees the offer
        // and click on "more info"
        OFFER_INFORMATION_URL: 'https://cliqz.com/products/cliqz-for-desktop/cliqz-angebote',

        // the time we want to track the signals after they were created
        OFFERS_HISTORY_LIVE_TIME_SECS: 20 * 60 * 24 * 60,

        // trigger specific browser history
        LOAD_TRIGGER_HISTORY_DATA: true,
        TRIGGER_HISTORY_DATA: isChromium ? undefined : 'chrome://cliqz/content/offers-v2/trigger_history.json',
        // the current trigger engine version
        TRIGGER_ENGINE_VERSION: '7',

        // offer storage
        LOAD_OFFERS_STORAGE_DATA: true,
        OFFERS_STORAGE_DEFAULT_TTS_SECS: 60 * 60 * 24 * 10,
        OFFERS_STORAGE_AUTOSAVE_FREQ_SECS: 2 * 60,

        //////////////////////////////////////////////////////////////////////////////
        // SIGNALS

        // how often we want to send the signals related with the offers to the BE
        // ten minutes
        SIGNALS_OFFERS_FREQ_SECS: 30,
        SIGNALS_HPN_BE_ADDR: 'https://offers-api.cliqz.com/api/v1/savesignal',
        SIGNALS_HPN_BE_ACTION: 'offers-signal',
        // the time we want to keep the signals (accumulating) from the last time
        // the signal was modified (#GR-298)
        SIGNALS_OFFERS_EXPIRATION_SECS: 60 * 60 * 24 * 60, //60 days?
        // the version number of the signal structure we are currently using
        SIGNALS_VERSION: 3.1,
        // debug variable to load / not load the data from DB
        SIGNALS_LOAD_FROM_DB: true,
        // how frequent we want to save into DB
        SIGNALS_AUTOSAVE_FREQ_SECS: 2 * 60,
        // maximum number of retries sending a signal
        MAX_RETRIES: 3,

        // adding configs values for the send_signal operation (EX-4976)
        SEND_SIG_OP_AUTOSAVE_FREQ_SECS: 2 * 60,
        SEND_SIG_OP_EXPIRATION_SECS: 60 * 60 * 24 * 60, //60 days?
        SEND_SIG_OP_SHOULD_LOAD: true,

        // conf for trigger history database
        TRIGGER_HISTORY_OP_AUTOSAVE_FREQ_SECS: 2 * 60,
        TRIGGER_HISTORY_MAX_RECORDS: 1000,

        //////////////////////////////////////////////////////////////////////////////
        // QUERY HANDLER
        // how frequent we want to save query data into DB
        QUERY_HANDLER_AUTOSAVE_FREQ_SECS: 10 * 60,
        // debug variable to load / not load the data from DB
        QUERY_POSTINGS_LOAD_FROM_DB: true,
        POSTING_SLICE: 20,
        //////////////////////////////////////////////////////////////////////////////
        // CONFIG / DEBUG variables
        //

        // override the timeout time of the offers only if this is > 0
        OFFERS_OVERRIDE_TIMEOUT: -1

      };

      const LOG_PREFIX = '[offers-v2]';

      /**
       * No-op function.
       */
      function noop$1() {}

      function timestampStr() {
        return `[${Date.now()}]`;
      }

      class OfferV2Logger {
        constructor() {
          this.init();
        }

        init() {
          this.LOG_LEVEL = OffersConfigs.LOG_LEVEL;
          const debugConsole = console$1.debug;
          const errorConsole = console$1.error;
          const infoConsole = console$1.log;
          const warnConsole = console$1.log;

          Object.defineProperty(this, 'debug', {
            get: () => Function.prototype.bind.call(debugConsole, console$1, LOG_PREFIX, '[debug]', timestampStr()),
            configurable: true
          });
          Object.defineProperty(this, 'info', {
            get: () => Function.prototype.bind.call(infoConsole, console$1, LOG_PREFIX, '[info]', timestampStr()),
            configurable: true
          });
          Object.defineProperty(this, 'log', {
            get: () => Function.prototype.bind.call(infoConsole, console$1, LOG_PREFIX, '[log]', timestampStr()),
            configurable: true
          });
          Object.defineProperty(this, 'warn', {
            get: () => Function.prototype.bind.call(warnConsole, console$1, LOG_PREFIX, '[warn]', timestampStr()),
            configurable: true
          });
          Object.defineProperty(this, 'error', {
            get: () => Function.prototype.bind.call(errorConsole, console$1, LOG_PREFIX, '[error]', timestampStr()),
            configurable: true
          });

          this.logObject = obj => {
            // log object while keeping its state
            // since this is an expensive operation, we do it only if LOG_LEVEL == 'debug'
            if (this.LOG_LEVEL === 'debug') {
              this.debug(JSON.parse(JSON.stringify(obj)));
            }
          };

          if (this.LOG_LEVEL === 'off') {
            this._disableConsoles(['debug', 'info', 'log', 'warn', 'error']);
          } else if (this.LOG_LEVEL === 'error') {
            this._disableConsoles(['debug', 'info', 'log', 'warn']);
          } else if (this.LOG_LEVEL === 'warn' || this.LOG_LEVEL === 'info' || this.LOG_LEVEL === 'log') {
            this._disableConsoles(['debug']);
          }
        }

        _disableConsoles(consolesStr) {
          consolesStr.forEach(consoleStr => {
            Object.defineProperty(this, consoleStr, {
              get: () => noop$1,
              configurable: true
            });
          });
        }
      }

      /**
       * A customized logger object
       * Sample: Cliqz [offers-v2] [INFO] [1500559534046] log message   caller_source_file.js:line_number
       * Format: <Cliqz> <module_name> <log_level> <timestamp> <log message>    <caller:line_number>
       * support the log levels: debug < info (log) < warn < error < off
       * support the following functions:
       * - logger.debug(msg)
       * - logger.logObject(obj)
       * - logger.info(msg)
       * - logger.log(msg)
       * - logger.warn(msg)
       * - logger.error(msg)
       */
      var logger$2 = new OfferV2Logger();

      function nope(arg) {
        return arg;
      }
      class ReverseIndex {
        constructor(filters, getTokens) {
          var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
              _ref$optimizer = _ref.optimizer;

          let optimizer = _ref$optimizer === undefined ? nope : _ref$optimizer;
          var _ref$multiKeys = _ref.multiKeys;
          let multiKeys = _ref$multiKeys === undefined ? false : _ref$multiKeys;

          this.index = new Map();
          this.size = 0;
          this.optimizer = optimizer;
          this.getTokens = getTokens;
          this.multiKeys = multiKeys || false;
          this.addFilters(filters || []);
        }
        iterMatchingFilters(tokens, cb) {
          for (let j = 0; j < tokens.length; j += 1) {
            if (this.iterBucket(tokens[j], cb) === false) {
              return;
            }
          }
          this.iterBucket(0, cb);
        }
        report() {
          const sizes = new Map();
          let strResult = '';
          this.index.forEach((bucket, token) => {
            const filters = bucket.filters;
            sizes.set(filters.length, (sizes.get(filters.length) || 0) + 1);
            if (length > 5) {
              strResult = strResult.concat(`adblocker size bucket "${token}" => ${filters.length}\n`);
              filters.forEach(f => {
                strResult = strResult.concat(`    ${f.toString()} ${f.mask}\n`);
              });
            }
          });
          sizes.forEach((count, size) => {
            strResult = strResult.concat(`adblocker sizes ${size} => ${count} buckets\n`);
          });
          return strResult;
        }
        optimizeAheadOfTime() {
          if (this.optimizer) {
            this.index.forEach(bucket => {
              this.optimize(bucket, true);
            });
          }
        }
        addFilters(filters) {
          const length = filters.length;
          this.size = length;
          const idToTokens = new Map();
          const histogram = new Map();
          for (let i = 0; i < filters.length; i += 1) {
            const filter = filters[i];
            const multiTokens = this.multiKeys ? this.getTokens(filter) : [this.getTokens(filter)];
            idToTokens.set(filter.id, multiTokens);
            for (let j = 0; j < multiTokens.length; j += 1) {
              const tokens = multiTokens[j];
              for (let k = 0; k < tokens.length; k += 1) {
                const token = tokens[k];
                histogram.set(token, (histogram.get(token) || 0) + 1);
              }
            }
          }
          for (let i = 0; i < filters.length; i += 1) {
            let wildCardInserted = false;
            const filter = filters[i];
            const multiTokens = idToTokens.get(filter.id);
            for (let j = 0; j < multiTokens.length; j += 1) {
              const tokens = multiTokens[j];
              let bestToken = 0;
              let count = length;
              for (let k = 0; k < tokens.length; k += 1) {
                const token = tokens[k];
                const tokenCount = histogram.get(token);
                if (tokenCount < count) {
                  bestToken = token;
                  count = tokenCount;
                }
              }
              if (bestToken === 0) {
                if (wildCardInserted) {
                  continue;
                } else {
                  wildCardInserted = true;
                }
              }
              const bucket = this.index.get(bestToken);
              if (bucket === undefined) {
                this.index.set(bestToken, {
                  filters: [filter],
                  hit: 0,
                  optimized: false
                });
              } else {
                bucket.filters.push(filter);
              }
            }
          }
        }
        optimize(bucket) {
          let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (this.optimizer && !bucket.optimized && (force || bucket.hit >= 5)) {
            if (bucket.filters.length > 1) {
              bucket.filters = this.optimizer(bucket.filters);
            }
            bucket.optimized = true;
          }
        }
        iterBucket(token, cb) {
          const bucket = this.index.get(token);
          if (bucket !== undefined) {
            bucket.hit += 1;
            this.optimize(bucket);
            const filters = bucket.filters;
            for (let k = 0; k < filters.length; k += 1) {
              if (cb(filters[k]) === false) {
                return false;
              }
            }
          }
          return true;
        }
      }

      function getBit(n, mask) {
        return !!(n & mask);
      }
      function setBit(n, mask) {
        return n | mask;
      }
      function clearBit(n, mask) {
        return n & ~mask;
      }
      function fastHash(str) {
        if (!str) {
          return 0;
        }
        let hash = 5407;
        for (let i = 0; i < str.length; i += 1) {
          hash = hash * 31 ^ str.charCodeAt(i);
        }
        return hash >>> 0;
      }
      function fastStartsWith(haystack, needle) {
        if (haystack.length < needle.length) {
          return false;
        }
        const ceil = needle.length;
        for (let i = 0; i < ceil; i += 1) {
          if (haystack[i] !== needle[i]) {
            return false;
          }
        }
        return true;
      }
      function fastStartsWithFrom(haystack, needle, start) {
        if (haystack.length - start < needle.length) {
          return false;
        }
        const ceil = start + needle.length;
        for (let i = start; i < ceil; i += 1) {
          if (haystack[i] !== needle[i - start]) {
            return false;
          }
        }
        return true;
      }
      function isDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      function isAlpha(ch) {
        ch &= ~32;
        return ch >= 65 && ch <= 90;
      }
      function isAllowed(ch) {
        return isDigit(ch) || isAlpha(ch);
      }
      function fastTokenizer(pattern, isAllowedCode) {
        let allowRegexSurround = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        const tokens = [];
        let inside = false;
        let start = 0;
        let length = 0;
        for (let i = 0, len = pattern.length; i < len; i += 1) {
          const ch = pattern.charCodeAt(i);
          if (isAllowedCode(ch)) {
            if (!inside) {
              inside = true;
              start = i;
              length = 0;
            }
            length += 1;
          } else if (inside) {
            inside = false;
            if (allowRegexSurround || ch !== 42) {
              tokens.push(fastHash(pattern.substr(start, length)));
            }
          }
        }
        if (inside) {
          tokens.push(fastHash(pattern.substr(start, length)));
        }
        return tokens;
      }
      function tokenize(pattern) {
        return fastTokenizer(pattern, isAllowed, false);
      }

      function isAnchoredByHostname(filterHostname, hostname) {
        const matchIndex = hostname.indexOf(filterHostname);
        return matchIndex === 0 || matchIndex > 0 && hostname[matchIndex - 1] === '.';
      }
      function checkPatternPlainFilter(filter, _ref2) {
        let url = _ref2.url;

        return url.indexOf(filter.getFilter()) !== -1;
      }
      function checkPatternRightAnchorFilter(filter, _ref3) {
        let url = _ref3.url;

        return url.endsWith(filter.getFilter());
      }
      function checkPatternLeftAnchorFilter(filter, _ref4) {
        let url = _ref4.url;

        return fastStartsWith(url, filter.getFilter());
      }
      function checkPatternLeftRightAnchorFilter(filter, _ref5) {
        let url = _ref5.url;

        return url === filter.getFilter();
      }
      function checkPatternRegexFilter(filter, _ref6) {
        let url = _ref6.url;

        return filter.getRegex().test(url);
      }
      function checkPatternHostnameAnchorRegexFilter(filter, _ref7) {
        let url = _ref7.url,
            hostname = _ref7.hostname;

        if (isAnchoredByHostname(filter.getHostname(), hostname)) {
          return checkPatternRegexFilter(filter, { url });
        }
        return false;
      }
      function checkPatternHostnameRightAnchorFilter(filter, _ref8) {
        let url = _ref8.url,
            hostname = _ref8.hostname;

        if (isAnchoredByHostname(filter.getHostname(), hostname)) {
          const urlAfterHostname = url.substring(url.indexOf(filter.getHostname()) + filter.getHostname().length);
          return filter.getFilter() === urlAfterHostname;
        }
        return false;
      }
      function checkPatternHostnameAnchorFilter(filter, _ref9) {
        let url = _ref9.url,
            hostname = _ref9.hostname;

        if (isAnchoredByHostname(filter.getHostname(), hostname)) {
          const urlAfterHostname = url.substring(url.indexOf(filter.getHostname()) + filter.getHostname().length);
          return fastStartsWith(urlAfterHostname, filter.getFilter());
        }
        return false;
      }
      function checkPattern(filter, request) {
        if (filter.isHostnameAnchor()) {
          if (filter.isRegex()) {
            return checkPatternHostnameAnchorRegexFilter(filter, request);
          } else if (filter.isRightAnchor()) {
            return checkPatternHostnameRightAnchorFilter(filter, request);
          }
          return checkPatternHostnameAnchorFilter(filter, request);
        } else if (filter.isRegex()) {
          return checkPatternRegexFilter(filter, request);
        } else if (filter.isLeftAnchor() && filter.isRightAnchor()) {
          return checkPatternLeftRightAnchorFilter(filter, request);
        } else if (filter.isLeftAnchor()) {
          return checkPatternLeftAnchorFilter(filter, request);
        } else if (filter.isRightAnchor()) {
          return checkPatternRightAnchorFilter(filter, request);
        }
        return checkPatternPlainFilter(filter, request);
      }
      function checkOptions(filter, request) {
        if (!filter.isCptAllowed(request.cpt)) {
          return false;
        }
        const sHost = request.sourceHostname;
        const sHostGD = request.sourceGD;
        const hostGD = request.hostGD;
        const isFirstParty = sHostGD === hostGD;
        if (!filter.firstParty() && isFirstParty) {
          return false;
        }
        if (!filter.thirdParty() && !isFirstParty) {
          return false;
        }
        if (filter.hasOptDomains()) {
          const optDomains = filter.getOptDomains();
          if (optDomains.size > 0 && !(optDomains.has(sHostGD) || optDomains.has(sHost))) {
            return false;
          }
        }
        if (filter.hasOptNotDomains()) {
          const optNotDomains = filter.getOptNotDomains();
          if (optNotDomains.size > 0 && (optNotDomains.has(sHostGD) || optNotDomains.has(sHost))) {
            return false;
          }
        }
        return true;
      }
      function matchNetworkFilter(filter, request) {
        return checkOptions(filter, request) && checkPattern(filter, request);
      }

      const FROM_ANY = 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768 | 65536;
      const CPT_TO_MASK = {
        1: 16,
        2: 64,
        3: 1,
        4: 128,
        5: 4,
        7: 256,
        10: 32,
        11: 1024,
        12: 8,
        13: 4096,
        14: 8192,
        15: 2,
        16: 512,
        17: 65536,
        18: 16384,
        19: 32768,
        20: 2048,
        21: 1
      };
      const SEPARATOR = /[/^*]/;
      function compileRegex(filterStr, isRightAnchor, isLeftAnchor, matchCase) {
        let filter = filterStr;
        filter = filter.replace(/([|.$+?{}()[\]\\])/g, '\\$1');
        filter = filter.replace(/\*/g, '.*');
        filter = filter.replace(/\^/g, '(?:[^\\w\\d_.%-]|$)');
        if (isRightAnchor) {
          filter = `${filter}$`;
        }
        if (isLeftAnchor) {
          filter = `^${filter}`;
        }
        if (matchCase) {
          return new RegExp(filter);
        }
        return new RegExp(filter, 'i');
      }
      function parseDomainsOption(domains) {
        return new Set(domains ? domains.split('|') : []);
      }
      class NetworkFilter {
        constructor(_ref10) {
          let mask = _ref10.mask,
              filter = _ref10.filter,
              optDomains = _ref10.optDomains,
              optNotDomains = _ref10.optNotDomains,
              redirect = _ref10.redirect,
              hostname = _ref10.hostname,
              id = _ref10.id;

          this.id = id;
          this.mask = mask;
          this.filter = filter;
          this.optDomains = optDomains;
          this.optNotDomains = optNotDomains;
          this.redirect = redirect;
          this.hostname = hostname;
          this.regex = null;
          this.optDomainsSet = null;
          this.optNotDomainsSet = null;
          this.rawLine = null;
        }
        isCosmeticFilter() {
          return false;
        }
        isNetworkFilter() {
          return true;
        }
        toString() {
          let filter = '';
          if (this.isException()) {
            filter += '@@';
          }
          if (this.isHostnameAnchor()) {
            filter += '||';
          }
          if (this.isLeftAnchor()) {
            filter += '|';
          }
          if (!this.isRegex()) {
            if (this.hasHostname()) {
              filter += this.getHostname();
              filter += '^';
            }
            filter += this.getFilter();
          } else {
            filter += this.getRegex().source;
          }
          const options = [];
          if (!this.fromAny()) {
            if (this.fromImage()) {
              options.push('image');
            }
            if (this.fromMedia()) {
              options.push('media');
            }
            if (this.fromObject()) {
              options.push('object');
            }
            if (this.fromObjectSubrequest()) {
              options.push('object-subrequest');
            }
            if (this.fromOther()) {
              options.push('other');
            }
            if (this.fromPing()) {
              options.push('ping');
            }
            if (this.fromScript()) {
              options.push('script');
            }
            if (this.fromStylesheet()) {
              options.push('stylesheet');
            }
            if (this.fromSubdocument()) {
              options.push('subdocument');
            }
            if (this.fromWebsocket()) {
              options.push('websocket');
            }
            if (this.fromXmlHttpRequest()) {
              options.push('xmlhttprequest');
            }
            if (this.fromFont()) {
              options.push('font');
            }
          }
          if (this.isImportant()) {
            options.push('important');
          }
          if (this.isRedirect()) {
            options.push(`redirect=${this.getRedirect()}`);
          }
          if (this.firstParty() !== this.thirdParty()) {
            if (this.firstParty()) {
              options.push('first-party');
            }
            if (this.thirdParty()) {
              options.push('third-party');
            }
          }
          if (this.hasOptDomains() || this.hasOptNotDomains()) {
            const domains = [...this.getOptDomains()];
            this.getOptNotDomains().forEach(nd => domains.push(`~${nd}`));
            options.push(`domain=${domains.join('|')}`);
          }
          if (options.length > 0) {
            filter += `$${options.join(',')}`;
          }
          if (this.isRightAnchor()) {
            filter += '|';
          }
          return filter;
        }
        hasFilter() {
          return !!this.filter;
        }
        hasOptNotDomains() {
          return !!this.optNotDomains;
        }
        getOptNotDomains() {
          this.optNotDomainsSet = this.optNotDomainsSet || parseDomainsOption(this.optNotDomains);
          return this.optNotDomainsSet;
        }
        hasOptDomains() {
          return !!this.optDomains;
        }
        getOptDomains() {
          this.optDomainsSet = this.optDomainsSet || parseDomainsOption(this.optDomains);
          return this.optDomainsSet;
        }
        getMask() {
          return this.mask;
        }
        isRedirect() {
          return !!this.redirect;
        }
        getRedirect() {
          return this.redirect;
        }
        hasHostname() {
          return !!this.hostname;
        }
        getHostname() {
          return this.hostname;
        }
        getFilter() {
          return this.filter;
        }
        setRegex(re) {
          this.regex = re;
          this.mask = setBit(this.mask, 8388608);
          this.mask = clearBit(this.mask, 4194304);
        }
        getRegex() {
          if (this.regex === null) {
            this.regex = compileRegex(this.filter, this.isRightAnchor(), this.isLeftAnchor(), this.matchCase());
          }
          return this.regex;
        }
        getTokens() {
          return tokenize(this.filter).concat(tokenize(this.hostname));
        }
        isCptAllowed(cpt) {
          const mask = CPT_TO_MASK[cpt];
          if (mask !== undefined) {
            return getBit(this.mask, mask);
          }
          return true;
        }
        isException() {
          return getBit(this.mask, 134217728);
        }
        isHostnameAnchor() {
          return getBit(this.mask, 67108864);
        }
        isRightAnchor() {
          return getBit(this.mask, 33554432);
        }
        isLeftAnchor() {
          return getBit(this.mask, 16777216);
        }
        matchCase() {
          return getBit(this.mask, 262144);
        }
        isImportant() {
          return getBit(this.mask, 131072);
        }
        isRegex() {
          return getBit(this.mask, 8388608);
        }
        isPlain() {
          return !getBit(this.mask, 8388608);
        }
        isHostname() {
          return getBit(this.mask, 2097152);
        }
        fromAny() {
          return (this.mask & FROM_ANY) === FROM_ANY;
        }
        thirdParty() {
          return getBit(this.mask, 524288);
        }
        firstParty() {
          return getBit(this.mask, 1048576);
        }
        fromImage() {
          return getBit(this.mask, 1);
        }
        fromMedia() {
          return getBit(this.mask, 2);
        }
        fromObject() {
          return getBit(this.mask, 4);
        }
        fromObjectSubrequest() {
          return getBit(this.mask, 8);
        }
        fromOther() {
          return getBit(this.mask, 16);
        }
        fromPing() {
          return getBit(this.mask, 32);
        }
        fromScript() {
          return getBit(this.mask, 64);
        }
        fromStylesheet() {
          return getBit(this.mask, 128);
        }
        fromSubdocument() {
          return getBit(this.mask, 256);
        }
        fromWebsocket() {
          return getBit(this.mask, 512);
        }
        fromXmlHttpRequest() {
          return getBit(this.mask, 1024);
        }
        fromFont() {
          return getBit(this.mask, 8192);
        }
      }
      function setNetworkMask(mask, m, value) {
        if (value) {
          return setBit(mask, m);
        }
        return clearBit(mask, m);
      }
      function checkIsRegex(filter, start, end) {
        const starIndex = filter.indexOf('*', start);
        const separatorIndex = filter.indexOf('^', start);
        return starIndex !== -1 && starIndex < end || separatorIndex !== -1 && separatorIndex < end;
      }
      function parseNetworkFilter(rawLine) {
        const line = rawLine;
        let mask = 524288 | 1048576;
        let filter = null;
        let hostname = null;
        let optDomains = '';
        let optNotDomains = '';
        let redirect = '';
        let hasCptOption = false;
        let filterIndexStart = 0;
        let filterIndexEnd = line.length;
        if (fastStartsWith(line, '@@')) {
          filterIndexStart += 2;
          mask = setBit(mask, 134217728);
        }
        const optionsIndex = line.indexOf('$', filterIndexStart);
        if (optionsIndex !== -1) {
          filterIndexEnd = optionsIndex;
          const rawOptions = line.substr(optionsIndex + 1);
          const options = rawOptions.split(',');
          for (let i = 0; i < options.length; i += 1) {
            const rawOption = options[i];
            let negation = false;
            let option = rawOption;
            if (fastStartsWith(option, '~')) {
              negation = true;
              option = option.substr(1);
            } else {
              negation = false;
            }
            let optionValues = [];
            if (option.indexOf('=') !== -1) {
              const optionAndValues = option.split('=', 2);
              option = optionAndValues[0];
              optionValues = optionAndValues[1].split('|');
            }
            switch (option) {
              case 'domain':
                {
                  const optDomainsArray = [];
                  const optNotDomainsArray = [];
                  for (let j = 0; j < optionValues.length; j += 1) {
                    const value = optionValues[j];
                    if (value) {
                      if (fastStartsWith(value, '~')) {
                        optNotDomainsArray.push(value.substr(1));
                      } else {
                        optDomainsArray.push(value);
                      }
                    }
                  }
                  if (optDomainsArray.length > 0) {
                    optDomains = optDomainsArray.join('|');
                  }
                  if (optNotDomainsArray.length > 0) {
                    optNotDomains = optNotDomainsArray.join('|');
                  }
                  break;
                }
              case 'image':
                hasCptOption = true;
                mask = setNetworkMask(mask, 1, !negation);
                break;
              case 'media':
                hasCptOption = true;
                mask = setNetworkMask(mask, 2, !negation);
                break;
              case 'object':
                hasCptOption = true;
                mask = setNetworkMask(mask, 4, !negation);
                break;
              case 'object-subrequest':
                hasCptOption = true;
                mask = setNetworkMask(mask, 8, !negation);
                break;
              case 'other':
                hasCptOption = true;
                mask = setNetworkMask(mask, 16, !negation);
                break;
              case 'ping':
                hasCptOption = true;
                mask = setNetworkMask(mask, 32, !negation);
                break;
              case 'script':
                hasCptOption = true;
                mask = setNetworkMask(mask, 64, !negation);
                break;
              case 'stylesheet':
                hasCptOption = true;
                mask = setNetworkMask(mask, 128, !negation);
                break;
              case 'subdocument':
                hasCptOption = true;
                mask = setNetworkMask(mask, 256, !negation);
                break;
              case 'xmlhttprequest':
                hasCptOption = true;
                mask = setNetworkMask(mask, 1024, !negation);
                break;
              case 'websocket':
                hasCptOption = true;
                mask = setNetworkMask(mask, 512, !negation);
                break;
              case 'font':
                hasCptOption = true;
                mask = setNetworkMask(mask, 8192, !negation);
                break;
              case 'important':
                if (negation) {
                  return null;
                }
                mask = setBit(mask, 131072);
                break;
              case 'match-case':
                if (negation) {
                  return null;
                }
                mask = setBit(mask, 262144);
                break;
              case 'third-party':
                if (negation) {
                  mask = clearBit(mask, 524288);
                } else {
                  mask = clearBit(mask, 1048576);
                }
                break;
              case 'first-party':
                if (negation) {
                  mask = clearBit(mask, 1048576);
                } else {
                  mask = clearBit(mask, 524288);
                }
                break;
              case 'collapse':
                break;
              case 'redirect':
                if (negation) {
                  return null;
                }
                if (optionValues.length === 0) {
                  return null;
                }
                redirect = optionValues[0];
                break;
              default:
                return null;
            }
          }
        }
        if (hasCptOption === false) {
          mask = setBit(mask, FROM_ANY);
        }
        if (fastStartsWith(line, '127.0.0.1')) {
          hostname = line.substr(line.lastIndexOf(' ') + 1);
          filter = '';
          mask = clearBit(mask, 8388608);
          mask = setBit(mask, 2097152);
          mask = setBit(mask, 67108864);
        } else {
          if (line[filterIndexEnd - 1] === '|') {
            mask = setBit(mask, 33554432);
            filterIndexEnd -= 1;
          }
          if (fastStartsWithFrom(line, '||', filterIndexStart)) {
            mask = setBit(mask, 67108864);
            filterIndexStart += 2;
          } else if (line[filterIndexStart] === '|') {
            mask = setBit(mask, 16777216);
            filterIndexStart += 1;
          }
          if (line.charAt(filterIndexEnd - 1) === '*' && filterIndexEnd - filterIndexStart > 1) {
            filterIndexEnd -= 1;
          }
          const isRegex = checkIsRegex(line, filterIndexStart, filterIndexEnd);
          mask = setNetworkMask(mask, 8388608, isRegex);
          const isHostnameAnchor = getBit(mask, 67108864);
          if (!isRegex && isHostnameAnchor) {
            const slashIndex = line.indexOf('/', filterIndexStart);
            if (slashIndex !== -1) {
              hostname = line.substring(filterIndexStart, slashIndex);
              filterIndexStart = slashIndex;
            } else {
              hostname = line.substring(filterIndexStart, filterIndexEnd);
              filter = '';
            }
          } else if (isRegex && isHostnameAnchor) {
            const firstSeparator = line.search(SEPARATOR);
            if (firstSeparator !== -1) {
              hostname = line.substring(filterIndexStart, firstSeparator);
              filterIndexStart = firstSeparator;
              if (filterIndexEnd - filterIndexStart === 1 && line.charAt(filterIndexStart) === '^') {
                filter = '';
                mask = clearBit(mask, 8388608);
              } else {
                mask = setNetworkMask(mask, 8388608, checkIsRegex(line, filterIndexStart, filterIndexEnd));
              }
            }
          }
        }
        if (filter === null) {
          filter = line.substring(filterIndexStart, filterIndexEnd).toLowerCase();
        }
        let finalHostname = '';
        if (hostname !== null) {
          finalHostname = hostname;
        }
        let finalFilter = '';
        if (filter !== null) {
          finalFilter = filter;
        }
        if (getBit(mask, 67108864) && fastStartsWith(finalHostname, 'www.')) {
          finalHostname = finalHostname.slice(4);
        }
        if (finalHostname !== '') {
          finalHostname = finalHostname.toLowerCase();
        }
        const id = fastHash(line);
        return new NetworkFilter({
          filter: finalFilter,
          hostname: finalHostname,
          id,
          mask,
          optDomains,
          optNotDomains,
          redirect
        });
      }

      function mkRequest(_ref11) {
        var _ref11$url = _ref11.url;
        let url = _ref11$url === undefined ? '' : _ref11$url;
        var _ref11$hostname = _ref11.hostname;
        let hostname = _ref11$hostname === undefined ? '' : _ref11$hostname;
        var _ref11$domain = _ref11.domain;
        let domain = _ref11$domain === undefined ? '' : _ref11$domain;
        var _ref11$sourceHostname = _ref11.sourceHostname;
        let sourceHostname = _ref11$sourceHostname === undefined ? '' : _ref11$sourceHostname;
        var _ref11$sourceDomain = _ref11.sourceDomain;
        let sourceDomain = _ref11$sourceDomain === undefined ? '' : _ref11$sourceDomain;
        var _ref11$cpt = _ref11.cpt;
        let cpt = _ref11$cpt === undefined ? 6 : _ref11$cpt;

        return {
          cpt,
          tokens: tokenize(url),
          sourceGD: sourceDomain,
          sourceHostname,
          hostGD: domain,
          hostname,
          url: url.toLowerCase()
        };
      }

      /**
       * this method will generate the proper structure we need to use when matching
       * later against the patterns. This will build the "tokenizedURL object"
       * @param  {[type]} url [description]
       * @return {Object}     will be the object needed to parse later
       */
      function tokenizeUrl(url) {
        if (url) {
          var _parse = parse(url);

          const hostname = _parse.hostname,
                domain = _parse.domain;

          return mkRequest({
            url,
            domain,
            hostname,
            cpt: 2,
            sourceHostname: hostname,
            sourceDomain: domain
          });
        }
        return null;
      }

      /**
       * Accelerating data structure for network filters matching. Makes use of the
       * reverse index structure defined above.
       */
      class PatternIndex {
        constructor(filters) {
          this.index = new ReverseIndex(filters, filter => filter.getTokens());
        }

        optimizeAheadOfTime() {
          this.index.optimizeAheadOfTime();
        }

        /**
         * we will check if the request matches the patterns associated.
         * @param  {[type]} url         [description]
         * @return {[type]}            true if it matches / false otherwise
         */
        match() /* request */{
          throw new Error('should be implemented by the inherited class ');
        }
      }

      /**
       * Accelerating data structure for network filters matching. Makes use of the
       * reverse index structure defined above.
       */
      class SimplePatternIndex extends PatternIndex {
        /**
         * we will check if the request matches the patterns associated.
         * @param  {[type]} url         [description]
         * @return {[type]}            true if it matches / false otherwise
         */
        match(request) {
          let matched = false;
          const checkMatch = pattern => {
            matched = matchNetworkFilter(pattern, request);

            // returning true we will continue iterating but is not needed anymore
            return !matched;
          };

          this.index.iterMatchingFilters(request.tokens, checkMatch);

          return matched;
        }
      }

      /**
       * Accelerating data structure for network filters matching for multiple patterns
       * match detection. Makes use of the reverse index structure defined above.
       */
      class MultiPatternIndex extends PatternIndex {
        /**
         * we will check if the request matches the patterns associated.
         * @param  {[type]} url         [description]
         * @return {[type]}             the set of patterns id that matched this url
         */
        match(request) {
          const matchedIDsSet = new Set();
          const checkMatch = pattern => {
            const patternGroupID = pattern.groupID;
            // we will add the pattern id if it matches and is new
            if (!matchedIDsSet.has(patternGroupID) && matchNetworkFilter(pattern, request)) {
              matchedIDsSet.add(patternGroupID);
            }
            // in any case we need to continue iterating
            return true;
          };

          this.index.iterMatchingFilters(request.tokens, checkMatch);

          return matchedIDsSet;
        }
      }

      /**
       * This class will be a wrapper containing the url information that will calculate
       * the data needed on demand. This way we can use one unique object containing
       * all the url information we need and share it between different operations
       */
      class UrlData {
        constructor(rawUrl) {
          let referrer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (typeof rawUrl !== 'string') {
            throw new Error('invalid raw url type');
          }
          this.rawUrl = rawUrl;
          this.referrer = referrer;

          // all the fields we will handle and share
          this.lowercaseUrl = null;
          this.urlDetails = null;
          this.patternsRequest = null;
        }

        hasReferrer() {
          return this.referrer !== null;
        }

        getReferrer() {
          return this.referrer;
        }

        getRawUrl() {
          return this.rawUrl;
        }

        getLowercaseUrl() {
          if (this.lowercaseUrl === null) {
            this.lowercaseUrl = this.rawUrl.toLowerCase();
          }
          return this.lowercaseUrl;
        }

        getUrlDetails() {
          if (this.urlDetails === null) {
            this.urlDetails = CliqzUtils.getDetailsFromUrl(this.rawUrl);
          }
          return this.urlDetails;
        }

        getDomain() {
          if (this.urlDetails === null) {
            this.urlDetails = CliqzUtils.getDetailsFromUrl(this.rawUrl);
          }
          return this.urlDetails.domain;
        }

        getPatternRequest() {
          if (this.patternsRequest === null) {
            this.patternsRequest = tokenizeUrl(this.rawUrl);
          }
          return this.patternsRequest;
        }
      }

      /*
      
      This module will be used to handle different kind of events in a more efficient
      way for the offers module.
      
      */

      class EventHandler {

        constructor() {
          // the list of callbacks we will handle.
          this.callbacksMap = {
            url_change: [],
            http_req: {}
          };

          this.onTabLocChanged = this.onTabLocChanged.bind(this);

          CliqzEvents.sub('content:location-change', this.onTabLocChanged);

          this.beforeRequestListener = this.beforeRequestListener.bind(this);
          this.requestListenerAdded = false;
        }

        //
        // @brief destructor
        //
        destroy() {
          CliqzEvents.un_sub('content:location-change', this.onTabLocChanged);
          if (this.requestListenerAdded) {
            WebRequest$1.onBeforeRequest.removeListener(this.beforeRequestListener);
            this.requestListenerAdded = false;
          }
        }

        //////////////////////////////////////////////////////////////////////////////
        //                          PUBLIC METHODS
        //////////////////////////////////////////////////////////////////////////////

        //
        // @brief subscribe to get events whenever a new url is performed
        // @note
        //  The event emitted is a url details structure + referrer field (check
        //  utils.getDetailsFromUrl(url); for more info)
        //
        subscribeUrlChange(cb) {
          let cargs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          this.callbacksMap['url_change'].push({ cb, cargs });
        }
        unsubscribeUrlChange(cb) {
          this._unsubscribeCallback('url_change', cb);
        }

        //
        // @brief subscribe to get events for http requests (POST / GET) for particular
        //        domains
        // @param cb  The callback to receive the event
        // @param domainName The domain name that we want to get the callback.
        // @param cargs is the arguments that will be passed to the callback
        // @note The event structure will look like:
        //  {
        //    'req_obj' : x, // the request object containing the full info of it
        //  }
        //
        //
        subscribeHttpReq(cb, domainName) {
          let cargs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (!this.callbacksMap['http_req'][domainName]) {
            this.callbacksMap['http_req'][domainName] = [];
          }

          // add the listener if not added before
          if (!this.requestListenerAdded) {
            this.requestListenerAdded = true;
            WebRequest$1.onBeforeRequest.addListener(this.beforeRequestListener, {
              urls: ["http://*/*", "https://*/*"]
            });
          }

          var alreadySubscribed = false;
          this.callbacksMap['http_req'][domainName].forEach(function (elem) {
            if (elem.cb === cb) {
              alreadySubscribed = true;
            }
          });

          if (!alreadySubscribed) {
            this.callbacksMap['http_req'][domainName].push({ cb, cargs });
          }

          return !alreadySubscribed;
        }
        unsubscribeHttpReq(cb, domainName) {
          if (!this.callbacksMap['http_req'][domainName]) {
            // nothing to do
            return;
          }
          // now remove it
          let index = -1;
          for (let i = 0; i < this.callbacksMap['http_req'][domainName].length; i += 1) {
            if (this.callbacksMap['http_req'][domainName][i].cb === cb) {
              index = i;
              break;
            }
          }
          if (index > -1) {
            this.callbacksMap['http_req'][domainName].splice(index, 1);
          }
        }

        isHttpReqDomainSubscribed(cb, domainName) {
          if (!this.callbacksMap['http_req'][domainName]) {
            return false;
          }

          // add the listener if not added before
          if (!this.requestListenerAdded) {
            this.requestListenerAdded = true;
            WebRequest$1.onBeforeRequest.addListener(this.beforeRequestListener, {
              urls: ["*://*/*"]
            });
          }

          return this.callbacksMap['http_req'][domainName].some(e => e.cb === cb);
        }

        //////////////////////////////////////////////////////////////////////////////
        //                          PRIVATE METHODS
        //////////////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////////////
        onTabLocChanged(data) {
          // EX-2561: private mode then we don't do anything here
          if (data.isPrivate) {
            logger$2.info('window is private skipping: onTabLocChanged');
            return;
          }

          // We need to subscribe here to get events everytime the location is
          // changing and is the a new url. We had issues since everytime we switch
          // the tabs we got the event from core.locaiton_change and this is not correct
          // for our project.
          // Check issue https://cliqztix.atlassian.net/projects/GR/issues/GR-117
          //

          // skip the event if is the same document here
          // https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIWebProgressListener
          //
          if (data.isSameDocument) {
            return;
          }

          // we will do a further check here so we can avoid extra execution
          if (!data.url || data.url.length === 0 || this.lastUrl === data.url) {
            return;
          }

          this.lastUrl = data.url;

          // else we emit the event here
          this.onLocationChangeHandler(data.url, data.referrer);
        }

        //////////////////////////////////////////////////////////////////////////////
        onLocationChangeHandler(url, referrer) {
          // we will filter some urls here, we need to add them in the future we will
          // https://cliqztix.atlassian.net/browse/EX-4570
          // resource://
          // about:
          // file://
          if (!url || !(url.startsWith('http://') || url.startsWith('https://'))) {
            return;
          }

          // now we add the referrer to the url
          let referrerName = null;
          if (referrer) {
            var referrerUrlDetails = CliqzUtils.getDetailsFromUrl(referrer);
            referrerName = referrerUrlDetails.name;
          }

          const urlData = new UrlData(url, referrerName);

          try {
            this._publish(this.callbacksMap['url_change'], urlData);
          } catch (e) {
            // log this error, is nasty, something went wrong
            logger$2.error('Exception catched when processing a new event: ' + e);
          }
        }

        //////////////////////////////////////////////////////////////////////////////
        beforeRequestListener(requestObj) {
          const url = requestObj.url;

          // do first filtering
          if (!url) {
            return;
          }

          // check if we have a domain for this
          const urlData = new UrlData(requestObj.url);
          const domainName = urlData.getDomain();
          // check if we have the associated domain
          if (domainName && this.callbacksMap['http_req']) {
            var callbacks = this.callbacksMap['http_req'][domainName];
            if (!callbacks) {
              return;
            }

            // we have callbacks then we call them
            this._publish(callbacks, { reqObj: requestObj, url_data: urlData });
          }
        }

        //////////////////////////////////////////////////////////////////////////////
        //
        // @brief generic unsubscription of a callback
        //
        _unsubscribeCallback(typeName, cb) {
          if (!this.callbacksMap[typeName]) {
            return;
          }
          let index = -1;
          for (let i = 0; i < this.callbacksMap[typeName].length; i += 1) {
            if (this.callbacksMap[typeName][i].cb === cb) {
              index = i;
              break;
            }
          }
          if (index > -1) {
            this.callbacksMap[typeName].splice(index, 1);
          }
        }

        //
        // @brief generic publish method
        // @param args
        //
        _publish(callbacksList) {
          let args = Array.prototype.slice.call(arguments, 1);
          // we will use the last argument to provide the cargs
          args.push(null);
          (callbacksList || []).forEach(function (ev) {
            CliqzUtils.setTimeout(function () {
              try {
                args[args.length - 1] = ev.cargs;
                ev.cb.apply(null, args);
              } catch (e) {
                logger$2.error('Error on publishing an event: ' + e.toString() + ' -- ' + e.stack);
              }
            }, 0);
          });
        }
      }

      /*
      
      The purpose of this file will be to define a list of signals that we want to
      track to avoid misspellings and have a common place where we will have listed
      all the signals keys
      
       */

      // track signals ids
      const ActionID = {
        // New version names:
        //
        // this signal will be sent whenever the trigger that has an offer to show on its
        // actions is executed / evaluated.
        AID_OFFER_TRIGGERED: 'offer_triggered',
        // whenever the offer will be broadcasted / pushed to all the real estates when
        // the offers should be displayed (before, known as offer_added / offer_displayed).
        AID_OFFER_PUSHED: 'offer_pushed',
        // Notification type when an offer is pushed to the Reward box (Hub or offers-cc)
        // it can be a small tooltip, or full pop-up of the window
        AID_OFFER_NOTIF_T: 'offer_notif_tooltip',
        AID_OFFER_NOTIF_T_E: 'offer_notif_tooltip_extra',
        AID_OFFER_NOTIF_P: 'offer_notif_popup',
        // whenever the offer is filtered out by a filter rule info
        AID_OFFER_FILTERED: 'offer_filtered',
        // this signal will be sent every time a new "display" session ENDS on the given
        // real estate. It counts the number of opportunities we have to make a conversion.
        // This doesn't mean that showing the same offer in multiple tabs are multiple
        // display session but one (multiple showns will be counted in this case).
        AID_OFFER_DISPLAY_SESSION: 'offer_dsp_session',
        // this should be sent whenever the offer is shown to the user, not for the
        // first time but could be multiple times the same offer on the same url, for
        // example the panel, everytime there is a tab switch then we show and hide the
        // same offer multiple times.
        // Basically: graphic impressions.
        AID_OFFER_SHOWN: 'offer_shown',
        // whenever the offer is closed by timeout and not because of the user actively
        // close it.
        AID_OFFER_TIMEOUT: 'offer_timeout',
        // when the user close the offer actively pressing on the X button for example.
        AID_OFFER_CLOSED: 'offer_closed',
        // when the offer is removed from the container (any) so we should not keep track
        // of it anymore.
        AID_OFFER_REMOVED: 'offer_removed',
        // when the offer was properly removed from the DB (this is happening on the
        // processor mainly)
        AID_OFFER_DB_REMOVED: 'offer_db_removed',
        // when the user press on "More about cliqz offers" button, this is not related
        // usually to an offer, but can be associated (depending the real state).
        AID_OFFER_MORE_ABT_CLIQZ: 'more_about_cliqz',
        // when the user hovers over offer conditions (tooltip)
        AID_OFFER_MORE_INFO: 'offer_more_info',
        // when the user press on the main offer button (call to action).
        AID_OFFER_CALL_TO_ACTION: 'offer_ca_action',
        // whenever the user clicks on the real estate "copy code" part.
        AID_OFFER_CODE_COPIED: 'code_copied',
        // when the user click on a collapsed offer to expand it
        AID_OFFER_EXPANDED: 'offer_expanded',

        // extras
        //
        // hub
        // this signal will be sent at the same time that the offer_dsp_session but
        // only when the offer is displayed on the hub after the user actively opened the hub
        // (check confluence for more information).
        AID_OFFER_HUB_PULLED: 'offer_pulled',
        AID_OFFER_HUB_FB_NO_OPT: 'feedback_no',
        AID_OFFER_HUB_FB_OPT_1: 'feedback_option1',
        AID_OFFER_HUB_FB_OPT_2: 'feedback_option2',
        AID_OFFER_HUB_FB_OPT_3: 'feedback_option3',
        AID_OFFER_HUB_REMOVE_LINK: 'remove_offer_link',
        AID_OFFER_HUB_CANCEL_REMOVE_LINK: 'remove_offer_cancel',
        AID_OFFER_HUB_TOOLTIP_CLICKED: 'tooltip_clicked',
        AID_OFFER_HUB_TOOLTIP_CLOSED: 'tooltip_closed',
        AID_OFFER_HUB_TOOLTIP_SHOWN: 'tooltip_shown',
        AID_OFFER_HUB_POP_UP: 'hub_pop_up',
        AID_OFFER_HUB_OPEN: 'hub_open',
        AID_OFFER_HUB_CLOSED: 'hub_closed',
        AID_OFFER_HUB_SHOW_MORE_OFFERS: 'show_more_offers'

      };

      /*
       * @brief Evaluate the filtering rules of a particular offer
       */

      class FilterRulesEvaluator {
        //
        constructor(offersDB) {
          this.offersDB = offersDB;
          // filter actions
          this.filterEvalFunMap = {
            eval_expression: this._evalExpression.bind(this),
            generic_comparator: this._genericComparator.bind(this)
          };
          // predefined operators
          this.operationsMap = {
            '>=': this._gtOrEqTo.bind(this),
            '<=': this._lsOrEqTo.bind(this),
            '==': this._eqTo.bind(this),
            '!=': this._notEqTo.bind(this)
          };
        }

        destroy() {}
        // nothing to do


        // ///////////////////////////////////////////////////////////////////////////
        //                                API
        // ///////////////////////////////////////////////////////////////////////////

        buildJsepRules(strRules) {
          if (!strRules) {
            return null;
          }
          try {
            return jsep(strRules);
          } catch (e) {
            logger$2.error(`jsep couldn't parse with error ${e}`);
          }
          return null;
        }
        shouldWeShowOffer(offerID, argRules) {
          const rules = argRules;
          if (!offerID) {
            logger$2.warn('shouldWeShowOffer: undefined offer ID');
            return false;
          }

          // if we dont have rules or the offer has no actions then we can just return
          if (!rules || !this.offersDB.hasOfferData(offerID)) {
            logger$2.info(`shouldWeShowOffer: no rules or no actions for offer ${offerID}`);
            return true;
          }

          // get the displayID as well
          const offerObj = this.offersDB.getOfferObject(offerID);
          const offerDisplayID = offerObj ? offerObj.display_id : null;
          /*
            depending on the version of the triggers the rules can be object or string
            object is the previous version and has structure: {
              // show if not closed more than
              not_closed_mt: 3,
            }
            string is the new format and should be used from now on
           */

          // show if all the conditions are true
          const self = this;
          let someFailed = false;
          Object.keys(rules).forEach(ruleName => {
            if (someFailed) {
              return;
            }
            const ruleFun = self.filterEvalFunMap[ruleName];
            if (!ruleFun) {
              logger$2.warn('shouldWeShowOffer: one of the rules specified on the offer is not ' + `implemented. Filter Rule name: ${ruleName}. Skipping this one`);
              return;
            }
            if (!rules.jsep_built) {
              rules.jsep_built = self.buildJsepRules(rules[ruleName]);
              if (!rules.jsep_built) {
                someFailed = true;
                return;
              }
            }

            if (!ruleFun(offerDisplayID, rules.jsep_built)) {
              logger$2.info(`shouldWeShowOffer: filter rule ${ruleName} didnt passed. We should ` + `not show this offer with ID ${offerID}`);
              someFailed = true;
            }
            // rule passed, check the next
          });

          return !someFailed;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            PRIVATE METHODS
        // ///////////////////////////////////////////////////////////////////////////

        // Operators
        _gtOrEqTo(leftArg, rightArg) {
          logger$2.info(`_gtOrEqTo: evaluating ${leftArg} >= ${rightArg}`);
          return leftArg >= rightArg;
        }

        _lsOrEqTo(leftArg, rightArg) {
          logger$2.info(`_lsOrEqTo: evaluating ${leftArg} <= ${rightArg}`);
          return leftArg <= rightArg;
        }

        _eqTo(leftArg, rightArg) {
          logger$2.info(`_eqTo: evaluating ${leftArg} === ${rightArg}`);
          return leftArg === rightArg;
        }

        _notEqTo(leftArg, rightArg) {
          logger$2.info(`_notEqTo: evaluating ${leftArg} !== ${rightArg}`);
          return leftArg !== rightArg;
        }
        /**
         * Compares a given offer attribute to an input number
         * @param  {[type]} offerDisplayID  [description]
         * @param  {Object} args  contains the following 4 elements
         * * @param {string} action_id offer's action involved
         * * @param {string} att_type attribute to be evaluated (counter, c_ts, l_u_ts)
         * * @param {string} operator one of these: '>=', '<=', '==', '!='
         * * @param {integer} value numerical value to be compared to
         * @return {boolean} true on success (show it) | false otherwise
         * @version 1.0
         */
        _genericComparator(offerDisplayID, args) {
          const operation = this.operationsMap[args.operator];
          if (!operation) {
            logger$2.warn(`_genericComparator: This operation wasn't found ${args.operator}`);
            return false;
          }
          const offerAction = this.offersDB.getOfferDisplayActionMeta(offerDisplayID, args.action_id);
          if (!offerAction) {
            return true;
          }
          if (args.att_type === 'counter') {
            // compare counter of events
            return operation(offerAction.count, args.value);
          } else if (args.att_type === 'c_ts' || args.att_type === 'l_u_ts') {
            // calculate the time diff assuming args.att_type has the right name,
            // we could make a map to do this as well
            const timeDelta = (Date.now() - offerAction[args.att_type]) / 1000;
            return operation(timeDelta, args.value);
          }
          logger$2.warn(`_genericComparator: unknown attribute '${args.att_type}'`);
          return false;
        }

        _evalExpression(offerDisplayID, expr) {
          try {
            if (expr.type === 'CallExpression') {
              const callee = expr.callee.name;
              if (!this.filterEvalFunMap[callee]) {
                logger$2.warn(`_evalExpression: filter function ${callee} doesn't exist`);
                return false;
              }
              if (expr.arguments.length < 4) {
                logger$2.warn(`_evalExpression: not enough arguments (${expr.arguments.length})`);
                return false;
              }
              const args = {
                action_id: expr.arguments[0].value,
                att_type: expr.arguments[1].value,
                operator: expr.arguments[2].value,
                value: expr.arguments[3].value
              };
              // if condition not fulfilled, save
              if (!this.filterEvalFunMap[callee](offerDisplayID, args)) {
                this.failed = args;
                return false;
              }
              return true;
            } else if (expr.type === 'LogicalExpression' && expr.operator === '||') {
              return this._evalExpression(offerDisplayID, expr.left) || this._evalExpression(offerDisplayID, expr.right);
            } else if (expr.type === 'LogicalExpression' && expr.operator === '&&') {
              return this._evalExpression(offerDisplayID, expr.left) && this._evalExpression(offerDisplayID, expr.right);
            }
          } catch (e) {
            logger$2.error(`expr failed: ${JSON.stringify(expr)}`);
            logger$2.error(`with error message: ${e}`);
            return false;
          }
          return false;
        }
      }

      /*
       * @brief This will be the entry point for all the Offers to be shown. Here
       *        we will control all the display logic.
       */
      // /////////////////////////////////////////////////////////////////////////////
      // consts
      // the time we want to avoid any update on the DB for a particular offer. This cache
      // is not persistence on disk, meaning will be just an optimization to avoid multiple
      // updates everytime a offer is pushed.
      const MAX_OFFER_CACHE_TIME_MS = 60 * 60 * 1000;

      const MessageType = {
        MT_PUSH_OFFER: 'push-offer',
        MT_REMOVE_OFFER: 'remove-offer',
        MT_OFFERS_STATE_CHANGED: 'offers-state-changed'
      };

      const ORIGIN_ID = 'processor';

      const FILTERS_OFF = 'offersFiltersOff';

      // /////////////////////////////////////////////////////////////////////////////
      class OfferProcessor {
        //
        constructor(sigHandler, baseDB, offersDB, offersStatusHandler) {
          this.baseDB = baseDB;
          this.offersDB = offersDB;
          this.offersStatusHandler = offersStatusHandler;

          // local offer-ids cached (offer_id -> cachedTime)
          this.offerUpdateCache = {};

          // filtering rules evaluator
          this.filterRuleEval = new FilterRulesEvaluator(this.offersDB);

          // the action function map for signals coming from the UI (not tracking)
          // There will be 2 type of signals:
          //  - (1) signals that are related to an offer and have some action on them (they
          //    change the status or any logic of the business).
          //  - (2) signals that are "actions" (telemtry) related to a particular offer but
          //    there is no influence on the logic in any form.
          //  - (3) signals that are not related to any offer at all (simple telemetry). This
          //    has no any effect on the main logic of offers.
          this.uiActionsMap = {
            // (1)
            'remove-offer': this._uiFunRemoveOffer.bind(this),
            'change-offer-state': this._uiFunOffersStateChanged.bind(this),
            // (2)
            'offer-action-signal': this._uiFunOfferActionSignal.bind(this),
            // (3)
            'action-signal': this._uiFunActionSignal.bind(this)
          };

          // signal handler
          this.sigHandler = sigHandler;
        }

        destroy() {
          if (this.sigHandler) {
            this.sigHandler.destroy();
          }
          if (this.filterRuleEval) {
            this.filterRuleEval.destroy();
          }
        }

        // /////////////////////////////////////////////////////////////////////////////

        savePersistenceData() {}

        // /////////////////////////////////////////////////////////////////////////////
        // add / remove offers

        //
        // @brief This method will be called everytime we should push an offer to the
        //        real estates. We will do some checkings before like:
        //         - proper format / fields.
        //         - apply filtering rules.
        //         - store it on DB if we don't have it, otherwise cache it and store it
        // @param offerInfo:
        // {
        //   offer_id: 'XX',
        //   ui_info: {
        //     template_name: 'template1',
        //     template_data: {
        //       // ...
        //     }
        //   },
        //   rule_info: {
        //     // the information associated to the rule we should apply to show this
        //   },
        //   filter_info: {
        //     // the filter rules options like: show if was not closed >= 3 times, or
        //     // was not created >= N days, etc
        //   }
        // }
        //
        // @param origin will be the origin who is calling this method.
        // @param newDisplayRule if the displayRule is different than the one the offer
        //                       currently has
        //
        pushOffer(offerInfo) {
          let newDisplayRule = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          let originID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ORIGIN_ID;

          // check offer validity
          if (!offerInfo || !offerInfo.offer_id || !offerInfo.display_id || !offerInfo.campaign_id) {
            logger$2.warn('pushOffer: invalid offer or missing fields');
            return false;
          }

          // check if the offer is obsolete or not, if thats the case we directly skip
          // this step
          if (this._isOfferObsolete(offerInfo.offer_id)) {
            return false;
          }

          // this is the entry point for every place where we will create an offer.
          // Everyone who creates an offer should call this method.
          //
          this.sigHandler.setCampaignSignal(offerInfo.campaign_id, offerInfo.offer_id, originID, ActionID.AID_OFFER_TRIGGERED);

          // check if we should or should not show this offer
          if (!this._shouldShowOffer(offerInfo)) {
            logger$2.info(`pushOffer: We should not show this offer with ID: ${offerInfo.offer_id}`);
            this.sigHandler.setCampaignSignal(offerInfo.campaign_id, offerInfo.offer_id, originID, ActionID.AID_OFFER_FILTERED);
            return false;
          }

          // check if it is cached so we add it or update it
          if (!this._isOfferCached(offerInfo.offer_id)) {
            // we then need to add the offer to the DB and mark it as active
            if (this.offersDB.hasOfferData(offerInfo.offer_id)) {
              // try to update it just in case
              if (!this.offersDB.updateOfferObject(offerInfo.offer_id, offerInfo)) {
                logger$2.error(`pushOffer: Error updating the offer to the DB: ${offerInfo.offer_id}`);
                return false;
              }
            } else if (!this.offersDB.addOfferObject(offerInfo.offer_id, offerInfo)) {
              // it is a new one
              // we cannot continue here since we depend on having the offer in the DB
              logger$2.error(`pushOffer: Error adding the offer to the DB: ${offerInfo.offer_id}`);
              return false;
            }

            // cache the offer
            this._cacheOffer(offerInfo.offer_id);
          }

          // now we will publish the message notifying that we have a new offer
          const offerObject = this.offersDB.getOfferObject(offerInfo.offer_id);

          // track some signals
          this.offersDB.incOfferAction(offerObject.offer_id, ActionID.AID_OFFER_PUSHED);
          this.sigHandler.setCampaignSignal(offerObject.campaign_id, offerObject.offer_id, originID, ActionID.AID_OFFER_PUSHED);

          // broadcast the message
          let displayRule = newDisplayRule;
          if (!displayRule) {
            displayRule = offerObject.rule_info;
          }

          const msgData = {
            offer_id: offerObject.offer_id,
            display_rule: displayRule,
            offer_data: offerObject
          };
          const realStatesDest = this._getDestRealStatesForOffer(offerObject.offer_id);
          this._publishMessage(MessageType.MT_PUSH_OFFER, realStatesDest, msgData);
          return true;
        }

        /* ***************************************************************************
         *                            EXPOSED API
         *
         * check https://cliqztix.atlassian.net/wiki/pages/viewpage.action?pageId=88618158
         * for more information which are the functions and description
         ***************************************************************************** */

        /**
         * will return a list of offers filtered and sorted as specified in args
         * @param  {object} args
         * <pre>
         * {
         *   // to filter entries using the following types of filters
         *   filters: {
         *     // will filter by real estate
         *     by_rs_dest: 'real-estate-name',
         *     // this flag will be used to ensure that we have the real estate destination
         *     // listed. This is a fix for EX-5468, we will need to change this later
         *     ensure_has_dest: true / false,
         *   }
         * }
         * </pre>
         * @return {[type]}      [description]
         */
        getStoredOffers(args) {
          // for this first version we will just return all the offers directly
          const self = this;
          const rawOffers = this.offersDB.getOffers();
          const result = [];
          const filters = args ? args.filters : null;

          rawOffers.forEach(offerElement => {
            if (filters) {
              // we should filter
              if (filters.ensure_has_dest && (!offerElement.offer.rs_dest || offerElement.offer.rs_dest.length === 0)) {
                // skip this one, since doesn't contain real estate destinations
                return;
              }
              if (filters.by_rs_dest && offerElement.offer.rs_dest) {
                const realEstatesSet = typeof filters.by_rs_dest === 'string' ? new Set([filters.by_rs_dest]) : new Set(filters.by_rs_dest);

                // check the real estate destination of the offer
                if (!offerElement.offer.rs_dest.some(dre => realEstatesSet.has(dre))) {
                  // skip this one
                  return;
                }
              }
            }
            result.push({
              offer_id: offerElement.offer_id,
              offer_info: offerElement.offer,
              created_ts: offerElement.created,
              attrs: {
                state: self.offersDB.getOfferAttribute(offerElement.offer_id, 'state')
              }
            });
          });
          return result;
        }

        /**
         * This method will update all the current offers we have on the DB and remove
         * the ones that are obsolete using the offers-status-handler.
         * @return {[type]} [description]
         */
        updateOffersStatus() {
          const rawOffers = this.offersDB.getOffers();
          rawOffers.forEach(offerElement => {
            // EX-5923: we will need to remove all the offers that are obsolete
            if (this._isOfferObsolete(offerElement.offer_id)) {
              // remove this from the database without emitting any signal
              this.offersDB.removeOfferObject(offerElement.offer_id);
            }
          });
        }

        /**
         * This method will be called from externals (other modules) to generate a new
         * offer on our system. This will bypass the trigger engine system.
         * If the offer already exists nothing will be done.
         * One example of use can be for example the dropdown that the offers are triggered
         * from the search results and is not related with our system, but we still need
         * to track the offer actions and more. For this purpose we will provide an API
         * to generate offers from outside.
         * @param  {object} args The argument containing the following information:
         * <pre>
         * {
         *   // the one who is performing the call
         *   origin: 'dropdown',
         *
         *   // for more information about what is the required offer data needed
         *   // check:
         *   // https://cliqztix.atlassian.net/wiki/pages/viewpage.action?pageId=89041894
         *   {
         *     data: {
         *       offer_id: 'xyz',
         *       campaign_id: 'c_id',
         *       display_id: 'd_id',
         *
         *       // the rule information on how we should display this offer if any
         *       rule_info: {
         *         // ...
         *       },
         *
         *       // the ui information how we should display this offer
         *       ui_info: {
         *         // ...
         *       },
         *
         *       // the list of destinations (real estates) where this offer should be
         *       // displayed
         *       rs_dest: ['xyz1',...]
         *     },
         *     // ...
         *   }
         * }
         * </pre>
         * @return {Boolean} true on success (offer created) | false otherwise
         */
        createExternalOffer(args) {
          if (!args || !args.origin || !args.data) {
            logger$2.warn('createExternalOffer: invalid arguments');
            return false;
          }
          if (this.hasExternalOffer(args)) {
            // already exists
            return false;
          }
          return this.pushOffer(args.data, null, args.origin);
        }

        /**
         * Check if we have an offer present on the DB or not
         * @param  {object}  The following data should be on the argument:
         * <pre>
         *
         * {
         *   data: {
         *     // the offer id we want to check if exists or not
         *     offer_id: 'xyz'
         *   }
         * }
         * </pre>
         * @return {Boolean}         true if we have | false otherwise.
         */
        hasExternalOffer(args) {
          if (!args || !args.data || !args.data.offer_id) {
            return false;
          }
          return this.offersDB.isOfferPresent(args.data.offer_id);
        }

        // /////////////////////////////////////////////////////////////////////////////
        // internal methods


        /**
         * will check if we have an offer on memory recently added / updated on the DB.
         * @param  {string}  offerID [description]
         * @return {Boolean}         true if it is cached, false otherwise
         */
        _isOfferCached(offerID) {
          if (!offerID) {
            return false;
          }
          const cachedTime = this.offerUpdateCache[offerID];
          if (!cachedTime) {
            return false;
          }
          const now = Date.now();
          const diffTime = now - cachedTime;
          if (diffTime > MAX_OFFER_CACHE_TIME_MS) {
            delete this.offerUpdateCache[offerID];
            return false;
          }
          // still cached
          return true;
        }

        // check if an offer is obsolete or not
        _isOfferObsolete(offerID) {
          return this.offersStatusHandler.getOfferStatus(offerID) === 'obsolete';
        }

        /**
         * will cache an offer id on memory with the current timestamp.
         * @param  {[type]} offerID [description]
         */
        _cacheOffer(offerID) {
          if (!offerID) {
            return;
          }
          this.offerUpdateCache[offerID] = Date.now();
        }

        //
        // @brief Remove a particular offer
        //
        _removeOffer(offerID) {
          const offerObj = this.offersDB.getOfferObject(offerID);
          if (!offerObj) {
            logger$2.warn(`removeOffer: the offer ${offerID} is not on our DB`);
            return false;
          }

          // remove the offer from the DB
          if (!this.offersDB.removeOfferObject(offerID)) {
            logger$2.warn(`removeOffer: failed removing the offer object from the DB ${offerID}`);
            return false;
          }

          // track signal
          const campaignID = this.offersDB.getCampaignID(offerID);
          this.sigHandler.setCampaignSignal(campaignID, offerID, ORIGIN_ID, ActionID.AID_OFFER_DB_REMOVED);

          // we emit the event for the real states now
          const realStatesDest = this._getDestRealStatesForOffer(offerID);
          const data = { offer_id: offerID };
          this._publishMessage(MessageType.MT_REMOVE_OFFER, realStatesDest, data);

          return true;
        }

        /**
         * This method will process the messages coming from the real states or anyone
         * that will interact with the offers-core module
         * @param  {[type]} msg Is the object containing all the message information.
         *                      For more information check the documentation
         * @return {[type]}     [description]
         */
        processRealEstateMessage(msg) {
          // message:
          // {
          //    origin: who is sending it,
          //    type: message type, should be one of the one listed on the functions map
          //    data: {...},  object containing the data depending on the message type
          // }

          if (!msg || !msg.origin || !msg.type || !msg.data) {
            logger$2.error('ProcessRealEstateMessage: invalid message format, discarding it');
            return false;
          }

          // check if we have the associated function
          const handlerFun = this.uiActionsMap[msg.type];
          if (!handlerFun) {
            logger$2.warn(`ProcessRealEstateMessage: we cannot process the message type ${msg.type}`);
            return false;
          }

          // we can, so we call the method
          return handlerFun(msg);
        }

        //
        // @brief check the rules and current data to see if the offer should be shown
        //        or not
        // @precondition: Assumes that the offer history is ready for this offer
        // @return true if it should | false otherwise
        //
        _shouldShowOffer(offerInfo) {
          if (!offerInfo) {
            logger$2.error('_shouldShowOffer: the offer is null');
            return false;
          }
          const rules = offerInfo.filter_info;
          const offerID = offerInfo.offer_id;
          return prefs.get(FILTERS_OFF, false) || this.filterRuleEval.shouldWeShowOffer(offerID, rules);
        }

        _getDestRealStatesForOffer(offerID) {
          const offerObj = this.offersDB.getOfferObject(offerID);
          if (!offerObj || !offerObj.rs_dest) {
            return [];
          }
          return offerObj.rs_dest;
        }

        /**
         * this will publish a message into the common channel so all the real states
         * can get the message and do something with it.
         * Check the documentation for more information about messages types and format.
         * @param  {[type]} type       [description]
         * @param  {[type]} destList   [description]
         * @param  {[type]} data       [description]
         * @return {[type]}            [description]
         */
        _publishMessage(type, destList, data) {
          // for now for backward compatibility we will hardcode this part here.
          // in the future we should adapt the ui (ghostery) to this new interface.
          try {
            // this will be the normal case
            const message = {
              origin: 'offers-core',
              type,
              dest: destList,
              data
            };

            if (isChromium && type === MessageType.MT_PUSH_OFFER) {
              CliqzEvents.pub('msg_center:show_message', message, 'ghostery');
              return;
            }

            CliqzEvents.pub('offers-send-ch', message);
          } catch (err) {
            logger$2.error(`_publishMessage: something failed publishing the message ${JSON.stringify(err)}`);
          }
        }

        // ///////////////////////////////////////////////////////////////////////////
        // actions from ui

        _uiFunRemoveOffer(msg) {
          if (!msg.data || !msg.data.offer_id) {
            logger$2.warn(`_uiFunRemoveOffer: invalid format of the message: ${JSON.stringify(msg)}`);
            return false;
          }
          const offerID = msg.data.offer_id;
          const campaignID = this.offersDB.getCampaignID(offerID);
          logger$2.info(`_uiFunRemoveOffer: called for offer id: ${offerID}`);
          this.sigHandler.setCampaignSignal(campaignID, offerID, msg.origin, ActionID.AID_OFFER_REMOVED);
          this.offersDB.incOfferAction(offerID, ActionID.AID_OFFER_REMOVED);

          return this._removeOffer(offerID);
        }

        /**
         * Record signals that are not related to a campaign or offer.
         * @param  {[type]} options.data    [description]
         * @param  {[type]} options.origin  [description]
         * @return {[type]}                 [description]
         */
        _uiFunActionSignal(msg) {
          if (!msg.data || !msg.data.action_id) {
            logger$2.warn(`_uiFunActionSignal: data: ${msg.data} are invalid`);
            return false;
          }
          // we will send the new signal here depending on the action id:
          const counter = msg.data.counter ? msg.data.counter : 1;
          this.sigHandler.setActionSignal(msg.data.action_id, msg.origin, counter);

          return true;
        }

        _uiFunOffersStateChanged(msg) {
          if (!msg.data || !msg.data.offers_ids || !msg.data.new_state) {
            logger$2.warn(`_uiFunOffersStateChanged: invalid arguments: ${JSON.stringify(msg)}`);
            return false;
          }

          // for each of the offers we now set the new state
          let somethingModified = false;
          const self = this;
          msg.data.offers_ids.forEach(oid => {
            const campaignID = this.offersDB.getCampaignID(oid);
            if (!campaignID) {
              logger$2.warn(`_uiFunOffersStateChanged: offer with ID ${oid} is not present?`);
              return;
            }
            // change the state here directly
            self.offersDB.addOfferAttribute(oid, 'state', msg.data.new_state);
            somethingModified = true;
          });

          // TODO: do we want to track this here? for example the history that the
          // state has changed? maybe not since it will happen very frequent in some
          // real states.

          if (somethingModified) {
            // emit a message to all the real states?
            const realStatesDest = [];
            const msgData = {
              offer_ids: msg.data.offers_ids
            };
            this._publishMessage(MessageType.MT_OFFERS_STATE_CHANGED, realStatesDest, msgData);
          }
          return true;
        }

        /**
         * This method will track all the action signals that are related to an offer
         * but doesn't modify the logic of the core or anything, just for information.
         * @param  {[type]} options.offerID [description]
         * @param  {[type]} options.data    [description]
         * @param  {[type]} options.origin  [description]
         * @return {[type]}                 [description]
         */
        _uiFunOfferActionSignal(msg) {
          if (!msg.data || !msg.data.offer_id || !msg.data.action_id || typeof msg.data.action_id !== 'string') {
            logger$2.warn(`_uiFunOfferActionSignal: invalid arguments: ${JSON.stringify(msg)}`);
            return false;
          }
          const offerID = msg.data.offer_id;
          const campaignID = this.offersDB.getCampaignID(offerID);
          if (!campaignID) {
            logger$2.warn(`_uiFunOfferActionSignal: no campaign id for offer ${offerID}`);
            return false;
          }

          // send signal and add it as action on the offer list
          const counter = msg.data.counter ? msg.data.counter : 1;
          this.sigHandler.setCampaignSignal(campaignID, offerID, msg.origin, msg.data.action_id, counter);
          this.offersDB.incOfferAction(offerID, msg.data.action_id, counter);

          return true;
        }
      }

      /*
       * This module will provide an interface for saving / loading persistent data.
       *
       */

      class DBHelper {
        //
        // @brief constructor
        // @param db  the database instance to use (pouchdb)
        //
        constructor(db) {
          this.db = db;
        }

        saveDocData(docID, docData) {
          const self = this;
          return this.db.get(docID).catch(() => ({ _id: docID, doc_data: {} })).then(data => {
            const doc = Object.assign({}, data, {
              doc_data: Object.assign({}, data.doc_data, docData)
            });
            return self.db.put(doc);
          });
        }

        getDocData(docID) {
          return this.db.get(docID).then(doc => doc.doc_data).catch(err => {
            if (err && err.status && err.status !== 404) {
              logger$2.error(`getDocData: error getting doc ${docID} with err: `, err);
            } else {
              logger$2.log(`missing DB entry for docID ${docID}`);
            }
            return null;
          });
        }

        removeDocData(docID) {
          // https://pouchdb.com/api.html#delete_document
          const self = this;
          return self.db.get(docID).then(doc => {
            logger$2.log(`removeDocData: removing doc ${docID}`);
            return self.db.remove(doc);
          }).then(() => {
            // nothing to do
            logger$2.log(`removeDocData: doc ${docID} removed properly`);
          }).catch(err => {
            // nothing to do there
            if (err && err.status && err.status !== 404) {
              logger$2.error(`removeDocData: something happened removing the doc: ${docID} - err:`, err);
            } else {
              logger$2.log(`missing DB entry for docID ${docID}`);
            }
          });
        }
      }

      // generate a new UUID
      function generateUUID() {
        function s4() {
          return Math.floor((1 + random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
      }

      function timestamp() {
        return Math.round(Date.now() / 1000);
      }

      function timestampMS() {
        return Date.now();
      }

      function weekDay() {
        return new Date().getDay() + 1;
      }

      function dayHour() {
        return new Date().getHours();
      }

      /**
       * This method will return the unique generated number for a particular browser.
       * If the value is not generated yet will create a new one.
       * @return {int} the unique number we have for this user, the values will be between
       *               [0, 9999].
       */
      function getABNumber() {
        const prefID = 'offersUniqueNumber';
        let num = null;
        if (!CliqzUtils.hasPref(prefID)) {
          // generate one
          num = Math.floor(random() * 10000);
          CliqzUtils.setPref(prefID, num.toString());
        } else {
          // we get it and transform it to num
          num = Number(CliqzUtils.getPref(prefID, 0));
        }

        return num;
      }

      /**
       * this will generate a hash for the given string
       * @param  {[type]} str [description]
       * @return {[type]}     [description]
       */
      function hashString(str) {
        // copied from fast hash from adblocker/utils

        /* eslint-disable no-bitwise */

        let hash = 5381;
        for (let i = 0, len = str.length; i < len; i += 1) {
          hash = hash * 33 ^ str.charCodeAt(i);
        }

        // For higher values, we cannot pack/unpack
        return (hash >>> 0) % 2147483648;
      }

      /*
       * Module used to send signals to the BE every OffersConfigs.SIGNALS_OFFERS_FREQ_SECS
       * seconds.
       * Each signal (id) will be kept on the DB till OffersConfigs.SIGNALS_OFFERS_EXPIRATION_SECS
       * is reached from the last modification time.
       */
      ////////////////////////////////////////////////////////////////////////////////
      // consts
      const STORAGE_DB_DOC_ID = 'offers-signals';

      ////////////////////////////////////////////////////////////////////////////////
      // Helper methods

      function addOrCreate(d, field) {
        let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

        const elem = d[field];
        if (elem) {
          d[field] = elem + value;
        } else {
          d[field] = value;
        }
      }

      ////////////////////////////////////////////////////////////////////////////////
      class SignalHandler {

        //
        // @brief [v3.0] we will not use bucket anymore so now we will have the following
        //        data for each signal:
        // {
        //   sig_id: {
        //     created_ts: (when the signal was created),
        //     modified_ts: (when was last modified),
        //     be_sync: true/false (defines if the signal was sent properly to the BE)
        //     data: {
        //       // the signal data
        //     }
        //   }
        // }
        //
        // additionally we will have types of signals that will be stored in different
        // containers. Each type of signal should be identified with a unique ID as well.
        // @param sender is the interface to be use to sent messages, it will take:
        //  sender.httpPost args: (url, success_callback, data, onerror_callback, timeout)
        //
        constructor(offersDB, sender) {
          this.db = new DBHelper(offersDB);
          if (!sender) {
            sender = CliqzUtils;
          }
          this.sender = sender;
          // map from sig_type -> (sig_id -> sig_data)
          this.sigMap = {};
          // the builders
          this.sigBuilder = {
            'campaign': this._sigBuilderCampaign.bind(this),
            'action': this._sigBuilderAction.bind(this)

            // the signal queue
          };this.sigsToSend = {};

          // a mapping (signalType, signalKey) to the number of retries - sending signals to backend
          // we don't want to retry sending a signal more than 3 times because of network error
          this.signalSendingRetries = {};

          // dirty flag to save or not data
          this.dbDirty = false;

          // load the persistent data
          this._loadPersistenceData();

          // set the interval timer method to send the signals
          this.sendIntervalTimer = null;
          this._startSendSignalsLoop(OffersConfigs.SIGNALS_OFFERS_FREQ_SECS);

          // save signals in a frequent way
          const self = this;
          if (OffersConfigs.SIGNALS_LOAD_FROM_DB) {
            this.saveInterval = CliqzUtils.setInterval(() => {
              if (self.dbDirty) {
                self._savePersistenceData();
              }
            }, OffersConfigs.SIGNALS_AUTOSAVE_FREQ_SECS * 1000);
          }
        }

        _isMaximumNumRetriesReached(signalType, signalKey) {
          if (signalType in this.signalSendingRetries && signalKey in this.signalSendingRetries[signalType]) {
            const nRetries = this.signalSendingRetries[signalType][signalKey];
            return nRetries >= OffersConfigs.MAX_RETRIES;
          }
          return false;
        }

        _removeNumRetriesRecord(signalType, signalKey) {
          if (signalType in this.signalSendingRetries && signalKey in this.signalSendingRetries[signalType]) {
            delete this.signalSendingRetries[signalType][signalKey];
          }
        }

        _increaseNumRetriesRecord(signalType, signalKey) {
          if (!(signalType in this.signalSendingRetries)) {
            this.signalSendingRetries[signalType] = { [signalKey]: 1 };
            return;
          }

          if (!(signalKey in this.signalSendingRetries[signalType])) {
            this.signalSendingRetries[signalType][signalKey] = 1;
            return;
          }

          this.signalSendingRetries[signalType][signalKey] += 1;
        }

        // destructor
        destroy() {
          // save data
          this._savePersistenceData();

          // stop interval
          if (this.sendIntervalTimer) {
            CliqzUtils.clearInterval(this.sendIntervalTimer);
            this.sendIntervalTimer = null;
          }

          if (this.saveInterval) {
            CliqzUtils.clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
        }

        savePersistenceData() {
          return this._savePersistenceData();
        }

        //////////////////////////////////////////////////////////////////////////////
        //                    Special methods for signals types
        //////////////////////////////////////////////////////////////////////////////

        //
        // @brief We will store the following internal structure. Note that
        //        the internal structure is not the same than the one we will sent, still
        //        we need to have a possible way of building the structure from this one
        //
        //        This method will be used to increment the signals counters / values.
        //
        // {
        //   "campaign": {
        //     campaign_id_1: {
        //       created_ts: timestamp,
        //       modified_ts: timestamp,
        //       be_sync: false,
        //       seq: 0,
        //       data: {
        //         ucid: unique campaign id per user.,
        //         "offers": {
        //           offer_id_1: {
        //             created_ts: timestamp,
        //             "origins": {
        //               origin_id_1: {
        //                 signal_id_1: XXX,
        //                 ...
        //               }
        //             }
        //           }
        //         }
        //       }
        //     }
        //   }
        // }
        //
        // @param cid     is the campaign id
        // @param oid     is the offer id
        // @param origID  is the origin id of the signal
        // @param sid     is the signal id
        // @param count   is the number for which we want to increase the signal
        //
        setCampaignSignal(cid, oid, origID, sid) {
          let count = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

          if (!cid || !oid || !origID || !sid) {
            logger$2.warn('setCampaignSignal: invalid arguments?: ' + ' - cid: ' + cid + ' - oid: ' + oid + ' - origID: ' + origID + ' - sid: ' + sid);
            return false;
          }
          const sigType = 'campaign';
          const sigKey = cid;

          let sigInfo = this._getOrCreateSignal(sigType, sigKey);
          if (!sigInfo) {
            logger$2.error('setCampaignSignal: cannot create or get campaign signal: ' + sigKey);
            return false;
          }

          // now we update the data here
          let sigData = sigInfo.data;

          // check if we have the ucid
          if (!sigData.ucid) {
            // generate a new one
            sigData.ucid = generateUUID();
          }
          let offers = sigData.offers;
          if (!offers) {
            sigData.offers = offers = {};
          }

          // get the offer
          let currOffer = offers[oid];
          if (!currOffer) {
            offers[oid] = currOffer = {
              created_ts: Date.now(),
              origins: {}
            };
          }
          let origins = currOffer.origins;
          let origin = origins[origID];
          if (!origin) {
            origins[origID] = origin = {};
          }

          // create or increment the given signal
          addOrCreate(origin, sid, count);

          // mark it as modified
          this._markSignalAsModified(sigType, sigKey);

          logger$2.info(`setCampaignSignal: new signal added: ${cid} - ${oid} - ${origID} - ${sid} - +${count}`);
          return true;
        }

        /**
         * Will record a new action signal (basically normal telemetry that is not associated
         * to a particular offer or campaign id).
         * @param {string} actionID the action id (signal id)
         * @param {string} origID   the origin of the signal (who is producing it)
         * @param count   is the number for which we want to increase the signal
         * @description The internal information will be stored in a different way,
         * <pre>
         * {
         *  "action": {
         *    origin_id_1: {
         *      created_ts: timestamp,
         *      modified_ts: timestamp,
         *      be_sync: false,
         *      seq: 0,
         *      data: {
         *        uuid: unique campaign id per user.,
         *        "actions": {
         *          action_id_1: 1,
         *          action_id_2: N
         *        }
         *      }
         *    }
         *   }
         * }
         * </pre>
         *
         * We should send to the BE:
         * <pre>
         *   {
         *       "action": "offers-signal",
         *       "signal_id": "origin_here",
         *       "timestamp": "20170421",
         *       "payload": {
         *           "v": 3,
         *           "ex_v": "1.16.0",
         *           "is_developer": true,
         *           "type": "action",
         *           "data": {
         *               "o_id": "origin_here",
         *               "o_data": {
         *                   "seq": 0,
         *                   "created_ts": 1492768930539,
         *                   "uuid": "937bc2b7-5e27-772c-5d85-41da0110dc86",
         *                   "actions": {
         *                       "action_1": 0,
         *                       "action_2": 10,
         *                   }
         *               }
         *           }
         *       }
         * </pre>
         */
        setActionSignal(actionID, origID) {
          let count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

          if (!actionID || !origID) {
            logger$2.warn(`setActionSignal: invalid arguments?: ${actionID} - ${origID}`);
            return false;
          }
          const sigType = 'action';
          const sigKey = origID;

          let sigInfo = this._getOrCreateSignal(sigType, sigKey);
          if (!sigInfo) {
            logger$2.error(`setActionSignal: cannot create or get action signal: ${sigKey}`);
            return false;
          }

          // now we update the data here
          let sigData = sigInfo.data;

          // check if we have the uuid
          if (!sigData.uuid) {
            // generate a new one
            sigData.uuid = generateUUID();
          }

          // get the actions
          let actions = sigData.actions;
          if (!actions) {
            actions = sigData['actions'] = {};
          }

          // create or increment the given signal
          addOrCreate(actions, actionID, count);

          // mark it as modified
          this._markSignalAsModified(sigType, sigKey);

          logger$2.info(`setActionSignal: new signal added: ${origID} - ${actionID} - +${count}`);
          return true;
        }

        //////////////////////////////////////////////////////////////////////////////
        //                            PRIVATE METHODS

        _createSignal(sigData) {
          return {
            created_ts: Date.now(),
            modified_ts: Date.now(),
            seq: 0,
            be_sync: false,
            data: sigData
          };
        }

        //
        // @brief set a signal on a particular container
        //
        _markSignalAsModified(sigType, sigKey) {
          if (!sigType || !sigKey) {
            logger$2.warn('_markSignalAsModified: invalid args');
            return;
          }
          // check if the container exists
          let container = this.sigMap[sigType];
          if (!container) {
            logger$2.warn('_markSignalAsModified: invalid signal? cannot be updated');
            return;
          }

          // check if the sig exists for the given container
          let sigInfo = container[sigKey];
          if (!sigInfo) {
            logger$2.warn('_markSignalAsModified: signal is null, cannot be updated');
            return;
          }
          sigInfo.modified_ts = Date.now();

          // mark it as dirty
          sigInfo.be_sync = false;

          // we mark the DB as dirty here
          this.dbDirty = true;

          this._addSignalToBeSent(sigType, sigKey);
        }

        //
        // @brief this method will create the container if not exists, otherwise will
        //        return the container (in container.data should be stored the data)
        // @return on error null otherwise the pointer to the signalData
        //
        _getOrCreateSignal(sigType, sigKey) {
          let initData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          if (!sigType || !sigKey) {
            logger$2.warn('_getOrCreateSignal: invalid args');
            return null;
          }
          // check if the container exists
          let container = this.sigMap[sigType];
          if (!container) {
            // create a new one
            this.sigMap[sigType] = container = {};
          }

          // check if the sig exists for the given container
          let sigInfo = container[sigKey];
          if (!sigInfo) {
            logger$2.info('_setSignalData: creating new signal in ' + sigType + ' - ' + sigKey);
            container[sigKey] = sigInfo = this._createSignal(initData);
          }
          return sigInfo;
        }

        _getSignalInfo(sigType, sigKey) {
          if (!sigType || !sigKey) {
            logger$2.warn('getSignalData: sigType or sigKey null?');
            return null;
          }
          let container = this.sigMap[sigType];
          if (!container) {
            return null;
          }
          return container[sigKey];
        }

        // (EX-4191) Fix hpn-ts format to "yyyyMMdd"
        _getHpnTimeStamp() {
          var now = new Date();
          return now.toISOString().slice(0, 10).replace(/-/g, "");
        }

        _getMinuteTimestamp() {
          return Math.floor(Date.now() / 1000 / 60);
        }

        _addSignalToBeSent(sigType, sigKey) {
          let container = this.sigsToSend[sigType];
          if (!container) {
            this.sigsToSend[sigType] = container = new Set();
          }
          container.add(sigKey);
        }

        _sendSignalsToBE() {
          // iterate over all the signals and send them to the BE
          logger$2.info('_sendSignalsToBE: SENDING SIGNALSS TO BE!!!');
          const isDeveloper = CliqzUtils.getPref('developer', false) || CliqzUtils.getPref('offersDevFlag', false);

          let GID = CliqzUtils.getPref('anolysisGID');
          try {
            GID = JSON.parse(String(GID));
          } catch (err) {
            logger$2.log('sendSignalsToBE: GID is undefined');
            GID = 'undefined';
          }

          let self = this;
          try {
            const sigsKeysToSend = Object.keys(self.sigsToSend);
            const numSignalsToSend = sigsKeysToSend.length;

            sigsKeysToSend.forEach(function (signalType) {
              const container = self.sigsToSend[signalType];
              const containerArr = [...container];
              Object.keys(containerArr).forEach(function (i) {
                const sigID = containerArr[i];
                if (self._isMaximumNumRetriesReached(signalType, sigID)) {
                  return;
                }

                try {
                  let sigInfo = self._getSignalInfo(signalType, sigID);
                  if (!sigInfo || !sigInfo.data) {
                    logger$2.error('_sendSignalsToBE: we have a signal on the queue but the signal was removed?: ' + signalType + ' - ' + sigID + ' - ' + JSON.stringify(self.sigMap));
                    return;
                  }
                  let sigData = sigInfo.data;

                  // this will help us to avoid duplicated signals
                  if (sigInfo.be_sync) {
                    return;
                  }

                  // build the signal depending on the type
                  let builder = self.sigBuilder[signalType];
                  if (!builder) {
                    logger$2.error('_sendSignalsToBE: we dont have a builder for the sigtype: ' + signalType);
                    return;
                  }

                  let sigDataToSend = builder(sigID, sigInfo);
                  if (!sigDataToSend) {
                    logger$2.error('_sendSignalsToBE: something happened building the signal. ' + 'sigtype: ' + signalType + ' data: ' + JSON.stringify(sigInfo));
                    return;
                  }

                  // now we have the data in the proper structure to be sent over hpn

                  const hpnSignal = {
                    action: OffersConfigs.SIGNALS_HPN_BE_ACTION,
                    signal_id: sigID,
                    timestamp: self._getHpnTimeStamp(),
                    payload: {
                      v: OffersConfigs.SIGNALS_VERSION,
                      ex_v: config.EXTENSION_VERSION,
                      is_developer: isDeveloper,
                      gid: GID,
                      type: signalType,
                      sent_ts: self._getMinuteTimestamp(),
                      data: sigDataToSend
                    }
                  };

                  const hpnStrSignal = JSON.stringify(hpnSignal);
                  self.sender.httpPost(OffersConfigs.SIGNALS_HPN_BE_ADDR, function (success) {
                    logger$2.info('sendSignalsToBE: hpn signal sent');
                    const telMonitorSignal = {
                      type: 'offers_monitor',
                      is_developer: isDeveloper,
                      batch_total: numSignalsToSend,
                      msg_delivered: true
                    };
                    CliqzUtils.telemetry(telMonitorSignal);
                    self._removeFromSigsToSend(this.bindedST, this.bindedSID);
                    self._removeNumRetriesRecord(this.bindedST, this.bindedSID);
                  }.bind({ bindedST: signalType, bindedSID: sigID }), hpnStrSignal, function (err) {
                    logger$2.error('sendSignalsToBE: error sending signal to hpn: ' + err);
                    const telMonitorSignal = {
                      type: 'offers_monitor',
                      is_developer: isDeveloper,
                      batch_total: numSignalsToSend,
                      msg_delivered: false
                    };
                    CliqzUtils.telemetry(telMonitorSignal);
                    self._increaseNumRetriesRecord(this.bindedST, this.bindedSID);
                  }.bind({ bindedST: signalType, bindedSID: sigID }));
                  logger$2.info('sendSignalsToBE: hpn: ' + hpnStrSignal);
                } catch (err) {
                  logger$2.error('send one signal: something bad happened: ' + err);
                  self._removeFromSigsToSend(signalType, sigID);
                }
              });
            });
          } catch (err) {
            logger$2.error('sendSignalsToBE: something bad happened: ' + err);
            // we still want to remove here the signals to avoid infinit loop error?
            // this still means we will remove signals that will never reach the BE
            self.sigsToSend = {};
          }
          return true;
        }

        _removeFromSigsToSend(signalType, signalID) {
          const sInfo = this._getSignalInfo(signalType, signalID);
          // we mark the signal as sent to the BE
          sInfo.be_sync = true;
          // if we don't mark the db dirty here we will not be able to know that
          // was already sync
          this.dbDirty = true;

          if (signalType in this.sigsToSend) {
            this.sigsToSend[signalType].delete(signalID);
            if (this.sigsToSend[signalType].size === 0) {
              delete this.sigsToSend[signalType];
            }
          }
        }

        // this method will configure the interval call to
        _startSendSignalsLoop(timeToSendSecs) {
          this.sendIntervalTimer = CliqzUtils.setInterval(function () {
            // here we need to process this particular bucket
            if (Object.keys(this.sigsToSend).length > 0) {
              this._sendSignalsToBE();
            } else {
              logger$2.info('_startSendSignalsLoop: nothing to send');
            }
          }.bind(this), timeToSendSecs * 1000);
        }

        // save persistence data
        _savePersistenceData() {
          // for testing comment the following check
          if (!OffersConfigs.SIGNALS_LOAD_FROM_DB) {
            logger$2.info('_savePersistenceData: skipping the saving');
            return Promise.resolve(true);
          }
          // is db dirty?
          if (!this.dbDirty) {
            return Promise.resolve(true);
          }

          return new Promise((resolve, reject) => {
            return this.db.saveDocData(STORAGE_DB_DOC_ID, {
              sig_map: this.sigMap
            }).then(() => {
              this.dbDirty = false;
              resolve(true);
            });
          });
        }

        // load persistence data
        _loadPersistenceData() {
          // for testing comment the following check
          if (!OffersConfigs.SIGNALS_LOAD_FROM_DB) {
            logger$2.info('_loadPersistenceData: skipping the loading');
            return Promise.resolve(true);
          }

          let self = this;
          return self.db.getDocData(STORAGE_DB_DOC_ID).then(docData => {
            if (!docData || !docData.sig_map) {
              logger$2.error('_loadPersistenceData: something went wrong loading the data?');
              return;
            }
            // set the data
            self.sigMap = docData.sig_map;

            // db is not dirty anymore
            self.dbDirty = false;

            // remove old signals and add all the keys that are not sync with the BE yet
            const currentTS = Date.now();
            Object.keys(self.sigMap).forEach(signalType => {
              const container = self.sigMap[signalType];
              Object.keys(container).forEach(sigID => {
                const sigData = self._getSignalInfo(signalType, sigID);
                if (!sigData) {
                  return;
                }
                const timeDiff = (currentTS - sigData.modified_ts) / 1000;
                if (timeDiff >= OffersConfigs.SIGNALS_OFFERS_EXPIRATION_SECS) {
                  // remove this signal
                  logger$2.info('removing signal: ' + k + ' - data: ' + JSON.stringify(sigData));
                  delete container[k];
                  return;
                }
                if (!sigData.be_sync) {
                  self._addSignalToBeSent(signalType, sigID);
                  logger$2.info('_loadPersistenceData: signal ' + sigID + ' added to be sent to BE');
                }
              });
            });
            Promise.resolve(true);
          }).catch(err => {
            logger$2.error('_loadPersistenceData: error loading the storage data...: ' + JSON.stringify(err));
            Promise.resolve(false);
          });
        }

        //////////////////////////////////////////////////////////////////////////////
        //                      SIGNALS STRUCTURE BUILDERS
        //
        // each of those builders should return the data that we will put on the payload
        // basically.
        //////////////////////////////////////////////////////////////////////////////

        _sigBuilderCampaign(sigKey, sigData) {
          // we are storing the information as explained on setCampaignSignal
          // and we have to build it as explained on
          // https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/87966116/Real+Time+Analytics
          if (!sigKey || !sigData || !sigData.data) {
            logger$2.warn('_sigBuilderCampaign: invalid args');
            return null;
          }
          const sdata = sigData.data;
          let result = {
            c_id: sigKey,
            c_data: {
              seq: sigData.seq,
              created_ts: sigData.created_ts,
              ucid: sdata.ucid,
              offers: []
            }
          };

          // increment the sequence number here
          sigData.seq = sigData.seq + 1;

          // add the offers
          let offers = result.c_data.offers;
          Object.keys(sdata.offers).forEach(offerID => {
            const offerData = sdata.offers[offerID];
            const origins = offerData.origins;
            let resultOffer = {
              offer_id: offerID,
              created_ts: offerData.created_ts,
              offer_data: []
            };
            let resOfferData = resultOffer.offer_data;

            Object.keys(origins).forEach(originID => {
              let resultOrigin = {
                origin: originID,
                origin_data: origins[originID]
              };
              resOfferData.push(resultOrigin);
            });
            offers.push(resultOffer);
          });

          return result;
        }

        _sigBuilderAction(sigKey, sigData) {
          // we are storing the information as explained on setActionSignal
          // and we have to build it as explained on
          // https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/87966116/Real+Time+Analytics
          if (!sigKey || !sigData || !sigData.data) {
            logger$2.warn('_sigBuilderAction: invalid args');
            return null;
          }

          const sdata = sigData.data;
          let result = {
            o_id: sigKey,
            o_data: {
              seq: sigData.seq,
              created_ts: sigData.created_ts,
              uuid: sdata.uuid,
              actions: sdata.actions
            }
          };

          // increment the sequence number here
          sigData.seq = sigData.seq + 1;

          return result;
        }

      }

      const STORAGE_DB_DOC_ID$1 = 'offers-db';

      /**
       * This class will be used to hold all the information related to offers locally.
       * Will be the index for:
       * - offers object stored locally (storage).
       * - Signals we want to track per offer (history).
       * - index to retrieve offers from campaigns and campaigns from offers, etc.
       *
       */
      class OfferDB {
        constructor(offersDB) {
          this.db = new DBHelper(offersDB);

          // we will hold here the index data needed in a very basic and non duplicated
          // form, all the other index tables will be built after loaded from disk.
          // {
          //    // offer_id -> offer container information (main data)
          //    offers_index: {},
          //    // display_id -> (action_id -> action_container)
          //    display_ids_index: {}
          // }
          this.dataIndex = {
            offers_index: {},
            display_id_index: {}
          };

          // load and clean
          this._loadPersistentData();

          // temporary mapping counter to know when to remove a display or not
          this.displayIDCounter = {};

          // we will dynamically keep track of which offers are related to a particular
          // campaign id: campaign_id -> Set(offersIDs)
          this.campaignToOffersMap = {};

          this.dbDirty = false;

          // save offers in a frequent way
          const self = this;
          if (OffersConfigs.LOAD_OFFERS_STORAGE_DATA) {
            this.saveInterval = CliqzUtils.setInterval(() => {
              if (self.dbDirty) {
                self._savePersistentData();
              }
            }, OffersConfigs.OFFERS_STORAGE_AUTOSAVE_FREQ_SECS * 1000);
          }
        }

        destroy() {
          this.savePersistentData();
          if (this.saveInterval) {
            CliqzUtils.clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
        }

        savePersistentData() {
          return this._savePersistentData();
        }

        loadPersistentData() {
          return this._loadPersistentData();
        }

        // ---------------------------------------------------------------------------
        // The public methods will go here
        // ---------------------------------------------------------------------------

        /**
         * will return the metadata for a particular offer or null if not exists
         * @param  {string} offerID the offer id
         * @return {object} metadata or null if not exists.
         * <pre>
         * {
         *   c_ts: when was created timestamp
         *   l_u_ts: when was last updated timestamp (any interaction).
         * }
         * </pre>
         */
        getOfferMeta(offerID) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            return null;
          }
          return {
            c_ts: container.c_ts,
            l_u_ts: container.l_u_ts
          };
        }

        /**
         * adds a new offer object, this should be the object coming from the backend
         * with all the required fields
         * @param {[type]} offerID   [description]
         * @param {[type]} offerData [description]
         * @return {bool} true if was added | false otherwise
         */
        addOfferObject(offerID, offerData) {
          if (!this._isOfferValid(offerID, offerData)) {
            logger$2.warn(`addOfferObject: args invalid or data invalid: ${offerID} - ${offerData}`);
            return false;
          }

          let container = this.dataIndex.offers_index[offerID];
          if (container) {
            logger$2.warn(`addOfferObject: The offer id: ${offerID} already exists, will not add it here`);
            return false;
          }

          // create the container and a copy of the offer data object to avoid issues
          const offerDataCpy = JSON.parse(JSON.stringify(offerData));
          container = this._createOfferContainer();
          container.offer_obj = offerDataCpy;
          this.dataIndex.offers_index[offerID] = container;

          // update index tables
          this._updateIndexTablesForOffer(offerID);

          // mark it as dirty
          this._markOfferDirty(offerID);

          return true;
        }

        /**
         * will remove the offer object but not the action history
         * @param  {[type]} offerID [description]
         * @return {boolean} true on success false otherwise
         */
        removeOfferObject(offerID) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            logger$2.warn(`removeOfferObject: The offer id: ${offerID} is not stored`);
            return false;
          }

          // mark as dirty and update tables
          this._markOfferDirty(offerID);

          // we should not remove this since we relay still on accessing the display_id
          // information of the offer
          // this._removeIndexTablesForOffer(offerID);

          // remove the data
          // delete container.offer_obj;
          container.removed = true;

          // last update
          container.l_u_ts = timestampMS();

          return true;
        }

        /**
         * will return the offer object if we have it or null if not
         * Do not modify this object from outside.
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        getOfferObject(offerID) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            return null;
          }
          return container.offer_obj;
        }

        /**
         * will check if there is information about the offer or not
         * @param  {[type]}  offerID [description]
         * @return {Boolean}         true if there are or false otherwise
         */
        hasOfferData(offerID) {
          return this.dataIndex.offers_index[offerID] !== undefined;
        }
        hasOfferObject(offerID) {
          if (this.getOfferObject(offerID)) {
            return true;
          }
          return false;
        }
        isOfferPresent(offerID) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            return false;
          }
          return !container.removed;
        }

        /**
         * will update an offer object.
         * @param  {[type]} offerID   [description]
         * @param  {[type]} offerData [description]
         * @return {boolean} true on success | false otherwise
         */
        updateOfferObject(offerID, offerData) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            logger$2.warn(`updateOfferObject: the offer with ID: ${offerID} is not present`);
            return false;
          }
          // check if the offer is valid and is the same
          if (!this._isOfferValid(offerID, offerData)) {
            logger$2.warn(`updateOfferObject: offer ${offerID} is not valid`);
            return false;
          }

          if (container.offer_obj) {
            // check if we have an old object here
            const localOffer = container.offer_obj;
            if (offerData.offer_id !== localOffer.offer_id || offerData.campaign_id !== localOffer.campaign_id || offerData.display_id !== localOffer.display_id) {
              logger$2.warn('updateOfferObject: the offer core data is not similar? not supported for now');
              return false;
            }
          }
          // it is ok, we update the data
          container.offer_obj = JSON.parse(JSON.stringify(offerData));
          container.removed = false;

          // update timestamp
          this._markOfferDirty(offerID);
          container.l_u_ts = timestampMS();

          return true;
        }

        /**
         * this method will increment +1 a particular action for a given offer. This
         * will also update if needed the display ID
         * @param  {[type]} offerID  [description]
         * @param  {[type]} actionID [description]
         * @param  {[type]} incDisplay if true this will also increment the signal in the
         *                             display map.
         * @return {boolean} true on success | false otherwise
         */
        incOfferAction(offerID, actionID) {
          let incDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

          if (!offerID || !actionID) {
            logger$2.warn('incOfferAction: invalid args');
            return false;
          }
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            logger$2.warn(`incOfferAction: The offer id: ${offerID} is not stored`);
            return false;
          }

          const now = timestampMS();
          const offerObj = container.offer_obj;
          let actionCont = container.offer_actions[actionID];
          if (!actionCont) {
            // create a new one
            actionCont = this._createElementContainer();
            container.offer_actions[actionID] = actionCont;
            actionCont.count = 0;
          }
          actionCont.count += count;
          actionCont.l_u_ts = now;

          if (incDisplay) {
            const displayMap = this.dataIndex.display_id_index;
            let displayActionMap = displayMap[offerObj.display_id];
            if (!displayActionMap) {
              displayActionMap = {};
              displayMap[offerObj.display_id] = displayActionMap;
            }
            let displayCont = displayActionMap[actionID];
            if (!displayCont) {
              displayCont = this._createElementContainer();
              displayActionMap[actionID] = displayCont;
              displayCont.count = 0;
            }
            displayCont.count += count;
            displayCont.l_u_ts = now;
          }

          this._markOfferDirty(offerID);
          container.l_u_ts = now;

          return true;
        }

        /**
         * will return the metadata for a particular actionID and offerID.
         * @param  {[type]} offerID  [description]
         * @param  {[type]} actionID [description]
         * @return {object} the metadata for an action or null | undefined if not found
         * <pre>
         * {
         *   c_ts: timestamp,
         *   l_u_ts: timestamp,
         *   count: N,
         * }
         * </pre>
         */
        getOfferActionMeta(offerID, actionID) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            return null;
          }
          return container.offer_actions[actionID];
        }

        /**
         * add a generic attribute data to be stored on the offer with a generic value
         * @param {[type]} offerID [description]
         * @param {[type]} attrID  [description]
         * @param {[type]} data    [description]
         * @return {boolean} true on success | false otherwise
         */
        addOfferAttribute(offerID, attrID, data) {
          if (!offerID || !attrID) {
            logger$2.warn('addOfferAttribute: invalid args');
            return false;
          }
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            logger$2.warn(`addOfferAttribute: The offer id: ${offerID} is not stored`);
            return false;
          }

          const offerAttr = container.offer_attrs;
          let attrCont = offerAttr[attrID];
          if (!attrCont) {
            attrCont = this._createElementContainer();
            offerAttr[attrID] = attrCont;
          }

          const now = timestampMS();

          attrCont.attr = data;
          attrCont.l_u_ts = now;

          this._markOfferDirty(offerID);
          container.l_u_ts = now;

          return true;
        }

        /**
         * will return the associated attribute for the given offer and attrID, null if
         * not exists
         * @param  {[type]} offerID [description]
         * @param  {[type]} attrID  [description]
         * @return {[type]}         [description]
         */
        getOfferAttribute(offerID, attrID) {
          if (!offerID || !attrID) {
            logger$2.warn('getOfferAttribute: invalid args');
            return null;
          }
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            logger$2.warn(`getOfferAttribute: The offer id: ${offerID} is not stored`);
            return null;
          }

          const offerAttr = container.offer_attrs[attrID];
          if (!offerAttr) {
            return null;
          }
          return offerAttr.attr;
        }

        /**
         * will return the metadata of a display id for a particular actionID and displayID.
         * @param  {[type]} displayID  [description]
         * @param  {[type]} actionID [description]
         * @return {object} the metadata for an action and displayID or null if not found
         * <pre>
         * {
         *   c_ts: timestamp,
         *   l_u_ts: timestamp,
         *   count: N,
         * }
         * </pre>
         */
        getOfferDisplayActionMeta(displayID, actionID) {
          const displayMap = this.dataIndex.display_id_index;
          const container = displayMap[displayID];
          if (!container || !actionID) {
            return null;
          }
          return container[actionID];
        }

        /**
         * will return the associated campaign id for a particular offer, or null if not found
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        getCampaignID(offerID) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            return null;
          }
          return container.offer_obj.campaign_id;
        }

        /**
         * will return a set of all offers ids associated to a campaign, or null if no
         * campaign is found
         * @param  {[type]} campaignID [description]
         * @return {[type]}            [description]
         */
        getCampaignOffers(campaignID) {
          if (!campaignID) {
            return null;
          }
          return this.campaignToOffersMap[campaignID];
        }

        /**
         * this method will check on the given set of offers ids which is the offer
         * that was latest updated and still on the DB (i/e not removed).
         * @param  {[type]} offersIDsSet [description]
         * @return {list}              sorted list (by latest updated offer) of objects
         * with the following information:
         * {
         *   l_u_ts: ts,
         *   offer_id: offer id,
         *   campaign_id: cid,
         * }
         */
        getLatestUpdatedOffer(offersIDsSet) {
          if (!offersIDsSet) {
            return null;
          }

          const sortedOffers = [];
          const self = this;
          offersIDsSet.forEach(oid => {
            const offerCont = self.dataIndex.offers_index[oid];
            if (!offerCont || offerCont.removed === true || !offerCont.offer_obj) {
              return;
            }

            sortedOffers.push({
              offer_id: offerCont.offer_obj.offer_id,
              campaign_id: offerCont.offer_obj.campaign_id,
              last_update: offerCont.l_u_ts
            });
          });
          // we will sort using the last update field and putting the latest update
          sortedOffers.sort((a, b) => b.last_update - a.last_update);

          return sortedOffers;
        }

        /**
         * will retrieve all the offers we have applying filters and also sorting given
         * on the options argument.
         * @param  {object} opt containing the filter and sorting options:
         * <pre>
         * {
         *   filter: {
         *     // the dest field will be used just to query all the offers that
         *     // belong to a particular destination (on the list).
         *     // If the offer destination field is on the list will be returned
         *     dest: ['dest1', ...]
         *   },
         *   // how we want to sort the list, for now will be the newest first, olders
         *   // at the end
         *   sort: 'c_ts' or 'l_u_ts',
         * }
         * </pre>
         * @return {[type]}     [description]
         */
        getOffers() /* opt */{
          // for now we will list all the current offers and return them in a list
          const offers = [];
          const self = this;
          Object.keys(this.dataIndex.offers_index).forEach(offerID => {
            const cont = self.dataIndex.offers_index[offerID];
            // we add it if we have the offer object only
            if (cont.offer_obj && !cont.removed) {
              const offerInfo = {
                offer_id: cont.offer_obj.offer_id,
                offer: cont.offer_obj,
                last_update: cont.l_u_ts,
                created: cont.c_ts
              };
              offers.push(offerInfo);
            }
          });

          return offers;
        }

        // ---------------------------------------------------------------------------
        // The "private" methods will go here
        // ---------------------------------------------------------------------------

        /**
         * will return a basic container for every element we want to track: actions,
         * attributes, etc
         * @return {[type]} [description]
         * <pre>
         *   {
         *     c_ts: ts,
         *     l_u_ts: ts
         *   }
         * </pre>
         */
        _createElementContainer() {
          const now = timestampMS();
          return {
            c_ts: now,
            l_u_ts: now
          };
        }

        /**
         * this method will mark an offer as index, to improve the saving step
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        _markOfferDirty() {
          // TODO: for now we will just mark a flag that is dirty
          this.dbDirty = true;
        }

        /**
         * check validity of an offer
         * @param  {[type]}  offerID   [description]
         * @param  {[type]}  offerData [description]
         * @return {Boolean} true on success | false otherwise
         */
        _isOfferValid(offerID, offerData) {
          if (!offerID || !offerData || !offerData.offer_id || offerData.offer_id !== offerID || !offerData.display_id || !offerData.campaign_id) {
            return false;
          }
          return true;
        }

        /**
         * will create a new container (metadata) for an offerID
         * @return {object} that should be inserted on the index.
         * <pre>
         * {
         *   c_ts: ts,
         *   l_u_ts: ts,
         *   offer_obj: null,
         *   offer_attrs: {},
         *   offer_actions: {}, // the "history signals",
         *   removed: false,  // if it was removed or not from DB
         * }
         * </pre>
         */
        _createOfferContainer() {
          const now = timestampMS();
          return {
            c_ts: now,
            l_u_ts: now,
            offer_obj: null,
            offer_attrs: {},
            offer_actions: {},
            removed: false
          };
        }

        /**
         * will remove old entries from the main index
         * @return {[type]} [description]
         */
        _removeOldEntries() {
          const self = this;
          const now = timestampMS();
          const expTimeMs = OffersConfigs.OFFERS_STORAGE_DEFAULT_TTS_SECS * 1000;
          let dirty = false;
          Object.keys(this.dataIndex.offers_index).forEach(offerID => {
            const cont = self.dataIndex.offers_index[offerID];
            // check delta
            const delta = now - cont.l_u_ts;
            if (delta >= expTimeMs) {
              // we need to remove this.
              dirty = true;
              logger$2.info(`_removeOldEntries: removing old offer ${offerID} with delta time: ${delta}`);
              self._removeIndexTablesForOffer(offerID);
              delete self.dataIndex.offers_index[offerID];
            }
          });

          if (dirty) {
            this.dbDirty = true;
          }
        }

        /**
         * will add all the needed mappings on the tables for a particular offerID.
         * The offer should be added into the main index before calling this method.
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        _updateIndexTablesForOffer(offerID) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            logger$2.warn(`_updateIndexTablesForOffer: The offer id: ${offerID} is not stored`);
            return false;
          }
          const displayID = container.offer_obj.display_id;
          if (!this.dataIndex.display_id_index[displayID]) {
            this.dataIndex.display_id_index[displayID] = {};
          }
          if (this.displayIDCounter[displayID]) {
            this.displayIDCounter[displayID] += 1;
          } else {
            this.displayIDCounter[displayID] = 1;
          }

          this._addOfferInCampaignMap(container.offer_obj);

          return true;
        }

        /**
         * remove entries on the maps (index tables) for a given offer (that should still
         * be on the DB main index).
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        _removeIndexTablesForOffer(offerID) {
          const container = this.dataIndex.offers_index[offerID];
          if (!container) {
            logger$2.warn(`_removeIndexTablesForOffer: The offer id: ${offerID} is not stored`);
            return false;
          }
          const displayID = container.offer_obj.display_id;
          this.displayIDCounter[displayID] -= 1;
          if (this.displayIDCounter[displayID] <= 0) {
            // we need to remove this from the display_id_index
            delete this.dataIndex.display_id_index[displayID];
            this.dbDirty = true;
          }
          return true;
        }

        /**
         * will build all the needed index tables here.
         * @return {[type]} [description]
         */
        _buildIndexTables() {
          const self = this;
          Object.keys(this.dataIndex.offers_index).forEach(offerID => {
            self._updateIndexTablesForOffer(offerID);
          });
        }

        /**
         * will save the main index, all the others should be built from this one
         */
        _savePersistentData() {
          if (!OffersConfigs.LOAD_OFFERS_STORAGE_DATA) {
            logger$2.info('_savePersistentData: skipping saving offers DB');
            return Promise.resolve(true);
          }

          if (!this.dbDirty) {
            return Promise.resolve(true);
          }

          return this.db.saveDocData(STORAGE_DB_DOC_ID$1, {
            data_index: this.dataIndex
          }).then(() => {
            this.dbDirty = false;
            return Promise.resolve(true);
          });
        }

        /**
         * will load the main index and
         * return the Promise on success.
         */
        _loadPersistentData() {
          if (!OffersConfigs.LOAD_OFFERS_STORAGE_DATA) {
            logger$2.info('_loadPersistenceData: skipping the load of storage data');
            return new Promise(resolve => {
              resolve(true);
            });
          }
          const self = this;
          return new Promise(resolve => {
            this.db.getDocData(STORAGE_DB_DOC_ID$1).then(docData => {
              if (!docData || !docData.data_index) {
                logger$2.error('_loadPersistenceData: something went wrong loading the data?');
                resolve(false);
                return;
              }
              // set the data
              self.dataIndex = docData.data_index;

              // remove the old ones
              self._removeOldEntries();

              // build tables
              self._buildIndexTables();

              self.dbDirty = false;
              resolve(true);
            }).catch(err => {
              logger$2.error(`_loadPersistenceData: error loading the storage data...: ${JSON.stringify(err)}`);
              resolve(false);
            });
          });
        }

        _addOfferInCampaignMap(offer) {
          if (!offer || !offer.offer_id || !offer.campaign_id) {
            return;
          }
          let cset = this.campaignToOffersMap[offer.campaign_id];
          if (!cset) {
            cset = new Set();
            this.campaignToOffersMap[offer.campaign_id] = cset;
          }
          cset.add(offer.offer_id);
        }

        // ///////////////////////////////////////////////////////////////////////////
        // DEBUG HELPER METHODS
        // ///////////////////////////////////////////////////////////////////////////
        //

        /**
         * will remove the current database and store an empty element on the storage
         */
        __removePersistenLocalDB() {
          logger$2.info('__removePersistenLocalDB: removing current data and DB');
          this.dataIndex = {
            offers_index: {},
            display_id_index: {}
          };
          this.db.saveDocData(STORAGE_DB_DOC_ID$1, {
            data_index: this.dataIndex
          });
        }
      }

      var _slicedToArray$15 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /**
       * Implements a message queue, to force order in the processing of messages.
       * The queue is instantiated with a name and a callback (which can be async
       * and must return a Promise), and will feed in order the data received by
       * the `push` method.
       *
       * @constructor
       * @param {string} name - The name of the queue, useful for logging
       * @param {function} callback - Callback called on every message pushed in the
       *  queue. This can be a simple function, or async returning a Promise. In
       *  any case, all messages of the queue will be processed in the order of
       *  insertion.
       */
      var MessageQueue = function (name, callback) {
        const queue = [];
        let globalResolve = null;

        /**
         * @function getNextData
         *
         * Define a function to wait for next available message and
         * call `callback` on it. If nothing is available when this
         * is called, then the `resolve` is registered and will be
         * resolve on next message.
         */
        const getNextData = () => new Promise(resolve => {
          if (queue.length > 0) {
            // There is at least one message available in the queue.
            // Remove it from the queue and return it.
            resolve(queue.splice(0, 1)[0]);
          } else {
            // No message available in the queue, then register
            // the `resolve` which will be called when the next
            // message arrives.
            globalResolve = resolve;
          }
        });

        /**
         * @function registerCallbackOnData
         *
         * Define a listener on new messages, will continuously listen
         * on new messages (thanks to `getNextData`) and call callback
         * on each of them, in order.
         */
        const registerCallbackOnData = () => {
          getNextData().then(_ref => {
            var _ref2 = _slicedToArray$15(_ref, 3);

            let data = _ref2[0],
                resolvePush = _ref2[1],
                rejectPush = _ref2[2];
            return Promise.resolve(callback(data)).then(resolvePush).catch(rejectPush);
          }).catch(ex => console$1.error(`MessageQueue ${name} :: error: ${ex}`)).then(registerCallbackOnData);
        };

        /**
         * @function push
         *
         * Push a new message in the queue.
         *
         * @param {object} data - push a new message in the queue.
         */
        const push = data => {
          if (globalResolve !== null) {
            // A `getNextData` promise is waiting, so just resolve it with the
            // next message.
            const resolve = globalResolve;
            globalResolve = null;
            return new Promise((resolvePush, rejectPush) => resolve([data, resolvePush, rejectPush]));
          }

          // If no `getNextData` is waiting, then push the message into the
          // queue for later processing.
          return new Promise((resolve, reject) => {
            queue.push([data, resolve, reject]);
          });
        };

        // Start listening to incoming messages
        registerCallbackOnData();

        // The only interface for this entity is the `push` function,
        // that will add a message in the queue, processed async by
        // the callback.
        return {
          push,
          getSize() {
            return queue.length;
          }
        };
      };

      /**
       * We will define the interface that an expression should have here
       */
      class Expression {
        /**
         * construct the expression
         * @param  {Object} data object containing:
         * <pre>
         * {
         *   raw_op: {
         *     op_name: name,
         *     args: args,
         *     ttl: ttl if exists / null otherwise,
         *
         *   },
         *   // the parent trigger of the expression
         *   parent_trigger: parentTrigger,
         *
         *   // the expression builder that we will use to build them
         *   exp_builder: expBuilder,
         *
         *   // the regex cache handler
         *   regex_cache: regexpCache,
         *
         *   // the trigger cache
         *   trigger_cache: triggerCache,
         *   trigger_machine: triggerMachine
         *
         *   // the offer processor object
         *   offer_processor: offerProcessor,
         *   signals_handler: sigHandler,
         *   event_handler: evtHandlerMock,
         *
         *   // offers db
         *   offers_db: offersDB,
         *
         *   // history index
         *   history_index: historyIndex,
         *
         *   // extra databases needed.
         *   url_signal_db: urlSignalsDB,
         *   last_campaign_signal_db: lastCampaignSignalDB
         *
         * }
         * </pre>
         * @return {[type]}       [description]
         */
        constructor(data) {
          // we will store this since we will use it to create the hash in case we need it
          this.data = data;
          this.hash_id = null;
        }

        getHashID() {
          if (!this.hash_id) {
            this._buildHashID();
          }
          return this.hash_id;
        }

        getOpName() {
          if (!this.data || !this.data.raw_op) {
            return '';
          }
          return this.data.raw_op.op_name;
        }

        getTTL() {
          if (!this.data || !this.data.raw_op) {
            return null;
          }
          return this.data.raw_op.ttl;
        }

        /**
         * will evaluate the expression and return the promise value
         * @param  {[type]} ctx [description]
         * @return {[type]}     [description]
         */
        evalExpr(ctx) {
          if (!this.isBuilt()) {
            try {
              this.build();
            } catch (err) {
              return Promise.reject(err);
            }
          }
          // check if we have to check the cache or not
          const ttl = this.getTTL();
          if (ttl) {
            const hashID = this.getHashID();
            // check on the cache
            if (this.data.expression_cache.hasEntry(hashID)) {
              return Promise.resolve(this.data.expression_cache.getEntry(hashID));
            }

            // we don't have cache so evaluate, store and return
            return this.getExprValue(ctx).then(result => {
              this.data.expression_cache.addEntry(hashID, ttl, result);
              return Promise.resolve(result);
            });
          }
          // we dont have any ttl so no need to check nor store the cache
          return this.getExprValue(ctx);
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        API TO IMPLEMENT
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * return true if was built or false other wise
         * @return {Boolean} [description]
         */
        isBuilt() {
          throw new Error('isBuilt: this should be implemented on the inherited classes');
        }

        /**
         * will build the expression
         * @return {[type]} [description]
         */
        build() {
          throw new Error('build: this should be implemented on the inherited classes');
        }

        /**
         * will clean up if needed
         * @return {[type]} [description]
         */
        destroy() {}
        // nothing to do here


        /**
         * will evaluate the expression, this should be implemented by inherited classes
         * We assume here that the expression was already built
         * @param  {[type]} ctx [description]
         * @return {Promise}    should return a promise.
         */
        getExprValue() /* ctx */{
          throw new Error('getExprValue: this should be implemented on the inherited classes');
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        PRIVATE METHODS
        // ///////////////////////////////////////////////////////////////////////////

        _buildHashID() {
          if (this.hash_id || !this.data || !this.data.raw_op) {
            return;
          }
          try {
            this.hash_id = hashString(JSON.stringify(this.data.raw_op));
          } catch (err) {
            // error
            logger$2.error(`Error building the hash: ${err}`);
            logger$2.error(`Error building the hash for trigger id: ${this.data.parent_trigger.trigger_id}`);
            this.hash_id = null;
          }
        }
      }

      class ContextExpression extends Expression {
        constructor(data, ctxName) {
          super(data);
          this.ctxName = ctxName;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        API TO IMPLEMENT
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * return true if was built or false other wise
         * @return {Boolean} [description]
         */
        isBuilt() {
          return true;
        }

        /**
         * will build the expression
         * @return {[type]} [description]
         */
        build() {}
        // nothing to do


        /**
         * will clean up if needed
         * @return {[type]} [description]
         */
        destroy() {}
        // nothing to do here


        /**
         * will evaluate the expression, this should be implemented by inherited classes
         * @param  {[type]} ctx [description]
         * @return {Promise}    should return a promise.
         */
        getExprValue(ctx) {
          return Promise.resolve(ctx[this.ctxName]);
        }
      }

      class ValueExpression extends Expression {
        constructor(data, val) {
          super(data);
          this.val = val;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        API TO IMPLEMENT
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * return true if was built or false other wise
         * @return {Boolean} [description]
         */
        isBuilt() {
          return true;
        }

        /**
         * will build the expression
         * @return {[type]} [description]
         */
        build() {}
        // nothing to do


        /**
         * will clean up if needed
         * @return {[type]} [description]
         */
        destroy() {}
        // nothing to do here


        /**
         * will evaluate the expression, this should be implemented by inherited classes
         * @param  {[type]} ctx [description]
         * @return {Promise}    should return a promise.
         */
        getExprValue() /* ctx */{
          return Promise.resolve(this.val);
        }
      }

      // Helper modules
      function perfExprAnd(ctx, elemList) {
        let idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        if (!elemList || idx >= elemList.length) {
          return Promise.resolve(false);
        }
        const first = elemList[idx];
        return first.evalExpr(ctx).then(r => {
          if (!r) {
            return Promise.resolve(false);
          }
          // if we are in the last case return
          if (elemList.length === idx + 1) {
            return Promise.resolve(true);
          }
          return perfExprAnd(ctx, elemList, idx + 1);
        });
      }

      function perfExprOr(ctx, elemList) {
        let idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        if (!elemList || idx >= elemList.length) {
          return Promise.resolve(false);
        }
        const first = elemList[idx];
        return first.evalExpr(ctx).then(r => {
          if (r) {
            return Promise.resolve(true);
          }
          // if we are in the last case return
          if (elemList.length === idx + 1) {
            return Promise.resolve(false);
          }
          return perfExprOr(ctx, elemList, idx + 1);
        });
      }

      /**
       * This operation checks whether a particular pref is enabled or not.
       * @param {object} eventLoop
       * @param {list} args is a list of strings containing the pref as
       * first element and the expected value as second argument.
       * @return {Promise(Boolean)} String(getPref(args[0])) === String(args[1])
       * @version 1.0
       */
      class IfPrefExpr extends Expression {
        constructor(data) {
          super(data);
          this.prefName = null;
          this.expectedVal = null;
        }

        isBuilt() {
          if (!this.prefName || !this.expectedVal) {
            return false;
          }
          return true;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 2) {
            throw new Error('IfPrefExpr invalid args');
          }
          this.prefName = String(this.data.raw_op.args[0]);
          this.expectedVal = String(this.data.raw_op.args[1]);
        }

        destroy() {}

        getExprValue() /* ctx */{
          const prefVal = CliqzUtils.getPref(this.prefName, undefined);
          return Promise.resolve(prefVal === this.expectedVal);
        }
      }

      /**
       * Prints a message on the console
       * @param  {String} msg      the message to print on the console
       * @version 1.0
       */
      class LogExpr extends Expression {
        isBuilt() {
          return true;
        }

        build() {}

        destroy() {}

        getExprValue() /* ctx */{
          return new Promise(resolve => {
            if (OffersConfigs.LOG_ENABLED && this.data.raw_op.args && this.data.raw_op.args.length > 0) {
              // TODO: replace with the new logger?
              logger$2.info('log_expr', `[trigger_id: ${this.data.parent_trigger.trigger_id}]: ${this.data.raw_op.args[0]}`);
            }
            return resolve(true);
          });
        }
      }

      /**
       * Do a AND logic operation between the list of arguments
       * @param  {list} args is the list of arguments we want to perform the AND. It will
       *                     perform the AND between all of them.
       * @return {Promise(Boolean)}      true if all args return true, false otherwise
       * @version 1.0
       */
      class AndExpr extends Expression {
        constructor(data) {
          super(data);
          this.ops = null;
        }

        isBuilt() {
          return this.ops !== null;
        }

        build() {
          if (!this.data.raw_op.args) {
            throw new Error(`AndExpr invalid args: ${this.data.raw_op.args}`);
          }
          if (this.data.raw_op.args.length === 0) {
            this.ops = [];
            return;
          }
          // now we should build each operation
          const opList = [];
          this.data.raw_op.args.forEach(opArg => {
            opList.push(this.data.exp_builder.createExp(opArg, this.data.parent_trigger));
          });
          this.ops = opList;
        }

        destroy() {}

        getExprValue(ctx) {
          return perfExprAnd(ctx, this.ops);
        }
      }

      /**
       * Perform a OR logic operation over all the arguments provided
       * @param  {list} args the list of arguments we want to apply the OR operation.
       * @return {Promise(Boolean)}      true if any of the args is true, false otherwise
       * @version 1.0
       */
      class OrExpr extends Expression {
        constructor(data) {
          super(data);
          this.ops = null;
        }

        isBuilt() {
          return this.ops !== null;
        }

        build() {
          if (!this.data.raw_op.args) {
            throw new Error('OrExpr invalid args');
          }
          if (this.data.raw_op.args.length === 0) {
            this.ops = [];
            return;
          }
          // now we should build each operation
          const opList = [];
          this.data.raw_op.args.forEach(opArg => {
            opList.push(this.data.exp_builder.createExp(opArg, this.data.parent_trigger));
          });
          this.ops = opList;
        }

        destroy() {}

        getExprValue(ctx) {
          return perfExprOr(ctx, this.ops);
        }
      }

      /**
       * Negates (boolean) a particular argument
       * @param  {Boolean} arg the boolean value we want to negate.
       * @return {Promise(Boolean)} the negated value of arg.
       * @version 1.0
       */
      class NotExpr extends Expression {
        constructor(data) {
          super(data);
          this.exprToNegate = null;
        }

        isBuilt() {
          return this.exprToNegate !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length === 0) {
            throw new Error('NotExpr invalid args');
          }
          this.exprToNegate = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
        }

        destroy() {}

        getExprValue(ctx) {
          return this.exprToNegate.evalExpr(ctx).then(result => Promise.resolve(!result));
        }
      }

      /**
       * checks for equality of 2 arguments
       * @param  {anything} e1  The first element to check against the other
       * @param  {anything} e2  The second element to check against the other.
       * @return {Boolean} e1 === e2. Note that they should be of the same type or possible
       *                   to compare.
       * @version 1.0
       */
      class EqExpr extends Expression {
        constructor(data) {
          super(data);
          this.lExpr = null;
          this.rExpr = null;
        }

        isBuilt() {
          return this.lExpr && this.rExpr;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 2) {
            throw new Error('EqExpr invalid args');
          }
          this.lExpr = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
          this.rExpr = this.data.exp_builder.createExp(this.data.raw_op.args[1], this.data.parent_trigger);
        }

        destroy() {}

        getExprValue(ctx) {
          return Promise.all([this.lExpr.evalExpr(ctx), this.rExpr.evalExpr(ctx)]).then(result => Promise.resolve(result[0] === result[1]));
        }
      }

      /**
       * checks for greater than between 2 arguments
       * @param  {anything} e1  The first element to check against the other
       * @param  {anything} e2  The second element to check against the other.
       * @return {Boolean} e1 > e2. Note that they should be of the same type or possible
       *                   to compare.
       * @version 1.0
       */
      class GtExpr extends Expression {
        constructor(data) {
          super(data);
          this.lExpr = null;
          this.rExpr = null;
        }

        isBuilt() {
          return this.lExpr && this.rExpr;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 2) {
            throw new Error('GtExpr invalid args');
          }
          this.lExpr = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
          this.rExpr = this.data.exp_builder.createExp(this.data.raw_op.args[1], this.data.parent_trigger);
        }

        destroy() {}

        getExprValue(ctx) {
          return Promise.all([this.lExpr.evalExpr(ctx), this.rExpr.evalExpr(ctx)]).then(result => Promise.resolve(result[0] > result[1]));
        }
      }

      /**
       * checks for less than between 2 arguments
       * @param  {anything} e1  The first element to check against the other
       * @param  {anything} e2  The second element to check against the other.
       * @return {Boolean} e1 < e2. Note that they should be of the same type or possible
       *                   to compare.
       * @version 1.0
       */
      class LtExpr extends Expression {
        constructor(data) {
          super(data);
          this.lExpr = null;
          this.rExpr = null;
        }

        isBuilt() {
          return this.lExpr && this.rExpr;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 2) {
            throw new Error('LtExpr invalid args');
          }
          this.lExpr = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
          this.rExpr = this.data.exp_builder.createExp(this.data.raw_op.args[1], this.data.parent_trigger);
        }

        destroy() {}

        getExprValue(ctx) {
          return Promise.all([this.lExpr.evalExpr(ctx), this.rExpr.evalExpr(ctx)]).then(result => Promise.resolve(result[0] < result[1]));
        }
      }

      /**
       * check for text matching using normal regular expressions
       * @param  {String} text  The text we want to check against the regular expressions.
       *                        This can be the url for example.
       * @param  {String(s)} regexes The list of strings (regexes) we will use to check the
       *                        text.
       * @return {Promise(Boolean)} true if any of the regexes matches the text, false otherwise
       * @version 1.0
       */
      class MatchExpr extends Expression {
        constructor(data) {
          super(data);
          this.patterns = null;
        }

        isBuilt() {
          return !!this.patterns;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 2) {
            throw new Error('MatchExpr invalid args');
          }
          // we must ensure that is a list here, if not will fail
          this.patterns = [];
          // 04.10.2017 This loop starts from 1 to be compatible with the current trigger version,
          // we have to coordinate with new trigger version and change this.
          for (let i = 1; i < this.data.raw_op.args.length; i += 1) {
            this.patterns.push(this.data.raw_op.args[i]);
          }
        }

        destroy() {}

        getExprValue(ctx) {
          const currUlr = ctx['#lc_url'];
          let matched = false;
          for (let i = 0; i < this.patterns.length; i += 1) {
            const regex = this.data.regex_cache.getRegexp(this.patterns[i]);
            if (regex !== null && regex.test(currUlr)) {
              matched = true;
              break;
            }
          }
          return Promise.resolve(matched);
        }
      }

      /**
       * return the current timestamo
       * @return {Number} current time (Date.now())
       * @version 1.0
       */
      class TimestampExpr extends Expression {
        isBuilt() {
          return true;
        }

        build() {}

        destroy() {}

        getExprValue() /* ctx */{
          return Promise.resolve(timestampMS());
        }
      }

      /**
       * returns the current hour of the current time
       * @return {Number} current hour
       * @version 1.0
       */
      class DayHourExpr extends Expression {
        isBuilt() {
          return true;
        }

        build() {}

        destroy() {}

        getExprValue() /* ctx */{
          return Promise.resolve(dayHour());
        }
      }

      /**
       * return the current week day
       * @return {number} returns the current week day number
       * (1-Sunday, 2-Monday, ... 7-Saturday)
       * @version 1.0
       */
      class WeekDayExpr extends Expression {
        isBuilt() {
          return true;
        }

        build() {}

        destroy() {}

        getExprValue() /* ctx */{
          return Promise.resolve(weekDay());
        }
      }

      /**
       * this method is will check if queried keywords matche a given condition
       * @param  {Array} args is an array of objects
       * <pre>
       * [
       *   {
       *     keywords_list: [],
       *     time_range: N,
       *   }
       * ]
       * </pre>
       * @param {Object} context contains query related information
       * <pre>
       *  {
       *   #domain: "google.de",
       *   #query_info: "",
       *   #referrer: "",
       *   #url: "url_string",
       *   #url_data: Object
       * }
       * </pre>
       * @return {[Promise[boolean]]} async return whether there is a match or not
       * @version 1.0
       */
      class MatchQueryExpr extends Expression {
        constructor(data) {
          super(data);
          this.normalizedArgs = null;
          this.timeRange = null;
        }

        isBuilt() {
          return this.normalizedArgs;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('MatchQueryExpr invalid args');
          }
          const args = this.data.raw_op.args[0];
          if (!args.keywords_list) {
            throw new Error('MatchQueryExpr invalid args');
          }
          this.timeRange = Number(args.time_range);
          const normalizedKeywordData = [];
          args.keywords_list.forEach(rawTokenData => {
            normalizedKeywordData.push({
              contained: this.data.query_handler.normalizeTokenList(rawTokenData.keywords),
              filtered: this.data.query_handler.normalizeTokenList(rawTokenData.filter)
            });
          });
          this.normalizedArgs = normalizedKeywordData;
        }

        destroy() {}

        getExprValue(ctx) {
          const queryInfo = ctx['#query_info'];
          if (!queryInfo) {
            return Promise.resolve(false);
          }

          const thereIsAMatch = this.normalizedArgs.some(tokenData => this.data.query_handler.matchTokens(tokenData, this.timeRange));

          return Promise.resolve(thereIsAMatch);
        }
      }

      /**
       * this method will check if the user is in a particular area / place
       * @param  {Object} args
       * <pre>
       * {
       *   // this flag will be used to decide what we should use to check the location
       *   // as first option, if not available we check the second option.
       *   main_check: 'locs' | 'coords'
       *
       *   // coords checker information, basically a list of possible locations
       *   // and distances. If any of those matches => we return true
       *   //
       *   coords: [
       *     {long: X, lat: Y, d_km: Z},
       *     ...
       *   ],
       *
       *   // the locations information that we want to check, if any of those matches
       *   // then we return true.
       *   locs: {
       *     country_id: {
       *       cities: {
       *         city_id: [postal_code1, postal_code2, ...]
       *       }
       *     }
       *   }
       * }
       * </pre>
       * @return {[Promise[boolean]]} async return whether there is a match or not
       * @version 3.0
       */
      class GeoCheckExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('GeoCheckExpr invalid args');
          }
          const args = this.data.raw_op.args[0];
          if (!args.main_check || args.main_check !== 'locs' && args.main_check !== 'coords') {
            throw new Error('GeoCheckExpr invalid args for field main_check');
          }

          // check we have the default one at least
          if (args.main_check === 'locs') {
            if (!args.locs) {
              throw new Error('GeoCheckExpr invalid args: locs is missing?');
            }
          } else if (!args.coords) {
            throw new Error('GeoCheckExpr invalid args: coords is missing?');
          }

          this.args = args;
        }

        destroy() {}

        getExprValue() /* ctx */{
          try {
            // get the geo checker feature and check if it is available
            if (!this.data.feature_handler.isFeatureAvailable('geo')) {
              // for now we will not do anything
              return Promise.resolve(false);
            }
            const geoChecker = this.data.feature_handler.getFeature('geo');

            if (this.args.main_check === 'coords') {
              logger$2.error('We do not support coords yet');
              return Promise.resolve(false);
            }
            if (!geoChecker.isLocAvailable()) {
              // TODO: we can switch to the next check type
              return Promise.resolve(false);
            }
            // check check using the locs (we can maybe prebuilt this before)
            const countries = Object.keys(this.args.locs);
            for (let i = 0; i < countries.length; i += 1) {
              const country = countries[i];
              const cmap = this.args.locs[country];
              const cities = Object.keys(cmap);
              for (let j = 0; j < cities.length; j += 1) {
                const city = cities[j];
                const postals = cmap[city];
                if (!postals || postals.length === 0) {
                  const info = { country, city };
                  if (geoChecker.isSameLocation(info)) {
                    // finish automatically
                    return Promise.resolve(true);
                  }
                } else {
                  for (let k = 0; k < postals.length; k += 1) {
                    const info = { country, city, zip: postals[k] };
                    if (geoChecker.isSameLocation(info)) {
                      // finish automatically
                      return Promise.resolve(true);
                    }
                  }
                }
              }
            }
          } catch (e) {
            logger$2.error(`GeoCheckExpr error: ${JSON.stringify(e)}`);
          }
          return Promise.resolve(false);
        }
      }

      /**
       * This method will check if a particular feature is enabled or not and will
       * return true | false depending on that.
       * @param  {Object} The argument will be an object as follow
       * <pre>
       * {
       *   name: 'the_feature_name_to_check'
       * }
       * @return {[Promise[boolean]]} async returns true if the feature is enabled or not
       * @version 3.0
       */
      class IsFeatureEnabledExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
        }

        isBuilt() {
          return this.args;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('IsFeatureEnabledExpr invalid args');
          }
          const args = this.data.raw_op.args[0];
          if (!args.name) {
            throw new Error('IsFeatureEnabledExpr invalid args: name should be present');
          }
          this.args = args;
        }

        destroy() {}

        getExprValue() /* ctx */{
          let exists = false;
          try {
            exists = this.data.feature_handler.isFeatureAvailable(this.args.name);
          } catch (e) {
            logger$2.error('IsFeatureEnabledExpr exception: ', e);
          }
          return Promise.resolve(exists);
        }
      }

      /**
       * This operation will be the new way we will performs checks, in the history and
       * in the current url, depending on the type of arguments we provide.
       * The operation will take one argument that will be the arguments associated to it:
       * @param  {Object} args is an array of objects
       * <pre>
       * {
       *   // this flag will define if we should check the current url or the history
       *   // note that if this is set to true all the history flags will be ignored.
       *   match_current: true | false,
       *
       *   // will define the patterns object used for matching
       *   patterns: {
       *     // this will identify this patters uniquely, meaning if something change
       *     // on the patterns this id will change as well. If two operations use
       *     // the same patterns the id should be the same (id = hash(patterns_list))
       *     pid: 'unique pattern id',
       *     p_list: [
       *       p1,
       *       p2,...
       *     ]
       *   },
       *
       *  // this attributes will make only sense if we are in history mode.
       *
       *  // which is the minimum expected number of matches to make the operation true
       *  // meaning if #of_matches >= min_expected => true
       *  min_matches_expected: 1,
       *
       *  // since how many seconds ago we want to check the history. This is relative
       *  // from NOW_secs - since_secs.
       *  since_secs: N,
       *  // till how many seconds ago (end time = NOW_secs - till_secs).
       *  till_secs: M,
       *
       *  // if this flag is present and set to X then we will cache the value once
       *  // of the operation if and only if (#of_matches >= min_expected == true)
       *  // for the following X seconds.
       *  // Note that this is not the same than caching the value of the operation
       *  // itself since we cache true and false at a trigger level.
       *  cache_if_match_value_secs: X,
       *
       * }
       * </pre>
       * @return {[Promise[boolean]]} async return whether there is a match or not
       * @version 3.0
       */
      class PatternMatchExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
          this.isHistory = null;
          this.expireCache = null;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('PatternMatchExpr invalid args');
          }
          // we check that we have the proper arguments
          const args = this.data.raw_op.args[0];
          if (!args.patterns || !args.patterns.pid || !args.patterns.p_list) {
            throw new Error('PatternMatchExpr invalid args, missing patterns?');
          }
          // check if it is history or not, this should be defined
          if (args.match_current === undefined) {
            throw new Error('PatternMatchExpr invalid args, match_current argument missing?');
          }
          this.isHistory = args.match_current === false;
          if (this.isHistory === true) {
            // check history arguments
            if (!(args.min_matches_expected > 0)) {
              throw new Error('PatternMatchExpr invalid args, min_matches_expected argument missing?');
            }
            if (args.since_secs === undefined || args.till_secs === undefined || args.since_secs < args.till_secs) {
              throw new Error('PatternMatchExpr invalid args, since_secs or till_secs are wrong?');
            }
          }
          this.args = args;
        }

        destroy() {}

        getExprValue(ctx) {
          try {
            let result = false;
            if (this.isHistory === false) {
              result = this._matchCurrentUrl(ctx);
            } else if (this.isHistory === true) {
              result = this._matchHistory(ctx);
            }

            return Promise.resolve(result);
          } catch (e) {
            logger$2.error('PatternMatchExpr Error:', e);
            return Promise.reject(e);
          }
        }

        // ///////////////////////////////////////////////////////////////////////////
        // Private methods
        //

        _matchCurrentUrl(ctx) {
          // get the #url_data
          const urlData = ctx['#url_data'];
          if (!urlData) {
            logger$2.error('We do not have the #url_data object?');
            return false;
          }
          const mhandler = this.data.pattern_matching_handler;
          return mhandler.itMatches(urlData.getPatternRequest(), this.args.patterns);
        }

        _matchHistory() /* ctx */{
          const query = {
            since_secs: this.args.since_secs,
            till_secs: this.args.till_secs
          };

          // check if we have the cache flag activated, cache will be active only
          // if we matched and cache_if_match_value_secs > 0
          if (this.expireCache !== null && this.args.cache_if_match_value_secs > 0) {
            const lastStoredValSecs = (timestampMS() - this.expireCache) / 1000;
            if (lastStoredValSecs < this.args.cache_if_match_value_secs) {
              // we should return true here since we only cache when is true
              return true;
            }
          }
          // it is not cached check
          const handler = this.data.pattern_matching_handler;
          const historyMatchesCount = handler.countHistoryMatches(query, this.args.patterns);

          // check if it is partial
          const result = historyMatchesCount >= this.args.min_matches_expected;
          if (result && this.args.cache_if_match_value_secs > 0) {
            // cache the result
            this.expireCache = timestampMS();
          }
          return result;
        }
      }

      const ops = {
        $if_pref: IfPrefExpr,
        $log: LogExpr,
        $and: AndExpr,
        $or: OrExpr,
        $not: NotExpr,
        $eq: EqExpr,
        $gt: GtExpr,
        $lt: LtExpr,
        $match: MatchExpr,
        $timestamp: TimestampExpr,
        $day_hour: DayHourExpr,
        $week_day: WeekDayExpr,
        $match_query: MatchQueryExpr,
        $geo_check: GeoCheckExpr,
        $is_feature_enabled: IsFeatureEnabledExpr,
        $pattern_match: PatternMatchExpr
      };

      /**
       * This operation will make an offer "active" into the system, basically, this will
       * call the offer processor module which is responsible to filter + show offers.
       * If the offer is not active it will be shown in the given real states.
       * @param  {string} url   the current url
       * @param  {object} offer  is the offer object itself
       * @return {Promise(Boolean)} true if display the offer, otherwise false
       * @version 1.0
       */
      class ShowOfferExpr extends Expression {
        constructor(data) {
          super(data);
          this.urlData = null;
          this.offerInfo = null;
        }

        isBuilt() {
          return this.urlData && this.offerInfo;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 2) {
            throw new Error('ShowOfferExpr invalid args');
          }
          this.urlData = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
          this.offerInfo = this.data.raw_op.args[1];
        }

        destroy() {}

        getExprValue(ctx) {
          return this.urlData.evalExpr(ctx).then(urlVal => {
            this.offerInfo.rule_info.type = 'exact_match';
            this.offerInfo.rule_info.url = [urlVal];
            const result = this.data.offer_processor.pushOffer(this.offerInfo, this.offerInfo.rule_info);
            return Promise.resolve(result);
          });
        }
      }

      /**
       * Offer added is a method used to check if an offer was added (is active) or not
       * on the system in the last N seconds.
       * @param  {string} offerID The offer id we want to check
       * @param  {integer} secs The number of seconds
       * @return {boolean} true if the offer was "added" in the last secs seconds or false
       *                   otherwise
       * @version 1.0
       */
      class OfferAddedExpr extends Expression {
        constructor(data) {
          super(data);
          this.offerID = null;
          this.seconds = null;
        }

        isBuilt() {
          return this.offerID && this.seconds;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 2) {
            throw new Error('OfferAddedExpr invalid args');
          }
          this.offerID = this.data.raw_op.args[0];
          this.seconds = this.data.raw_op.args[1];
        }

        destroy() {}

        getExprValue() /* ctx */{
          // get the last offer updated time for this id
          const offerMeta = this.data.offers_db.getOfferMeta(this.offerID);
          if (!offerMeta) {
            return Promise.resolve(false);
          }
          const result = offerMeta.l_u_ts > timestampMS() - this.seconds * 1000;
          return Promise.resolve(result);
        }
      }

      /**
       * This function will select an offer from a list of them, using a new parameter
       * to distinguish how much probability should have to be shown.
       * This is an AB test internal method.
       * The way it works is as follow:
       * Given a unique number generated on the client side once (ABNum) and a list of
       * N offers containing a percentage number POi (percentage for offer i), assuming
       * that SUM(POi) = 1 for i: 0,..,N, we:
       *  1) Filter all the offers that doesn't contain the POi (just in case to avoid error,
       *     even when this is actually an error).
       *  2) We normalize the percentages (just in case SUM(POi) != 1), basically dividing
       *     each of the POi with the SUM(POi).
       *  3) We generate ranges of the form [..,(PO(i-1) * 10000, 10000 * POi),..] and we
       *     check in which range ABNum is in (note 10000 is the max num of the ABNum).
       *  4) After selecting that offer we show it as usual.
       * @param {string} url is the url that we want to
       * @param {list} offerList is the list of offers with their given percentage
       * @version 1.0
       */
      class ShowABOfferExpr extends Expression {
        constructor(data) {
          super(data);
          this.urlData = null;
          this.offersList = null;
        }

        isBuilt() {
          return this.urlData && this.offersList;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 2) {
            throw new Error('ShowABOfferExpr invalid args');
          }
          this.urlData = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
          this.offersList = this.data.raw_op.args[1];
        }

        destroy() {}

        getExprValue(ctx) {
          return this.urlData.evalExpr(ctx).then(urlVal => {
            if (!this.offersList || this.offersList.length === 0) {
              return Promise.reject(new Error('invalid args, no offers list?'));
            }

            // get the percentages of possibilities of each of the offers, if some of them
            // has not then we stop here.
            const percentages = {};
            let totalPct = 0.0;
            let index = -1;

            this.offersList.forEach(offerObj => {
              index += 1;
              if (!offerObj.ab_test_info || !offerObj.ab_test_info.pct) {
                return;
              }
              // we consider this
              const percentage = Number(offerObj.ab_test_info.pct);
              totalPct += percentage;
              percentages[index] = percentage;
            });

            if (totalPct <= 0) {
              return Promise.reject(new Error('we couldnt calculate the percentage of all the offers on the AB test group'));
            }

            // normalize just in case
            Object.keys(percentages).forEach(idx => {
              percentages[idx] /= totalPct;
            });

            // get the number and see in which range it is
            let accumPct = 0;
            let selectedOffer = null;
            const abNum = getABNumber();
            Object.keys(percentages).forEach(idx => {
              if (selectedOffer) {
                return;
              }
              accumPct += percentages[idx];
              const normNum = accumPct * 10000;
              if (abNum < normNum) {
                // this is the selected one
                selectedOffer = this.offersList[idx];
              }
            });

            // if there is no selected offer something very bad happened?
            if (!selectedOffer) {
              return Promise.reject(new Error('we couldnt select any offer.. this is not right'));
            }

            // continue with the normal flow
            selectedOffer.rule_info.type = 'exact_match';
            selectedOffer.rule_info.url = [urlVal];
            const result = this.data.offer_processor.pushOffer(selectedOffer, selectedOffer.rule_info);

            return Promise.resolve(result);
          });
        }
      }

      const ops$1 = {
        $show_offer: ShowOfferExpr,
        $offer_added: OfferAddedExpr,
        $show_ab_offer: ShowABOfferExpr
      };

      /**
       * Will check in the history if there is any matching against a list of regular
       * expresions.
       * At the same time if there is will add the current url to the history.
       * We will analyze all the urls in a range of time (timestamps in seconds) [start, end]
       * @param  {Number} start   the start timestamp on seconds
       * @param  {Number} end     the end time timestamp on seconds
       * @param  {list} patterns  The list if patterns to check against (string regex)
       * @return {Number} the number of matches we have.
       * @todo We will make this deprecate soon after integrating the new regex algorithm.
       * @version 1.0
       */
      class MatchHistoryExpr extends Expression {
        constructor(data) {
          super(data);
          this.start = null;
          this.end = null;
          this.patterns = null;
          this.regexesListCache = null;
        }

        isBuilt() {
          return this.start !== null && this.end !== null && this.patterns !== null;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 3) {
            throw new Error('MatchHistoryExpr invalid args');
          }
          this.start = this.data.raw_op.args[0];
          this.end = this.data.raw_op.args[1];
          this.patterns = [];
          for (let i = 2; i < this.data.raw_op.args.length; i += 1) {
            this.patterns.push(this.data.raw_op.args[i]);
          }
        }

        destroy() {}

        getExprValue(ctx) {
          if (!this.regexesListCache) {
            // we get all the regexes first
            this.regexesListCache = [];
            for (let i = 0; i < this.patterns.length; i += 1) {
              const r = this.data.regex_cache.getRegexp(this.patterns[i]);
              if (r !== null) {
                this.regexesListCache.push(r);
              }
            }
          }

          // add current url to history, if it matches same patterns
          const currUlr = ctx['#lc_url'];
          if (currUlr && !this.data.history_index.hasUrl(ctx)) {
            for (let i = 0; i < this.regexesListCache.length; i += 1) {
              const re = this.regexesListCache[i];
              if (re && re.test(currUlr)) {
                this.data.history_index.addUrl(currUlr, ctx);
                break;
              }
            }
          }

          // now we ask for the cached versions
          const opID = this.getHashID();
          const ts = timestamp();
          const numMatches = this.data.history_index.countHistoryEntries(ts - this.start, ts - this.end, this.regexesListCache, opID);
          return Promise.resolve(numMatches);
        }
      }

      const ops$2 = {
        $match_history: MatchHistoryExpr
      };

      /**
       * send a signal to the BE, always associated to an offer. The offer will not be
       * the one provided on the arguments but we will get the latest offer active
       * for the given campaign:
       * offersIDs = offersForCampaign(campaignIDFromOffer(offer_id))
       * offerIDToUse = getLatestUpdatedOffer(offersIDs)
       * @param  {String} offerID The associated offer ID
       * @param  {String} actionID Is the signal name (key) to be sent
       * @param  {String} campaign id (@deprecated since it will not be used)
       * @param  {Object} will be a dictionary (object) with the following structure
       * <pre>
       * {
       *   // will be used to store the url where the signal will be sent getting it
       *   // from the context (current url). If the store is true and the url is on
       *   // the DB then we will change the signal name to repeated_ + signal_name.
       *   // On store == true we will also store the current url if not added before
       *   // If store == false we will not do anything described above.
       *   store: true / false,
       *
       *   // this parameter will be used (if present) to check when was the last signal
       *   // with the same name for the same campaign associated, and if exists we will
       *   // check the delta time from now to the last time we sent this signal.
       *   // in that case we will filter every signal that happened in that period of time
       *   // (now - last_signal_ts).
       *   // if this field is null or <= 0 nothing will be checked / filtered.
       *   filter_last_secs: N
       * }
       * </pre>
       * @version 2.0
       */
      class SendSignalExpr extends Expression {
        constructor(data) {
          super(data);
          this.offerID = null;
          this.key = null;
          this.options = null;

          // build the referrer cat map
          this.referrerCatMap = {
            // search cat
            google: 'search',
            yahoo: 'search',
            bing: 'search',
            duckduckgo: 'search'
            // meta-searchers?
          };
        }

        isBuilt() {
          return this.offerID && this.key;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 2) {
            throw new Error('SendSignalExpr invalid args');
          }
          this.offerID = this.data.raw_op.args[0];
          this.key = this.data.raw_op.args[1];
          // we will skip the campaign id since it is not used this.data.raw_op.args[2]
          this.options = this.data.raw_op.args[3];
        }

        destroy() {}

        getExprValue(ctx) {
          // if we do not have an offer already here then we will not create anything
          // here.
          if (!this.key || !this.data.offers_db.isOfferPresent(this.offerID)) {
            return Promise.resolve(false);
          }

          // EX-5017: store the action signal on the offer as well.
          // We will comment this line and fix it later on 1.19 since this will break
          // another behavior that is more important than this one. If we update the action
          // here on the offer db then when we get the latest offer that was updated
          // will be always this one.
          // We need to add a filter on db (extra argument) to avoid updating the latest
          // status of the offer for particular actions (silent actions).
          //
          // eventLoop.environment.incOfferAction(offerID, key);

          // we should get the associated offers for the current campaign id
          const campaignID = this.data.offers_db.getCampaignID(this.offerID);
          if (!campaignID) {
            return Promise.resolve(false);
          }

          const campaignOffers = this.data.offers_db.getCampaignOffers(campaignID);
          if (!campaignOffers) {
            return Promise.resolve(false);
          }

          const latestUpdatedOffers = this.data.offers_db.getLatestUpdatedOffer(campaignOffers);
          if (!latestUpdatedOffers || latestUpdatedOffers.length <= 0 || !latestUpdatedOffers[0].offer_id) {
            return Promise.resolve(false);
          }

          // we now get the latest updated offer that will be used to sent the signal
          const offerIDToUse = latestUpdatedOffers[0].offer_id;

          // check if we have this.options as arguments
          let sigToSend = this.key;
          let shouldFilterSignal = false;
          let referrerCat = null;
          if (this.options) {
            const currUrl = ctx['#url'];
            if (this.options.store && currUrl) {
              if (!this.data.url_signal_db) {
                return Promise.reject(new Error('we dont have the url_signal_db?'));
              }
              // we need to check on the DB the current url
              const sendSignalDb = this.data.url_signal_db;
              const urlEntryCont = sendSignalDb.getEntryContainer(currUrl);
              if (urlEntryCont) {
                // we need to increment the counter
                urlEntryCont.data.counter += 1;
                // update the key
                sigToSend = `repeated_${this.key}`;
              } else {
                sendSignalDb.setEntryData(currUrl, { counter: 1 });
              }
            }

            if (this.options.filter_last_secs && this.options.filter_last_secs > 0) {
              if (!this.data.last_campaign_signal_db) {
                return Promise.reject(new Error('we dont have the last_campaign_signal_db?'));
              }
              const lastCmpSignalDB = this.data.last_campaign_signal_db;
              let campaignMap = lastCmpSignalDB.getEntryData(campaignID);
              let lastUpdateTS = null;
              const now = timestampMS();
              if (!campaignMap) {
                // we need to create one
                campaignMap = {
                  [this.key]: {
                    counter: 1,
                    l_u_ts: now
                  }
                };
              } else {
                const keyMap = campaignMap[this.key];
                if (!keyMap) {
                  campaignMap[this.key] = { counter: 1, l_u_ts: now };
                } else {
                  campaignMap[this.key].counter += 1;
                  lastUpdateTS = keyMap.l_u_ts;
                  keyMap.l_u_ts = now;
                }
              }
              lastCmpSignalDB.setEntryData(campaignID, campaignMap);

              // check last update if we have it
              const deltaTime = (now - lastUpdateTS) / 1000;
              if (lastUpdateTS && deltaTime <= this.options.filter_last_secs) {
                shouldFilterSignal = true;
              }
            }

            if (this.options.referrer_cat) {
              // we get the referrer cat
              referrerCat = this._getReferrerCat(ctx['#referrer']);
              if (referrerCat) {
                referrerCat = `ref_${referrerCat}`;
              }
            }
          }

          // check if we need to filter the signal or not
          let result = true;
          if (!shouldFilterSignal) {
            result = this._sendSignal(offerIDToUse, sigToSend, referrerCat);
          }

          return Promise.resolve(result);
        }

        // ///////////////////////////////////////////////////////////////////////////
        // Private methods
        // ///////////////////////////////////////////////////////////////////////////

        _getReferrerCat(referrerName) {
          if (!referrerName || referrerName === '') {
            // it is none
            return 'none';
          }
          const refCat = this.referrerCatMap[referrerName];
          if (!refCat) {
            // is other
            return 'other';
          }
          return refCat;
        }

        _sendSignal(offerId, key) {
          let referrer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (!offerId || !key || !this.data.offers_db) {
            return false;
          }

          // get the campaign id for this offer if we have one.
          const campaignId = this.data.offers_db.getCampaignID(offerId);
          if (!campaignId) {
            return false;
          }

          // send the signal associated to the campaign using the origin trigger
          const originID = 'trigger';
          const sigHandler = this.data.signals_handler;
          let result = sigHandler.setCampaignSignal(campaignId, offerId, originID, key);

          // we also add the referrer category here
          if (referrer !== null) {
            result = sigHandler.setCampaignSignal(campaignId, offerId, originID, referrer) && result;
          }
          return result;
        }
      }

      const ops$3 = {
        $send_signal: SendSignalExpr
      };

      /* eslint no-param-reassign: ["error", { "props": false }] */

      /**
       * will start checking for requests in a domain. This is will start the mechanisms
       * to catch all requests that are performed on that domain so we can check for
       * conversions and more
       * @param  {string} domain the domain we want to start watching
       * @version 1.0
       */
      class WatchRequestsExpr extends Expression {
        constructor(data) {
          super(data);
          this.domain = null;
        }

        isBuilt() {
          return this.domain;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 1) {
            throw new Error('WatchRequestsExpr invalid args');
          }
          this.domain = this.data.raw_op.args[0];
        }

        destroy() {
          if (!this.domain) {
            return;
          }
          const cb = this.data.trigger_machine_executor.processWatchReqCallback;
          if (!this.data.event_handler.isHttpReqDomainSubscribed(cb, this.domain)) {
            return;
          }
          this.data.event_handler.unsubscribeHttpReq(cb, this.domain);
        }

        getExprValue() /* ctx */{
          try {
            const cb = this.data.trigger_machine_executor.processWatchReqCallback;
            if (this.data.event_handler.isHttpReqDomainSubscribed(cb, this.domain)) {
              // finish here
              return Promise.resolve(true);
            }

            // we add it and set the CB info
            const cbArgs = {
              trigger_id: this.data.parent_trigger.trigger_id
            };
            this.data.event_handler.subscribeHttpReq(cb, this.domain, cbArgs);
          } catch (e) {
            logger$2.error('Something happened when trying to subscribe the watch request', e);
          }
          return Promise.resolve(true);
        }
      }

      /**
       * this method will fetch from the BE the new subtriggers given the parent trigger ID
       * @param  {string} parentTriggerID  the id of the parent trigger that we want to
       *                                   to fetch the subtriggers for
       * @version 1.0
       */
      class ActivateSubtriggersExpr extends Expression {
        constructor(data) {
          super(data);
          this.parentTriggerId = null;
        }

        isBuilt() {
          return this.parentTriggerId;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 1) {
            throw new Error('ActivateSubtriggersExpr invalid args');
          }
          this.parentTriggerId = this.data.raw_op.args[0];
        }

        destroy() {}

        getExprValue(ctx) {
          return new Promise((resolve, reject) => {
            if (!ctx._currentTriggerLevel) {
              ctx._currentTriggerLevel = 0;
            }

            ctx._currentTriggerLevel += 1;
            if (ctx._currentTriggerLevel > 25) {
              reject(new Error('trigger depth > 25'));
              return;
            }

            let subtriggers = this.data.trigger_cache.getSubtriggers(this.parentTriggerId);
            if (!subtriggers || subtriggers.length === 0) {
              // load from server

              this.data.be_connector.sendApiRequest('loadsubtriggers', { parent_id: this.parentTriggerId }).then(payload => {
                subtriggers = payload;

                logger$2.info('ActivateSubtriggersExpr', `Loaded ${subtriggers.length} subtriggers`);
                if (logger$2.LOG_LEVEL === 'debug') {
                  logger$2.logObject(subtriggers.map(trigger => trigger.trigger_id));
                }

                // first cache
                this.data.trigger_cache.setSubtriggers(this.parentTriggerId, subtriggers);

                const p = [];
                subtriggers.forEach(trigger => {
                  this.data.trigger_cache.addTrigger(trigger);
                  p.push(this.data.trigger_machine.run(trigger, ctx));
                });

                Promise.all(p).then(() => {
                  resolve();
                }).catch(err => {
                  reject(err);
                });
              }).catch(err => {
                reject(err);
              });
            } else {
              const p = [];

              subtriggers.forEach(trigger => {
                p.push(this.data.trigger_machine.run(trigger, ctx));
              });
              Promise.all(p).then(() => {
                resolve();
              }).catch(err => {
                reject(err);
              });
            }
          });
        }
      }

      const ops$4 = {
        $watch_requests: WatchRequestsExpr,
        $activate_subtriggers: ActivateSubtriggersExpr
      };

      var moment = lazyLoader('moment.min.js', 'moment');

      /**
       * will return a list of date keys of all the days that we have between those
       * 2 timestamps (milliseconds from epoch). The range is inclusive for start and end
       * On error we return Null
       * @param  {[type]} startTS [description]
       * @param  {[type]} endTS   [description]
       * @return {[type]}         [description]
       */
      function getDaysFromTimeRange(startTS, endTS) {
        if (endTS < startTS) {
          return null;
        }

        let currDate = moment(startTS).startOf('day');
        const lastDate = moment(endTS).startOf('day');

        // check the diff in terms of days, if the diff is longer than MAX_DAYS we limit
        // return false
        const MAX_DAYS_RANGE = 365 * 5; // 5 years?
        let diffDaysCount = lastDate.diff(currDate, 'days');
        if (diffDaysCount > MAX_DAYS_RANGE) {
          // we will set the new time limit here
          currDate = lastDate.clone().subtract(MAX_DAYS_RANGE, 'days');
          diffDaysCount = MAX_DAYS_RANGE;
        }

        const result = [Number(currDate.format('YYYYMMDD'))];
        while (diffDaysCount > 0) {
          result.push(Number(currDate.add(1, 'days').format('YYYYMMDD')));
          diffDaysCount -= 1;
        }
        return result;
      }

      function getTodayDayKey() {
        return Number(moment().format('YYYYMMDD'));
      }

      function getDateFromDateKey(dateKey) {
        let hours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let seconds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        const hstr = hours < 10 ? `0${hours}` : `${hours}`;
        const mstr = min < 10 ? `0${min}` : `${min}`;
        const sstr = seconds < 10 ? `0${seconds}` : `${seconds}`;
        return Number(moment(`${dateKey}:${hstr}:${mstr}:${sstr}`, 'YYYYMMDD:HH:mm:ss').format('x'));
      }

      function timestamp$1() {
        return Date.now();
      }

      const getValidDaysFromHistory = (timeRangeSecs, historyData) => {
        const now = timestampMS();
        const startMS = now - timeRangeSecs * 1000;
        const endMS = now;
        const supportedDays = new Set(getDaysFromTimeRange(startMS, endMS));
        const result = {};
        const dataDays = Object.keys(historyData.per_day);
        for (let i = 0; i < dataDays.length; i += 1) {
          const day = dataDays[i];
          if (supportedDays.has(day) && historyData.per_day[day] && historyData.per_day[day].m > 0) {
            result[day] = historyData.per_day[day];
          }
        }
        return result;
      };

      /**
       * definition of a category.
       * check https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/144310279/Categories
       *
       * A category will be basically:
       * - name identifying the category (or id)
       * - list of patterns that identify the category
       * - the version of the category (for further updates)
       * - time window in seconds for the category (for how much time we want to track
       *   the category)
       * - extra information defining when the category will be considered active or not
       *
       * We will hold basically the following information:
       * - total number of urls processed.
       * - total number of matches of the category
       * - per day: how many matches and urls we have
       * - last timestamp we saw a match
       * - first timestamp we saw a match
       *
       *
       */
      class Category {
        constructor(name, patterns, version, timeRangeSecs, activationData) {
          // general category data
          this.name = name;
          this.patterns = patterns;
          this.version = version;
          this.timeRangeSecs = timeRangeSecs;
          this.activationData = activationData;

          const now = timestampMS();
          this.lastUpdateTs = now;
          this.createdTs = now;

          // match data
          this.matchData = this._defaultMatchData();
          this.lastActivationTS = null;

          this.isHistoryDataSet = false;

          // temporary cache data (not persistent)
          this.todayKey = null;
          this.tmpActivationValue = null;

          this.activationFunctionMap = {
            normalized: this._normalizedResults.bind(this),
            simpleCount: this._simpleCountResults.bind(this)
          };
        }

        /**
         * we need to set this shared structure to be able to calculate if the category
         * is active or not
         */
        setTotalDayHandler(totalDayHandler) {
          this.totalDayHandler = totalDayHandler;
        }

        // serialize
        serialize() {
          return {
            name: this.name,
            patterns: this.patterns,
            version: this.version,
            timeRangeSecs: this.timeRangeSecs,
            lastUpdateTs: this.lastUpdateTs,
            createdTs: this.createdTs,
            matchData: this.matchData,
            isHistoryDataSet: this.isHistoryDataSet,
            activationData: this.activationData,
            lastActivationTS: this.lastActivationTS
          };
        }

        // deserialize
        deserialize(data) {
          this.name = data.name;
          this.patterns = data.patterns;
          this.version = data.version;
          this.lastUpdateTs = data.lastUpdateTs;
          this.createdTs = data.createdTs;
          this.timeRangeSecs = data.timeRangeSecs;
          this.matchData = data.matchData;
          this.isHistoryDataSet = data.isHistoryDataSet;
          this.activationData = data.activationData;
          this.lastActivationTS = data.lastActivationTS;
        }

        getName() {
          return this.name;
        }

        getVersion() {
          return this.version;
        }

        hasPatterns() {
          return !!this.patterns;
        }

        getPatterns() {
          return this.patterns;
        }

        isHistoryDataSettedUp() {
          return this.isHistoryDataSet;
        }

        isActive() {
          const now = timestampMS();
          if (this.lastActivationTS !== null) {
            const stillActive = (now - this.lastActivationTS) / 1000 <= this.activationData.activationTimeSecs;
            if (stillActive) {
              return true;
            }
            this.lastActivationTS = null;
          }
          // we need to check
          const activationFun = this.activationFunctionMap[this.activationData.func];
          if (!activationFun) {
            logger$2.error(`We do not have the activation function ${this.activationData.func}`);
            return false;
          }
          const activationResult = activationFun(this.activationData.args);
          if (activationResult) {
            // cache the result here
            this.lastActivationTS = now;
          }

          return activationResult;
        }

        getTimeRangeSecs() {
          return this.timeRangeSecs;
        }

        // we will check if need to remove old data
        cleanUp() {
          const now = timestampMS();
          const days = Object.keys(this.matchData.perDay);
          let modified = false;
          const catLifeTimeMs = this.timeRangeSecs * 1000;
          for (let i = 0; i < days; i += 1) {
            const dayTs = getDateFromDateKey(days[i]);
            const timeDiff = now - dayTs;
            if (timeDiff > catLifeTimeMs) {
              // we need to remove this day
              this._removeDay(days[i]);
              modified = true;
            }
          }
          if (modified) {
            this.lastUpdateTs = now;
          }
        }

        isObsolete() {
          const now = timestampMS();
          const expireMsCount = this.timeRangeSecs * 1000;
          let isObsolete = false;
          if (this.matchData.lastMatchTs === null) {
            isObsolete = now - this.createdTs > expireMsCount;
          } else {
            isObsolete = now - this.matchData.lastMatchTs > expireMsCount;
          }
          return isObsolete;
        }

        hit() {
          const now = timestampMS();
          if (this.matchData.firstMatchTs === null) {
            this.matchData.firstMatchTs = now;
          }
          this.matchData.lastMatchTs = now;
          this.matchData.total.matches += 1;

          const todayKey = getTodayDayKey();
          let todayMatchData = this.matchData.perDay[todayKey];
          if (!todayMatchData) {
            todayMatchData = { matches: 0 };
            this.matchData.perDay[todayKey] = todayMatchData;
          }
          todayMatchData.matches += 1;

          this.lastUpdateTs = now;
        }

        updateWithHistoryData(data) {
          if (!data || !data.per_day) {
            throw new Error('invalid history data', data);
          }
          // reset match data
          this.matchData = this._defaultMatchData();
          this.isHistoryDataSet = true;

          let updated = false;
          const validDays = getValidDaysFromHistory(this.timeRangeSecs, data);
          const dayList = Object.keys(validDays);
          for (let i = 0; i < dayList.length; i += 1) {
            const day = dayList[i];
            const dataDay = validDays[day];
            const dayTS = getDateFromDateKey(day);

            this.matchData.perDay[day] = { matches: dataDay.m };
            this.matchData.total.matches += dataDay.m;
            this.matchData.firstMatchTs = Math.min(this.matchData.firstMatchTs, dayTS);
            this.matchData.lastMatchTs = Math.max(this.matchData.lastMatchTs, dayTS);
            updated = true;
            // note: it can happen that if todayKey == day then we need to do more
            // deep checks since we may miss some hit to the category here (the
            // history query can be delayed and the user can navigate on the category.
            // still is not so probably)
          }

          if (updated) {
            this.lastUpdateTs = timestampMS();
          }
        }

        getTotalMatches() {
          return this.matchData.total.matches;
        }

        getLastMatchTs() {
          return this.matchData.lastMatchTs;
        }

        getFirstMatchTs() {
          return this.matchData.firstMatchTs;
        }

        countDaysWithMatches() {
          return Object.keys(this.matchData.perDay).length;
        }

        _removeDay(dayKey) {
          // decrease the counter
          this.matchData.total.matches -= this.matchData.perDay[dayKey].matches;
          delete this.matchData.perDay[dayKey];
          this.lastUpdateTs = timestampMS();
        }

        _defaultMatchData() {
          return {
            total: {
              matches: 0
            },
            perDay: {},
            firstMatchTs: null,
            lastMatchTs: null
          };
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                      Activation functions here
        // ///////////////////////////////////////////////////////////////////////////

        _simpleCountResults(_ref) {
          let numDays = _ref.numDays,
              totNumHits = _ref.totNumHits;

          return (numDays === undefined || this.countDaysWithMatches() >= numDays) && (totNumHits === undefined || this.getTotalMatches() >= totNumHits);
        }

        _normalizedResults(args) {
          // check cached results:
          const todayKey = getTodayDayKey();
          if (todayKey !== this.todayKey || this._sumTotalCount === undefined) {
            this._sumTotalCount = 0;
            this._sumTotMatches = 0;
            if (args.endDayIdx > 0) {
              const prevResults = this._gatherPrevDaysData(args.endDayIdx, args.startDayIdx);
              for (let i = 0; i < prevResults.length; i += 1) {
                this._sumTotalCount += prevResults[i].t;
                this._sumTotMatches += prevResults[i].m;
              }
            }
          }

          let sumTotal = this._sumTotalCount;
          let sumMatches = this._sumTotMatches;
          // check if we have to get today as well
          if (args.startDayIdx === 0) {
            const todayData = this._gatherTodayData();
            sumTotal += todayData.t;
            sumMatches += todayData.m;
          }
          const resultValue = sumTotal > 0.0 ? sumMatches / sumTotal : 0.0;
          return resultValue >= args.threshold;
        }

        /**
         * This method will gather all the data for all the days this category will
         * use except today (since will change)
         * The return value will be a list of { t: total urls, m: matches }
         * @return {[type]} [description]
         */
        _gatherPrevDaysData(startDayIdx, endDayIdx) {
          // calculate the days except today
          const todayKey = getTodayDayKey();
          const dayMS = 1000 * 60 * 60 * 25;
          const now = timestampMS();
          const start = now - dayMS * startDayIdx;
          const end = now - dayMS * endDayIdx;
          const activationDays = getDaysFromTimeRange(start, end).filter(x => x !== todayKey);

          // get the values
          const result = [];
          for (let i = 0; i < activationDays.length; i += 1) {
            const ad = activationDays[i];
            const totCount = this.totalDayHandler.getCount(ad);
            const matchValue = this.matchData.perDay[ad] ? this.matchData.perDay[ad].matches : undefined;
            if (totCount === undefined || matchValue === undefined) {
              logger$2.info(`Warning: we do not have information yet for the day ${ad}`);
              // we need to avoid calculating it now and we should calculate it later
              return -1;
            }
            result.push({ t: totCount, m: matchValue });
          }

          return result;
        }

        /**
         * will return the {t: total urls, m: total matches} for today
         */
        _gatherTodayData() {
          const todayKey = getTodayDayKey();
          const totToday = this.totalDayHandler.getCount(todayKey);
          let totMathes = 0;
          if (totToday > 0.0 && this.matchData.perDay[todayKey]) {
            totMathes = this.matchData.perDay[todayKey].matches;
          }
          return { t: totToday, m: totMathes };
        }
      }

      /**
       * This operation will be used to check if a category is active or not given
       * the name of the category.
       * This operation will return true if the category is active or false otherwise
       * @param {object} args
       * <pre>
       * {
       *   catName: 'category_name'
       * }
       * </pre>
       * @version 5.0
       */
      class IsCategoryActiveExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('IsCategoryActiveExpr invalid args');
          }
          // we check that we have the proper arguments
          const args = this.data.raw_op.args[0];
          if (!args || !args.catName) {
            throw new Error('IsCategoryActiveExpr invalid args, missing catName?');
          }
          this.args = args;
        }

        destroy() {}

        getExprValue() {
          try {
            return Promise.resolve(this.data.category_handler.isCategoryActive(this.args.catName));
          } catch (e) {
            logger$2.error('IsCategoryActiveExpr Error:', e);
            return Promise.reject(e);
          }
        }
      }

      /**
       * This operation will add new categories to be observe on the client. It will
       * also update old ones if they are newer (the version of the category is higher).
       * @param {object} args
       * <pre>
       * {
       *   toUpdate: [
       *     categoryObj1,
       *     categoryObj2,
       *     ...
       *   ]
       * }
       * </pre>
       * where the category object is as described on the confluence:
       * https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/144310279/Categories
       * @version 5.0
       */
      class AddCategoriesExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
          this.executed = false;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('AddCategoriesExpr invalid args');
          }
          // we check that we have the proper arguments
          const args = this.data.raw_op.args[0];
          if (!args || !args.toUpdate) {
            throw new Error('AddCategoriesExpr invalid args, missing catName?');
          }
          this.args = args;
        }

        destroy() {}

        getExprValue() {
          if (this.executed) {
            return Promise.resolve(true);
          }
          try {
            this.args.toUpdate.forEach(catObj => {
              const category = this._buildCategoryFromObj(catObj);
              if (category) {
                this.data.category_handler.addCategory(category);
              }
            });

            // build the handler again
            this.data.category_handler.build();

            this.executed = true;
            return Promise.resolve(true);
          } catch (e) {
            logger$2.error('IsCategoryActiveExpr Error:', e);
            return Promise.reject(e);
          }
        }

        _buildCategoryFromObj(catObj) {
          if (!catObj || !catObj.name || !catObj.patterns || !catObj.version || !catObj.timeRangeSecs || !catObj.activationData) {
            logger$2.warning('invalid category object: ', catObj);
            return null;
          }
          return new Category(catObj.name, catObj.patterns, catObj.version, catObj.timeRangeSecs, catObj.activationData);
        }
      }

      const ops$5 = {
        $is_category_active: IsCategoryActiveExpr,
        $add_categories: AddCategoriesExpr
      };

      /**
       * Will set the current offers status we currently have on the backend.
       * @param  {object} containing the list of offers and their status as follow:
       * <pre>
       * {
       *   offer_id_1: X,
       *   offer_id_2: Y,
       *   ...
       * }
       * </pre>
       *
       * Where X | Y can be: {'active', 'inactive'}.
       * For all the offers that are not present / obsolete we can skip them directly,
       * since the offers-status-handler will take care of it.
       *
       * @version 4.0
       */
      class SetOffersStatusExpr extends Expression {
        constructor(data) {
          super(data);
          this.statusObj = null;
          this.alreadySet = false;
        }

        isBuilt() {
          return this.statusObj !== null;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 1 || typeof this.data.raw_op.args[0] !== 'object') {
            throw new Error('SetOffersStatusExpr invalid args');
          }
          this.statusObj = this.data.raw_op.args[0];
        }

        destroy() {}

        getExprValue() /* ctx */{
          if (!this.alreadySet) {
            if (logger$2.LOG_LEVEL === 'debug') {
              logger$2.debug('Setting the new offers status: ', this.statusObj);
            }
            this.data.offers_status_handler.loadStatusFromObject(this.statusObj);
            this.alreadySet = true;
          }
          return Promise.resolve(true);
        }
      }

      const ops$6 = {
        $set_offers_status: SetOffersStatusExpr
      };

      class ExpressionBuilder {
        /**
         * constructor
         * @param  {[type]} globalObjs [description]
         * {
         *   regex_cache: regexpCache,
         *   trigger_cache: triggerCache,
         *   trigger_machine: triggerMachine,
         *   offer_processor: offerProcessor,
         *   signals_handler: sigHandler,
         *   event_handler: evtHandlerMock,
         *   offers_db: offersDB,
         *   history_index: historyIndex,
         *   url_signal_db: urlSignalsDB,
         *   last_campaign_signal_db: lastCampaignSignalDB
         * }
         * @return {[type]}            [description]
         */
        constructor(globalObjs) {
          // this map will contain a name => Constructor type, and should respect the
          // proper format for each of the 3 cases.
          this.buildMap = {
            value: {},
            context: {},
            ops: {}
          };
          // we store all the global objects here
          this.globObjs = globalObjs;

          // we will register here the basic ops
          [ops, ops$1, ops$2, ops$3, ops$4, ops$5, ops$6].forEach(opsBuilders => {
            Object.keys(opsBuilders).forEach(exprName => {
              this.buildMap.ops[exprName] = opsBuilders[exprName];
              this.registerOpsBuilder(exprName, opsBuilders[exprName]);
            });
          });
        }

        destroy() {
          // nothing to do
        }

        registerOpsBuilder(name, b) {
          this.buildMap.ops[name] = b;
        }

        /**
         * this will create an expression but will not build it. it will just construct
         * it.
         * The caller is responsible for building it later
         * @param  {[type]} e the expression object
         * @return {[type]}   the proper Expression class or null on error
         */
        createExp(e, parentTrigger) {
          // we have 3 cases or types of expressions:
          // - value => (string or number or boolean)
          // - context => (string starting with #)
          // - op => (string starting with $)
          //
          // the op can only be an op if it is a list
          if (e === undefined || e === null) {
            const buildData = {
              exp_builder: this,
              parent_trigger: parentTrigger
            };
            return new ValueExpression(buildData, true);
          }
          let result = null;
          if (typeof e === 'object') {
            // it is a list
            result = this._buildOpExpr(e, parentTrigger);
          } else {
            const buildData = {
              exp_builder: this,
              parent_trigger: parentTrigger
            };
            // it is a string or literal
            if (typeof e === 'string') {
              if (e.length > 0 && e[0] === '#') {
                // is a context type
                result = new ContextExpression(buildData, e);
              } else {
                // is a value
                result = new ValueExpression(buildData, e);
              }
            } else {
              // is also a value different one
              result = new ValueExpression(buildData, e);
            }
          }
          if (result === null || result === undefined) {
            throw new Error(`createExp: we cannot build the operation ${e}`);
          }
          return result;
        }

        _buildOpExpr(e, parentTrigger) {
          // check if e is valid (format)
          if (!e || e.length === 0) {
            return null;
          }
          // now w
          const op = e.slice();
          const opName = op.shift();

          // check if we have the operation name
          if (!this.buildMap.ops[opName]) {
            logger$2.warn(`_buildOpExpr: we don't have the operation with name ${opName}`);
            return null;
          }

          let args = [];
          if (op.length > 0) {
            args = op.shift();
          }

          let ttl = 0;
          if (op.length > 0) {
            ttl = op.shift();
          }
          const buildData = {
            raw_op: {
              op_name: opName,
              args,
              ttl
            },
            parent_trigger: parentTrigger,
            exp_builder: this,
            regex_cache: this.globObjs.regex_cache,
            trigger_cache: this.globObjs.trigger_cache,
            trigger_machine: this.globObjs.trigger_machine,
            offer_processor: this.globObjs.offer_processor,
            signals_handler: this.globObjs.signals_handler,
            event_handler: this.globObjs.event_handler,
            offers_db: this.globObjs.offers_db,
            history_index: this.globObjs.history_index,
            last_campaign_signal_db: this.globObjs.last_campaign_signal_db,
            url_signal_db: this.globObjs.url_signal_db,
            trigger_machine_executor: this.globObjs.trigger_machine_executor,
            query_handler: this.globObjs.query_handler,
            expression_cache: this.globObjs.expression_cache,
            feature_handler: this.globObjs.feature_handler,
            be_connector: this.globObjs.be_connector,
            pattern_matching_handler: this.globObjs.pattern_matching_handler,
            category_handler: this.globObjs.category_handler,
            offers_status_handler: this.globObjs.offers_status_handler
          };
          const Builder = this.buildMap.ops[opName];
          return new Builder(buildData);
        }
      }

      class ExpressionCache {
        /**
         * constructor
         * @return {[type]}            [description]
         */
        constructor() {
          this.cache = new Map();
        }

        destroy() {
          // nothing to do
        }

        addEntry(expID, ttlSecs, val) {
          if (!expID || !ttlSecs) {
            return;
          }
          const expTs = timestampMS() + ttlSecs * 1000;
          this.cache.set(expID, { expirate_ts: expTs, data: val });
        }

        hasEntry(expID) {
          return this._expireCacheEntry(expID);
        }

        getEntry(expID) {
          if (!this._expireCacheEntry(expID)) {
            return null;
          }
          return this.cache.get(expID).data;
        }

        _expireCacheEntry(expID) {
          if (!this.cache.has(expID)) {
            return false;
          }
          const elem = this.cache.get(expID);
          const now = timestampMS();
          if (elem.expirate_ts < now) {
            this.cache.delete(expID);
            return false;
          }
          return true;
        }
      }

      /* eslint-disable no-param-reassign */

      class TriggerCache {
        constructor() {
          let triggerDestroyCb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          this.triggerIndex = {};
          this.lastExpireRun = 0;
          this.triggerDestroyCb = triggerDestroyCb;
        }

        // Add trigger to the cache.
        addTrigger(trigger) {
          this.expireCache();

          // need adding time for expiration using ttl
          trigger._added_ts = timestamp();
          trigger._subtriggers = null;

          this.triggerIndex[trigger.trigger_id] = trigger;
        }

        getTrigger(triggerId) {
          const self = this;

          return self.triggerIndex[triggerId];
        }

        setSubtriggers(parentTriggerId, subtriggers) {
          const self = this;

          const trigger = self.triggerIndex[parentTriggerId];
          if (trigger) {
            trigger._subtriggers = subtriggers;
          }
        }

        // Get dependent trigger from cache if any.
        getSubtriggers(triggerId) {
          const self = this;

          self.expireCache();

          const trigger = self.triggerIndex[triggerId];
          if (trigger && trigger._subtriggers) {
            const subtriggers = trigger._subtriggers.filter(() => self.triggerIndex[triggerId]);

            return subtriggers;
          }

          return [];
        }

        // Try to expire triggers. Run max once per minute.
        expireCache() {
          const ts = timestamp();

          if (ts - this.lastExpireRun < 60) {
            return;
          }

          Object.keys(this.triggerIndex).forEach(triggerId => {
            const trigger = this.triggerIndex[triggerId];
            if (trigger.ttl !== null && trigger._added_ts + trigger.ttl < ts) {
              if (this.triggerDestroyCb) {
                this.triggerDestroyCb(this.triggerIndex[triggerId]);
              }
              delete this.triggerIndex[triggerId];
            }
          });

          this.lastExpireRun = ts;
        }
      }

      /* eslint no-param-reassign: ["error", { "props": false }] */

      // /////////////////////////////////////////////////////////////////////////////
      // consts

      class TriggerMachine {
        constructor(globObjs) {
          this.globObjs = globObjs;
          this.globObjs.trigger_machine = this;
          this._onTriggerDestroy = this._onTriggerDestroy.bind(this);
          this.globObjs.trigger_cache = new TriggerCache(this._onTriggerDestroy);
          // the expression cache
          this.globObjs.expression_cache = new ExpressionCache();

          // the expressions builder
          this.expressionBuilder = new ExpressionBuilder(this.globObjs);

          // we hardcode the trigger root here
          this.triggersRoot = config.settings['triggers-root'] || 'root';

          // override if exists this flag
          if (CliqzUtils.getPref('offersTriggerRootOverride')) {
            this.triggersRoot = CliqzUtils.getPref('offersTriggerRootOverride');
          }

          this.rootTrigger = {
            parent_trigger_ids: [],
            trigger_id: this.triggersRoot,
            ttl: 3600,
            condition: null,
            actions: [['$activate_subtriggers', [this.triggersRoot]]]
          };
        }

        /**
         * returns a trigger by ID if we have otherwise null is returned
         * @param  {[type]} triggerID [description]
         * @return {[type]}           [description]
         */
        getTriggerByID(triggerID) {
          return this.globObjs.trigger_cache.getTrigger(triggerID);
        }

        runRoot(context) {
          // if root trigger has expired, add it again.
          // This is needed to reload subtriggers
          if (!this.globObjs.trigger_cache.getTrigger(this.triggersRoot)) {
            this.globObjs.trigger_cache.addTrigger(this.rootTrigger);
          }

          return this.run(this.rootTrigger, context);
        }

        run(trigger, context) {
          if (!trigger || !context) {
            logger$2.warn('run: Invalid trigger or context');
            return Promise.reject(false);
          }

          // we need to check if already build the conditions / actions of the trigger
          // if not we do it now
          if (!trigger.built_actions || !trigger.built_conds) {
            if (!this._buildTriggerData(trigger)) {
              // something bad happened, we should return false here
              logger$2.warn(`run: We couldnt build the trigger: ${JSON.stringify(trigger.trigger_id)}`);
              return Promise.reject(false);
            }
          }

          // we now evaluate the condition, and if it is true we evaluate each of the
          // other actions
          return this._executeExpression(trigger.built_conds, context).then(result => {
            if (result && trigger.built_actions) {
              // we execute the actions
              const actionsP = [];
              trigger.built_actions.forEach(action => {
                actionsP.push(this._executeExpression(action, context));
              });
              return Promise.all(actionsP).then(() => Promise.resolve()).catch(err => Promise.reject(err));
            }
            return Promise.resolve();
          }).catch(err => Promise.reject(err));
        }

        /**
         * this method will let us pre-build a trigger condition object once we fetch it
         * from the backend so we can process it faster later.
         * @param  {[type]} trigger [description]
         * @return {[type]}         [description]
         */
        _buildTriggerData(trigger) {
          if (!trigger) {
            return false;
          }
          // check if we have already the data built
          if (trigger.built_conds || trigger.built_actions) {
            return true;
          }

          // we build the data now
          try {
            trigger.built_conds = this.expressionBuilder.createExp(trigger.condition, trigger);
            const builtActions = [];
            trigger.actions.forEach(action => {
              builtActions.push(this.expressionBuilder.createExp(action, trigger));
            });
            trigger.built_actions = builtActions;
          } catch (err) {
            logger$2.error(`_buildTriggerData: something happened building the trigger: ${err}`);
            return false;
          }

          return true;
        }

        _executeExpression(expr, ctx) {
          // else we need to evaluate the expression and return
          return expr.evalExpr(ctx);
        }

        _onTriggerDestroy(t) {
          if (!t) {
            return;
          }
          if (t.built_conds) {
            t.built_conds.destroy();
            t.built_conds = null;
          }
          if (t.built_actions && t.built_actions.length > 0) {
            t.built_actions.forEach(action => {
              if (action) {
                action.destroy();
              }
            });
            t.built_actions = null;
          }
        }
      }

      /*
       * This module will provide an interface for saving / loading persistent data.
       *
       */
      /**
       * This class will be used to store different entries on a common DB doc name
       * with the following functionalities:
       * - possibility of add entries with particular keys (with any type of data).
       * - automatic track of last update / created of each entry.
       * - autosave entries after a given period of time if the doc is dirty.
       * - automatic removal of old entries given a delta time frame.
       *
       * @note It is important to note that we will share the reference that is returned
       * so whatever it happens outside of this class that modifies the entry should
       * be notified over markEntryDirty(eid);
       *
       * The layout is something like:
       * doc_id: {
       *   entrie_id_1: {
       *     c_ts: X, // the created timestamp,
       *     l_u_ts: Y, // the last update of the entry (timestamp)
       *     d: {
       *       // whatever the data you want to store for the entrie
       *     }
       *   }
       * }
       */
      class PersistentCacheDB {
        /**
         * @param {object} [db] The database to be wrapped into the DBHelper
         * @param {string} [docName] The docname to be used for storing the doc on the db
         * @param {Object} [config] as follow:
         *
         * configs: {
         *   // if we should persist / load the data from disk
         *   should_persist: true,
         *   // autosave time freq seconds, 0 means do not autosave
         *   autosave_freq_secs: N,
         *   // old entries delta time in seconds used to remove all entries that
         *   // (now - last_update_timesamp) > old_entries_dt_secs.
         *   old_entries_dt_secs: Z
         * }
         *
         */
        constructor(db, docName, configs) {
          this.db = new DBHelper(db);
          this.docName = docName;
          this.configs = configs;
          this.dbDirty = false;
          this.entries = {};
          if (configs && configs.autosave_freq_secs > 0) {
            this.autosaveTimer = CliqzUtils.setInterval(() => {
              if (this.dbDirty) {
                this.saveEntries();
              }
            }, configs.autosave_freq_secs * 1000);
          }
        }

        destroy() {
          if (this.autosaveTimer) {
            CliqzUtils.clearInterval(this.autosaveTimer);
            this.autosaveTimer = null;
          }
        }

        /**
         * will save the current entries if dirty
         * @param {boolean} [force] will override the configs.should_persist flag
         * @return a promise resolving to true on success | false otherwise
         */
        saveEntries() {
          let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (!this.db || !this.docName) {
            logger$2.warn('saveEntries: no db set or no doc set?');
            return Promise.resolve(false);
          }
          if (!force && !this.configs.should_persist) {
            // nothing to do
            return Promise.resolve(true);
          }

          // is dirty?
          if (!this.dbDirty) {
            return Promise.resolve(true);
          }

          const self = this;
          self._removeOldEntries();
          return this.db.saveDocData(this.docName, { entries: this.entries }).then(() => {
            self.dbDirty = false;
            return Promise.resolve(true);
          });
        }

        /**
         * will reload the entries
         * @param {boolean} [force] will override the configs.should_persist flag
         * @return {[type]} [description]
         */
        loadEntries() {
          let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (!this.db || !this.docName) {
            logger$2.warn('loadEntries: no db set or no doc set?');
            return Promise.resolve(false);
          }
          if (!force && !this.configs.should_persist) {
            // nothing to do
            return Promise.resolve(true);
          }

          const self = this;
          return self.db.getDocData(this.docName).then(docData => {
            if (!docData || !docData.entries) {
              logger$2.error('loadEntries: something went wrong loading the data?');
              return Promise.resolve(false);
            }

            // set the data
            self.entries = docData.entries;
            self._removeOldEntries();

            // db is not dirty anymore
            self.dbDirty = false;

            return Promise.resolve(true);
          }).catch(err => {
            logger$2.error(`loadEntries: error loading the storage data...: ${JSON.stringify(err)}`);
            Promise.resolve(false);
          });
        }

        /**
         * will set a new entry on the list, will also make it as dirty and update the
         * last update time (l_u_ts).
         * @param {string} eid  entry id
         * @param {anything that can be stored} data entry data
         */
        setEntryData(eid, data) {
          if (!eid) {
            return false;
          }
          let cont = this.entries[eid];
          if (!cont) {
            cont = this._createContainer();
            this.entries[eid] = cont;
          }
          cont.data = data;

          // cont.l_u_ts = timestampMS(); // this will be called on markEntryDirty
          this.markEntryDirty(eid);

          return true;
        }

        /**
         * will return the entry data if any, null / undefined if not exists
         * @param  {[type]} eid [description]
         * @return {[type]}     [description]
         */
        getEntryData(eid) {
          if (!eid) {
            return null;
          }
          const cont = this.entries[eid];
          return cont ? cont.data : null;
        }

        /**
         * will return the container of the entry if exists
         * {
         *   c_ts: (created timestamp),
         *   l_u_ts: (last updated timestamp),
         *   data: (object data)
         * }
         * @return {[type]} [description]
         */
        getEntryContainer(eid) {
          if (!eid) {
            return null;
          }
          return this.entries[eid];
        }

        /**
         * mark an entry as dirty and ifupdateLUTS == True then update the last_update
         * timestamp of the container
         * @param  {[type]} eid [description]
         * @param  {[type]} updateLUTS [description]
         * @return {[type]}     [description]
         */
        markEntryDirty(eid) {
          let updateLUTS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          // for now we will do a basic all at once since we cannot save entries separately
          if (!eid) {
            return;
          }
          const cont = this.entries[eid];
          if (!cont) {
            return;
          }
          if (updateLUTS) {
            cont.l_u_ts = timestampMS();
          }
          this.dbDirty = true;
        }

        _removeOldEntries() {
          if (!this.configs || this.configs.old_entries_dt_secs <= 0) {
            return;
          }
          const now = timestampMS();
          let isDirty = false;
          Object.keys(this.entries).forEach(ek => {
            const entry = this.entries[ek];
            if (!entry) {
              return;
            }
            // check the entry delta time
            const dt = now - entry.l_u_ts;
            if (dt >= this.configs.old_entries_dt_secs) {
              delete this.entries[ek];
              isDirty = true;
            }
          });
          if (isDirty) {
            this.dbDirty = true;
          }
        }

        _createContainer() {
          const now = timestampMS();
          return {
            c_ts: now,
            l_u_ts: now
          };
        }
      }

      // NOTES
      // - dependent triggers are only requestsed only when ALL previous dep triggers expire
      class TriggerMachineExecutor {
        constructor(globObjs) {
          this.globObjs = globObjs;
          this.globObjs.trigger_machine_executor = this;
          // the list events we need to process.
          this._processEvent = this._processEvent.bind(this);
          this.evtQueue = new MessageQueue('trigger-machine-queue', this._processEvent);

          // here we need to create 2 new databases for the send_signal operation,
          // this is very nasty and we should move it away after the refactorization
          // for performance (put them on the send_signal operation object itself)
          const urlDBconfigs = {
            should_persist: OffersConfigs.SEND_SIG_OP_SHOULD_LOAD,
            autosave_freq_secs: OffersConfigs.SEND_SIG_OP_AUTOSAVE_FREQ_SECS,
            old_entries_dt_secs: OffersConfigs.SEND_SIG_OP_EXPIRATION_SECS
          };
          // we will store here:
          // {
          //  url: {
          //    counter: N
          //  }
          // }
          // since we can get the last_update value from the container
          const urlSignalsDB = new PersistentCacheDB(this.globObjs.db, 'offers-signals-url', urlDBconfigs);
          urlSignalsDB.loadEntries();
          this.globObjs.url_signal_db = urlSignalsDB;

          // we will store here the latest conversion that happened for a campaign id:
          // {
          //  cid: {
          //    sig_name: {
          //      counter: N,
          //      l_u_ts: last timestamp happened.
          //    }
          //  }
          // }
          const lastCampaignSignalDB = new PersistentCacheDB(this.globObjs.db, 'offers-last-cmp-signals', urlDBconfigs);
          lastCampaignSignalDB.loadEntries();
          this.globObjs.last_campaign_signal_db = lastCampaignSignalDB;

          // the trigger machine
          this.triggerMachine = new TriggerMachine(this.globObjs);

          // callback
          this.processWatchReqCallback = this.processWatchReqCallback.bind(this);
        }

        destroy() {
          if (this.globObjs.url_signal_db) {
            this.globObjs.url_signal_db.saveEntries();
            this.globObjs.url_signal_db.destroy();
            this.globObjs.url_signal_db = null;
          }
          if (this.globObjs.last_campaign_signal_db) {
            this.globObjs.last_campaign_signal_db.saveEntries();
            this.globObjs.last_campaign_signal_db.destroy();
            this.globObjs.last_campaign_signal_db = null;
          }
        }

        /**
         * this method should be called everytime there is a url change
         * @param  {[type]} data contains the url and url object information.
         * @return {[type]}      [description]
         */
        processUrlChange(data) {
          let evtType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'url';

          this.evtQueue.push({ evt_type: evtType, evt_data: data });
        }

        /**
         * this method will be used to subscribe a new domain to watch a request
         * @param  {[type]} data [description]
         * @return {[type]}      [description]
         */
        processWatchReqCallback(data, cbArgs) {
          if (!data || !data.url_data || !cbArgs || !cbArgs.trigger_id) {
            // invalid call?
            logger$2.warn('processWatchReqCallback: invalid args');
            return;
          }
          // we check here if the trigger still exists
          const trigger = this.triggerMachine.getTriggerByID(cbArgs.trigger_id);
          if (!trigger) {
            return;
          }
          const d = {
            trigger_id: cbArgs.trigger_id,
            url_data: data.url_data
          };
          this.processUrlChange(d, 'req');
        }

        // ///////////////////////////////////////////////////////////////////////////
        // Private methods
        // ///////////////////////////////////////////////////////////////////////////
        //

        _processEvent(evtData) {
          if (!evtData || !evtData.evt_data) {
            return Promise.resolve(false);
          }
          const data = evtData.evt_data;
          try {
            // we process the event now
            const ctx = {
              '#url': data.url_data.getRawUrl(),
              '#lc_url': data.url_data.getLowercaseUrl(),
              '#domain': data.url_data.getDomain(),
              '#url_data': data.url_data,
              // adding the referrer as context information
              '#referrer': data.url_data.getReferrer()
            };

            // add the query handler info
            ctx['#query_info'] = data.queryInfo;

            let trigger = null;
            if (data.trigger_id) {
              trigger = this.triggerMachine.getTriggerByID(data.trigger_id);
            }
            logger$2.info(`processing new event for url: ${data.url_data.getRawUrl()}`);
            if (trigger) {
              return this.triggerMachine.run(trigger, ctx);
            }
            return this.triggerMachine.runRoot(ctx);
          } catch (err) {
            logger$2.error(`_processEvents: something wrong happened: ${err}`);
          }
          return Promise.resolve(false);
        }
      }

      class RegexpCache {
        constructor() {
          this.compiledRegexp = {};
          this.compiledRegexpCount = 0;
        }

        // Add trigger to the cache.
        getRegexp(pattern) {
          var self = this;

          var re = self.compiledRegexp[pattern];
          if (re) {
            return re;
          }

          try {
            re = new RegExp(pattern);
          } catch (e) {
            re = null;
          }
          if (self.compiledRegexpCount > 2500) {
            // reset cache completely.... TODO: improve this
            self.compiledRegexp = {};
            self.compiledRegexpCount = 0;
          }
          self.compiledRegexp[pattern] = re;
          self.compiledRegexpCount++;

          return re;
        }

      }

      const DB_DOC_NAME = 'trigger_history';
      const DB_ENTRY_ID = 'history';
      const MAX_HISTORY_RECORDS = OffersConfigs.TRIGGER_HISTORY_MAX_RECORDS;

      class HistoryIndex {
        constructor(db) {
          this.cachedCounts = new Map();
          this.entries = [];
          this.load(db);
        }

        load(db) {
          const self = this;
          // we won't persist any trigger history if LOAD_TRIGGER_HISTORY_DATA is disabled
          const conf = {
            should_persist: OffersConfigs.LOAD_TRIGGER_HISTORY_DATA,
            autosave_freq_secs: OffersConfigs.TRIGGER_HISTORY_OP_AUTOSAVE_FREQ_SECS,
            old_entries_dt_secs: -1
          };

          self.triggerHistoryDB = new PersistentCacheDB(db, DB_DOC_NAME, conf);
          if (OffersConfigs.LOAD_TRIGGER_HISTORY_DATA) {
            self.triggerHistoryDB.loadEntries().then(() => {
              self.entries = self.triggerHistoryDB.getEntryData(DB_ENTRY_ID);
              if (!self.entries) {
                self.entries = [];
              }
              logger$2.info(`Loaded trigger history from local storage. Num entries: ${self.entries.length}`);
            });
          } else {
            self.entries = [];
            logger$2.info('Loading history disabled');
          }
          this._save();
        }

        _save() {
          this.triggerHistoryDB.setEntryData(DB_ENTRY_ID, this.entries);
          this.triggerHistoryDB.saveEntries();
        }

        queryHistory(start, end) {
          let result = [];
          const leftIdx = this._leftMostIndex(start);
          const rightIdx = this._rightMostIndex(end);
          if (!(leftIdx === -1 || rightIdx === -1 || leftIdx > rightIdx)) {
            result = this.entries.slice(leftIdx, rightIdx + 1);
          }

          return result;
        }

        /**
         * This method caches the counts for query matches for:
         * 1. given time interval
         * and
         * 2. given set of triggers (i.e. operation)
         * This is done in order to reduce the amount of pattern match invocations
         * and limit them only to the time deltas
         * @param {number} start : start time
         * @param {number} end : end time
         * @param {Object[]} regexList : list of regexes that should be matched
         * @param {number} id : id of the operation
         * @returns {number} count of matches for a given timestamp and a given operation
         */
        countHistoryEntries(start, end, regexList, id) {
          let entriesToProcess = [];
          const cache = this.cachedCounts.get(id);
          let iStartCache = -1;
          let iEndCache = -1;
          let counts = 0;
          if (cache) {
            iStartCache = this._leftMostIndex(cache.t_start);
            iEndCache = this._rightMostIndex(cache.t_end);
            counts = cache.count;
          }
          const leftIdx = this._leftMostIndex(start);
          const rightIdx = this._rightMostIndex(end);

          // fail fast on error of index retrieval
          if (leftIdx === -1 || rightIdx === -1 || leftIdx > rightIdx) {
            return 0;
          }

          // a set of flags that are used to define a cache intersection with a given range
          const notIntersected = iEndCache < leftIdx || rightIdx < iStartCache;
          const cacheIsEmbedded = leftIdx <= iStartCache && iEndCache <= rightIdx;
          const intervalIsEmbedded = iStartCache <= leftIdx && rightIdx <= iEndCache;
          const isCacheRequiredForIntersection = () => {
            const leftCount = iStartCache < leftIdx ? leftIdx - iStartCache : 0;
            const rightCount = rightIdx > iEndCache ? rightIdx - iEndCache : 0;
            return iEndCache - leftIdx > leftCount + rightCount;
          };
          isCacheRequiredForIntersection();

          /**
           * Count a number of matches for a given set of triggers and a given set of History Entries
           * @param {[Object]} entriesForProcessing
           * @returns {number} number of matches
           */
          function countMatches(entriesForProcessing) {
            return entriesForProcessing.map(e => regexList.filter(r => r.test(e.url))).reduce((all, arr) => [...all, ...arr], []).length;
          }

          if (notIntersected) {
            counts = countMatches(this.entries.slice(leftIdx, rightIdx + 1));
          } else if (cacheIsEmbedded) {
            if (iStartCache - iEndCache > 0) {
              entriesToProcess = this.entries.slice(leftIdx, rightIdx + 1);
            } else if (iStartCache === leftIdx && iEndCache < rightIdx) {
              entriesToProcess = this.entries.slice(iEndCache + 1, rightIdx + 1);
            } else if (iEndCache === rightIdx && iStartCache > leftIdx) {
              entriesToProcess = this.entries.slice(leftIdx, iStartCache);
            } else if (iStartCache > leftIdx && iEndCache < rightIdx) {
              entriesToProcess = this.entries.slice(leftIdx, iStartCache).concat(this.entries.slice(iEndCache + 1, rightIdx + 1));
            } else {
              entriesToProcess = [];
            }
            if (entriesToProcess.length !== 0) {
              counts += countMatches(entriesToProcess);
            }
          } else if (intervalIsEmbedded) {
            if (isCacheRequiredForIntersection) {
              if (iStartCache === leftIdx && iEndCache > rightIdx) {
                entriesToProcess = this.entries.slice(rightIdx + 1, iEndCache + 1);
              } else if (iEndCache === rightIdx && iStartCache < leftIdx) {
                entriesToProcess = this.entries.slice(iStartCache, leftIdx);
              } else {
                entriesToProcess = this.entries.slice(iStartCache, leftIdx).concat(this.entries.slice(rightIdx + 1, iEndCache + 1));
              }
              counts -= countMatches(entriesToProcess);
            } else {
              entriesToProcess = this.entries.slice(leftIdx, rightIdx + 1);
              counts = countMatches(entriesToProcess);
            }
          } else {
            counts = countMatches(this.entries.slice(leftIdx, rightIdx + 1));
          }
          this.cachedCounts.set(id, { t_start: start, t_end: end, count: counts });
          return counts;
        }

        /**
         * perform binary search
         * return the index of the first element (from left to right) having ts >= leftBoundTS
         * @param leftBoundTS
         * @returns {number}
         * @private
         */
        _leftMostIndex(leftBoundTS) {
          const nEntries = this.entries.length;
          if (nEntries === 0) {
            return -1;
          }
          if (this.entries[nEntries - 1].ts < leftBoundTS) {
            return -1;
          }

          let low = 0;
          let high = nEntries - 1;
          while (low <= high) {
            const mid = Math.floor(low + (high - low) / 2);
            if (this.entries[mid].ts >= leftBoundTS) {
              high = mid - 1;
            } else {
              low = mid + 1;
            }
          }
          return high + 1;
        }

        /**
         * perform binary search
         * return the index of the last element (from left to right) having ts <= rightBoundTS
         * @param rightBoundTS
         * @returns {number}
         * @private
         */
        _rightMostIndex(rightBoundTS) {
          const nEntries = this.entries.length;
          if (nEntries === 0) {
            return -1;
          }
          if (this.entries[0].ts > rightBoundTS) {
            return -1;
          }

          let low = 0;
          let high = nEntries - 1;
          while (low <= high) {
            const mid = Math.floor(low + (high - low) / 2);
            if (this.entries[mid].ts > rightBoundTS) {
              high = mid - 1;
            } else {
              low = mid + 1;
            }
          }
          return low - 1;
        }

        addUrl(url, context) {
          /* eslint-disable no-param-reassign */

          if (context._urlAddedToHistory) {
            return;
          }
          context._urlAddedToHistory = true;

          logger$2.info(`URL added to history: ${url}`);

          this.entries.push({
            url,
            ts: timestamp()
          });
        }

        hasUrl(context) {
          return !!context._urlAddedToHistory;
        }

        savePersistentData() {
          if (OffersConfigs.LOAD_TRIGGER_HISTORY_DATA) {
            this.entries = this.entries.splice(-MAX_HISTORY_RECORDS);
            this._save();
          }
        }

        destroy() {
          this.triggerHistoryDB.destroy();
        }
      }

      // //////////////////////////////////////////////////////////////////////////////////
      // This module is used to handle (extract and normalize) queries that are typed by
      // the User in the following commercially valuable engines:
      // * Google
      // * Bing
      // * Amazon
      // * Yahoo
      // //////////////////////////////////////////////////////////////////////////////////
      const STORAGE_DB_DOC_ID$2 = 'offers-queries';

      class QueryHandler {
        constructor(offersDB) {
          if (offersDB) {
            this.db = new DBHelper(offersDB);
          } else {
            this.db = null;
          }

          // Posting list related to the query.
          this.queryPostings = {};

          // tsToPosting represents a mapping form ts to a posting.
          // Timestamp is effectively used as lookup index.
          this.tsToPostingMap = {};

          // listPostings DS is a list of objects containing postings in a structured way
          // Used for persising. At the time of writing list is always truncated to the last 20 elements
          this.listPostings = [];

          this.enginePatternMap = {
            amazon: /.*[?&#]field-keywords=([^&]*)/,
            bing: /.*[?&#]q=([^&]*)/,
            google: /.*[?&#]q=([^&]*)/,
            yahoo: /.*[?&#]p=([^&]*)/
          };

          this.isDataDirty = false;
          this._loadPersistentData();

          // save signals in a frequent way
          const self = this;
          if (OffersConfigs.QUERY_POSTINGS_LOAD_FROM_DB) {
            this.saveInterval = CliqzUtils.setInterval(() => {
              if (self.isDataDirty) {
                self._savePersistenceData();
              }
            }, OffersConfigs.QUERY_HANDLER_AUTOSAVE_FREQ_SECS * 1000);
          }
        }

        destroy() {
          this._savePersistenceData();

          if (this.saveInterval) {
            CliqzUtils.clearInterval(this.saveInterval);
            this.saveInterval = null;
          }
        }

        // //////////////////////////////////////////////////////////////////////////////////
        //                             Public Methods.
        // //////////////////////////////////////////////////////////////////////////////////
        /**
         * Method takes a raw url and a top level domain and returns an object that contains
         * the search engine extracted from the domain name and the normalized form of the query
         * @param url
         * @param domain
         * @returns
         *  {
         *    engine [String]: Domain Name of the supported search engine. E.g amazon
         *    query [String]: very basic normalized form of query. Umlauts are retained
         *    ts [Long] : timeStamp when the qurey was processed
         *  }
         */
        normalize(url, domain) {
          if (!url || !url.length || !domain || !domain.length) {
            return null;
          }
          const domainName = domain.split('.')[0];
          if (domainName in this.enginePatternMap) {
            const data = {
              query: this._normalizeQuery(this._extractQuery(url, domainName)),
              origin: domainName,
              ts: timestampMS()
            };
            this._addNewPosting(data);
            return data;
          }
          return null;
        }

        /**
         * This method normalizes a list of tokens. Umlauts are removed.
         * No stemming or lemmatization is performed.
         * Converttion of non-ASCII characters (umlauts, accents) to their closest ASCII
         * equivalent (slug creation)
         * @param  {List[String]} tokenList [Input list of non-normalized tokens]
         * @return {List[String]} [normalized list of tokens]
         */
        normalizeTokenList(tokenList) {
          const combining = /[\u0300-\u036F]/g;
          const tokenizedList = [];
          tokenList.forEach(element => {
            const tmp = element.normalize('NFKD').replace(combining, '');
            tokenizedList.push(tmp);
          });
          return tokenizedList;
        }

        /**
         * This method checks if a given information (tokens)
         * matches seen queries in a given period of time.
         * It is supposed that a match occured if
         * all "contatined" tokens were found in at least one query
         * while none fo the filter tokens were found.
         * @param  {Object} tokenData SHOULD BE ALREADY NORMALIZED TOKENS, the caller
         *                            should first call normalizeTokenList() method for each of them
         * {
         *   contained: [t1,t2,..],
         *   filtered: [ft1,ft2,...]
         * }
         * @param  {Long} time delta that is used to define interval [currentTime-delta, currentTime]
         *   ts
         * @return {[Boolean]}           [returns true if all the tokens are matched independently of the
         *                                order and all filter tokens are not
         *                                present in the normalized query]
         */
        matchTokens(tokenData, timeRange) {
          // get list of timestamps for the contained words
          // use contained list to grab the set of timestamps
          let finalSetTS = new Set();
          let tokenMissed = false;

          // as a safeguard we check that required keys are present
          // if not we return false
          if (!tokenData || !tokenData.contained || !tokenData.filtered) {
            return false;
          }

          tokenData.contained.forEach(containedToken => {
            if (tokenMissed) {
              return;
            }
            const involvedTS = this.queryPostings[containedToken];
            if (involvedTS) {
              if (finalSetTS.size === 0) {
                finalSetTS = involvedTS;
              } else {
                finalSetTS = new Set([...finalSetTS].filter(x => involvedTS.has(x)));
              }
            } else {
              tokenMissed = true;
            }
          });

          if (finalSetTS.size === 0 || tokenMissed) {
            return false;
          }

          tokenData.filtered.forEach(filterToken => {
            if (filterToken) {
              const involvedTS = this.queryPostings[filterToken];
              if (involvedTS) {
                finalSetTS.delete(involvedTS);
              }
            }
          });

          // now we have to exclude the filterTokensTs from finalSetTS
          // and check if the resulting set, if it is not empty and is in the TimeRange

          let threshold = -1;
          if (timeRange > 0) {
            threshold = timestampMS() - timeRange;
          }
          const inTheRange = [...finalSetTS].filter(x => x > threshold);

          return inTheRange.length > 0;
        }

        // //////////////////////////////////////////////////////////////////////////////////
        //                           Private Methods.
        // //////////////////////////////////////////////////////////////////////////////////
        _extractQuery(url, domainName) {
          let query = '';
          const pattern = this.enginePatternMap[domainName];
          if (pattern) {
            const _mat = pattern.exec(url);

            if (_mat) {
              try {
                query = decodeURIComponent(_mat[1]).replace(/\+/g, ' ');
              } catch (e) {
                return null;
              }
              if (query) {
                return query.replace(/\s+/g, ' ').trim();
              }
            }
          }
          return null;
        }

        _normalizeQuery(query) {
          if (query) {
            return this._removePunctuation(query.toLowerCase());
          }
          return null;
        }

        _removePunctuation(query) {
          const punctuationless = query.replace(/[.,/#!$%^&*;:{}=\-_`~()"]/g, '');
          const finalString = punctuationless.replace(/\s{2,}/g, ' ');
          return finalString;
        }

        /**
         * Takes a data object that contains a query that is extracted from the URL,
         * splits into separate tokens and normalizes the tokens.
         * The posting list is constructed from the normalized tokens , origin and the TS
         * This method also creates the following structures
         * - index mapping
         * - posting dynamic map.
         * @param {Object} rawQuery [description]
         */
        _addNewPosting(data) {
          if (!data || !data.query || !data.origin || !data.ts) {
            return;
          }
          const tokens = data.query.split(' ');
          let normalizedTokens = [];

          if (tokens) {
            // fill in queryPostings structure
            // {
            //    normalizedToken: Set([ts1, ts2])
            // }
            normalizedTokens = this.normalizeTokenList(tokens);
            normalizedTokens.forEach(element => {
              if (Object.prototype.hasOwnProperty.call(this.queryPostings, element)) {
                this.queryPostings[element].add(data.ts);
              } else {
                this.queryPostings[element] = new Set();
                this.queryPostings[element].add(data.ts);
              }
            });

            // fill in tsToPosingMap
            // {
            //   ts : (raw query, normalized query, ts, origin)
            // }
            // Here we assume that we do not run into situation when two queries have the same timestamp
            // if such a situation happens we simply override the posting for this specific timestampv
            this.tsToPostingMap[data.ts] = {
              full_query: data.query,
              origin: data.origin,
              tokens: normalizedTokens
            };
          }

          // we also have to update the list of Postings that will be used for persistance of data
          this.listPostings.push({
            query: data.query,
            tokens: normalizedTokens,
            origin: data.origin,
            ts: data.ts
          });
          this.isDataDirty = true;
        }

        /**
         * This Method takes a posting list (loaded from DB) and constructs all
         * required in memory strucutres
         */
        _buildDynamicPostingsFromDB(postingList) {
          postingList.forEach(posting => {
            if (posting && posting.tokens) {
              posting.tokens.forEach(token => {
                if (this.queryPostings[token]) {
                  this.queryPostings[token].add(posting.ts);
                } else {
                  this.queryPostings[token] = new Set();
                  this.queryPostings[token].add(posting.ts);
                }
              });

              this.tsToPostingMap[posting.ts] = {
                full_query: posting.query,
                origin: posting.origin,
                tokens: posting.tokens
              };
            }
          });
        }

        _savePersistenceData() {
          if (!OffersConfigs.QUERY_POSTINGS_LOAD_FROM_DB || !this.db) {
            return Promise.resolve(true);
          }
          // is db dirty?
          if (!this.isDataDirty) {
            return Promise.resolve(true);
          }

          return this.db.saveDocData(STORAGE_DB_DOC_ID$2, {
            posting_list: this.listPostings.slice(-OffersConfigs.POSTING_SLICE)
          }).then(() => {
            this.isDataDirty = false;
            return true;
          });
        }

        _loadPersistentData() {
          // for testing comment the following check
          if (!OffersConfigs.QUERY_POSTINGS_LOAD_FROM_DB || !this.db) {
            return Promise.resolve(true);
          }

          return new Promise(resolve => this.db.getDocData(STORAGE_DB_DOC_ID$2).then(docData => {
            if (!docData || !docData.posting_list) {
              resolve(false);
            }
            this.listPostings = docData.posting_list;
            this._buildDynamicPostingsFromDB(this.listPostings);
            this.isDataDirty = false;
            resolve(true);
          }).catch(() => {
            // it may happen that is the first time we are trying to load them
            logger$2.log('unable to load the posting.');
          }));
        }
      }

      /**
       * Interface for a feature
       */
      class Feature {
        constructor(name) {
          this.name = name;
        }

        getName() {
          return this.name;
        }

        // to be implemented by the inherited classes
        init() {
          throw new Error('This should be implemented by the inherited class');
        }

        unload() {
          throw new Error('This should be implemented by the inherited class');
        }

        isAvailable() {
          throw new Error('This should be implemented by the inherited class');
        }
      }

      const GEO_COUNTRY_PREF_NAME = 'config_location';
      const GEO_CITY_PREF_NAME = 'config_location.city';
      const GEO_ALLOWED = 'offers_location';

      class GeoChecker extends Feature {
        constructor() {
          super('geo');
          this.loc = null;
          this.onPrefChange = undefined;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            Feature methods

        init() {
          this._updateLocFromPrefs();

          // for now we will listen for a pref change
          this.onPrefChange = CliqzEvents.subscribe('prefchange', pref => {
            if (pref === GEO_CITY_PREF_NAME || pref === GEO_COUNTRY_PREF_NAME) {
              this._updateLocFromPrefs();
            }
          });
          return true;
        }

        unload() {
          if (this.onPrefChange) {
            this.onPrefChange.unsubscribe();
            this.onPrefChange = undefined;
          }
          return true;
        }

        isAvailable() {
          return this.isLocAvailable();
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            GEO API

        isLocAvailable() {
          return prefs.get(GEO_ALLOWED, 1) === 1 && this._checkLoc(this.loc) && this.loc.country !== '--';
        }

        /**
         * will update the current location of the user, the required information will be
         * {
         *   loc: {
         *     // cannot be null the country
         *     country: 'x',
         *     // can be undefined = unknown
         *     city: 'y',
         *     // can be undefined = unknown
         *     zip: 'z'
         *   }
         * }
         * @param  {[type]} data [description]
         * @return {[type]}      [description]
         */
        updateLocation(data) {
          if (prefs.get(GEO_ALLOWED, 1) === 1) {
            // 0 = off, 1 = IP based
            this.loc = data ? data.loc : null;
          } else {
            this.loc = null;
          }
        }

        /**
         * we will check if the current location information matches the given one
         * @param  {[type]} loc [description]
         * @return {[type]}     [description]
         */
        isSameLocation(loc) {
          if (!this._checkLoc(loc) || !this._checkLoc(this.loc)) {
            return false;
          }

          // check if we match all the data we currently have and need
          if (this.loc.country !== loc.country) {
            return false;
          }
          // now we need to see if we have to check more fields from
          if (loc.city) {
            if (loc.city !== this.loc.city) {
              return false;
            }
            if (loc.zip && loc.zip !== this.loc.zip) {
              return false;
            }
          }

          // everything matched
          return true;
        }

        _checkLoc(c) {
          return !!(c && c.country);
        }

        _updateLocFromPrefs() {
          const locData = {
            loc: {
              country: prefs.get(GEO_COUNTRY_PREF_NAME, '--'),
              city: prefs.get(GEO_CITY_PREF_NAME, '--')
            }
          };
          this.updateLocation(locData);
        }
      }

      const MOD_NAME = 'history-analyzer';

      /**
       * Interface for a feature
       */
      class HistoryFeature extends Feature {
        constructor() {
          super('history');
          this.mod = null;
          this.ongoingQueries = new Map();
        }

        // to be implemented by the inherited classes
        init() {
          this.mod = inject.module(MOD_NAME);
          return true;
        }

        unload() {
          return true;
        }

        isAvailable() {
          return this.mod.isEnabled();
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        INTERFACE
        //

        hasCachedData(pid) {
          return this.mod.action('hasCachedData', pid);
        }

        performQuery(q) {
          if (this.ongoingQueries.has(q.pid)) {
            return this.ongoingQueries.get(q.pid);
          }

          const promise = this.mod.action('performQuery', q);
          this.ongoingQueries.set(q.pid, promise);

          promise.then(data => Promise.resolve(data)).catch().then(() => {
            this.ongoingQueries.delete(q.pid);
          });
          return promise;
        }

        removeEntry(pid) {
          return this.mod.action('removeEntry', pid);
        }
      }

      function getFeatures() {
        return [new GeoChecker(), new HistoryFeature()];
      }

      class FeatureHandler {
        constructor() {
          this.features = new Map();
          const features = getFeatures();
          features.forEach(feature => {
            // init the feature and check
            if (!feature.init()) {
              logger$2.error(`Problem initializing the feature ${feature.getName()}`);
            } else {
              logger$2.info(`Feature ${feature.getName()} initialized properly`);
              this.features.set(feature.getName(), feature);
            }
          });
        }

        unload() {
          this.features.forEach((feature, fname) => {
            if (!feature.unload()) {
              logger$2.error(`Error uninitializing the feature ${fname}`);
            } else {
              logger$2.info(`Feature ${fname} uninitialized properly`);
            }
          });
          this.features.clear();
        }

        isFeatureAvailable(featureName) {
          if (!this.features.has(featureName)) {
            return false;
          }
          return this.features.get(featureName).isAvailable();
        }

        getFeature(featureName) {
          return this.features.get(featureName);
        }

        dumpFeaturesData() {
          logger$2.info('Features data: ', this.features);
        }
      }

      /* eslint no-param-reassign: ["error", { "props": false }] */
      /**
       * this module will be used to perform queries to the BE and fetch triggers
       * We can in the future implement some cache system here so we store the triggers
       * locally with a given TTL. This will also perform better.
       */
      class BEConnector {
        /**
         * performs the query for the given endpoint and params.
         * If the query performs correctly we will return the parsed json result as
         * the resolved argument of the promise.
         * Otherwise the error message will be returned on the reject method
         * @param  {[type]} endpoint [description]
         * @param  {[type]} params   [description]
         * @return {Promise}          [description]
         */
        sendApiRequest(endpoint, params) {
          logger$2.info('backend_connector', 'sendApiRequest called');

          return new Promise((resolve, reject) => {
            // we will always set the engine version as argument
            params.t_eng_ver = OffersConfigs.TRIGGER_ENGINE_VERSION;
            const url = this._buildUrl(endpoint, params);

            // TODO: we can check for cached results here if needed. Not for now

            logger$2.info('backend_connector', `url called: ${url}`);
            const headers = new Headers();
            headers.append('Content-Type', 'application/json');
            const request = new Request(url, { headers, method: 'POST' });

            return fetch(request).then(response => {
              if (response.ok) {
                resolve(response.json());
              } else {
                reject(`Status code ${response.status} for ${url}`);
              }
            });
          });
        }

        _buildUrl(endpoint, params) {
          return `${OffersConfigs.BACKEND_URL}/api/v1/${endpoint}?`.concat(Object.keys(params).map(key => `${key}=${encodeURIComponent(params[key])}`).join('&'));
        }
      }

      /* eslint-disable no-return-assign */
      const MAX_NUM_URLS_ON_MEM = 500;

      /**
       * perform binary search
       * return the index of the first element (from left to right) having ts >= leftBoundTS
       * @param leftBoundTS
       * @returns {number}
       * @private
       */
      const leftMostIndex = (entries, leftBoundTS) => {
        const nEntries = entries.length;
        if (nEntries === 0 || entries[nEntries - 1].ts < leftBoundTS) {
          return -1;
        }

        let low = 0;
        let high = nEntries - 1;
        while (low <= high) {
          const mid = Math.floor(low + (high - low) / 2);
          if (entries[mid].ts >= leftBoundTS) {
            high = mid - 1;
          } else {
            low = mid + 1;
          }
        }
        return high + 1;
      };

      /**
       * perform binary search
       * return the index of the last element (from left to right) having ts <= rightBoundTS
       * @param rightBoundTS
       * @returns {number}
       * @private
       */
      const rightMostIndex = (entries, rightBoundTS) => {
        const nEntries = entries.length;
        if (nEntries === 0 || entries[0].ts > rightBoundTS) {
          return -1;
        }

        let low = 0;
        let high = nEntries - 1;
        while (low <= high) {
          const mid = Math.floor(low + (high - low) / 2);
          if (entries[mid].ts > rightBoundTS) {
            high = mid - 1;
          } else {
            low = mid + 1;
          }
        }
        return low - 1;
      };

      /**
       * Helper handy class to simplify intervals handling
       */
      class Interval {
        constructor(start, end) {
          this.start = start;
          this.end = end;
        }

        overlaps(otherInterval) {
          // overlaps if not not overlaps :)
          return !(this.end <= otherInterval.start || otherInterval.end <= this.start);
        }

        len() {
          return this.end - this.start;
        }

        /**
         * returns if the current interval is contained in the otherInterval (meaning the otherInterval is
         * bigger than the current one and the current one is inside)
         * @param  {[type]}  otherInterval [description]
         * @return {Boolean}       [description]
         */
        isInside(otherInterval) {
          return otherInterval && otherInterval.start <= this.start && otherInterval.end >= this.end;
        }

        isPointInside(p) {
          return this.start <= p && p <= this.end;
        }

        eql(otherInterval) {
          return otherInterval && this.start === otherInterval.start && this.end === otherInterval.end;
        }

        /**
         * will return all the intervals that results from overlapping intervals
         * This method will return all the non-overlaping possible intervals from all
         * the intersections of the current and otherInterval interval
         * @param  {[type]} otherInterval [description]
         * @return {[type]}       [description]
         */
        splitOverlaps(otherInterval) {
          if (!this.overlaps(otherInterval)) {
            return [];
          }
          const positions = [...new Set([this.start, this.end, otherInterval.start, otherInterval.end])].sort();
          const result = [];
          for (let i = 1; i < positions.length; i += 1) {
            result.push(new Interval(positions[i - 1], positions[i]));
          }
          return result;
        }
      }

      /**
       * This class will handle the urls that the user visited since the browser started
       * so we can perform fast history checks for short period of times
       */
      class MemoryHistoryHandler {
        /**
         * the matchMethod is required to compare (patternObject, url). will return
         * true if there is a match or false otherwise
         */
        constructor(matchMethod) {
          this.matchMethod = matchMethod;
          this.entries = [];
          // we will hold: pid -> {startMS, endMS, count}
          this.cache = new Map();
          this.startedListeningTS = timestampMS();
        }

        getStartedListeningTS() {
          return this.startedListeningTS;
        }

        /**
         * add a tokenized url in the list assuming the current timestamp
         */
        addTokenizedUrl(tokenizedUrl) {
          this.entries.push({ urlData: tokenizedUrl, ts: timestampMS() });

          // make the entries fixed size
          if (this.entries.length > MAX_NUM_URLS_ON_MEM) {
            this.entries.splice(0, 10);
            this.startedListeningTS = this.entries[0].ts;
          }
        }

        /**
         * will check if a pattern index (uniquely identify with the pid) matches
         * the given range on the memory history.
         * Returns the number of matches on memory history.
         */
        countMatches(startMS, endMS, pObj, pid) {
          const queryInterval = new Interval(leftMostIndex(this.entries, startMS), rightMostIndex(this.entries, endMS));

          if (queryInterval.start < 0 || queryInterval.end < 0) {
            logger$2.error('Something went wrong here', queryInterval);
            return 0;
          }

          // if we already have the query in the cache we return
          const cache = this.cache.get(pid);
          let cacheInterval = null;
          if (cache) {
            cacheInterval = new Interval(leftMostIndex(this.entries, cache.startMS), rightMostIndex(this.entries, cache.endMS));
          }
          if (queryInterval.eql(cacheInterval)) {
            return cache.count;
          }

          // We will split the code as follow:
          // 0 / 1) non overlaps (no cache or they do not overlap at all)
          // 2) they overlap:
          //  - one inside of the other (x2)
          //  - or overlapping
          //
          let resultMatches = 0;
          if (cacheInterval === null || !queryInterval.overlaps(cacheInterval)) {
            // 0 / 1)
            resultMatches = this._countInRange(queryInterval.start, queryInterval.end, pObj);
          } else {
            let substractCache = [];
            let addCache = [];
            if (cacheInterval.isInside(queryInterval)) {
              const intervals = this._getNormalizedSplitIntervals(queryInterval, cacheInterval, cacheInterval);
              addCache = intervals.filter(interval => !interval.eql(cacheInterval));
            } else if (queryInterval.isInside(cacheInterval)) {
              const intervals = this._getNormalizedSplitIntervals(queryInterval, cacheInterval, queryInterval);
              substractCache = intervals.filter(interval => !interval.eql(queryInterval));
            } else {
              // overlaps
              const intervals = this._getNormalizedSplitIntervals(queryInterval, cacheInterval, cacheInterval);
              addCache = intervals.filter(interval => !interval.eql(cacheInterval));
              substractCache = intervals.filter(interval => !interval.eql(queryInterval));
            }

            // now we check if it is faster to calculate all again or the intervals
            let totalLen = 0;
            substractCache.forEach(i => totalLen += i.len());
            addCache.forEach(i => totalLen += i.len());
            if (totalLen > queryInterval.len()) {
              resultMatches = this._countInRange(queryInterval.start, queryInterval.end, pObj);
            } else {
              resultMatches = cache.count;
              substractCache.forEach(i => resultMatches -= this._countInRange(i.start, i.end, pObj));
              addCache.forEach(i => resultMatches += this._countInRange(i.start, i.end, pObj));
            }
          }

          this.cache.set(pid, { startMS, endMS, count: resultMatches });
          return resultMatches;
        }

        _getNormalizedSplitIntervals(qInterval, cInterval, keepInterval) {
          const intervals = qInterval.splitOverlaps(cInterval);
          // normalize them since we do not want to overlap with the query one
          for (let i = 0; i < intervals.length; i += 1) {
            const interval = intervals[i];
            // check if starts or end
            if (interval.end === keepInterval.start) {
              interval.end -= 1;
            } else if (interval.start === keepInterval.end) {
              interval.start += 1;
            }
          }
          return intervals;
        }

        _countInRange(leftIndex, rightIndex, patternObj) {
          let counter = 0;
          for (let i = leftIndex; i <= rightIndex; i += 1) {
            if (this.matchMethod(this.entries[i].urlData, patternObj)) {
              counter += 1;
            }
          }
          return counter;
        }
      }
      /* eslint-enable no-return-assign */

      // this time will specify how many seconds we want to wait till perform the next
      // call on the history, In the future we will have a local history
      const RE_QUERY_THRESHOLD_SECS = 60 * 30;

      /**
       * Helper class to handle all the data associated to history
       * This class assumes that the feature is enabled
       */
      class PatternHistoryMatching {
        /**
         * will get the history feature if enabled or null otherwise
         * also the matchOperation: (tokenizedURL, patternObj) -> true / false
         */
        constructor(historyFeature, matchOperation) {
          this.historyFeature = historyFeature;
          this.memoryHistory = new MemoryHistoryHandler(matchOperation);
          // cache of pattern id -> cache_entry data (check history-analyzer module)
          this.cache = new Map();
        }

        /**
         * Will count how many matches do we have on the history (on the given time range
         * in the query).
         * This method will for now query the history module every N seconds only.
         *
         * Query:
         * {
         *   since_secs: X
         *   till_secs: Y
         * }
         * we will check the history in [now - since_secs,  now - till_secs] window
         */
        countMatches(query, patternObj) {
          if (!this._checkQuery(query) || !this._checkPatternObj(patternObj)) {
            logger$2.error('Invalid arguments: ', query, patternObj);
            return 0;
          }

          const now = timestampMS();
          const startQueryMS = now - query.since_secs * 1000;
          const endQueryMS = now - query.till_secs * 1000;
          let result = 0;

          // check if we only need memory history
          if (startQueryMS < this.memoryHistory.getStartedListeningTS()) {
            // we need real history
            result = this._countRealHistoryMatches(query, patternObj);
          }

          // check what we have to check from memory
          if (endQueryMS > this.memoryHistory.getStartedListeningTS()) {
            result += this._countMemoryHistoryMatches(startQueryMS, endQueryMS, patternObj);
          }

          return result;
        }

        trackTokenizedUrlOnMem(tokenizedURL) {
          this.memoryHistory.addTokenizedUrl(tokenizedURL);
        }

        // ///////////////////////////////////////////////////////////////////////////

        _countMemoryHistoryMatches(startQueryMS, endQueryMS, patternObj) {
          const cacheEntry = this._getOrCreateCacheEntry(patternObj);
          // we need to transform the query into memory query:
          const lastHistoryCache = cacheEntry.lastHistoryResultTS ? cacheEntry.lastHistoryResultTS : 0;
          const memStartMS = Math.max(lastHistoryCache, startQueryMS);
          return this.memoryHistory.countMatches(memStartMS, endQueryMS, patternObj, patternObj.pid);
        }

        _countRealHistoryMatches(query, patternObj) {
          // check if we have the feature enabled
          if (this.historyFeature === null) {
            return 0;
          }

          // check if we have a cache data for it right now and return
          const cacheEntry = this._getOrCreateCacheEntry(patternObj);
          let result = 0;
          if (this._isCacheInvalid(cacheEntry, query)) {
            /* eslint no-param-reassign: off */
            logger$2.info(`invalidating cache for ${patternObj.pid}`);

            // invalidate the current cache
            this._invalidateCurrentCache(cacheEntry);
            // set the new values to it
            cacheEntry.lastQuery = { since_secs: query.since_secs, till_secs: query.till_secs };
            cacheEntry.lastQueryToHistoryTs = timestampMS();
            // perform the query
            this._performQueryOnHistory(query, cacheEntry.patterns, patternObj.pid);
          } else {
            result = cacheEntry.matchesCount;
          }

          return result;
        }

        _isCacheInvalid(cacheEntry, newQuery) {
          // we need to update the data if:
          // 1) the latest query differs from the current one
          // 2) we do not have any query nor data.
          // 3) the last time we perform a query is too old

          const areQueriesEq = (q1, q2) => q1 && q2 && q1.since_secs === q2.since_secs && q1.till_secs === q2.till_secs;
          return cacheEntry.lastQuery === null || !areQueriesEq(cacheEntry.lastQuery, newQuery) || (timestampMS() - cacheEntry.lastQueryToHistoryTs) / 1000 > RE_QUERY_THRESHOLD_SECS;
        }

        _invalidateCurrentCache(cacheEntry) {
          cacheEntry.lastQuery = null;
          cacheEntry.matchesCount = 0;
          cacheEntry.last_checked_url_ts = 0;
        }

        _performQueryOnHistory(q, pList, pid) {
          // check history-analyzer for more info
          const now = timestampMS();
          const historyQuery = {
            patterns: pList,
            pid,
            start_ms: now - q.since_secs * 1000,
            end_ms: now - q.till_secs * 1000
          };
          this.historyFeature.performQuery(historyQuery).then(data => {
            if (!data || !data.d || !data.d.match_data || !data.d.match_data.total) {
              logger$2.error('invalid data received? ', data);
              return;
            }
            const cacheEntry = this.cache.get(pid);
            cacheEntry.matchesCount = data.d.match_data.total.m;
            cacheEntry.lastHistoryResultTS = data.d.match_data.total.last_checked_url_ts;
            logger$2.info(`updated entry for ${pid} = ${cacheEntry.matchesCount}`);
          });
        }

        _getOrCreateCacheEntry(patternObj) {
          if (this.cache.has(patternObj.pid)) {
            return this.cache.get(patternObj.pid);
          }
          const entry = {
            lastQueryToHistoryTs: 0,
            lastHistoryResultTS: 0,
            matchesCount: 0,
            lastQuery: null,
            patterns: patternObj.p_list
          };
          this.cache.set(patternObj.pid, entry);
          return entry;
        }

        _checkPatternObj(po) {
          return po !== undefined && po !== null && po.pid && po.p_list && po.p_list.length > 0;
        }

        _checkQuery(q) {
          return q && q.since_secs >= 0 && q.till_secs >= 0 && q.since_secs >= q.till_secs;
        }
      }

      /**
       * This class will handle all the queries and everything that can be related to
       * pattern matching algorithms.
       * On the bottom will use the pattern-matching ReverseIndex and utils for doing the match.
       */
      class PatternMatchingHandler {
        constructor(featureHandler) {
          // the cache of pid -> data:
          // {
          //  pi: the pattern index (PatternIndex) associated to this pid.
          // }
          this.cache = new Map();

          // check if we have history feature
          const historyFeature = featureHandler.isFeatureAvailable('history') ? featureHandler.getFeature('history') : null;
          this.historyMatch = new PatternHistoryMatching(historyFeature, this.itMatches.bind(this));
        }

        /**
         * will check if the pattern object matches a given tokenized url
         * @param  {[type]} toknezedURL [description]
         * @param  {Object} patternObj
         *   patternObj: {
         *     // this will identify this patters uniquely, meaning if something change
         *     // on the patterns this id will change as well. If two operations use
         *     // the same patterns the id should be the same (id = hash(patterns_list))
         *     pid: 'unique pattern id',
         *     // the list of associated patterns
         *     p_list: [
         *       p1,
         *       p2,...
         *     ]
         *   },
         * @return {Object}   We will return an object with the follow information:
         * {
         *   // will return if the current data is partial or not
         *   is_partial: true | false,
         *   // the data (or null if any) associated for the given query:
         *   data: {
         *     // the number of matches we have
         *     matches: N,
         *
         *   }
         * }
         */
        itMatches(tokenizedURL, patternObj) {
          if (!tokenizedURL || !this._checkPatternObj(patternObj)) {
            logger$2.error('Invalid tokenizedURL or patternObject');
            return false;
          }
          // check if we have a cache for this object already
          const ce = this._getOrCreateIndex(patternObj);
          if (!ce) {
            return false;
          }
          return ce.pi.match(tokenizedURL);
        }

        /**
         * Will count the number of matches for a given pattern list and a query
         * on the history. Check history-pattern-matching for more information
         * @return number of matches for that given period of time
         */
        countHistoryMatches(query, patternObj) {
          return this.historyMatch.countMatches(query, patternObj);
        }

        trackTokenizedUrlOnMem(tokenizedURL) {
          this.historyMatch.trackTokenizedUrlOnMem(tokenizedURL);
        }

        // ///////////////////////////////////////////////////////////////////////////

        /**
         * will match a multi pattern object (check buildMultiPatternObject) against
         * a particular tokenized url and return the list of pattern ids that matched
         * the url
         */
        getMatchIDs(tokenizedURL, multiPatternObj) {
          return multiPatternObj.match(tokenizedURL);
        }

        /**
         * will build a pattern matching object with all the patterns and their
         * associated ids.
         * The patternsList should be as follow:
         * [
         *   {
         *     pid: 'id of the patterns',
         *     p_list: [ pattern1, pattern2,...]
         *   }
         * ]
         */
        buildMultiPatternObject(patternsList) {
          let allFilters = [];
          for (let i = 0; i < patternsList.length; i += 1) {
            const patternData = patternsList[i];
            allFilters = allFilters.concat(this._buildFilters(patternData, patternData.pid));
          }
          return new MultiPatternIndex(allFilters);
        }

        // ///////////////////////////////////////////////////////////////////////////

        _checkPatternObj(po) {
          return po !== undefined && po !== null && po.pid && po.p_list && po.p_list.length > 0;
        }

        _buildFilters(po) {
          let filterGroupID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          const plist = [];
          for (let i = 0; i < po.p_list.length; i += 1) {
            const filter = parseNetworkFilter(po.p_list[i], true, false);
            if (filter) {
              if (filterGroupID !== null) {
                filter.groupID = filterGroupID;
              }
              plist.push(filter);
            } else {
              logger$2.error('Error parsing the filter: ', filter);
            }
          }
          return plist;
        }

        _buildSimplePattern(po) {
          return new SimplePatternIndex(this._buildFilters(po));
        }

        _getOrCreateIndex(po) {
          if (!this.cache.has(po.pid)) {
            const patternIndex = this._buildSimplePattern(po);
            if (!patternIndex) {
              return null;
            }
            const cacheEntry = {
              pi: patternIndex
            };
            this.cache.set(po.pid, cacheEntry);
          }
          return this.cache.get(po.pid);
        }
      }

      const getNodeNamesFromCatName = catName => catName ? catName.split('.') : [];
      const getParentNodeFromCatName = catName => {
        const nodeNames = getNodeNamesFromCatName(catName) || [];
        nodeNames.pop();
        return nodeNames;
      };

      /**
       * Category node on the tree
       */
      class CategoryNode {
        constructor(cname, category) {
          this.name = cname;
          this.category = category;
          this.children = new Map();
        }
        setCategory(cat) {
          this.category = cat;
        }
        hasCategory() {
          return !!this.category;
        }
        getCategory() {
          return this.category;
        }
        getName() {
          return this.name;
        }
        addChild(cnode) {
          this.children.set(cnode.name, cnode);
        }
        removeChild(name) {
          this.children.delete(name);
        }
        hasChildName(cnodeName) {
          return this.children.has(cnodeName);
        }
        getChild(cname) {
          return this.children.get(cname);
        }
        getChildren() {
          return [...this.children.values()];
        }
      }

      /**
       * category tree for easy access
       */
      class CategoryTree {
        constructor() {
          this.root = new CategoryNode('');
        }

        addCategory(category) {
          const cname = category.getName();
          const catNames = getNodeNamesFromCatName(cname);
          const node = this._getOrCreateNode(catNames);
          node.setCategory(category);
        }

        hasCategory(cname) {
          return this._getNode(getNodeNamesFromCatName(cname)) !== null;
        }

        clear() {
          this.root = new CategoryNode('');
        }

        removeCategory(cname) {
          // we will remove all the children here?
          const parentNode = this._getNode(getParentNodeFromCatName(cname));
          if (parentNode !== null) {
            parentNode.removeChild(cname);
          }
        }

        getCategoryNode(cname) {
          return this._getNode(getNodeNamesFromCatName(cname));
        }

        getSubCategories(cname) {
          const node = this._getNode(getNodeNamesFromCatName(cname));
          if (node === null) {
            return [];
          }
          return node.getChildren();
        }

        getAllSubCategories(cname) {
          return this._filterSubCategoriesWithStop(cname, () => false).result;
        }

        someSubCategory(cname, f) {
          return this._filterSubCategoriesWithStop(cname, f).cond;
        }

        _filterSubCategoriesWithStop(cname) {
          let stopCond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          const result = [];
          const toProcess = [this._getNode(getNodeNamesFromCatName(cname))];
          while (toProcess.length > 0) {
            const top = toProcess.pop();
            if (top !== null) {
              if (stopCond(top)) {
                return { result, cond: true };
              }
              result.push(top);
              // else we will evaluate the children
              top.getChildren().forEach(c => toProcess.push(c));
            }
          }
          return { result, cond: false };
        }

        _getOrCreateNode(catNameList) {
          let currentParent = this.root;
          for (let i = 0; i < catNameList.length; i += 1) {
            const childName = catNameList[i];
            if (!currentParent.hasChildName(childName)) {
              const childNode = new CategoryNode(childName);
              currentParent.addChild(childNode);
              currentParent = childNode;
            } else {
              currentParent = currentParent.getChild(childName);
            }
          }
          return currentParent;
        }

        _getNode(catNameList) {
          let currentParent = this.root;
          for (let i = 0; i < catNameList.length && currentParent !== null; i += 1) {
            const childName = catNameList[i];
            if (childName === currentParent.getName()) {
              return currentParent;
            }
            currentParent = currentParent.hasChildName(childName) ? currentParent.getChild(childName) : null;
          }
          return currentParent;
        }
      }

      /**
       * This class will be used to simplify the handling and matching logic for
       * categories
       */
      class CategoryMatch {
        constructor(patternMatchingHandler) {
          this.patternMatchingHandler = patternMatchingHandler;
          this.patternIndex = null;
          this.multiPatternObj = null;
          // cat id -> patterns data
          this.patterns = new Map();
        }

        addCategoryPatterns(catID, patterns) {
          if (!catID || !patterns) {
            return;
          }
          this.patterns.set(catID, patterns);
        }

        removeCategoryPatterns(catID) {
          this.patterns.delete(catID);
        }

        clear() {
          this.patternIndex = null;
          this.patterns = new Map();
        }

        build() {
          const patternsList = [];
          this.patterns.forEach((patterns, catID) => patternsList.push({ pid: catID, p_list: patterns }));
          this.multiPatternObj = this.patternMatchingHandler.buildMultiPatternObject(patternsList);
        }

        /**
         * will return a set of categories ids that match the current tokenized url
         */
        checkMatches(tokenizedURL) {
          return this.multiPatternObj ? this.patternMatchingHandler.getMatchIDs(tokenizedURL, this.multiPatternObj) : new Set();
        }
      }

      var _extends$11 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      /*
       * This module will provide an interface for saving / loading persistent data.
       *
       */

      class SimpleDB {
        //
        // @brief constructor
        // @param db  the database instance to use (pouchdb)
        //
        constructor(db) {
          let logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console$1;

          this.db = db;
          this.logger = logger;
        }

        upsert(docID, docData) {
          return this.db.get(docID).catch(() => ({ _id: docID, docData: {} })).then(data => this.db.put(_extends$11({}, data, {
            docData: _extends$11({}, data.docData, docData)
          })));
        }

        get(docID) {
          return this.db.get(docID).then(doc => doc.docData).catch(err => {
            if (err && err.status && err.status !== 404) {
              this.logger.error(`getDocData: error getting doc ${docID} with err: `, err);
            } else {
              this.logger.log(`missing DB entry for docID ${docID}`);
            }
            return null;
          });
        }

        remove(docID) {
          // https://pouchdb.com/api.html#delete_document
          return this.db.get(docID).then(doc => {
            this.logger.log(`removeDocData: removing doc ${docID}`);
            return this.db.remove(doc);
          }).then(() => {
            // nothing to do
            this.logger.log(`removeDocData: doc ${docID} removed properly`);
          }).catch(err => {
            // nothing to do there
            if (err && err.status && err.status !== 404) {
              this.logger.error(`removeDocData: something happened removing the doc: ${docID} - err:`, err);
            } else {
              this.logger.log(`missing DB entry for docID ${docID}`);
            }
          });
        }
      }

      const PATTERN_DOC_ID = 'cliqz-cat-patterns';
      const CATEGORIES_DOC_ID = 'cliqz-cat-categories';
      const METADATA_DOC_ID = 'cliqz-cat-metadata';
      const DAY_COUNTER_DOC_ID = 'cliqz-cat-day-counter';
      const AUTO_SAVE_TIME_FREQ_SECS = 60;

      /**
       * we will isolate the way we load the data in this helper. we will save the
       * patterns separated from the categories itself since they will highly probably
       * do not change.
       */
      class CategoryPersistentDataHelper {
        constructor(catTree, db) {
          this.db = db ? new SimpleDB(db) : null;
          this.catTree = catTree;
          this.needsToUpdatePatterns = false;
          this.needsToUpdateCategories = false;

          // we will save frequently if we detect changes on the categories / patterns
          this.autosaveTimer = CliqzUtils.setInterval(() => {
            this.save();
          }, AUTO_SAVE_TIME_FREQ_SECS * 1000);
        }

        destroy() {
          CliqzUtils.clearInterval(this.autosaveTimer);
        }

        loadMetadata() {
          return this.db.get(METADATA_DOC_ID);
        }

        saveMetadata(metadata) {
          return this.db.upsert(METADATA_DOC_ID, metadata);
        }

        loadDayCounterData() {
          return this.db.get(DAY_COUNTER_DOC_ID);
        }

        saveDayCounterData(data) {
          return this.db.upsert(DAY_COUNTER_DOC_ID, data);
        }

        /**
         * will return a promise with a list of all the categories already built
         */
        loadCategories() {
          this._clear();
          const patternsProm = this.db.get(PATTERN_DOC_ID);
          const categoriesProm = this.db.get(CATEGORIES_DOC_ID);
          return Promise.all([patternsProm, categoriesProm]).then(data => {
            const patternsData = data[0] && data[0].patternsMap ? data[0].patternsMap : {};
            const catData = data[1] && data[1].catList ? data[1].catList : [];
            const result = [];
            for (let i = 0; i < catData.length; i += 1) {
              const category = new Category();
              const catDataObj = catData[i];
              catDataObj.patterns = patternsData[catDataObj.name];
              category.deserialize(catDataObj);
              // do not load anything on debug
              if (!CliqzUtils.getPref('offersDevFlag', false)) {
                result.push(category);
              }
            }

            return Promise.resolve(result);
          });
        }

        save() {
          let patternsProm = true;
          if (this.needsToUpdatePatterns) {
            patternsProm = this.db.upsert(PATTERN_DOC_ID, { patternsMap: this._getPatternsFromTree() });
            this.needsToUpdatePatterns = false;
          }
          let catProm = true;
          if (this.needsToUpdateCategories) {
            catProm = this.db.upsert(CATEGORIES_DOC_ID, { catList: this._categories() });
            this.needsToUpdateCategories = false;
          }
          return Promise.all([patternsProm, catProm]);
        }

        categoryModified() /* category */{
          this.needsToUpdateCategories = true;
        }

        categoryRemoved() /* category */{
          this.needsToUpdateCategories = true;
          this.needsToUpdatePatterns = true;
        }

        categoryAdded() /* category */{
          this.needsToUpdateCategories = true;
          this.needsToUpdatePatterns = true;
        }

        _getPatternsFromTree() {
          return this._categories().filter(cat => cat.hasPatterns()).map(cat => cat.getPatterns());
        }

        _categories() {
          return this.catTree.getAllSubCategories('').filter(node => node.hasCategory()).map(catNode => catNode.getCategory());
        }

        _clear() {
          this.needsToUpdatePatterns = false;
          this.needsToUpdateCategories = false;
        }
      }

      const MAX_NUM_DAYS_TO_STORE = 365;

      /**
       * This class will be used to keep track of how many urls did we process per day
       * (urls for now, in the future we may add extra information)
       */
      class DayCounterHelper {
        constructor() {
          this.urlCountsPerDayMap = {};
        }

        serialize() {
          this._removeOldData();
          return { urlCountsPerDayMap: this.urlCountsPerDayMap };
        }

        deserialize(data) {
          this.urlCountsPerDayMap = data.urlCountsPerDayMap;
        }

        /**
         * we will merge the data from the history module into this one. We assume that
         * urlCountsPerDayEntriesMap is the "per_day" map from the history-analyzer
         */
        mergeDaysData(urlCountsPerDayEntriesMap) {
          const dayNames = Object.keys(urlCountsPerDayEntriesMap);
          for (let i = 0; i < dayNames.length; i += 1) {
            const dayName = dayNames[i];
            // we get the max always
            if (this.urlCountsPerDayMap[dayName] !== undefined) {
              this.urlCountsPerDayMap[dayName] = Math.max(this.urlCountsPerDayMap[dayName], urlCountsPerDayEntriesMap[dayName].c);
            } else {
              this.urlCountsPerDayMap[dayName] = urlCountsPerDayEntriesMap[dayName].c;
            }
          }
        }

        incToday() {
          const todayKey = getTodayDayKey();
          if (!this.urlCountsPerDayMap[todayKey]) {
            this.urlCountsPerDayMap[todayKey] = 0;
          }
          this.urlCountsPerDayMap[todayKey] += 1;
        }

        getCount(dayKey) {
          return this.urlCountsPerDayMap[dayKey];
        }

        _removeOldData() {
          // we can truncate till MAX_NUM_DAYS_TO_STORE days?
          const dayNames = Object.keys(this.urlCountsPerDayMap);
          if (dayNames.length > MAX_NUM_DAYS_TO_STORE) {
            // cut the oldest (meaning the sorted ones )
            dayNames.sort();
            const toCut = dayNames.length - MAX_NUM_DAYS_TO_STORE;
            for (let i = 0; i < toCut; i += 1) {
              delete this.urlCountsPerDayMap[dayNames[i]];
            }
          }
        }
      }

      class CategoryHandler {
        constructor(historyFeature, db, patternMatchingHandler) {
          this.catTree = new CategoryTree();
          this.catMatch = new CategoryMatch(patternMatchingHandler);
          this.historyFeature = historyFeature;
          this.persistentHelper = new CategoryPersistentDataHelper(this.catTree, db);
          this.metadata = {
            version: 1
          };
          // for now we always save metadata
          this.dayCounterHelper = new DayCounterHelper();
          this.persistentHelper.loadDayCounterData().then(data => {
            if (data) {
              this.dayCounterHelper.deserialize(data);
            }
          });
        }

        destroy() {
          this.persistentHelper.save();
          this.persistentHelper.destroy();
        }

        /**
         * Check if a category exists or not
         */
        hasCategory(catName) {
          return this.catTree.hasCategory(catName);
        }

        /**
         * Add a new category to be observed. Note that we should call build() after
         * adding all the categories we want to observe.
         */
        addCategory(category) {
          if (!this._checkCategory(category)) {
            logger$2.error('Category is invalid', category);
            return;
          }
          // check if we have the category => need to update? otherwise we add it
          if (this.hasCategory(category.getName())) {
            if (this._shouldUpdateCategory(category)) {
              logger$2.info(`updating category ${category.getName()}`);
              this.removeCategory(category);
            } else {
              // nothing to do
              return;
            }
          }
          this._addNewCategory(category);
        }

        /**
         * Will remove a particular category if exists.
         * Make sure to call build() after all the desired categories are removed
         */
        removeCategory(category) {
          const catName = category.getName();
          if (this.catTree.hasCategory(catName)) {
            this.catTree.removeCategory(catName);
            this.persistentHelper.categoryRemoved(category);
            this.catMatch.removeCategoryPatterns(catName);
            if (this.historyFeature) {
              this.historyFeature.removeEntry(this._getCatHistoryPIDID(category));
            }
          }
        }

        /**
         * This will build the proper data after categories were added / removed.
         * Without calling this method the expected behavior cannot be ensured.
         */
        build() {
          this.catMatch.build();
          // check if we need to get historical data for the categories
          this._applyToAllSubCategories('', category => {
            if (!category.isHistoryDataSettedUp()) {
              this._getHistoricalData(category);
            }
          });
        }

        /**
         * will clean up the categories (to check if they are still valid or we should
         * remove some old data)
         */
        cleanUp() {
          this._applyToAllSubCategories('', cat => {
            cat.cleanUp();
            if (cat.isObsolete()) {
              this.removeCategory(cat);
            }
          });
        }

        // we will call this method whenever there is a new location change so we
        // can evaluate all the categories for this case.
        newUrlEvent(tokenizedUrl) {
          if (!tokenizedUrl) {
            logger$2.error('skipping invalid tokenizedUrl', tokenizedUrl);
            return;
          }
          const catIDSet = this.catMatch.checkMatches(tokenizedUrl);
          catIDSet.forEach(catID => {
            const catNode = this.catTree.getCategoryNode(catID);
            if (catNode === null || !catNode.hasCategory()) {
              logger$2.error(`We do not have a category with id ${catID}??`);
              return;
            }
            // hit the category
            catNode.getCategory().hit();
            this._catModified(catNode.getCategory());
          });
          // increment the number of urls we have for this particular day
          this.dayCounterHelper.incToday();
          // TODO: optimize here to save not every time but every N url changes
          this.persistentHelper.saveDayCounterData(this.dayCounterHelper.serialize());
        }

        loadPersistentData() {
          return this.persistentHelper.loadCategories().then(catList => {
            this.catTree.clear();
            this.catMatch.clear();
            for (let i = 0; i < catList.length; i += 1) {
              const category = catList[i];
              this.catTree.addCategory(category);
              this.catMatch.addCategoryPatterns(category.getName(), category.getPatterns());
            }
            // build the pattern index here
            this.build();
          });
        }

        savePersistentData() {
          return this.persistentHelper.save();
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            QUERY METHODS
        // ///////////////////////////////////////////////////////////////////////////

        // recursive get the total count (sum)
        getMatchesForCategory(catName) {
          let matches = 0;
          this._applyToAllSubCategories(catName, cat => {
            matches += cat.getTotalMatches();
          });
          return matches;
        }

        // get the max number of days in any of the children categories
        getMaxCountDaysForCategory(catName) {
          let maxNumDays = 0;
          this._applyToAllSubCategories(catName, cat => {
            maxNumDays = Math.max(maxNumDays, cat.countDaysWithMatches());
          });
          return maxNumDays;
        }

        getLastMatchTsForCategory(catName) {
          let result = 0;
          this._applyToAllSubCategories(catName, cat => {
            result = Math.max(result, cat.getLastMatchTs());
          });
          return result > 0 ? result : null;
        }

        isCategoryActive(catName) {
          return this.hasCategory(catName) && this.catTree.someSubCategory(catName, catNode => catNode.hasCategory() && catNode.getCategory().isActive());
        }

        // ///////////////////////////////////////////////////////////////////////////

        _shouldUpdateCategory(category) {
          const catNode = this.catTree.getCategoryNode(category.getName());
          return catNode === null || !catNode.hasCategory() || catNode.getCategory().getVersion() < category.getVersion();
        }

        _addNewCategory(category) {
          this.persistentHelper.categoryAdded(category);
          this.catTree.addCategory(category);
          this.catMatch.addCategoryPatterns(category.getName(), category.getPatterns());
          category.setTotalDayHandler(this.dayCounterHelper);
        }

        _getHistoricalData(category) {
          if (!this.historyFeature) {
            // no history feature so no historical data
            return;
          }

          const now = timestampMS();
          // to avoid possible issues we will generate a new id using the category name
          // and the current version
          const catPID = this._getCatHistoryPIDID(category);
          const historyQuery = {
            patterns: category.getPatterns(),
            pid: catPID,
            start_ms: now - category.getTimeRangeSecs() * 1000,
            end_ms: now
          };
          this.historyFeature.performQuery(historyQuery).then(data => {
            if (!data || !data.d || !data.d.match_data || !data.pid) {
              logger$2.error('invalid data received from the history module', data);
              return;
            }
            if (data.pid !== catPID) {
              logger$2.error(`invalid data for category ${category.getName()}?`, data);
              return;
            }
            category.updateWithHistoryData(data.d.match_data);
            this.dayCounterHelper.mergeDaysData(data.d.match_data.per_day);
            this._catModified(category);
          });
        }

        _checkCategory(category) {
          return !!category;
        }

        /**
         * will apply the function f to all the categories we find including the catName
         */
        _applyToAllSubCategories(catName, f) {
          // clean all the old possible categories data
          const allNodes = this.catTree.getAllSubCategories(catName);
          for (let i = 0; i < allNodes.length; i += 1) {
            const cat = allNodes[i].getCategory();
            if (cat) {
              f(cat);
            }
          }
        }

        _catModified(category) {
          this.persistentHelper.categoryModified(category);
        }

        _getCatHistoryPIDID(category) {
          return `${category.getName()}|${category.getVersion()}`;
        }
      }

      /**
       * This module will take care of holding the status of the offers and return the
       * proper status for each offer.
       * We will assume for now that any offer that is not in the list has an unknown
       * state, only the ones that are explicitly defined on the list will be treated
       * as they are.
       * For now we will not do it persistently.
       *
       * The possible status will be:
       *   - active: exists and still active
       *   - inactive: exists but is not active anymore
       *   - obsolete: doesn't exists (and hence is not active)
       *   - unknown: we do not know yet the status of the offer? (couldn't get the data from
       *              the backend for example)
       */

      class OfferStatusHandler {
        constructor() {
          // offer_id -> status
          this.statusMap = null;
          this.onStatusChangedCallback = null;
        }

        setStatusChangedCallback(onStatusChangedCallback) {
          this.onStatusChangedCallback = onStatusChangedCallback;
        }

        // this will load the status from an object (got from the backend)
        loadStatusFromObject(obj) {
          // reset current data
          this.statusMap = new Map();
          if (!obj) {
            return;
          }
          const offerIDs = Object.keys(obj);
          for (let i = 0; i < offerIDs.length; i += 1) {
            const offerID = offerIDs[i];
            this.statusMap.set(offerID, obj[offerID]);
          }
          if (this.onStatusChangedCallback) {
            this.onStatusChangedCallback();
          }
        }

        getOfferStatus(offerID) {
          if (this.statusMap === null) {
            return 'unknown';
          }
          return this.statusMap.has(offerID) ? this.statusMap.get(offerID) : 'unknown';
        }
      }

      // /////////////////////////////////////////////////////////////////////////////
      // consts
      const USER_ENABLED = 'offers2UserEnabled';
      const OFFERS_CC_ENABLED = 'modules.offers-cc.enabled';
      const PROMO_BAR_ENABLED = 'modules.browser-panel.enabled';

      var Background$15 = background({
        // to be able to read the config prefs
        requiresServices: ['cliqz-config'],

        init() {
          // we setup the endpoint coming from the config here
          // BACKEND_URL: 'https://offers-api.cliqz.com',
          if (config.settings.OFFERS_BE_BASE_URL) {
            OffersConfigs.BACKEND_URL = config.settings.OFFERS_BE_BASE_URL;
          }
          this.softInit();
        },

        softInit() /* settings */{
          // check if we need to do something or not
          if (!CliqzUtils.getPref('offers2FeatureEnabled', false) || !CliqzUtils.getPref(USER_ENABLED, true)) {
            this.initialized = false;
            return;
          }

          // check for some other flags here:
          //
          // enable logging into the console
          if (CliqzUtils.getPref('offersLogsEnabled', false)) {
            OffersConfigs.LOG_LEVEL = 'debug';
            OffersConfigs.LOG_ENABLED = true;
          }

          // check if we need to set dev flags or not
          // extensions.cliqz.offersDevFlag
          if (CliqzUtils.getPref('offersDevFlag', false)) {
            // new ui system
            OffersConfigs.LOAD_OFFERS_STORAGE_DATA = false;
            // enable logs?
            OffersConfigs.LOG_LEVEL = 'debug';
            OffersConfigs.LOG_ENABLED = true;

            // enable trigger history
            OffersConfigs.LOAD_TRIGGER_HISTORY_DATA = false;
            // dont load signals from DB
            OffersConfigs.SIGNALS_LOAD_FROM_DB = CliqzUtils.getPref('offersLoadSignalsFromDB', false);
            // avoid loading storage data if needed
            OffersConfigs.LOAD_OFFERS_STORAGE_DATA = CliqzUtils.getPref('offersSaveStorage', false);
            // avoid loading db for signals
            OffersConfigs.SEND_SIG_OP_SHOULD_LOAD = false;
          }

          if (CliqzUtils.getPref('triggersBE')) {
            OffersConfigs.BACKEND_URL = CliqzUtils.getPref('triggersBE');
          }

          // set some extra variables
          if (CliqzUtils.getPref('offersTelemetryFreq')) {
            OffersConfigs.SIGNALS_OFFERS_FREQ_SECS = CliqzUtils.getPref('offersTelemetryFreq');
          }
          if (CliqzUtils.getPref('offersOverrideTimeout')) {
            OffersConfigs.OFFERS_OVERRIDE_TIMEOUT = CliqzUtils.getPref('offersOverrideTimeout');
          }
          logger$2.init();
          logger$2.info(`\n\n
      ------------------------------------------------------------------------
                                  NEW SESSION STARTED
      Version: ${OffersConfigs.CURRENT_VERSION}
      timestamp: ${Date.now()}
      OffersConfigs.LOG_LEVEL: ${OffersConfigs.LOG_LEVEL}
      dev_flag: ${CliqzUtils.getPref('offersDevFlag', false)}
      triggersBE: ${OffersConfigs.BACKEND_URL}
      offersTelemetryFreq: ${OffersConfigs.SIGNALS_OFFERS_FREQ_SECS}
      '------------------------------------------------------------------------\n`);

          // create the DB to be used over all offers module
          this.db = new DB('cliqz-offers');

          // the backend connector
          this.backendConnector = new BEConnector();

          // the offersDB will be used by multiple modules and will be the new place
          // where we will centralize all the information related to offers
          this.offersDB = new OfferDB(this.db);

          // create the event handler
          this.queryHandler = new QueryHandler(this.db);
          this.eventHandler = new EventHandler(this.queryHandler);

          this.onUrlChange = this.onUrlChange.bind(this);
          this.eventHandler.subscribeUrlChange(this.onUrlChange);

          // for the new ui system
          this.signalsHandler = new SignalHandler(this.db);

          const oStatusHandler = new OfferStatusHandler();

          this.offerProc = new OfferProcessor(this.signalsHandler, this.db, this.offersDB, oStatusHandler);
          oStatusHandler.setStatusChangedCallback(this.offerProc.updateOffersStatus.bind(this.offerProc));

          // init the features here
          this.featureHandler = new FeatureHandler();
          this.patternMatchingHandler = new PatternMatchingHandler(this.featureHandler);

          const historyFeature = this.featureHandler.getFeature('history');
          this.categoryHandler = new CategoryHandler(historyFeature, this.db, this.patternMatchingHandler);

          // load the data from the category handler
          this.categoryHandler.loadPersistentData();

          // create the trigger machine executor
          this.globObjects = {
            regex_cache: new RegexpCache(),
            db: this.db,
            offer_processor: this.offerProc,
            signals_handler: this.signalsHandler,
            event_handler: this.eventHandler,
            offers_db: this.offersDB,
            history_index: new HistoryIndex(this.db),
            query_handler: this.queryHandler,
            feature_handler: this.featureHandler,
            be_connector: this.backendConnector,
            pattern_matching_handler: this.patternMatchingHandler,
            category_handler: this.categoryHandler,
            offers_status_handler: oStatusHandler
          };
          this.triggerMachineExecutor = new TriggerMachineExecutor(this.globObjects);

          // to be checked on unload
          this.initialized = true;
        },

        // ///////////////////////////////////////////////////////////////////////////
        unload() {
          this.softUnload();
        },

        softUnload() {
          if (this.initialized === false) {
            return;
          }

          if (this.triggerMachineExecutor) {
            this.triggerMachineExecutor.destroy();
            this.triggerMachineExecutor = null;
          }

          if (this.globObjects) {
            if (this.globObjects.history_index) {
              this.globObjects.history_index.savePersistentData();
              this.globObjects.history_index.destroy();
            }
            this.globObjects = null;
          }

          if (this.offerProc) {
            this.offerProc.destroy();
            this.offerProc = null;
          }
          if (this.signalsHandler) {
            this.signalsHandler.destroy();
            this.signalsHandler = null;
          }
          if (this.eventHandler) {
            this.eventHandler.destroy();
            this.eventHandler = null;
          }
          if (this.offersDB) {
            this.offersDB.savePersistentData();
          }
          if (this.featureHandler) {
            this.featureHandler.unload();
            this.featureHandler = null;
          }

          if (this.categoryHandler) {
            this.categoryHandler.destroy();
            this.categoryHandler = null;
          }

          this.initialized = false;
        },

        // ///////////////////////////////////////////////////////////////////////////
        start() {
          // nothing to do
        },

        // ///////////////////////////////////////////////////////////////////////////
        beforeBrowserShutdown() {
          // check if we have the feature  enabled
          if (this.initialized === false) {
            return;
          }

          logger$2.info('unloading background');

          if (this.triggerMachineExecutor) {
            this.triggerMachineExecutor.destroy();
            this.triggerMachineExecutor = null;
          }

          if (this.offerProc) {
            this.offerProc.savePersistenceData();
            this.offerProc.destroy();
          }

          if (this.offersDB) {
            this.offersDB.savePersistentData();
          }

          if (this.signalsHandler) {
            this.signalsHandler.savePersistenceData();
          }

          if (this.globObjects.history_index) {
            this.globObjects.history_index.savePersistentData();
          }

          // TODO: savePersistentData()
          logger$2.info('background script unloaded');
        },

        onUrlChange(urlData) {
          if (!urlData || !this.triggerMachineExecutor) {
            return;
          }
          const data = {
            url_data: urlData,
            queryInfo: this.queryHandler.normalize(urlData.getRawUrl(), urlData.getDomain())
          };
          this.triggerMachineExecutor.processUrlChange(data);
          // keep this url on memory
          this.patternMatchingHandler.trackTokenizedUrlOnMem(urlData.getPatternRequest());
          // evaluate categories as well
          this.categoryHandler.newUrlEvent(urlData.getPatternRequest());
        },

        // ///////////////////////////////////////////////////////////////////////////
        events: {
          'core.window_closed': function coreWinClose() {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            let remaining = _ref.remaining;

            logger$2.info(`window closed!!: remaining: ${remaining}`);
            // GR-147: if this is the last window then we just save everything here
            if (remaining === 0) {
              if (this.offerProc) {
                this.offerProc.savePersistenceData();
              }
            }
          },
          'offers-recv-ch': function onRealEstateMessage(message) {
            this.offerProc.processRealEstateMessage(message);
          },
          prefchange: function onPrefChange(pref) {
            if (pref === USER_ENABLED) {
              if (CliqzUtils.getPref(USER_ENABLED, true) === true) {
                CliqzUtils.setPref(OFFERS_CC_ENABLED, true);
                CliqzUtils.setPref(PROMO_BAR_ENABLED, true);
                this.softInit();
              } else {
                CliqzUtils.setPref(OFFERS_CC_ENABLED, false);
                CliqzUtils.setPref(PROMO_BAR_ENABLED, false);
                this.softUnload();
              }
            }
          }
        },

        actions: {
          getStoredOffers(args) {
            return this.offerProc ? this.offerProc.getStoredOffers(args) : [];
          },

          createExternalOffer(args) {
            return this.offerProc ? this.offerProc.createExternalOffer(args) : false;
          },

          hasExternalOffer(args) {
            return this.offerProc ? this.offerProc.hasExternalOffer(args) : false;
          },

          processRealEstateMessage(message) {
            if (this.offerProc) {
              this.offerProc.processRealEstateMessage(message);
            }
          }
        }

      });

      ////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////
      class Win$14 {
        init() {}

        unload() {}

        status() {
          return {
            visible: true,
            userEnabled: CliqzUtils.getPref('offers2UserEnabled', true) === true,
            locationEnabled: CliqzUtils.getPref('offers_location', 1) === 1 // 0 = off, 1 = IP based
          };
        }
      }

      var offersV2Module = {
        Background: Background$15,
        Window: Win$14
      };

      const logger$3 = new Logger({
        useDump: false,
        level: 'log',
        prefix: '[history-analysis]'
      });

      class HistoryInterface {
        constructor() {
          // TODO: this will work on all platforms?
          this.historyService = Components.classes['@mozilla.org/browser/nav-history-service;1'].getService(Components.interfaces.nsINavHistoryService);
        }

        /**
         * will perform queries for each day and will return a map from keydate => [urlentries..]
         * @param  {[type]} keyDaysList [description]
         * @return {Promise}            promise
         */
        getHistoryForKeyDays(keyDaysList) {
          if (!keyDaysList || keyDaysList.length === 0) {
            return null;
          }

          const queriesResult = [];
          const todayKey = getTodayDayKey();
          for (let i = 0; i < keyDaysList.length; i += 1) {
            const currKeyDate = Number(keyDaysList[i]);
            const startMicro = getDateFromDateKey(currKeyDate) * 1000;
            const endMicro = todayKey === currKeyDate ? timestamp$1() * 1000 : getDateFromDateKey(currKeyDate, 23, 59, 59) * 1000;
            // we need to perform a history query for this day and store the resulting
            // history entries on the map
            queriesResult.push(this._performHistoryQuery(startMicro, endMicro, currKeyDate));
          }

          const result = {};
          for (let i = 0; i < queriesResult.length; i += 1) {
            const pres = queriesResult[i];
            if (pres !== null) {
              result[pres.id] = { places: pres.places, last_ts: pres.last_ts };
            }
          }
          return result;
        }

        /**
         * start and end in microseconds
         * @param  {[type]} start microseconds
         * @param  {[type]} end   microseconds
         * @param  {[type]} id    [description]
         * @return {[type]}       [description]
         */
        _performHistoryQuery(start, end, id) {
          if (!this.historyService) {
            logger$3.error('No historyService present?');
            return null;
          }
          // queries parameters (e.g. domain name matching, text terms matching, time range...)
          // see : https://developer.mozilla.org/en/nsINavHistoryQuery
          const query = this.historyService.getNewQuery();
          if (!query) {
            logger$3.error('cannot get a new query from the history');
            return null;
          }
          query.beginTimeReference = query.TIME_RELATIVE_EPOCH;
          query.beginTime = start;
          query.endTimeReference = query.TIME_RELATIVE_EPOCH;
          query.endTime = end;

          // options parameters (e.g. ordering mode and sorting mode...)
          // see : https://developer.mozilla.org/en/nsINavHistoryQueryOptions
          const options = this.historyService.getNewQueryOptions();

          // TODO: here we should define better what options we want to support in the
          // future

          // execute the query
          // see : https://developer.mozilla.org/en/nsINavHistoryService#executeQuery()
          const result = this.historyService.executeQuery(query, options);
          if (!result) {
            logger$3.error('cannot execute the query');
          }

          // Using the results by traversing a container
          // see : https://developer.mozilla.org/en/nsINavHistoryContainerResultNode
          const cont = result.root;
          cont.containerOpen = true;
          const resultPages = [];
          for (let i = 0; i < cont.childCount; i += 1) {
            const node = cont.getChild(i);

            // "node" attributes contains the information (e.g. uri, title, time, icon...)
            // see : https://developer.mozilla.org/en/nsINavHistoryResultNode
            resultPages.push(node.uri);
          }
          // Close container when done
          // see : https://developer.mozilla.org/en/nsINavHistoryContainerResultNode
          cont.containerOpen = false;
          return { id, places: resultPages, last_ts: end / 1000 };
        }
      }

      /**
       * This class / structure will contain the history-related information for a given
       * pattern set (pattern set = pattern list). This pattern set are identified by
       * an unique id (for example, the hash(list_patterns)).
       * The history-related data contained is basically 2 groups of things:
       * Metainformation (info) like when was accessed / created / modified to used
       * later to know if we should remove the entry or not (not accessed in the last N
       * days for example).
       *
       * We also will hold the matching data (match_data) that will basically contains
       * a map of day -> num of matches / total urls checked for that day for the given
       * pattern / etc.
       * We will also hold the total number of matches (for all those days).
       * {
       *   info: {
       *     // when this entry was created
       *     created_ts: X,
       *     // last time the entry was updated
       *     last_updated_ts: M,
       *     // the last time this entry was accessed / requested for information
       *     last_accessed_ts: Z,
       *   },
       *   match_data: {
       *     total: {
       *       // total of number of days we have info regarding this entry
       *       num_days: N,
       *       // the total number of matches on those days
       *       m: M,
       *       // the total number of urls we checked on history on those days for this
       *       // particular pattern.
       *       c: X,
       *
       *       // the following keys will store the first and last day we see that
       *       // we analyzed the data, NOTE THAT THIS DOESNT MEANS THAT WE READ ALL
       *       // IN BETWEEN, it could be that we just read part of it or some intervals
       *       // NOT IMPLEMENTED YET
       *
       *       // this will contain the timestamp on ms of the latest history url processed
       *       // for this particular entry
       *       last_checked_url_ts: Z,
       *       // the latest day we have analyzed (key format)
       *       last_day_key: X,
       *       // the first day we analyzed
       *       first_day_key: Y,
       *     },
       *     per_day: {
       *       // we will store the data in the following format: YYYYMMDD
       *       day_key_1: {
       *         // the number of matches for this particular day
       *         m: N,
       *         // the number of urls checked on this day
       *         c: M,
       *         // the last time we accessed / used this day data
       *         last_accessed_ts: X,
       *       },
       *       ...
       *     }
       *   }
       * }
       */
      class HistoryEntry {
        constructor() {
          let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          const now = timestamp$1();
          if (data) {
            this.data = data;
          } else {
            this.data = {
              info: {
                created_ts: now,
                last_updated_ts: now,
                last_accessed_ts: now
              },
              match_data: {
                total: {
                  num_days: 0,
                  m: 0,
                  c: 0,
                  last_checked_url_ts: 0,
                  last_day_key: null,
                  first_day_key: null
                },
                per_day: {}
              }
            };
          }
        }

        /**
         * will return the content of the object so can be serialized
         * @return {[type]} [description]
         */
        getData() {
          return this.data;
        }

        hasProcessedDay(dateKey) {
          return !!this.data.match_data.per_day[dateKey];
        }

        /**
         * this will change the last access date to the entry
         */
        getProcessedDayData(dateKey) {
          if (!dateKey) {
            return null;
          }
          const dayEntry = this.data.match_data.per_day[dateKey];
          if (!dayEntry) {
            return null;
          }
          this._updateLastAccessDate(dateKey);
          return dayEntry;
        }

        getLastAccessedTimestamp() {
          return this.data.info.last_accessed_ts;
        }

        /**
         * will create an object containing the days in the given list (or null if we
         * do not have it) with the following information:
         * {
         *   match_data: {
         *     total: {
         *       // total of number of days we have info regarding this entry
         *       num_days: N,
         *       // the total number of matches on those days
         *       m: M,
         *       // the total number of urls we checked on history on those days for this
         *       // particular pattern.
         *       c: X,
         *       // the last timestamp of the last url we have checked (it can be that
         *       // is not in the query of those days).
         *       last_checked_url_ts: T,
         *     },
         *     per_day: {
         *       // we will store the data in the following format: YYYYMMDD
         *       day_key_1: {
         *         // the number of matches for this particular day
         *         m: N,
         *         // the number of urls checked on this day
         *         c: M,
         *         // the last time we accessed / used this day data
         *         last_accessed_ts: X,
         *       },
         *       ...
         *     }
         *   }
         * }
         */
        getDataForDays(dayList) {
          const result = {
            match_data: {
              total: {
                num_days: 0,
                m: 0,
                c: 0,
                last_checked_url_ts: this.data.match_data.total.last_checked_url_ts
              },
              per_day: {}
            }
          };

          const incrementTotalDataFromDay = (t, dayData) => {
            /* eslint-disable no-param-reassign */
            t.num_days += 1;
            t.m += dayData.m;
            t.c += dayData.c;
          };

          for (let i = 0; i < dayList.length; i += 1) {
            const dayKey = dayList[i];
            const processedDay = this.getProcessedDayData(dayKey);
            if (processedDay !== null) {
              result.match_data.per_day[dayKey] = processedDay;
              incrementTotalDataFromDay(result.match_data.total, processedDay);
            }
          }
          return result;
        }

        /**
         * will add / set / update new data for a particular day
         * @param {[type]} dateKey the datekey
         * @param {[type]} data    object containing the following infomration:
         * {
         *   m: num of matches,
         *   c: the number of url processed for that day,
         *   last_ts: the last url timestamp analyzed for that particular day,
         * }
         */
        setDayData(dateKey, data) {
          if (!dateKey || !this._checkDayData(data) || !data.last_ts) {
            logger$3.error(`Invalid arguments provided for adding data: ${dateKey} - ${data}`);
            return false;
          }
          this._removeDay(dateKey);
          return this._addDayData(dateKey, data, data.last_ts);
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            Private methods
        // ///////////////////////////////////////////////////////////////////////////
        //

        _updateLastAccessDate(dateKey) {
          const entry = this.data.match_data.per_day[dateKey];
          if (!entry) {
            return;
          }
          const now = timestamp$1();
          entry.last_accessed_ts = now;
          this.data.last_accessed_ts = now;
        }

        _updateLastModifiedDate() /* dateKey */{
          // we do not have this per date so skip
          const now = timestamp$1();
          this.data.last_updated_ts = now;
        }

        _removeDay(dateKey) {
          const entry = this.data.match_data.per_day[dateKey];
          if (!entry) {
            return;
          }
          // substract from the general stats
          const totData = this.data.match_data.total;
          totData.num_days -= 1;
          totData.m -= entry.m;
          totData.c -= entry.c;
          this._updateLastAccessDate(dateKey);
          this._updateLastModifiedDate();
          delete this.data.match_data.per_day[dateKey];
        }

        _addDayData(dateKey, data, lastUrlTS) {
          if (!dateKey || !this._checkDayData(data) || !lastUrlTS) {
            logger$3.error(`Invalid arguments provided for adding data: ${dateKey} - ${data}`);
            return false;
          }
          // ensure we do not have the entry already
          if (this.hasProcessedDay(dateKey)) {
            logger$3.error('We already have that day here, we should not add => inconsistent data');
            return false;
          }
          this.data.match_data.per_day[dateKey] = {
            m: data.m,
            c: data.c,
            last_accessed_ts: 0
          };
          // add data to the global information
          const totData = this.data.match_data.total;
          totData.num_days += 1;
          totData.m += data.m;
          totData.last_checked_url_ts = Math.max(lastUrlTS, totData.last_checked_url_ts);
          totData.c += data.c;

          // update the last_access here and the general one as well
          this._updateLastAccessDate(dateKey);
          this._updateLastModifiedDate();
          return true;
        }

        _checkDayData(data) {
          return data && data.m !== undefined && data.c !== undefined;
        }
      }

      class HistoryWorker {
        constructor() {
          const workerPath = `${config.baseURL}history-analyzer/worker.bundle.js`;
          this.worker = new Worker(workerPath);
        }

        setOnmessageCb(fn) {
          this.worker.onmessage = fn;
        }

        postMessage() {
          this.worker.postMessage(...arguments);
        }

        terminate() {
          this.worker.terminate();
        }
      }

      /**
       * This file will contain some helper classes to handle persistent state /
       * information.
       */

      // /////////////////////////////////////////////////////////////////////////////
      // Data handler / holder abstraction
      //
      class BasicDataHolder {
        constructor(docID, data, db) {
          this.docID = docID;
          this.d = data;
          this.db = db;
        }
        destroy() {}
        save() {
          return Promise.resolve(true);
        }
        load() {
          return Promise.resolve(true);
        }
        markDataDirty() {}
        erase() {
          return Promise.resolve(true);
        }
        get data() {
          return this.d;
        }
        set data(d) {
          this.d = d;
        }
      }

      class PersistentDataHandler extends BasicDataHolder {
        constructor(docID, data, db) {
          super(docID, data, db);
          this.dataDirty = false;
        }

        destroy() {
          return this.save();
        }

        save() {
          let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (!force && !this.dataDirty) {
            return Promise.resolve(true);
          }
          return this.db.upsert(this.docID, { data: this.d }).then(() => {
            logger$3.log('data saved successfully');
            this.dataDirty = false;
            return Promise.resolve(true);
          });
        }

        load() {
          return this.db.get(this.docID).then(docData => {
            if (!docData || !docData.data) {
              logger$3.log('empty data from DB, probably not yet created?');
              return Promise.resolve(false);
            }

            // set the data
            this.d = docData.data;
            this.dataDirty = false;
            return Promise.resolve(true);
          }).catch(err => {
            if (err && err.status && err.status !== 404) {
              logger$3.log('load: error loading the storage data...:', err);
            }
            return Promise.resolve(false);
          });
        }

        markDataDirty() {
          this.dataDirty = true;
        }

        erase() {
          return this.db.remove(this.docID);
        }
      }

      /**
       * This class is intended to abstract the notion of an interval and provide handy
       * functions on intervals like for example, if they overlap, which are the intersections
       * the possible subintervals when intersecting multiple and so on
       */
      class Interval$1 {
        constructor(start, end) {
          let clientData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          this.start = start;
          this.end = end;
          this.clientData = clientData;
        }

        overlaps(otherInterval) {
          // overlaps if not not overlaps :)
          return !(this.end <= otherInterval.start || otherInterval.end <= this.start);
        }

        /**
         * will return all the intervals that results from overlapping intervals
         * This method will return all the non-overlaping possible intervals from all
         * the intersections of the current and otherInterval interval
         * @param  {[type]} otherInterval [description]
         * @return {[type]}       [description]
         */
        splitOverlaps(otherInterval) {
          if (!this.overlaps(otherInterval)) {
            return [];
          }
          const positions = [...new Set([this.start, this.end, otherInterval.start, otherInterval.end])].sort();
          const result = [];
          for (let i = 1; i < positions.length; i += 1) {
            result.push(new Interval$1(positions[i - 1], positions[i]));
          }
          return result;
        }

        static generateNonOverlapsIntervals(lIntervals) {
          if (lIntervals.length <= 1) {
            return lIntervals;
          }
          const overlapingGroups = [[]];
          // sort the intervals
          lIntervals.sort((a, b) => a.start < b.start);
          for (let i = 0; i < lIntervals.length - 1; i += 1) {
            // check if the next overlaps the current
            const curr = lIntervals[i];
            const next = lIntervals[i + 1];
            const currList = overlapingGroups[overlapingGroups.length - 1];
            currList.push(curr);
            if (!next.overlaps(curr)) {
              // this was the last one, now we create the next list for the incoming
              // overlapping elements
              overlapingGroups.push([]);
            }
          }
          // clean up
          if (overlapingGroups[overlapingGroups.length - 1].length === 0) {
            overlapingGroups[overlapingGroups.length - 1].pop();
          }

          const result = [];
          for (let i = 0; i < overlapingGroups.length; i += 1) {
            const ilist = overlapingGroups[i];
            const pointsSet = new Set();
            for (let k = 0; k < ilist.length; k += 1) {
              pointsSet.add(ilist[k].start);
              pointsSet.add(ilist[k].end);
            }
            const points = [...pointsSet].sort();
            for (let j = 1; j < points.length; j += 1) {
              result.push(new Interval$1(points[j - 1], points[j]));
            }
          }

          return result;
        }

        /**
         * returns if the current interval is contained in the otherInterval (meaning the otherInterval is
         * bigger than the current one and the current one is inside)
         * @param  {[type]}  otherInterval [description]
         * @return {Boolean}       [description]
         */
        isInside(otherInterval) {
          return otherInterval.start <= this.start && otherInterval.end >= this.end;
        }

        isPointInside(p) {
          return this.start <= p && p <= this.end;
        }

        /**
         * this will return a list of resulting intervals (non overlaping ones) that
         * are the result of cutting the current interval by another one
         */
        cutBy(otherInterval) {
          if (!this.overlaps(otherInterval) || this.isInside(otherInterval)) {
            return [this];
          }
          if (otherInterval.isInside(this)) {
            return this.splitOverlaps(otherInterval);
          }
          // now either start or end are contained in the interval
          let midPoint = otherInterval.end;
          if (this.isPointInside(otherInterval.start)) {
            midPoint = otherInterval.start;
          }
          return [new Interval$1(this.start, midPoint), new Interval$1(midPoint, this.end)];
        }

        eql(otherInterval) {
          return this.start === otherInterval.start && this.end === otherInterval.end;
        }
      }

      // /////////////////////////////////////////////////////////////////////////////

      const MAX_DAYS_BUCKET = 200;
      const STATE_DOC_ID = 'ha-history-handler-state';
      const defaultState = {
        queries: [],
        taskQueue: [],
        currentTaskID: ''
      };

      // /////////////////////////////////////////////////////////////////////////////

      // TODO: move this to core?
      const getUniqueID = () => {
        function s4() {
          return Math.floor((1 + random()) * 0x10000).toString(16).substring(1);
        }
        return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
      };

      /**
       * Build a map of pattern id -> list of intervals
       */
      const buildIntervalsMapFromQueriesList = queriesList => {
        const intervalsMap = new Map();
        for (let i = 0; i < queriesList.length; i += 1) {
          const q = queriesList[i];
          const interval = new Interval$1(q.start_ms, q.end_ms);
          if (!intervalsMap.has(q.pid)) {
            intervalsMap.set(q.pid, [interval]);
          } else {
            intervalsMap.get(q.pid).push(interval);
          }
        }
        return intervalsMap;
      };

      /**
       * for each patterns ids -> list of intervals we will first normalize them
       * to non-overlapping intervals and for each of the non overlapping interval
       * we will get the days on that time range to get the days we need to calculate
       * filtering out the days we already have on the entries cache (+ today)
       *
       * @return {object} of the shape id_key -> list(pids), meaning in which days we
       * have to match witch patterns.
       */
      const buildDayQueriesMap = (intervalsMap, entriesCache) => {
        // helper entries cache map function
        const haveCachedData = (pid, dayKey) => entriesCache.has(pid) && entriesCache.get(pid).hasProcessedDay(dayKey);

        const todayKeyDay = getTodayDayKey();
        const daysQueriesMap = {};
        intervalsMap.forEach((intervalList, pid) => {
          const nonOverlapings = Interval$1.generateNonOverlapsIntervals(intervalList);
          // (4)
          for (let i = 0; i < nonOverlapings.length; i += 1) {
            const interval = nonOverlapings[i];
            const days = getDaysFromTimeRange(interval.start, interval.end);
            // (5), (6)
            for (let j = 0; j < days.length; j += 1) {
              const currDayKey = days[j];
              // check if we have that entry already or not, or if it is today (we will
              // re calculate in that case).
              if (!haveCachedData(pid, currDayKey) || currDayKey === todayKeyDay) {
                let pidList = daysQueriesMap[currDayKey];
                if (!pidList) {
                  pidList = [];
                  daysQueriesMap[currDayKey] = pidList;
                }
                pidList.push(pid);
              }
            }
          }
        });
        return daysQueriesMap;
      };

      /**
       * This method will split the current days we are trying to query (DB) and split
       * it in buckets of tasks (list of tasks).
       * The output of this method is a list of tasks of non-overlaping days to be
       * queried to the DB
       */
      const splitAndCreateTasks = (daysQueriesMap, patternsMap) => {
        // split here for every N days to avoid bottlenecks, we can do more
        // intelligent splitting in the future
        const dayKeys = Object.keys(daysQueriesMap);
        const numDays = dayKeys.length;
        const result = [];
        if (numDays === 0) {
          // no days provided??
          return result;
        }
        if (numDays > MAX_DAYS_BUCKET) {
          const resultDaysBuckets = [];
          while (dayKeys.length > 0) {
            resultDaysBuckets.push(dayKeys.splice(0, MAX_DAYS_BUCKET));
          }
          logger$3.log(`Splitting tasks into ${resultDaysBuckets.length} for ${numDays} days`);
          for (let i = 0; i < resultDaysBuckets.length; i += 1) {
            const daysBucket = resultDaysBuckets[i];
            const daysQueryBucketMap = {};
            const patternIdsSet = new Set();
            for (let j = 0; j < daysBucket.length; j += 1) {
              const dayKey = daysBucket[j];
              daysQueryBucketMap[dayKey] = daysQueriesMap[dayKey];
              for (let k = 0; k < daysQueriesMap[dayKey].length; k += 1) {
                patternIdsSet.add(daysQueriesMap[dayKey][k]);
              }
            }
            // get the patterns for this bucket
            const patternsBucketMap = {};
            patternIdsSet.forEach(pid => {
              patternsBucketMap[pid] = patternsMap[pid];
            });

            result.push({
              patterns_map: patternsBucketMap,
              days_queries_map: daysQueryBucketMap,
              task_id: getUniqueID()
            });
          }
        } else {
          // now we can store the task
          result.push({
            patterns_map: patternsMap,
            days_queries_map: daysQueriesMap,
            task_id: getUniqueID()
          });
        }
        return result;
      };

      /**
       * This class will wrap the tasks we need to process and also will be in charge
       * of building them if new queries arrives.
       */
      class TaskHandler {
        constructor(db, entriesCache) {
          this.entriesCache = entriesCache;
          this.dh = db ? new PersistentDataHandler(STATE_DOC_ID, defaultState, db) : new BasicDataHolder(STATE_DOC_ID, defaultState, db);
          this.d = this.dh.data;
        }

        load() {
          return this.dh.load();
        }
        save() {
          return this.dh.save();
        }

        addQuery(q) {
          if (!this._checkQuery(q)) {
            logger$3.error('Invalid query: ', q);
            throw new Error('Invalid query!');
          }
          this.d.queries.push(q);
          this.dh.save(true);
          return true;
        }

        /**
         * will return the result for the given query if we have all the data, otherwise
         * we will return null (we need to process the query)
         */
        getFullQueryResult(q) {
          if (!this._checkQuery(q)) {
            logger$3.error('Invalid query', q);
            throw new Error('Invalid query');
          }
          if (!this.entriesCache.has(q.pid)) {
            return null;
          }
          const cacheEntry = this.entriesCache.get(q.pid);
          const daysToBeQueried = getDaysFromTimeRange(q.start_ms, q.end_ms);
          const todayKeyDay = getTodayDayKey();

          // check if we have all days and any of them is today (we will recalculate this)
          for (let i = 0; i < daysToBeQueried.length; i += 1) {
            const dayKey = daysToBeQueried[i];
            if (todayKeyDay === dayKey || !cacheEntry.hasProcessedDay(dayKey)) {
              return null;
            }
          }

          // we can return right away
          return cacheEntry.getDataForDays(daysToBeQueried);
        }

        hasTasks() {
          return this.d.taskQueue.length > 0;
        }

        tasksCount() {
          return this.d.taskQueue.length;
        }

        currentTask() {
          return this.d.taskQueue[0];
        }

        popTask() {
          this.d.taskQueue.splice(0, 1);
          this.dh.save(true);
        }

        /**
         * this method will build the tasks if any from the given queries
         */
        build() {
          this._buildTasksFromQueries();
        }

        _checkQuery(q) {
          return q && q.start_ms !== undefined && q.end_ms !== undefined && q.start_ms <= q.end_ms && q.pid && q.patterns && q.patterns.length > 0;
        }

        // build a list of tasks given the current list of queries we want to perform
        // and enqueue them on the list
        _buildTasksFromQueries() {
          // A task will be an object with the following information
          // {
          //    patterns_map: {pid_1: pattern_object, ...},
          //    days_queries_map: {date_key_1: [pid_1, pid_2,...], ...},
          //    task_id: xyz, // the unique id for this task
          // }

          // algorithm
          // 1 - we group queries per id
          // 2 - once we have all queries of the same id we get the intervals
          // 3 - we later get all the non-overlaping intervals for the given intervals
          // 4 - for each interval we get the days
          // 5 - for each day we have and pid we will process it if and only if
          //     there is no cache entry for that day and pid
          // 6 - for each day we add the id to the days_queries_map

          if (this.d.queries.length === 0) {
            // nothing to do
            return;
          }

          // (1), (2)
          const intervalsMap = buildIntervalsMapFromQueriesList(this.d.queries);

          // (3), (4), (5), (6)
          const daysQueriesMap = buildDayQueriesMap(intervalsMap, this.entriesCache);

          // get the patterns here
          const patternsMap = {};
          for (let i = 0; i < this.d.queries.length; i += 1) {
            const q = this.d.queries[i];
            if (!patternsMap[q.pid]) {
              patternsMap[q.pid] = q.patterns;
            }
          }

          // get the tasks from the given queries
          const tasks = splitAndCreateTasks(daysQueriesMap, patternsMap);

          // now we need to add the current tasks into the queue and remove the queries
          this.d.queries = [];
          tasks.forEach(t => this.d.taskQueue.push(t));
          this.dh.save(true);
        }
      }

      // Status states of the executor
      const STATUS = {
        IDLE: 'idle',
        EXECUTING: 'executing',
        FINISHED: 'finished'
      };
      // how much time we want to wait till assume a task is dead or failed
      const MAX_TASK_TIME_MS = 10 * 1000;

      /**
       * This class will be in charge of executing a given task and track the progress
       * of it with the worker
       */
      class TaskExecutor {
        /**
         * The expected task layout:
         * {
         *   task_id: xyz,
         *   patterns_map: {},
         *   days_queries_map: {},
         *   history_data_map:{}
         * }
         */
        constructor(worker, onTaskFinishedCb) {
          this.task = null;
          this.worker = worker;
          this.status = STATUS.IDLE;
          this.failed = false;
          this.result = null;
          this.executedTS = null;
          this.onTaskFinishedCb = onTaskFinishedCb;

          // configure the worker
          this._processWorkerMessage = this._processWorkerMessage.bind(this);
          this.worker.setOnmessageCb(this._processWorkerMessage);
        }

        configureNewTask(task) {
          // clear all state
          this.status = STATUS.IDLE;
          this.failed = false;
          this.result = null;
          this.executedTS = null;

          // setup the new task
          this.task = task;
        }

        /**
         * Call this method to update the current status of the task
         */
        updateStatus() {
          this._calculateStatus();
        }

        isConfigured() {
          return this.task !== null;
        }
        hasStarted() {
          return this.status === STATUS.EXECUTING;
        }
        hasFinished() {
          return this.status === STATUS.FINISHED;
        }
        hasFailed() {
          return this.hasFinished() && this.failed;
        }
        hasSucceed() {
          return !this.hasFailed();
        }
        getResult() {
          return this.result;
        }
        getTask() {
          return this.task;
        }

        /**
         * executes the current task and return true on success | false otherwise
         */
        execute() {
          this.updateStatus();
          if (this.hasStarted() || this.hasFinished()) {
            // still waiting
            logger$3.error(`We are trying to execute the task [${this.task.task_id}] again?`);
            return false;
          }

          // execute it
          this.worker.postMessage({ msg_type: 'process-task', d: this.getTask() });
          this.executedTS = timestamp$1();
          this.status = STATUS.EXECUTING;

          return true;
        }

        /**
         * this method will check if the task we are currently executing failed or not
         * @return {[type]} [description]
         */
        _calculateStatus() {
          // check if already finished then there is nothing to do
          if (this.status === STATUS.FINISHED) {
            return;
          }

          // check if we already executed the task
          if (this.executedTS === null) {
            this.status = STATUS.IDLE;
            return;
          }

          // check if expired
          const now = timestamp$1();
          // check if the task is a new one
          if (now - this.executedTS < MAX_TASK_TIME_MS) {
            // still executing
            this.status = STATUS.EXECUTING;
            return;
          }

          // else is failed because of timeout
          this.status = STATUS.FINISHED;
          this.failed = true;
          if (this.onTaskFinishedCb) {
            this.onTaskFinishedCb();
          }
          logger$3.error('The task timedout?');
        }

        _processWorkerMessage(m) {
          if (this.hasFinished()) {
            logger$3.error(`The task ${this.task.task_id} already finished...`);
            return;
          }

          // m.data contains the packet
          if (!m || !m.data || !m.data.msg_type || !m.data.d || !m.data.d.task_id) {
            // we either skip the message or we assume is the current task that failed..
            // for now we will skip the message since if the worker doesnt reply anymore
            // we will assume the task failed after MAX_TASK_TIME_MS
            logger$3.error('Invalid message received from the worker?', m);
            return;
          }

          const d = m.data.d;
          // check if the message is associated to this task
          if (d.task_id !== this.task.task_id) {
            logger$3.error(`Worker wrong task id reply: ${d.task_id}, expected: ${this.task.task_id}`);
            return;
          }

          // the task finished either success or failed
          this.status = STATUS.FINISHED;

          // we now process the msg from the worker:
          // - task-failed
          // - task-finished
          if (m.data.msg_type === 'task-failed') {
            logger$3.error(`Task ${d.task_id} failed, error: ${d.error}`, d);
            this.failed = true;
            this.result = d.error;
          } else if (m.data.msg_type === 'task-finished') {
            // task finished successfully
            logger$3.log('task finished properly');
            this.failed = false;
            this.result = d.results;
          } else {
            logger$3.error(`invalid message type got from the worker ${m.data.msg_type}`, d);
            this.failed = true;
            this.result = null;
          }

          // notify the creator that the task finished
          if (this.onTaskFinishedCb) {
            this.onTaskFinishedCb();
          }
        }
      }

      // how frequently we will check for the current status of the task and proceed
      // with the next ones if we have some for any reason
      const PROCESS_INTERVAL_TIME_MS = 15 * 1000; // 15 seconds?
      // for how much time we want to store the data after the last time we saw an
      // access to it (someone use it basically)
      const MAX_DATA_TIME_PERSIST_MS = 15 * 24 * 60 * 60 * 1000;

      // cache globals
      const CACHE_DOC_ID = 'ha-hientries_cache';

      /**
       * We will hold the cache entries here and save whenever is needed
       */
      class CacheHandler {
        constructor(db) {
          this.dh = db ? new PersistentDataHandler(CACHE_DOC_ID, {}, db) : new BasicDataHolder(CACHE_DOC_ID, {}, db);
          this.c = new Map();
        }

        has(id) {
          return this.c.has(id);
        }
        get(id) {
          return this.c.get(id);
        }
        set(id, v) {
          this.c.set(id, v);
          this.dh.markDataDirty();
        }
        delete(id) {
          if (this.c.has(id)) {
            this.c.delete(id);
            this.dh.markDataDirty();
          }
        }
        get cache() {
          return this.c;
        }

        save() {
          // serialize and save
          const entriesCache = {};
          this.c.forEach((value, key) => {
            entriesCache[key] = value.getData();
          });
          this.dh.data = entriesCache;
          return this.dh.save(true).then(() => {
            // clear the data on the cache
            this.dh.data = {};
          });
        }

        load() {
          return this.dh.load().then(() => {
            this.c = new Map();
            const entriesKeys = Object.keys(this.dh.data);
            const now = timestamp$1();
            for (let i = 0; i < entriesKeys.length; i += 1) {
              const k = entriesKeys[i];
              const historyEntry = new HistoryEntry(this.dh.data[k]);
              // check if the history entry is too old
              const lastAccessedTs = historyEntry.getLastAccessedTimestamp();
              if (now - lastAccessedTs <= MAX_DATA_TIME_PERSIST_MS) {
                this.c.set(k, historyEntry);
              } else {
                logger$3.log(`discarding old entry ${k}`);
                this.dh.markDataDirty();
              }
            }
            // clear
            this.dh.data = {};
          });
        }

        clear() {
          this.c = new Map();
          this.dh.markDataDirty();
          this.dh.data = {};
        }

        erase() {
          this.clear();
          return this.dh.erase();
        }
      }

      /**
       * This class will will handle all the flow and functionality of the module:
       * - Gather queries (queries to be performed on history entries => pattern matching).
       * - Build tasks to be performed on the worker (TaskHandler), also keep the state
       *   in a persistent way.
       * - Execute the tasks on the worker and follow progress (TaskExecutor).
       * - Update the data on the cache and notify callbacks.
       */
      class HistoryHandler {
        /**
         *
         * @param  {[type]} historyInterface is a wrapper to the real history providing
         *                                   some helper and easy interface to access
         *                                   and sort the results
         * @param  {[type]} db               the database wrapper to use for storing the
         *                                   data
         * @param {Boolean} shouldPersist    flag indicating if we should store the
         *                                   data in DB or not
         * @return {[type]}                  [description]
         */
        constructor(historyInterface, db) {
          let shouldPersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          if (shouldPersist) {
            this.db = new SimpleDB(db);
          } else {
            this.db = null;
          }

          this.historyInterface = historyInterface;
          this._taskFinishedCb = this._taskFinishedCb.bind(this);
          // create the worker and init
          this.worker = new HistoryWorker();

          this.entriesCache = new CacheHandler(this.db);
          this.taskHandler = new TaskHandler(this.db, this.entriesCache);
          this.taskExecutor = new TaskExecutor(this.worker, this._taskFinishedCb);

          // callbacks to be called whenever there is a new data
          this.callbacksMap = new Map();

          // process interval
          this.checkInterval = CliqzUtils.setInterval(() => {
            this.processTasks();
          }, PROCESS_INTERVAL_TIME_MS);
        }

        destroy() {
          CliqzUtils.clearInterval(this.checkInterval);
          this.checkInterval = null;

          this.callbacksMap.clear();

          if (this.worker) {
            this.worker.terminate();
            this.worker = null;
          }
        }

        loadPersistentData() {
          return Promise.all([this.entriesCache.load(), this.taskHandler.load()]);
        }

        savePersistentData() {
          return Promise.all([this.entriesCache.save(), this.taskHandler.save()]);
        }

        // check if we have a history index for a given id (pattern id)
        hasEntryInCache(pid) {
          return this.entriesCache.has(pid);
        }

        // return the history entry associated to the pattern id if we have one
        // already cached
        getEntryData(pid) {
          return this.entriesCache.get(pid);
        }

        // subscribe a callback to get events
        addCallback(cb) {
          this.callbacksMap.set(cb, cb);
        }

        // remove the callback
        removeCallback(cb) {
          this.callbacksMap.delete(cb);
        }

        /**
         * add a new query to be executed on the history analyzer module
         * @param {[type]} q query data:
         * {
         *   // the object containing the patterns we want to use for this
         *   patterns: {},
         *   // the patterns unique id (category id)
         *   pid: 'xyz',
         *   // start timestmap to measure (ms)
         *   start_ms: x,
         *   // end timestamp to measure (ms)
         *   end_ms: y
         * }
         */
        addQuery(q) {
          return this.taskHandler.addQuery(q);
        }

        /**
         * will return the result for the given query if we have all the data, otherwise
         * we will return null (we need to process the query)
         */
        getFullQueryResult(q) {
          return this.taskHandler.getFullQueryResult(q);
        }

        // start processing tasks
        processTasks() {
          // update tasks if any
          this.taskHandler.build();

          // check if we have tasks to process
          if (!this.taskHandler.hasTasks()) {
            // nothing to do now
            return true;
          }

          // check if we finished the task already
          if (!this.taskExecutor.isConfigured() || this.taskExecutor.hasFinished()) {
            // we need to create one
            const taskData = this._getNextValidTask();
            if (taskData === null) {
              // nothing to do here...
              return false;
            }
            this.taskExecutor.configureNewTask(taskData);

            // execute the task here
            this.taskExecutor.execute();
          }

          // update the status of the executor to check if the task expired or finished
          this.taskExecutor.updateStatus();
          return true;
        }

        /**
         * will remove the data we have associated to a given pid
         */
        removeEntry(pid) {
          if (!this.hasEntryInCache(pid)) {
            return;
          }
          this.entriesCache.delete(pid);
          this.entriesCache.save();
        }

        /**
         * remove the current data from the databases as well
         * @return {[type]} [description]
         */
        removeCurrentData() {
          // remove the cache
          this.entriesCache.clear();
          this.entriesCache.erase();
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            Private methods
        // ///////////////////////////////////////////////////////////////////////////
        //

        _taskFinishedCb() {
          if (!this.taskExecutor.hasFinished()) {
            logger$3.error('The task executor actually didnt finished?');
            return;
          }

          // now we process the result of the task depending if succeed or fail
          if (this.taskExecutor.hasFailed()) {
            // nothing to do for now, just log
            logger$3.error('current task failed, skipping it', this.taskExecutor.getTask());
          } else if (this.taskExecutor.hasSucceed()) {
            this._processTaskFinished(this.taskExecutor.getResult());
          } else {
            logger$3.error('Inconsistent state?');
          }

          // we remove the current task since it is done and proceed
          this.taskHandler.popTask();
          this.taskExecutor.configureNewTask(null);
          this.processTasks();
        }

        _getNextValidTask() {
          let taskData = null;
          while (taskData === null && this.taskHandler.hasTasks()) {
            const currentTask = this.taskHandler.currentTask();
            taskData = this._prepareTask(currentTask);
            if (taskData === null) {
              logger$3.error('Skipping the task since cannot be built?', currentTask);
              this.taskHandler.popTask();
            }
          }
          return taskData;
        }

        /**
         * will notify all the callbacks that we have new data for a particular pid
         * @param  {[type]} pid [description]
         * @param  {string} msgType [description]
         * @param  {object} data [description]
         * @return {[type]}     [description]
         */
        _notifyCallbacks(pid, msgType, data) {
          this.callbacksMap.forEach(cb => {
            if (cb) {
              // get the data for the given pid
              const cbData = {
                msg_type: msgType,
                pid,
                d: data
              };
              cb(cbData);
            }
          });
        }

        /**
         * Will prepare the task to be delivery to the executor. Will fetch the history
         * data and prepare it in the correct format
         */
        _prepareTask(task) {
          if (!task || !task.patterns_map || !task.days_queries_map || !task.task_id) {
            logger$3.error('Cannot prepare a task: ', task);
            return null;
          }

          // we here need to build the package to be sent to the worker which will be
          // an object containing the following data:
          // {
          //  task_id: XYZ, identifying the current task.
          //  patterns_map: the patterns map (id -> pattern_object)
          //  days_queries_map: {date_key_1: [pid_1, pid_2,...], ...},
          //  history_data_map: {date_key_1: { requests: [req_url_1, req_url_2,...], last_ts: x },
          // }
          //
          const daysToQuery = Object.keys(task.days_queries_map);
          const historyDataMap = this.historyInterface.getHistoryForKeyDays(daysToQuery);
          if (!historyDataMap) {
            logger$3.error('cannot fetch urls days from history');
            return null;
          }

          // we now here will convert the url into requests since this is the way that
          // the worker will process the entries
          const resultDays = Object.keys(historyDataMap);
          const requestHistoryMap = {};
          for (let i = 0; i < resultDays.length; i += 1) {
            const cday = resultDays[i];
            const urls = historyDataMap[cday].places;
            requestHistoryMap[cday] = { last_ts: historyDataMap[cday].last_ts, requests: [] };
            const rresult = requestHistoryMap[cday].requests;
            for (let j = 0; j < urls.length; j += 1) {
              const url = urls[j];

              var _parse = parse(url);

              const hostname = _parse.hostname,
                    domain = _parse.domain;

              rresult.push(mkRequest({
                url: urls[j],
                domain,
                hostname,
                cpt: 2
              }));
            }
          }
          return {
            task_id: task.task_id,
            patterns_map: task.patterns_map,
            days_queries_map: task.days_queries_map,
            history_data_map: requestHistoryMap
          };
        }

        _processTaskFinished(taskResult) {
          logger$3.log('processing the results of the task finished');

          if (!taskResult) {
            logger$3.error('Invalid arguments: taskResult === null?');
            return false;
          }

          // add the results to the cache and save the results on the DB
          const pidList = Object.keys(taskResult);
          for (let i = 0; i < pidList.length; i += 1) {
            const pid = pidList[i];
            let cacheEntry = this.entriesCache.get(pid);
            if (!cacheEntry) {
              cacheEntry = new HistoryEntry();
              this.entriesCache.set(pid, cacheEntry);
            }
            const dayMap = taskResult[pid];
            const dayKeyList = Object.keys(dayMap);
            for (let j = 0; j < dayKeyList.length; j += 1) {
              const dayKey = dayKeyList[j];
              const dayData = dayMap[dayKey];
              cacheEntry.setDayData(dayKey, dayData);
            }
            try {
              this._notifyCallbacks(pid, 'new-data', cacheEntry.getDataForDays(dayKeyList));
            } catch (err) {
              logger$3.error('Error notifying the callbacks, some failed', err);
            }
          }

          // save the cache
          try {
            this.entriesCache.save().catch();
          } catch (e) {
            logger$3.error('Something went very bad when storing the data on pouchdb', e);
          }

          return true;
        }
      }

      /**
        @namespace <namespace>
        @class Background
       */
      var Background$16 = background({
        /**
          @method init
          @param settings
        */
        init() {
          this.persistFlag = prefs.get('historyAnalyzerPersistFlag', true);

          // the map holding the promises resolvers methods
          this.resultsCache = new Map();
          this._newDataCallbackBind = this._newDataCallback.bind(this);
          this.removeAllCachedDataBind = this.removeAllCachedData.bind(this);

          // subscribe to the history listener module if have one
          try {
            history$2.onVisitRemoved.addListener(this.removeAllCachedDataBind);
          } catch (e) {
            logger$3.error('Error setting the history remove listener: ', e);
          }

          this.historyInterface = new HistoryInterface();
          this.db = new DB('cliqz-history-analyzer');
          this.historyHandler = new HistoryHandler(this.historyInterface, this.db, this.persistFlag);
          this.historyHandler.addCallback(this._newDataCallbackBind);

          return this.historyHandler.loadPersistentData().then(() => {
            this.historyHandler.processTasks();
          });
        },

        unload() {
          // remove from the history module listener
          try {
            history$2.onVisitRemoved.removeListener(this.removeAllCachedDataBind);
          } catch (e) {
            logger$3.error('Error removing the history remove listener', e);
          }

          if (this.historyInterface) {
            this.historyInterface = null;
          }

          if (this.historyHandler) {
            this.historyHandler.removeCallback(this._newDataCallbackBind);
            this.historyHandler.destroy();
            this.historyHandler = null;
          }

          if (this.db) {
            this.db.close();
            this.db = null;
          }

          // resolve all promises if we have
          this.resultsCache.forEach(pr => {
            // resolve the promise
            pr.reject(null);
          });
          this.resultsCache.clear();
        },

        beforeBrowserShutdown() {},

        _newDataCallback(data) {
          if (!data || !data.pid || !data.d) {
            logger$3.error('invalid callback data: ', data);
            return;
          }
          // unloading / loading this blows
          if (!this.resultsCache.has(data.pid)) {
            return;
          }
          this.resultsCache.get(data.pid).resolve(data);
          this.resultsCache.delete(data.pid);
        },

        events: {},

        actions: {
          hasCachedData(pid) {
            return this.historyHandler.hasEntryInCache(pid);
          },

          getCachedData(pid) {
            return this.historyHandler.getEntryData(pid);
          },

          performQuery(q) {
            const result = this.resultsCache.get(q.pid);
            if (result) {
              return result.promise;
            }

            // check if we can return the data right away
            const fullResult = this.historyHandler.getFullQueryResult(q);
            if (fullResult !== null) {
              const data = {
                pid: q.pid,
                d: fullResult
              };
              return Promise.resolve(data);
            }

            // we need to process the result

            const defer = new Defer();
            this.resultsCache.set(q.pid, defer);
            this.historyHandler.addQuery(q);
            return defer.promise;
          },

          removeEntry(pid) {
            this.historyHandler.removeEntry(pid);
          }
        },

        // ///////////////////////////////////////////////////////////////////////////
        // Private
        // ///////////////////////////////////////////////////////////////////////////
        //

        /**
         * this method will be called when the user removes any entry on the history
         * so we also remove it on our cache
         * @return {[type]} [description]
         */
        removeAllCachedData() {
          this.historyHandler.removeCurrentData();
        }

      });

      class Win$15 {
        init() {}

        unload() {}
      }

      var historyAnalyzerModule = {
        Background: Background$16,
        Window: Win$15
      };

      const UI_TOUR_PREF = 'offerCCUITourDismissed';

      /**
        @namespace offers-cc
        @module offers-cc
        @class Background
       */
      var background$3 = background({
        /**
          @method init
          @param settings
        */
        init() {
          if (prefs.has(UI_TOUR_PREF)) {
            prefs.clear(UI_TOUR_PREF);
          }

          this.is_enabled = CliqzUtils.getPref('modules.offers-cc.enabled', true);

          if (!this.is_enabled) {
            return;
          }

          this.toolbarButton = new BrowserAction({
            widgetId: 'offers-cc',
            default_title: getMessage('offers-hub-title'),
            default_popup: `${config.baseURL}offers-cc/index.html`,
            default_icon: `${config.baseURL}offers-cc/images/offers-cc-icon.svg`,
            badgeBackgroundColor: 'transparent',
            badgeText: '',
            defaultWidth: () => 264,
            defaultHeight: () => 70
          });
          this.toolbarButton.build();
        },

        unload() {
          if (!this.is_enabled) {
            return;
          }
          this.toolbarButton.shutdown();
        },

        beforeBrowserShutdown() {},

        events: {},

        actions: {}
      });

      var _extends$12 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const ORIGIN_NAME = 'offers-cc';
      let seenOffersObj = {};
      let autoTrigger = false;

      class Win$16 {
        constructor(settings) {
          if (!background$3.is_enabled) {
            return;
          }

          this.window = settings.window;
          this.settings = settings.settings;
          this.channel = settings.settings.channel;
          this.cssUrl = `${config.baseURL}offers-cc/styles/xul.css`;
          this.offersV2 = inject.module('offers-v2');

          this.actions = {
            getEmptyFrameAndData: this.getEmptyFrameAndData.bind(this),
            resize: this.resizePopup.bind(this),
            sendTelemetry: this.sendTelemetry.bind(this),
            sendOfferActionSignal: this.sendOfferActionSignal.bind(this),
            sendActionSignal: this.sendActionSignal.bind(this),
            closePanel: this.closePanel.bind(this),
            openURL: this.openURL.bind(this),
            seenOffers: this.seenOffers.bind(this), // TODO still need this ?
            sendUserFeedback: this.sendUserFeedback.bind(this)
          };

          this.onOffersCoreEvent = this.onOffersCoreEvent.bind(this);

          this.toolbarButton = background$3.toolbarButton;
          this.toolbarButton.addWindow(this.window, this.actions, {
            onClick: this.onButtonClicked.bind(this),
            onViewShowing: this.onPopupShowing.bind(this),
            onViewHiding: this.onPopupHiding.bind(this)
          });

          this.toolbarButtonElement = this.window.document.getElementById(this.toolbarButton.id);
        }

        init() {
          if (!background$3.is_enabled) {
            return;
          }

          // stylesheet for offers-cc button
          addStylesheet(this.window.document, this.cssUrl);
          CliqzEvents.sub('offers-send-ch', this.onOffersCoreEvent);
        }

        unload() {
          if (!background$3.is_enabled) {
            return;
          }
          CliqzEvents.un_sub('offers-send-ch', this.onOffersCoreEvent);
          removeStylesheet(this.window.document, this.cssUrl);
        }

        onButtonClicked() {
          this.showTooltip = false;

          const signal = {
            type: 'offrz',
            view: 'box',
            action: 'click',
            target: 'icon'
          };
          CliqzUtils.telemetry(signal);
        }

        onPopupShowing() {
          // Now we use this pop-up to show the tooltip, but we don't want them to behave the same
          if (this.showTooltip) {
            return;
          }

          if (autoTrigger) {
            const msg = {
              type: 'action-signal',
              data: {
                action_id: 'hub_pop_up'
              }
            };
            this.sendMessageToOffersCore(msg);
          } else {
            const msg = {
              type: 'action-signal',
              data: {
                action_id: 'hub_open'
              }
            };
            this.sendMessageToOffersCore(msg);
          }

          this._getAllOffers().then(results => {
            const signal = {
              type: 'offrz',
              view: 'box',
              action: 'show',
              offer_count: results.length
            };
            CliqzUtils.telemetry(signal);
          });
        }

        onPopupHiding() {
          // Don't clear the red dot when the tooltip has shown
          if (this.showTooltip || this.toolbarButton.shownDurationTime <= 1000) {
            // nothing to do
            return;
          }

          this.toolbarButtonElement.setAttribute('state', '');
          // else we will change the state of all offers

          Object.keys(seenOffersObj).forEach(offer => {
            const msgSession = {
              type: 'offer-action-signal',
              data: {
                action_id: 'offer_dsp_session',
                offer_id: offer
              }
            };
            this.sendMessageToOffersCore(msgSession);

            if (!autoTrigger) {
              const msgPulled = {
                type: 'offer-action-signal',
                data: {
                  action_id: 'offer_pulled',
                  offer_id: offer
                }
              };
              this.sendMessageToOffersCore(msgPulled);
            }

            const msgShown = {
              type: 'offer-action-signal',
              data: {
                action_id: 'offer_shown',
                offer_id: offer,
                counter: seenOffersObj[offer]
              }
            };
            this.sendMessageToOffersCore(msgShown);
          });

          const signal = {
            type: 'offrz',
            view: 'box',
            action: 'hide',
            show_duration: this.toolbarButton.shownDurationTime
          };
          CliqzUtils.telemetry(signal);

          const msgState = {
            type: 'change-offer-state',
            // no data for now
            data: {
              offers_ids: Object.keys(seenOffersObj),
              new_state: 'old'
            }
          };
          this.sendMessageToOffersCore(msgState);

          const msg = {
            type: 'action-signal',
            data: {
              action_id: 'hub_closed'
            }
          };
          this.sendMessageToOffersCore(msg);

          seenOffersObj = {};
          autoTrigger = false;
        }

        getTooltipData(uiInfo) {
          // TODO: @mai make sure that all the fields in this uiInfo are existed
          if (uiInfo.notif_type === 'tooltip_extra') {
            let backgroundColor;
            if (uiInfo.template_data.styles && uiInfo.template_data.styles.background) {
              backgroundColor = uiInfo.template_data.styles.background;
            } else {
              const CTAUrl = uiInfo.template_data.call_to_action.url;
              const urlDetails = CliqzUtils.getDetailsFromUrl(CTAUrl);
              const logoDetails = CliqzUtils.getLogoDetails(urlDetails);
              backgroundColor = `#${logoDetails.backgroundColor}`;
            }

            let isExclusive = false;
            let isBestOffer = false;

            if (uiInfo.template_data.labels && uiInfo.template_data.labels.length) {
              isExclusive = uiInfo.template_data.labels.indexOf('exclusive') > -1;
              isBestOffer = uiInfo.template_data.labels.indexOf('best_offer') > -1;
            }

            const logoClass = uiInfo.template_data.logo_class || 'normal';
            const backgroundImage = uiInfo.template_data.logo_url;

            return {
              showTooltip: true,
              logo: uiInfo.template_data.logo_url,
              headline: uiInfo.template_data.headline || uiInfo.template_data.title,
              benefit: uiInfo.template_data.benefit,
              backgroundColor,
              isExclusive,
              isBestOffer,
              logoClass,
              backgroundImage
            };
          }

          // Default generic tooltip
          return {
            showTooltip: true,
            isGeneric: true,
            headline: CliqzUtils.getLocalizedString('offers_hub_tooltip_new_offer'),
            icon: `${config.baseURL}offers-cc/images/offers-cc-icon-white.svg`
          };
        }

        _mapTelemetryStyle(notifType) {
          let style = 'generic';
          if (notifType === 'tooltip_extra') {
            style = 'on_site';
          }

          return style;
        }

        _mapTelemetryLocation(buttonArea) {
          let location;

          switch (buttonArea) {
            case 'toolbar':
              location = 'toolbar';
              break;
            case 'menu-panel':
              location = 'burger_menu';
              break;
            default:
              location = 'hidden';
              break;
          }

          return location;
        }

        // used for a first faster rendering
        getEmptyFrameAndData() {
          let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          if (data.hideTooltip) {
            this.showTooltip = false;

            const msg = {
              type: 'action-signal',
              data: {
                action_id: 'tooltip_clicked'
              }
            };
            this.sendMessageToOffersCore(msg);

            const msg2 = {
              type: 'action-signal',
              // no data for now
              data: {
                action_id: 'tooltip_closed'
              }
            };
            this.sendMessageToOffersCore(msg2);

            this.toolbarButtonElement.setAttribute('state', '');
          }

          if (this.showTooltip) {
            this.sendMessageToPopup({
              action: 'pushData',
              data: this.getTooltipData(this.uiInfo)
            });
          } else {
            if (!autoTrigger) {
              this.preferredOfferId = null;
            }

            this._getAllOffers(this.preferredOfferId).then(aData => {
              if (aData.length === 0) {
                this.sendMessageToPopup({
                  action: 'pushData',
                  data: {
                    noVoucher: true
                  }
                });

                return;
              }

              if (data.hideTooltip) {
                const signal = {
                  type: 'offrz',
                  view: 'box_tooltip',
                  action: 'click',
                  style: this._mapTelemetryStyle(aData[0].notif_type)
                };

                CliqzUtils.telemetry(signal);
              }

              this.sendMessageToPopup({
                action: 'pushData',
                data: {
                  vouchers: aData,
                  showExpandButton: aData.some(result => result.preferred) && aData.length > 1
                }
              });
            });
          }
        }

        sendMessageToPopup(aMessage) {
          const msg = {
            target: 'cliqz-offers-cc',
            origin: 'window',
            message: aMessage
          };

          this.toolbarButton.sendMessage(this.window, msg);
        }

        resizePopup(_ref) {
          let width = _ref.width,
              height = _ref.height;

          this.toolbarButton.resizePopup(this.window, { width, height });
        }

        _getAllOffers() {
          let preferredOfferId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          const self = this;
          const args = {
            filters: {
              by_rs_dest: ORIGIN_NAME
            }
          };
          return this.offersV2.action('getStoredOffers', args).then(recentData => {
            const parsedResult = [];
            let desiredOffer;
            recentData.forEach(elem => {
              if (elem && elem.offer_id && elem.offer_info && elem.offer_info.ui_info) {
                // we need to send the template name and template data here from the
                // ui info
                const uiInfo = elem.offer_info.ui_info;

                let offerState = 'new';
                if (elem.attrs && elem.attrs.state) {
                  offerState = elem.attrs.state;
                }

                // Default values for new data fields (for backward compability)
                let backgroundColor;
                let validity = {};
                let isExclusive = false;
                let isBestOffer = false;
                const logoClass = uiInfo.template_data.logo_class || 'normal';

                if (uiInfo.template_data.styles && uiInfo.template_data.styles.background) {
                  backgroundColor = uiInfo.template_data.styles.background;
                } else {
                  const CTAUrl = uiInfo.template_data.call_to_action.url;
                  const urlDetails = CliqzUtils.getDetailsFromUrl(CTAUrl);
                  const logoDetails = CliqzUtils.getLogoDetails(urlDetails);
                  backgroundColor = `#${logoDetails.brandTxtColor}`;
                }

                // Expect this to be always greater than Date.now();
                if (uiInfo.template_data.validity) {
                  const expirationTime = uiInfo.template_data.validity;
                  // Expect the expirationTime from backend to be always greater than Date.now()
                  const timeDiff = Math.abs(expirationTime * 1000 - Date.now());

                  let difference = Math.floor(timeDiff / 86400000);
                  const isExpiredSoon = difference <= 2;
                  let diffUnit = difference === 1 ? 'offers-expires-day' : 'offers-expires-days';

                  if (difference < 1) {
                    difference = Math.floor(timeDiff % 86400000 / 3600000);
                    diffUnit = difference === 1 ? 'offers-expires-hour' : 'offers-expires-hours';

                    if (difference < 1) {
                      difference = Math.floor(timeDiff % 86400000 % 3600000 / 60000);
                      diffUnit = difference === 1 ? 'offers-expires-minute' : 'offers-expires-minutes';
                    }
                  }
                  validity = {
                    text: `${CliqzUtils.getLocalizedString('offers-expires-in')} ${difference} ${CliqzUtils.getLocalizedString(diffUnit)}`,
                    isExpiredSoon
                  };
                }

                if (uiInfo.template_data.labels && uiInfo.template_data.labels.length) {
                  isExclusive = uiInfo.template_data.labels.indexOf('exclusive') > -1;
                  isBestOffer = uiInfo.template_data.labels.indexOf('best_offer') > -1;
                }

                const data = {
                  created: elem.created_ts,
                  state: offerState,
                  template_name: uiInfo.template_name,
                  template_data: uiInfo.template_data,
                  offer_id: elem.offer_id,
                  backgroundColor,
                  isExclusive,
                  isBestOffer,
                  logoClass,
                  validity,
                  notif_type: uiInfo.notif_type || 'tooltip'
                };

                if (data.offer_id !== preferredOfferId) {
                  parsedResult.push(data);
                } else {
                  data.preferred = true;
                  desiredOffer = data;
                }
              }
            });

            // Sort the results by the most recent one
            parsedResult.sort((a, b) => b.created - a.created);

            if (desiredOffer) {
              parsedResult.unshift(desiredOffer);
            }

            self.allOffers = parsedResult;

            return Promise.resolve(parsedResult);
          });
        }

        /**
         * will send a message to the offers-core following the new API:
         * https://cliqztix.atlassian.net/wiki/pages/viewpage.action?pageId=88618158
         * @param  {[type]} msg  object containing the following parameters:
         *                       - type (signal type)
         *                       - data (depending on the type)
         * @return {[type]}      [description]
         */
        sendMessageToOffersCore(msg) {
          if (!msg || !msg.type) {
            CliqzUtils.log('Error: invalid message');
            return;
          }
          // create the message to be sent
          const message = {
            origin: ORIGIN_NAME,
            type: msg.type,
            data: msg.data
          };
          CliqzEvents.pub('offers-recv-ch', message);
        }

        sendTelemetry(data) {
          const vote = data.vote;
          const comments = data.comments;
          const signal = {
            type: 'offrz',
            view: 'box',
            action: 'click',
            target: data.target
          };

          if (vote) {
            signal.vote = vote;
          }
          if (comments) {
            signal.comments = comments;
          }

          CliqzUtils.telemetry(signal);
        }

        sendActionSignal(data) {
          const msg = {
            type: 'action-signal',
            data: {
              action_id: data.actionId
            }
          };

          this.sendMessageToOffersCore(msg);
        }

        sendOfferActionSignal(data) {
          // utils.telemetry(data);
          // check the data
          if (!data.signal_type) {
            // error invalid data
            return;
          }

          // we will do a "bridging" here from the current signals to the new API
          // format.
          let msg = null;

          if (data.signal_type === 'offer-action-signal') {
            // this signals will be associated to offers but will not affect the behavior
            // or anything on the offer module, just for information purposes.
            msg = {
              type: 'offer-action-signal',
              // no data for now
              data: {
                offer_id: data.offer_id,
                // this is the signal we want to send
                action_id: data.element_id
              }
            };
          } else if (data.signal_type === 'remove-offer') {
            msg = {
              type: 'remove-offer',
              data: {
                offer_id: data.offer_id
              }
            };
          }

          if (msg) {
            this.sendMessageToOffersCore(msg);
          } else {
            CliqzUtils.log(`sendOfferActionSignal: error: the message is null? invalid signal type? ${data.signal_type}`);
          }
        }

        //
        // subscribe to the storage events
        //
        onOffersCoreEvent(event) {
          // Ignore the event if this is not the most recent active window
          if (this.window !== CliqzUtils.getWindow()) {
            return;
          }

          // check if we need to discard the event or not
          if (event.dest && event.dest.length > 0 && event.dest.indexOf(ORIGIN_NAME) < 0) {
            // we should not process this message
            return;
          }
          // we also have event data: event.data;
          const eventID = event.type;

          this._getAllOffers().then(results => {
            // TODO: Do we need this check anymore ? Yes
            if (results.length <= 0 || !results.some(result => result.state === 'new')) {
              return;
            }

            switch (eventID) {
              case 'push-offer':
                {
                  const offersHubTrigger = event.data.offer_data.ui_info.notif_type || 'tooltip';
                  const offerID = event.data.offer_data.offer_id;
                  // Auto open the panel
                  autoTrigger = true;
                  this.toolbarButtonElement.setAttribute('state', 'new-offers');

                  const notifMsg = {
                    type: 'offer-action-signal'
                  };

                  if (offersHubTrigger === 'pop-up') {
                    notifMsg.data = {
                      action_id: 'offer_notif_popup',
                      offer_id: offerID
                    };
                    this.sendMessageToOffersCore(notifMsg);
                    this.showTooltip = false;
                    this.preferredOfferId = offerID;
                    this.openPanel();
                  } else {
                    // Open tooltip by default
                    // TODO: change this when there is a new notif_type
                    notifMsg.data = {
                      action_id: `offer_notif_${offersHubTrigger}`,
                      offer_id: offerID
                    };

                    const buttonArea = this.window.CustomizableUI.getWidget(this.toolbarButton.id).areaType;
                    const signal = {
                      type: 'offrz',
                      view: 'box_tooltip',
                      action: 'show',
                      style: this._mapTelemetryStyle(offersHubTrigger),
                      location: this._mapTelemetryLocation(buttonArea)
                    };

                    CliqzUtils.telemetry(signal);

                    if (location === 'hidden') {
                      return; // Don't show the tooltip if the button is on the palette
                    }

                    this.sendMessageToOffersCore(notifMsg);

                    this.showTooltip = true;
                    this.uiInfo = event.data.offer_data.ui_info;
                    const msg = {
                      type: 'action-signal',
                      data: {
                        action_id: 'tooltip_shown'
                      }
                    };
                    this.sendMessageToOffersCore(msg);

                    this.openPanel();
                  }
                  break;
                }
              default:
                {
                  CliqzUtils.log('invalid event from core type', eventID);
                  break;
                }
            }
          }).catch(err => {
            CliqzUtils.log('======= event: error: ', err);
          });
        }

        seenOffers(data) {
          seenOffersObj = data;
        }

        openPanel() {
          if (CliqzUtils.getWindow() !== this.window) {
            return;
          }

          // TODO: check if we still need it, this is for the burger menu
          this.window.PanelUI.panel.setAttribute('noautohide', 'false');
          this.toolbarButton.showPopup(this.window);
        }

        closePanel() {
          // TODO: not using anymore?
          const signal = {
            type: 'offrz',
            view: 'box',
            action: 'click',
            target: 'close'
          };

          CliqzUtils.telemetry(signal);

          this.toolbarButton.hidePopup(this.window);
          if (this.window.PanelUI.panel.state === 'open') {
            this.window.PanelUI.showMainView();
            // TODO: we need to find smth similar to open overflow menu
          }
        }

        openURL(data) {
          if (data.isCallToAction) {
            const msg = {
              type: 'offer-action-signal',
              data: {
                offer_id: data.offerId,
                action_id: 'offer_ca_action'
              }
            };
            this.sendMessageToOffersCore(msg);
          }
          const tab = CliqzUtils.openLink(this.window, data.url, true);
          if (data.closePopup === true) {
            this.toolbarButton.hidePopup(this.window);
          }
          this.window.gBrowser.selectedTab = tab;
        }

        sendUserFeedback(data) {
          const feedback = _extends$12({
            view: 'box'
          }, data);

          CliqzUtils.sendUserFeedback(feedback);
        }
      }

      var offersCcModule = {
        Background: background$3,
        Window: Win$16
      };

      var logger$5 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[browser-panel]'
      });

      // /////////////////////////////////////////////////////////////////////////////
      // consts

      const MODULE_NAME$1 = 'bp-display-mngr';

      function lwarn$1(msg) {
        logger$5.log(`${MODULE_NAME$1} ${msg}`);
      }
      function lerr(msg) {
        logger$5.error(`${MODULE_NAME$1} ${msg}`);
      }

      class DisplayManager {
        constructor(uiConnectorCb) {
          // we will have 2 maps to control where to display what
          // elementID -> {urls: set(urls), data: eData}
          // url -> elementID
          this.elemToUrlsMap = {};
          this.urlToElemMap = {};
          this.browserPanel = inject.module('browser-panel');
          this.timersMap = {};
          this.uiConnectorCb = uiConnectorCb;
        }

        destroy() {}

        // ///////////////////////////////////////////////////////////////////////////
        //                                API
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * will add a element to be shown on the given url
         * @param  {[type]} eID   unique id to identify an element
         * @param  {[type]} eurl  exact url where we will display the element
         * @param  {[type]} eData data to be provided to the window for render the element.
         *                        if this is null we will not be updated
         * @return {[type]}       true on success | false otherwise
         */
        displayElement(eID, eUrl, eData) {
          if (!eID || !eUrl) {
            lwarn$1('displayElement: invalid args');
            return false;
          }

          // check if the url already exists, for now and simplicity we will skip
          // the event if already exists,
          if (this.urlToElemMap[eUrl]) {
            lwarn$1(`displayElement: we already have the url ${eUrl}, skipping this`);
            return false;
          }

          let elemCont = this.elemToUrlsMap[eID];
          if (!elemCont) {
            // we are displaying the element for the first time, we will emit an event
            // here notifying this.
            if (this.uiConnectorCb) {
              this.uiConnectorCb({
                handler: 'offers',
                data: {
                  origin: 'browser-panel',
                  type: 'offer-action-signal',
                  data: {
                    action_id: 'offer_dsp_session',
                    offer_id: eID
                  }
                }
              });
            }
            elemCont = { urls: new Set(), data: eData };
            this.elemToUrlsMap[eID] = elemCont;
          }
          elemCont.urls.add(eUrl);
          if (eData) {
            // update the edata
            elemCont.data = eData;
          }
          this.urlToElemMap[eUrl] = eID;

          // show the element in any of the current active tabs if any
          this._showOrHideElementOnActiveTabs();

          // check if we need to add a timer or not for this element
          if (eData.display_time_secs && !this._hasTimer(eID)) {
            this._addTimer(eID, eData.display_time_secs);
          }

          return true;
        }

        /**
         * remove the current element data and maps information
         * @param  {[type]} eID [description]
         * @return {[type]}     [description]
         */
        removeElement(eID) {
          let timedOut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (!eID) {
            return;
          }
          // we need to remove for all the urls the element
          const elemCont = this.elemToUrlsMap[eID];
          if (!elemCont) {
            return;
          }
          const self = this;
          elemCont.urls.forEach(u => {
            delete self.urlToElemMap[u];
          });
          delete this.elemToUrlsMap[eID];

          // remove the timer if we have one
          if (this._hasTimer(eID)) {
            this._removeTimer(eID);
          }

          if (timedOut && this.uiConnectorCb) {
            this.uiConnectorCb({
              handler: 'offers',
              data: {
                origin: 'browser-panel',
                type: 'offer-action-signal',
                data: {
                  action_id: 'offer_timeout',
                  offer_id: eID
                }
              }
            });
          }

          // update the current tab if we have to
          this._showOrHideElementOnActiveTabs();
        }

        onTabOrUrlChange() /* { url } */{
          // TODO: we can improve here the code and check if the current change
          // requires a change in the current tabs, for simplicity we will check
          // always if the current active tabs should or should not show something
          try {
            // we will do a small filtering here to avoid showing pages we don't want
            // resource://
            // about:
            // file://
            // if (url.startsWith('resource://') ||
            //     url.startsWith('about:') ||
            //     url.startsWith('resource://')) {
            //   // we should hide any offer on those places...
            // }
            this._showOrHideElementOnActiveTabs();
          } catch (e) {
            lerr(`onTabOrUrlChange: something bad happened here... ${e}`);
          }
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                          CALLBACKS / SIGNALS
        // ///////////////////////////////////////////////////////////////////////////


        // ///////////////////////////////////////////////////////////////////////////
        //                          PRIVATE METHODS
        // ///////////////////////////////////////////////////////////////////////////

        _showElement(win, eType, eData) {
          if (!win || !eData) {
            lwarn$1('_showElement: the win object or eData is null');
            return;
          }

          // communicate with the window sending the offer data
          const args = {
            type: eType,
            data: eData
          };
          this.browserPanel.windowAction(win, 'showElement', args);
        }

        _hideElement(win, eType, eData) {
          if (!win) {
            lwarn$1('_hideElement: the win object is null');
            return;
          }

          // this will just hide the current offer on the given tab
          const args = {
            type: eType,
            data: eData
          };
          this.browserPanel.windowAction(win, 'hideElement', args);
        }

        _hasTimer(elemID) {
          return elemID && this.timersMap[elemID];
        }

        _addTimer(elemID, secs) {
          if (!elemID || !secs || secs <= 0) {
            return;
          }
          const currentTimer = this.timersMap[elemID];
          if (currentTimer) {
            this._removeTimer(elemID);
          }
          this.timersMap[elemID] = CliqzUtils.setTimeout(() => {
            this.removeElement(elemID, true); // this will remove the timer
          }, secs * 1000);
        }

        _removeTimer(elemID) {
          if (!elemID) {
            return;
          }
          const currentTimer = this.timersMap[elemID];
          if (currentTimer) {
            CliqzUtils.clearInterval(currentTimer);
            delete this.timersMap[elemID];
          }
        }

        //
        // @brief This method will check if a particular offer should be shown in any
        //        of the current active tabs of all windows
        //
        _showOrHideElementOnActiveTabs() {
          // get all tabs active tabs from the windows
          const activeTabsInfo = [];
          try {
            forEachWindow(win => {
              const openTabs = queryActiveTabs(win);
              openTabs.forEach(data => {
                if (data.isCurrent) {
                  activeTabsInfo.push({ win, tab: data });
                }
              });
            });
          } catch (ee) {
            lerr(`_showOrHideElementOnActiveTabs: ${ee}`);
          }

          // show or hide on the given tabs
          const self = this;
          activeTabsInfo.forEach(tabInfo => {
            const currentURL = tabInfo.tab.url;
            const elementID = self.urlToElemMap[currentURL];
            if (!elementID) {
              // nothing to show => hide

              // TODO: here offerElement shold be inserted maybe on the element data
              // instead of hardcoded here, whenever we have more types we should improve
              // this
              self._hideElement(tabInfo.win, 'offerElement', {});
              return;
            }
            // we show the element here
            const elemData = self.elemToUrlsMap[elementID];
            if (!elemData) {
              lerr('_showOrHideElementOnActiveTabs: we have a url but not an element? this is wrong');
              return;
            }
            // TODO: here offerElement shold be inserted maybe on the element data
            // instead of hardcoded here, whenever we have more types we should improve
            // this
            self._showElement(tabInfo.win, 'offerElement', elemData.data);
          });
        }
      }

      const MODULE_NAME = 'browser-panel-bg';

      function linfo(msg) {
        CliqzUtils.log(`[info] ${msg}`, MODULE_NAME);
      }
      function lwarn(msg) {
        CliqzUtils.log(`[warning] ${msg}`, MODULE_NAME);
      }
      // function lerr(msg) {
      //   utils.log(MODULE_NAME, `[error] ${msg}`);
      // }

      /**
        @namespace browser-panel
        @module browser-panel
        @class Background
       */
      var background$4 = background({
        /**
          @method init
          @param settings
        */
        init() {
          this.is_enabled = CliqzUtils.getPref('offersBrowserPanelEnableSwitch', false);

          if (!this.is_enabled) {
            return;
          }

          this.actions = {
            windowUIConnector: this.windowUIConnector.bind(this)
          };
          if (this.is_enabled) {
            this.displayMngr = new DisplayManager(this.actions.windowUIConnector);
          }
        },

        unload() {
          if (!this.is_enabled) {
            return;
          }
          if (this.displayMngr) {
            delete this.displayMngr;
          }
        },

        beforeBrowserShutdown() {},

        /**
         * in this method we will process all the events coming from the ui
         * the layout of the message:
         * {
         *   handler: offers,
         *   data: {...}, // real data of the message
         * }
         * @return {[type]} [description]
         */
        displayCbHandler(msg) {
          if (!msg || !msg.handler) {
            lwarn('displayCbHandler: invalid msg format');
            return;
          }
          switch (msg.handler) {
            case 'offers':
              this.sendOffersMessage(msg.data);
              // check if the message is close we need to close it on the display manager
              if (msg.data && msg.data.type === 'offer-action-signal' && msg.data.data.action_id === 'offer_closed') {
                // close the offer / remove it
                if (this.displayMngr) {
                  this.displayMngr.removeElement(msg.data.data.offer_id);
                }
              }
              break;
            default:
              lwarn(`displayCbHandler: invalid handler: ${msg.handler}`);
              break;
          }
        },

        /**
         * this method will process the message coming from the offer module and
         * properly adapt it to the display manager. This method should be called from
         * the offers-send-ch callback or from the message-center
         * @param  {[type]} msg [description]
         * @return {[type]}     [description]
         */
        processOfferMessage(msg) {
          if (!msg.type || !msg.data) {
            lwarn(`processOfferMessage: invalid msg: ${msg}`);
            return;
          }
          // we will execute the proper action
          switch (msg.type) {
            case 'push-offer':
              {
                // check that the format is the proper
                if (!msg.data.offer_id || !msg.data.offer_data) {
                  lwarn('processOfferMessage: missing arguments');
                  return;
                }
                const offerID = msg.data.offer_id;
                const offerData = msg.data.offer_data;
                let displayUrls = null;
                let displayTimeSecs = null;
                if (msg.data.display_rule) {
                  displayUrls = msg.data.display_rule.url;
                  displayTimeSecs = msg.data.display_rule.display_time_secs;
                } else {
                  displayUrls = msg.data.offer_data.rule_info.url;
                  displayTimeSecs = msg.data.offer_data.rule_info.display_time_secs;
                }
                if (!displayUrls) {
                  lwarn('processOfferMessage: missing arguments on the msg?');
                  return;
                }
                // we add the offer for all the urls
                const self = this;
                const offerInfo = {
                  offer_id: offerID,
                  offer_data: offerData,
                  display_time_secs: displayTimeSecs
                };
                displayUrls.forEach(url => {
                  self.displayMngr.displayElement(offerID, url, offerInfo);
                });
              }
              break;
            case 'remove-offer':
              linfo(`processOfferMessage: removing offer: ${msg.data.offer_id}`);
              this.displayMngr.removeElement(msg.data.offer_id);
              break;
            default:
              linfo(`processOfferMessage: skipping msg type: ${msg.type}`);
              break;
          }
        },

        /**
         * we will send the offer signals on this method
         * @param  {[type]} msg [description]
         * @return {[type]}     [description]
         */
        sendOffersMessage(msg) {
          CliqzEvents.pub('offers-recv-ch', msg);
        },

        windowUIConnector(msg) {
          this.displayCbHandler(msg);
        },

        events: {
          'content:location-change': function onLocationChange(_ref) {
            let url = _ref.url;

            // linfo(`content:location-change: ${JSON.stringify(url)}`);
            if (this.displayMngr) {
              this.displayMngr.onTabOrUrlChange({ url });
            }
          },
          'core:tab_select': function onTabSelected(_ref2) {
            let url = _ref2.url;

            // linfo(`core:tab_select: ${JSON.stringify(url)}`);
            if (this.displayMngr) {
              this.displayMngr.onTabOrUrlChange({ url });
            }
          },

          // TODO: here we should later use the proper listener to get the events
          // from the message-center, we will do this in a second step after
          // we add the proper functionality on other commit
          'offers-send-ch': function onOfferMessage(msg) {
            if (!this.displayMngr) {
              // skip this message since it is not enabled
              return;
            }
            if (!msg || msg.dest && msg.dest.length && msg.dest.indexOf('browser-panel') < 0) {
              return;
            }
            // else we have the proper format we process it
            this.processOfferMessage(msg);
          }
        },

        actions: {}
      });

      const MODULE_NAME$2 = 'browser-panel-window';
      const ORIGIN_NAME$1 = 'browser-panel';
      const UI_IFRAME_WIDTH_DEF = '100%';
      const UI_IFRAME_HEIGHT_DEF = '101';
      const UI_IFRAME_ELEM_ID = 'cqz-b-p-iframe';
      const UI_IFRAME_SRC_DEF = `${config.baseURL}browser-panel/index.html`;

      function linfo$1(msg) {
        console$1.log(`[info] ${msg}`, MODULE_NAME$2);
      }
      function lwarn$2(msg) {
        console$1.log(`[warning] ${msg}`, MODULE_NAME$2);
      }
      // function lerr(msg) {
      //   console.log(MODULE_NAME, `[error] ${msg}`);
      // }

      class Win$17 {
        constructor(settings) {
          // check if we have the feature  enabled
          if (!background$4.is_enabled) {
            return;
          }

          this.window = settings.window;
          this.settings = settings.settings;
          this.coreModule = inject.module('browser-panel');

          this.iframeHandlers = {
            offersIFrameHandler: this.offersIFrameHandler.bind(this),
            openUrlHandler: this.openURL.bind(this)
          };

          // integration of the new ui system here
          this.showElementHandlers = {
            offerElement: this.showOfferElementHandler.bind(this)
          };
          this.hideElementHandlers = {
            offerElement: this.hideOfferElementHandler.bind(this)
          };

          this.actions = {
            showElement: this.showElement.bind(this),
            hideElement: this.hideElement.bind(this)
          };

          // actions we will execute coming from the iframe
          this.offersActions = {
            button_pressed: this.iframeButtonPressedAction.bind(this),
            get_last_data: this.getLastDataToShow.bind(this)
          };

          this.onIframeMessage = this.onIframeMessage.bind(this);
          this.lastDataToShow = null;
        }

        init() {
          if (!background$4.is_enabled) {
            return Promise.resolve();
          }

          this.isPrivateMode = CliqzUtils.isPrivateMode(this.window);
          if (this.isPrivateMode) {
            linfo$1('we are in private mode, avoid any logic here');
            return Promise.resolve();
          }
          return this.injectNotificationFrameIfNeeded(this.window.document);
        }

        unload() {
          if (this.iframe) {
            this.iframe.parentElement.removeChild(this.iframe);
            delete this.iframe;
          }
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                              new ui system
        // ///////////////////////////////////////////////////////////////////////////
        //

        hideIframe() {
          if (!this.iframe) {
            return;
          }
          this.iframe.style.width = '0';
          this.iframe.style.height = '0';
          this.iframe.style.border = 'none';

          // for safety we remove the id of the offer
          this.setOfferID('');
        }

        showIframe() {
          if (!this.iframe) {
            return;
          }
          this.iframe.style.height = `${UI_IFRAME_HEIGHT_DEF}px`;
          this.iframe.style.width = UI_IFRAME_WIDTH_DEF;
          this.resizePanel();

          const signal = {
            type: 'offrz',
            view: 'bar',
            action: 'show'
          };
          CliqzUtils.telemetry(signal);
        }

        //
        // @brief Inject the notification iframe wherever we should put it
        //
        injectNotificationFrameIfNeeded(doc) {
          let resolver;
          const promise = new Promise(resolve => {
            resolver = resolve;
          });
          // check if we have it already
          if (this.iframe) {
            // nothing to do
            return Promise.resolve();
          }
          // we inject the message container at browser window level
          const panel = doc.getElementById('browser-panel') || doc.getElementById('main-window');
          const contentDeck = doc.getElementById('content-deck');
          const iframe = doc.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');

          // remove iframe from previous version
          try {
            const oldIframe = doc.getElementById(UI_IFRAME_ELEM_ID, panel);
            if (oldIframe) {
              oldIframe.parentElement.removeChild(oldIframe);
            }
          } catch (e) {/* bummer */}

          function onIframeReady() {
            iframe.style.height = 0;
            iframe.style.width = UI_IFRAME_WIDTH_DEF;
            iframe.style.overflow = 'visible';
            iframe.style.position = 'relative';
            iframe.style.minHeight = '0';
            iframe.style.zIndex = '99999';
            iframe.contentWindow.addEventListener('message', this.onIframeMessage);
            resolver();
          }
          // set the cliqz offers iframe
          // TODO: avoid some hardcoded values here
          iframe.id = UI_IFRAME_ELEM_ID;
          iframe.src = UI_IFRAME_SRC_DEF;
          panel.insertBefore(iframe, contentDeck);

          iframe.addEventListener('load', onIframeReady.bind(this), true);
          this.iframe = iframe;

          // init all cases
          this.setOfferID('');

          // we start with the frame hidden
          this.hideIframe();
          return promise;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                           COMMUNICATION
        // ///////////////////////////////////////////////////////////////////////////

        sendDataToIframe(actionID, dataObj) {
          const message = { action: actionID, data: dataObj };
          this.iframe.contentWindow.postMessage(JSON.stringify({
            target: 'cqz-browser-panel-re',
            origin: 'window',
            message
          }), '*');
        }

        /**
         * method that will process the message coming from the iframe, it should contain
         * the following layout:
         * <pre>
         * {
         *   data: {
         *     target: 'cqz-browser-panel-re',
         *     origin: 'iframe',
         *     message: {
         *       handler: 'handler_id' (example: 'offersIFrameHandler')
         *       data: {
         *         // the real data for the handler here
         *       }
         *     }
         *   }
         * }
         * </pre>
         * @param  {[type]} event [description]
         * @return {[type]}       [description]
         */
        onIframeMessage(event) {
          const evtData = JSON.parse(event.data);
          if (evtData.target !== 'cqz-browser-panel-re' || evtData.origin !== 'iframe') {
            return;
          }
          const data = evtData.message;

          if (!data || !this.iframeHandlers[data.handler]) {
            // nothing to do
            lwarn$2(`onIframeMessage: invalid data?: ${JSON.stringify(evtData)}`);
            return;
          }

          // now process the action with the given arguments
          this.iframeHandlers[data.handler](data);
        }

        //
        // @brief method to send a message to the core ui manager
        //
        sendToCoreUIHandler(data) {
          this.coreModule.action('windowUIConnector', data);
        }

        /**
         * will show the proper element on the browser panel. The arguments should contain
         * the type of element to show
         * @param  {...[type]} args [description]
         * @return {[type]}         [description]
         */
        showElement() {
          if (arguments.length === 0) {
            return;
          }

          const elementInfo = arguments.length <= 0 ? undefined : arguments[0];
          if (!elementInfo.type || !elementInfo.data) {
            lwarn$2('showElement: Some of the fields are missing to render the element');
            return;
          }

          // we call the proper render method
          const showHandler = this.showElementHandlers[elementInfo.type];
          if (!showHandler) {
            lwarn$2(`showElement: we dont have a handler for ${elementInfo.type}`);
            return;
          }
          showHandler(elementInfo.data);
        }

        hideElement() {
          if (arguments.length === 0) {
            return;
          }

          const elementInfo = arguments.length <= 0 ? undefined : arguments[0];
          if (!elementInfo.type) {
            lwarn$2('hideElement: Some of the fields are missing to render the element');
            return;
          }

          const hideHandler = this.hideElementHandlers[elementInfo.type];
          if (!hideHandler) {
            lwarn$2(`hideElement: we dont have a handler for ${elementInfo.type}`);
            return;
          }

          hideHandler(elementInfo.data);
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                                OFFERS
        // ///////////////////////////////////////////////////////////////////////////

        sendOffersTemplateDataToIframe(templateName, templateData) {
          const data = {
            template_name: templateName,
            template_data: templateData
          };

          let titleColor;
          if (templateData.styles && templateData.styles.background) {
            titleColor = templateData.styles.background;
          } else {
            const url = templateData.call_to_action.url;
            const urlDetails = CliqzUtils.getDetailsFromUrl(url);
            const logoDetails = CliqzUtils.getLogoDetails(urlDetails);
            titleColor = `#${logoDetails.brandTxtColor}`;
          }
          data.template_data.titleColor = titleColor;
          this.sendDataToIframe('render_template', data);
        }

        setOfferID(offerID) {
          if (!this.iframe) {
            return false;
          }
          this.rootDocElem = this.iframe.contentDocument || this.iframe.contentWindow.document;
          // this.rootDocElem = this.window.document || this.window.contentWindow.document;
          this.rootDocElem = this.rootDocElem.getElementById('cqz-browser-panel-re');

          if (!this.rootDocElem) {
            return false;
          }

          this.rootDocElem.setAttribute('data-cliqzofferid', offerID);
          return true;
        }

        // return the current offer ID of the offer being displayed or null if not
        //
        getCurrentOfferID() {
          if (!this.iframe) {
            return null;
          }
          this.rootDocElem = this.iframe.contentDocument || this.iframe.contentWindow.document;
          // this.rootDocElem = this.window.document || this.window.contentWindow.document;
          this.rootDocElem = this.rootDocElem.getElementById('cqz-browser-panel-re');

          if (!this.rootDocElem) {
            return null;
          }
          const attrValue = this.rootDocElem.getAttribute('data-cliqzofferid');
          return attrValue === '' ? null : attrValue;
        }

        // Actions coming from the core

        showOfferElementHandler(aOfferData) {
          // if it is private do nothing
          if (this.isPrivateMode) {
            return;
          }

          if (!aOfferData.offer_id || !aOfferData.offer_data || !aOfferData.offer_data.ui_info || !aOfferData.offer_data.ui_info.template_name || !aOfferData.offer_data.ui_info.template_data) {
            lwarn$2('showOfferElementHandler: Some of the fields are missing to render the offer');
            return;
          }
          const offerData = aOfferData.offer_data;

          // store it for later usage
          this.lastDataToShow = aOfferData;

          const offerID = aOfferData.offer_id;
          const currentOfferID = this.getCurrentOfferID();

          // check if we want to update and/or trigger a signal
          if (currentOfferID === offerID) {
            // is the same, do nothing?
            return;
          }

          // set the current offer id
          this.setOfferID(offerID);
          this.sendOffersTemplateDataToIframe(offerData.ui_info.template_name, offerData.ui_info.template_data);
          this.showIframe();

          // TODO: if we could show properly and was not shown before, we need to notify
          // here that the offer was shown with the given id
          this.sendToCoreUIHandler({
            handler: 'offers',
            data: {
              origin: ORIGIN_NAME$1,
              type: 'offer-action-signal',
              data: {
                action_id: 'offer_shown',
                offer_id: offerID
              }
            }
          });
        }

        hideOfferElementHandler() {
          if (this.isPrivateMode) {
            return;
          }

          // delete old data
          if (this.lastDataToShow) {
            delete this.lastDataToShow;
            this.lastDataToShow = null;
          }

          const offerID = this.getCurrentOfferID();

          if (!offerID) {
            // nothing to do
            this.hideIframe();
            return;
          }

          this.hideIframe();
        }

        // Actions coming from the iframe

        iframeButtonPressedAction(data) {
          // we will build the proper data here depending on the signal we receive
          const msgData = {
            origin: ORIGIN_NAME$1,
            type: 'offer-action-signal',
            data: {
              // action_id: data.element_id,
              offer_id: data.offer_id
            }
          };
          // only for some cases we need to change the layout
          switch (data.element_id) {
            case 'remove-offer':
              msgData.type = data.element_id;
              break;
            case 'more_about_cliqz':
              msgData.type = 'action-signal';
              msgData.data.action_id = data.element_id;
              delete msgData.data.offer_id;
              break;
            default:
              // we add the action id
              msgData.data.action_id = data.element_id;
              break;
          }

          this.sendToCoreUIHandler({
            handler: 'offers',
            data: msgData
          });
        }

        resizePanel() {
          if (this.lastDataToShow) {
            const offerData = this.lastDataToShow.offer_data;
            const templateData = offerData.ui_info.template_data;
            if (!templateData.code) {
              const newHeight = parseInt(UI_IFRAME_HEIGHT_DEF, 10) - 17;
              this.iframe.style.height = `${newHeight}px`;
            }
          }
        }

        getLastDataToShow() /* data */{
          if (this.lastDataToShow) {
            const offerData = this.lastDataToShow.offer_data;
            const offerIDToSet = this.lastDataToShow.offer_id;
            // # GR-293
            this.injectNotificationFrameIfNeeded(this.window.document);
            // #EX-3655 check if the id is properly set
            this.setOfferID(offerIDToSet);
            this.sendOffersTemplateDataToIframe(offerData.ui_info.template_name, offerData.ui_info.template_data);
          }
        }

        /**
         * this method will be called whenever we get a message from the UI and is related
         * to offers
         * @param  {[type]} data [description]
         * {
         *   action: 'action name',
         *   data: {...}
         * }
         * @return {[type]}     [description]
         */
        offersIFrameHandler(data) {
          if (!data || !this.offersActions[data.action]) {
            // nothing to do
            lwarn$2(`offersMsgHandler: invalid data?: ${JSON.stringify(data)}`);
            return;
          }

          // now process the action with the given arguments
          this.offersActions[data.action](data.data);
          let target = data.data.element_id;
          switch (target) {
            case 'code_copied':
              target = 'copy_code';
              break;
            case 'offer_closed':
              target = 'remove';
              break;
            default:
              return;
          }
          const signal = {
            type: 'offrz',
            view: 'bar',
            action: 'click',
            target
          };
          CliqzUtils.telemetry(signal);
        }

        openURL(data) {
          if (!data || !data.data) {
            return;
          }
          const tab = CliqzUtils.openLink(this.window, data.data.url, true);
          this.window.gBrowser.selectedTab = tab;

          // Send telemetry for all call to action elements
          const elId = data.data.el_id;
          if (elId) {
            if (elId === 'offer_description' || elId === 'offer_ca_action' || elId === 'offer_title' || elId === 'offer_logo') {
              const signal = {
                type: 'offrz',
                view: 'bar',
                action: 'click',
                target: 'use'
              };
              CliqzUtils.telemetry(signal);
            }
          }
        }
      }

      var browserPanelModule = {
        Background: background$4,
        Window: Win$17
      };

      class CliqzMsgHandler {
        constructor() {
          this._messageQueue = [];
          // message id is key
          this._callbacks = {};
        }

        enqueueMessage(message, callback) {
          const messageAlready = this._messageQueue.some(msg => {
            return msg.id === message.id;
          });
          if (!messageAlready) {
            this._messageQueue.push(message);
            this._callbacks[message.id] = callback;
            if (this._messageQueue.length === 1) {
              this._renderMessage(message);
            }
          }
        }

        dequeueMessage(message) {
          var i = this._messageQueue.indexOf(message);

          // same message, different object reference
          if (i === -1) {
            const msg = this._messageQueue.find(item => item.id === message.id);
            if (msg) {
              message = msg;
              i = this._messageQueue.indexOf(message);
            }
          }

          if (i === 0) {
            this.showNextMessage();
          } else if (i > -1) {
            this._messageQueue.splice(i, 1);
            delete this._callbacks[message.id];
          }
        }

        showNextMessage() {
          var message = this._messageQueue.shift();
          if (message) {
            delete this._callbacks[message.id];
            this._hideMessage(message);
            if (this._messageQueue.length > 0) {
              this._renderMessage(this._messageQueue[0]);
            }
          }
        }

        _renderMessage() {
          throw '_renderMessage not implemented';
        }

        _hideMessage() {
          throw '_hideMessage not implemented';
        }
      }

      class CliqzMsgHandlerAlert extends CliqzMsgHandler {
        constructor() {
          super();
        }

        _renderMessage(message) {
          //TODO wait for window to open
          CliqzUtils.getWindow().alert(message.text);
          if (this._callbacks[message.id]) {
            this._callbacks[message.id](message.id, message.options && message.options.length > 0 && message.options[0].action);
          }
          this.showNextMessage();
        }

        _hideMessage(message) {}
      }

      class CliqzMsgHandlerDropdown extends CliqzMsgHandler {
        constructor() {
          super();
          CliqzEvents.sub('ui:dropdown_message_click', this._onClick.bind(this));
        }

        _renderMessage(message) {
          CliqzEvents.pub('msg_handler_dropdown:message_ready', this._convertMessage(message));
        }

        _hideMessage(message) {
          CliqzEvents.pub('msg_handler_dropdown:message_revoked', this._convertMessage(message));
        }

        _convertMessage(message) {
          return {
            'footer-message': {
              simple_message: message.text,
              type: 'cqz-message-survey',
              location: message.location,
              options: (message.options || []).map(function (el) {
                return {
                  text: el.label,
                  state: el.style,
                  action: el.action
                };
              })
            }
          };
        }

        _onClick(action) {
          var message = this._messageQueue[0];
          // not thread-safe: if current message is removed while it is showing,
          // the next message is used when invoking the callback
          if (message && this._callbacks[message.id]) {
            this._callbacks[message.id](message.id, action);
          }
        }
      }

      class CliqzMsgHandlerFreshTabTop extends CliqzMsgHandler {
        _renderMessage(message) {
          inject.module('freshtab').isReady().then(() => {
            CliqzEvents.pub('message-center:handlers-freshtab:new-message', message);
          });
        }

        _hideMessage(message) {
          CliqzEvents.pub('message-center:handlers-freshtab:clear-message', message);
        }
      }

      class CliqzMsgHandlerFreshTabMiddle extends CliqzMsgHandler {
        _renderMessage(message) {
          inject.module('freshtab').isReady().then(() => {
            CliqzEvents.pub('message-center:handlers-freshtab:new-message', message);
          }).catch(); // no freshtab, no problem
        }

        _hideMessage(message) {
          CliqzEvents.pub('message-center:handlers-freshtab:clear-message', message);
        }
      }

      var _Components = Components;
      const Cu$3 = _Components.utils;

      Cu$3.import('resource:///modules/UITour.jsm');

      /* ************************************************************************* */
      function _log$2(msg) {
        CliqzUtils.log(msg, 'CliqzMsgCenter');
      }
      /* ************************************************************************* */

      function CliqzMsgCenter() {
        this._messageHandlers = {};

        this.showMessage = this.showMessage.bind(this);
        this.hideMessage = this.hideMessage.bind(this);

        this.registerMessageHandler('MESSAGE_HANDLER_DROPDOWN', new CliqzMsgHandlerDropdown());
        this.registerMessageHandler('MESSAGE_HANDLER_ALERT', new CliqzMsgHandlerAlert());
        this.registerMessageHandler('MESSAGE_HANDLER_FRESHTAB_TOP', new CliqzMsgHandlerFreshTabTop());
        this.registerMessageHandler('MESSAGE_HANDLER_FRESHTAB_MIDDLE', new CliqzMsgHandlerFreshTabMiddle());
      }

      CliqzMsgCenter.prototype = {

        registerMessageHandler: function registerMessageHandler(id, handler) {
          this._messageHandlers[id] = handler;
        },

        getHandlers: function getHandlers() {
          return Object.keys(this._messageHandlers);
        },

        showMessage: function showMessage(message, handlerId, callback) {
          var handler = this._messageHandlers[handlerId];
          if (handler) {
            handler.enqueueMessage(message, callback);
          } else {
            _log$2('message handler not found: ' + handlerId);
          }
        },

        hideMessage: function hideMessage(message, handlerId) {
          var handler = this._messageHandlers[handlerId];
          if (handler) {
            handler.dequeueMessage(message);
          } else {
            _log$2('message handler not found: ' + handlerId);
          }
        }
      };

      CliqzMsgCenter.getInstance = function () {
        CliqzMsgCenter.getInstance.instance = CliqzMsgCenter.getInstance.instance || new CliqzMsgCenter();
        return CliqzMsgCenter.getInstance.instance;
      };

      const LOCAL_DATA = [{
        id: 'new-cliqz-tab',
        active: false,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab.app.middle-box.new-cliqz-tab-hdr'),
        description: CliqzUtils.getLocalizedString('freshtab.app.middle-box.new-cliqz-tab-desc'),
        icon: './images/settings-icon_blue.svg',
        cta_text: CliqzUtils.getLocalizedString('freshtab.app.middle-box.new-cliqz-tab-cta'),
        cta_url: 'home-action:settings',
        handler: 'MESSAGE_HANDLER_FRESHTAB_MIDDLE',
        position: 'middle'
      }, {
        id: 'blue-theme',
        active: false,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab.app.middle-box.blue-theme-hdr'),
        description: CliqzUtils.getLocalizedString('freshtab.app.middle-box.blue-theme-desc'),
        icon: './images/settings-icon_blue.svg',
        cta_text: CliqzUtils.getLocalizedString('freshtab.app.middle-box.blue-theme-cta'),
        cta_url: 'home-action:settings',
        handler: 'MESSAGE_HANDLER_FRESHTAB_MIDDLE',
        position: 'middle',
        rules: [{
          fn: 'cliqzVersionCheck',
          value: '1.16.0'
        }]
      }, {
        id: 'french-news',
        active: false,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab.app.middle-box.french-news-hdr'),
        description: CliqzUtils.getLocalizedString('freshtab.app.middle-box.french-news-desc'),
        icon: './images/settings-icon_blue.svg',
        cta_text: CliqzUtils.getLocalizedString('freshtab.app.middle-box.french-news-cta'),
        cta_url: 'home-action:settings&news',
        handler: 'MESSAGE_HANDLER_FRESHTAB_MIDDLE',
        position: 'middle',
        rules: [{
          fn: 'locale',
          value: 'fr'
        }, {
          fn: 'currentNewsLanguageIsNot',
          value: 'fr'
        }]
      }, {
        id: 'promote-mobile',
        active: true,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab.app.middle-box.promote-mobile-hdr'),
        description: CliqzUtils.getLocalizedString('freshtab.app.middle-box.promote-mobile-desc'),
        handler: 'MESSAGE_HANDLER_FRESHTAB_MIDDLE',
        position: 'middle',
        buttons: [{
          id: 'promote-apple',
          src: 'apple-badge.svg',
          class: 'apple-badge',
          link: {
            en: 'https://itunes.apple.com/us/app/cliqz-browser/id1065837334',
            de: 'https://itunes.apple.com/de/app/cliqz-browser-suchmaschine/id1065837334?mt=8'
          }
        }, {
          id: 'promote-android',
          src: 'android-badge.svg',
          class: 'android-badge',
          link: {
            en: 'https://play.google.com/store/apps/details?hl=en&id=com.cliqz.browser&referrer=utm_source%3Dcliqz%26utm_medium%3Dproduct%26utm_campaign%3Den%26cliqz_campaign%3Dmobile_en',
            de: 'https://play.google.com/store/apps/details?hl=de&id=com.cliqz.browser&referrer=utm_source%3Dcliqz%26utm_medium%3Dproduct%26utm_campaign%3Dde%26cliqz_campaign%3Dmobile_de'
          }
        }],
        rules: [{
          fn: 'cliqzVersionCheck',
          value: '1.16.0'
        }]
      }];

      function getLocalMessages() {
        return Promise.resolve(LOCAL_DATA);
      }

      function getRemoteMessages() {
        const resourceLoader = new ResourceLoader(['freshtab', 'remoteMessages.json'], {
          remoteURL: `${config.settings.CDN_BASEURL}/notifications/messages.json`,
          cron: 1000 * 60 * 60 * 12, // update every 12 hours
          updateInterval: 1000 * 60 * 5 // check for updates 5 minutes after the browser starts
        });
        return resourceLoader.load();
      }

      var _slicedToArray$16 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const DISMISSED_ALERTS$1 = 'dismissedAlerts';
      const FRESHTAB_CONFIG_PREF$2 = 'freshtabConfig';
      const VERSION$1 = 1;

      const messageFunctions = {
        cliqzVersionCheck(value) {
          return isCliqzBrowser && isCliqzAtLeastInVersion(value) || prefs.get('developer', false);
        },
        locale(value) {
          return value === CliqzUtils.PREFERRED_LANGUAGE;
        },
        currentNewsLanguageIsNot(value, message) {
          const ftConfig = JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF$2, '{}'));

          if (ftConfig.news && ftConfig.news.preferedCountry) {
            if (ftConfig.news.preferedCountry === value) {
              // if the expected language is already set we should never show this message
              // therefore we need to dismiss this message
              const dismissedAlerts = JSON.parse(prefs.get(DISMISSED_ALERTS$1, '{}'));
              dismissedAlerts[message.id] = { count: 1 };
              prefs.set(DISMISSED_ALERTS$1, JSON.stringify(dismissedAlerts));

              return false;
            }
          }

          return true;
        },
        isCurrentDate(aDate) {
          const today = CliqzUtils.getPref('config_ts', null);
          return aDate.indexOf(today) !== -1;
        }
      };

      function checkRulesForMessage(message) {
        const rules = message.rules || [];
        return rules.every(r => {
          if (!Object.prototype.hasOwnProperty.call(messageFunctions, r.fn)) {
            // we did not expect this function so drop out
            return false;
          }
          return messageFunctions[r.fn](r.value, message);
        });
      }

      class Triggers {
        constructor() {
          this.messageCenter = inject.module('message-center');
        }

        get messages() {
          return Promise.all([getLocalMessages(), getRemoteMessages()]).then(sources => sources.reduce((acc, cur) => acc.concat(cur), []));
        }

        get handlers() {
          return this.messageCenter.action('getHandlers');
        }

        init() {
          const dismissedAlerts = JSON.parse(prefs.get(DISMISSED_ALERTS$1, '{}'));
          Promise.all([this.handlers, this.messages]).then(_ref => {
            var _ref2 = _slicedToArray$16(_ref, 2);

            let handlers = _ref2[0],
                messages = _ref2[1];

            messages
            // filter only the active ones
            .filter(message => message.active)
            // make sure the message is supported in this version
            .filter(message => message.version <= VERSION$1)
            // check if the message was already dismissed
            .filter(message => (dismissedAlerts[message.id] || { count: 0 }).count === 0)
            // check the rules
            .filter(checkRulesForMessage).forEach(message => {
              const handler = message.handler;
              if (handlers.indexOf(handler) !== -1) {
                this.messageCenter.action('showMessage', handler, message);
              }
            });
          });
        }
      }

      /**
        @namespace message-center
        @module message-center
        @class Background
       */
      var Background$17 = background({

        /**
          @method init
          @param settings
        */
        init(settings) {
          this.messageCenter = CliqzMsgCenter.getInstance();
          new Triggers().init();
        },

        unload() {},

        beforeBrowserShutdown() {},

        events: {
          'msg_center:show_message': function msg_centerShow_message() {
            this.messageCenter.showMessage.apply(this.messageCenter, arguments);
          },
          'msg_center:hide_message': function msg_centerHide_message() {
            this.messageCenter.hideMessage.apply(this.messageCenter, arguments);
          }
        },

        actions: {
          registerMessageHandler(id, handler) {
            class NewMessageHandler extends CliqzMsgHandler {
              _renderMessage(message) {
                handler(message);
              }

              _hideMessage(message) {
                // TODO
              }
            }
            this.messageCenter.registerMessageHandler(id, new NewMessageHandler());
          },
          getHandlers() {
            return this.messageCenter.getHandlers();
          },
          showMessage(handler, message) {
            this.messageCenter.showMessage(message, handler);
          },
          hideMessage(handlerID, message) {
            this.messageCenter.hideMessage(message, handlerID);
          }
        }
      });

      class Win$18 {
        constructor(settings) {}

        init() {}

        unload() {}
      }

      var messageCenterModule = {
        Background: Background$17,
        Window: Win$18
      };

      var Background$18 = {
        init() {},
        unload() {}
      };

      class Win$19 {
        constructor(_ref) {
          let window = _ref.window,
              settings = _ref.settings;

          this.settings = settings;
          this.window = window;
          this.coreCliqz = inject.module('core-cliqz');

          // in case the extension runs in the Cliqz browser we could get fake uninstall
          // signals from the system addon updater so we must remove any offboarding page
          // see https://bugzilla.mozilla.org/show_bug.cgi?id=1351617
          if (settings.channel === '40') {
            const offboardingURL = ['https://cliqz.com/home/offboarding', // == utils.UNINSTALL
            'https://cliqz.com/offboarding', 'https://cliqz.com/en/offboarding', 'https://cliqz.com/fr/offboarding'];
            forEachWindow(win => {
              win.gBrowser.tabs.forEach(tab => {
                if (offboardingURL.indexOf(tab.linkedBrowser.currentURI.spec) !== -1) {
                  win.gBrowser.removeTab(tab);
                }
              });
            });
          }
        }
        init() {}
        unload() {}
        disable() {
          const version = this.settings.version;
          const window = this.window;
          if (window === CliqzUtils.getWindow()) {
            this.coreCliqz.action('setSupportInfo', 'disabled');
            try {
              const UNINSTALL_PREF = 'uninstallVersion';
              const lastUninstallVersion = CliqzUtils.getPref(UNINSTALL_PREF, '');

              if (version && lastUninstallVersion !== version) {
                CliqzUtils.setPref(UNINSTALL_PREF, version);
                CliqzUtils.openLink(window, CliqzUtils.UNINSTALL, true, // newTab
                false, // newWindow
                false, // newPrivateWindow
                true); // focus
              }
            } catch (e) {
              // Nothing
            }
          }
        }
      }

      var offboardingModule = {
        Background: Background$18,
        Window: Win$19
      };

      var _extends$13 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function generateFromType(selectors) {
        return aggregation => {
          const signals = [];

          (typeof selectors === 'string' ? [selectors] : selectors).forEach(selector => {
            if (aggregation.types[selector] !== undefined) {
              signals.push(_extends$13({
                type: selector
              }, aggregation.types[selector]));
            }
          });

          return signals;
        };
      }

      function hardenSchema(schema) {
        return _extends$13({
          additionalProperties: false,
          required: Object.keys(schema.properties || {})
        }, schema);
      }

      const statsStringSchema = {
        additionalProperties: false,
        required: ['count', 'categories'],
        properties: {
          count: { type: 'number' },
          categories: {
            type: 'object'
            // TODO: Make use of `enum` field to list all possible categories
            // If available.
          }
        }
      };

      const statsNumberSchema = {
        additionalProperties: false,
        required: ['numbers', 'nulls'],
        properties: {
          numbers: {
            additionalProperties: false,
            required: ['count', 'mean', 'median', 'stdev', 'min', 'max'],
            properties: {
              count: { type: 'number' },
              mean: { type: 'number' },
              median: { type: 'number' },
              stdev: { type: 'number' },
              min: { type: 'number' },
              max: { type: 'number' }
            }
          },
          nulls: {
            additionalProperties: false,
            required: ['count'],
            properties: {
              count: { type: 'number' }
            }
          }
        }
      };

      function aggregationSchema(schema) {
        const keys = {};
        Object.keys(schema.properties).forEach(k => {
          if (k === 'type') {
            return;
          }

          const value = schema.properties[k];
          if (value.type === 'number') {
            keys[k] = statsNumberSchema;
          } else if (value.type === 'string') {
            // TODO: it would be nice to enforce the presence of `enum` for string
            // types. Which means you would need to specify the set of all possible
            // values in the schema. That would allow to make sure privacy is
            // preserved.
            keys[k] = statsStringSchema;
          } else {
            throw new Error(`Only numbers and strings are allowed in schemas: ${JSON.stringify(schema)}`);
          }
        });

        return {
          additionalProperties: false,
          required: ['count', 'keys'],
          properties: {
            type: { type: 'string' },
            count: { type: 'number' },
            keys: {
              additionalProperties: false,
              required: Object.keys(keys),
              properties: keys
            }
          }
        };
      }

      /**
       * Given a valid schema, create a new schema corresponding to the signals
       * automatically generated from the aggregation of the original signals.
       */
      function aggregate(name, _ref) {
        let schema = _ref.schema,
            needsGid = _ref.needsGid,
            generate = _ref.generate;

        return {
          _source_schema: hardenSchema(schema),
          generate: generate || generateFromType(name),
          instantPush: false,
          needsGid: needsGid || false,
          schema: aggregationSchema(schema)
        };
      }

      function loadSchemas(schemas) {
        const result = {};

        Object.keys(schemas).forEach(name => {
          const schema = schemas[name].schema;

          // Compile schema validator
          // TODO: Could be done lazily

          const ajv = new Ajv();
          const validate = ajv.compile(hardenSchema(schema));

          result[name] = Object.freeze(_extends$13({
            needsGid: false, // Default to not sending a GID with signals
            instantPush: false }, schemas[name], {
            name,
            validate
          }));
        });

        return result;
      }

      /* eslint-disable camelcase */
      var cliqztabSettings = function () {
        // keys ('background', 'historyDials', ...) don't exist by default
        var _JSON$parse = JSON.parse(prefs.get('freshtabConfig', '{}')),
            _JSON$parse$backgroun = _JSON$parse.background;

        _JSON$parse$backgroun = _JSON$parse$backgroun === undefined ? {} : _JSON$parse$backgroun;
        const backgroundImage = _JSON$parse$backgroun.image;
        var _JSON$parse$historyDi = _JSON$parse.historyDials;
        _JSON$parse$historyDi = _JSON$parse$historyDi === undefined ? {} : _JSON$parse$historyDi;
        const is_most_visited_on = _JSON$parse$historyDi.visible;
        var _JSON$parse$customDia = _JSON$parse.customDials;
        _JSON$parse$customDia = _JSON$parse$customDia === undefined ? {} : _JSON$parse$customDia;
        const is_favorites_on = _JSON$parse$customDia.visible;
        var _JSON$parse$search = _JSON$parse.search;
        _JSON$parse$search = _JSON$parse$search === undefined ? {} : _JSON$parse$search;
        const is_search_on = _JSON$parse$search.visible;
        var _JSON$parse$news = _JSON$parse.news;
        _JSON$parse$news = _JSON$parse$news === undefined ? {} : _JSON$parse$news;
        const is_news_on = _JSON$parse$news.visible;

        return [{
          // 'freshtab.blueTheme.enabled is set to `true` by default on Cliqz browser
          is_theme_on: prefs.get('freshtab.blueTheme.enabled', false),
          // background image is on by default, but 'image' is not set in prefs;
          // if the user switches the image off, 'image' is set to 'bg-default'
          is_background_on: !backgroundImage || backgroundImage !== 'bg-default',
          is_most_visited_on: Boolean(is_most_visited_on),
          is_favorites_on: Boolean(is_favorites_on),
          is_search_on: Boolean(is_search_on),
          is_news_on: Boolean(is_news_on)
        }];
      };

      var cliqztabState = function () {
        return [{
          is_cliqztab_on: prefs.get('freshtab.state', false)
        }];
      };

      /**
       * Custom signal generators. A signal generator is a function taking as argument
       * a daily aggregation of all other signals, and returning a list of signals to
       * be sent through Anolysis. They can be used as value of the `generate`
       * attribute of a schema.
       */
      /**
       * This file contains definition for all telemetry signals sent through Anolysis
       * from Cliqz browsers to our backend. All signals need to specify some
       * information, and can be customized in some aspects.
       *
       * Having the schemas centralized allows for a few things:
       * - It is easier to know, at any point of time, what data is sent from Cliqz.
       * - Schemas allow to automatically check that sent signals are valid.
       * - Each schema *must* be decorated with documentation to explain the intent.
       *
       * The minimum amount of information needed to define a new schema is:
       * - `schema`, which specifies the shape of the signal to be sent.
       *
       * Optional attributes:
       * - `needsGid` [default: false], specifies if the GID should be sent as well.
       * - `instantPush` [default: false], if `true` the signal will be sent as is to
       *   our backend. Otherwise, it is first stored for one day, then aggregated
       *   with all other signals of the same type; the aggregation is then used to
       *   generate one or more new signals containing only statistics.
       * - `generate` [default: generateFromType], function used to generate signals
       *   from a daily aggregation. By default, all statistics are sent as is, but
       *   you can customize the kind of signals you want to generate from the
       *   aggregation by providing a custom function.
       *
       * Please note that default values are very conservative (on purpose) and
       * designed to default to maximum privacy.
       *
       * In addition, we provide a decorator to make the addition of aggregated
       * signals as easy as possible: `aggregate`. The function takes as argument a
       * name as well as a valid schema, and generate a new schema corresponding to
       * the aggregation of the original schema.
       *
       * You can read: `aggregate(name, my_schema)` as:
       * - Aggregate all signals of type `name` for one day.
       * - At the end of the day, aggregate them.
       * - Send one aggregated signal to our backend.
       *
       * Last but not least, when you add a new schema which generates signals based
       * on some aggregated data *or* has a custom `generate` function, please add it
       * to the list of tested schema in the file:
       *  `anolysis/tests/unit/telemetry-schemas-test.es`.
       */

      const SCHEMAS = {
        // This telemetry signal is created by the abtests analysis.
        // It sends each AB test of the user atomically in a signal.
        abtests: {
          needsGid: true,
          instantPush: true,
          schema: {
            properties: {
              abtest: {
                type: 'string'
              }
            }
          }
        },

        // Sends no data, but pings once a day the backend along with the GID.
        ping: {
          needsGid: true,
          instantPush: true,
          schema: {}
        },

        // Retention signals: daily, weekly and monthly
        retention_daily: {
          needsGid: true,
          instantPush: true,
          schema: {
            properties: {
              units_active: {
                type: 'number' // 0 for inactive, 1 for active
              },
              offset: {
                type: 'number'
              }
            }
          }
        },

        retention_weekly: {
          needsGid: true,
          instantPush: true,
          schema: {
            properties: {
              units_active: { type: 'number' },
              offset: { type: 'number' }
            }
          }
        },

        retention_monthly: {
          needsGid: true,
          instantPush: true,
          schema: {
            properties: {
              units_active: { type: 'number' },
              offset: { type: 'number' }
            }
          }
        },

        // Abstraction of result_enter and result_click signals
        result_selection: aggregate('result_selection', {
          needsGid: true,
          instantPush: true,
          generate: generateFromType(['result_selection_autocomplete', 'result_selection_click', 'result_selection_enter', 'result_selection_query', 'result_selection_url']),
          schema: {
            properties: {
              type: {
                type: 'string',
                enum: ['result_selection_autocomplete', 'result_selection_click', 'result_selection_enter', 'result_selection_query', 'result_selection_url']
              },
              current_position: { type: 'string', minimum: 0 },
              query_length: { type: 'number', minimum: 0 },
              reaction_time: { type: 'number', minimum: 0 },
              display_time: { type: 'number', minimum: 0 },
              urlbar_time: { type: 'number', minimum: 0 }
            }
          }
        }),

        cliqztab_state: {
          needsGid: true,
          instantPush: true,
          generate: cliqztabState,
          schema: {
            properties: {
              is_cliqztab_on: { type: 'boolean' }
            }
          }
        },

        cliqztab_settings: {
          needsGid: false,
          instantPush: true,
          generate: cliqztabSettings,
          schema: {
            properties: {
              is_theme_on: { type: 'boolean' },
              is_background_on: { type: 'boolean' },
              is_most_visited_on: { type: 'boolean' },
              is_favorites_on: { type: 'boolean' },
              is_search_on: { type: 'boolean' },
              is_news_on: { type: 'boolean' }
            }
          }
        },

        // mobile telemetry
        // TODO: align with desktop
        // TODO: move to platform
        // TODO: at the moment only `number` and `string` types are allowed in
        // aggregated signals. We need to think about if it's safe to allow others as
        // well.
        // mobile_result_selection: aggregate('mobile_result_selection', {
        //   needsGid: true,
        //   schema: {
        //     properties: {
        //       current_position: { type: 'number' }, // result card index (zero based)
        //       position_type: {
        //         type: 'array',
        //         items: { type: 'string' },
        //       }, // result type
        //       tap_position: {
        //         type: 'array',
        //         items: { type: 'number' },
        //       }, // [number] x, y position of the tap
        //     },
        //   },
        // }),

        // mobile_swipe: aggregate('mobile_swipe', {
        //   needsGid: true,
        //   schema: {
        //     properties: {
        //       swipe_direction: {
        //         type: 'string',
        //         enum: ['left', 'right'],
        //       },
        //       index: { type: 'number' }, // card index (zero based)
        //       show_duration: { type: 'number' }, // duration since last card was shown
        //       card_count: { type: 'number' }, // visible cards count (including search engine card)
        //       position_type: {
        //         type: 'array',
        //         items: { type: 'string' },
        //       }, // result type
        //     },
        //   },
        // }),

        mobile_results_rendered: aggregate('mobile_results_rendered', {
          needsGid: true,
          schema: {
            properties: {
              result_count: { type: 'number' // number of results
              } }
          }
        })
      };

      var telemetrySchemas = loadSchemas(SCHEMAS);

      var Stats = lazyLoader('simple-statistics.min.js', 'ss');

      var logger$6 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[anolysis]'
      });

      class Aggregator {
        constructor() {
          let keyBlackList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['id', 'ts', 'session', 'seq', '_id', '_rev'];

          this.keyBlacklist = new Set(keyBlackList);
        }

        aggregate(data) {
          const aggregation = {
            empty: data.size === 0 || ![...data.values()].some(v => v.length !== 0),
            types: {}
          };

          data.forEach((records, type) => {
            const keys = this.getAllKeys(records, this.keyBlacklist);

            aggregation.types[type] = { count: records.length, keys: {} };
            keys.forEach(key => {
              const series = this.getValuesForKey(records, key);
              if (this.isIntervalSeries(series)) {
                aggregation.types[type].keys[key] = this.describeIntervalSeries(series);
              } else {
                aggregation.types[type].keys[key] = this.describeCategoricalSeries(series);
              }
            });
          });

          return aggregation;
        }

        // ----------------------------------------------------------------------- //
        // Private API - Kept in the class for unit tests
        // ----------------------------------------------------------------------- //

        getAllKeys(objects, blacklist) {
          const keys = new Set();
          for (let i = 0; i < objects.length; i += 1) {
            Object.keys(objects[i]).forEach(key => {
              if (!blacklist.has(key)) {
                keys.add(key);
              }
            });
          }
          return keys;
        }

        getValuesForKey(objects, key) {
          return objects.filter(o => Object.prototype.hasOwnProperty.call(o, key)).map(o => o[key]);
        }

        isIntervalSeries(series) {
          return series.every(e => e === null || typeof e === 'number');
        }

        countOccurences(array) {
          /* eslint no-param-reassign: off */
          return array.reduce((counts, value) => {
            counts[value] = (counts[value] || 0) + 1;
            return counts;
          }, {});
        }

        describeCategoricalSeries(series) {
          return {
            count: series.length,
            categories: this.countOccurences(series)
          };
        }

        // TODO: add histogram
        describeIntervalSeries(series) {
          const numbers = [];
          let nullCount = 0;

          series.forEach(value => {
            if (typeof value === 'number') {
              numbers.push(value);
            } else if (value === null) {
              nullCount += 1;
            }
          });

          const safeAggregation = fn => {
            try {
              // simple-statistics can throw exceptions if the input is not valid.
              return fn(numbers);
            } catch (ex) {
              logger$6.debug('Exception while trying to aggregate', fn, numbers, ex);
              return null;
            }
          };

          return {
            numbers: {
              count: numbers.length,
              mean: safeAggregation(ns => Stats.mean(ns)),
              median: safeAggregation(ns => Stats.median(ns)),
              stdev: safeAggregation(ns => Stats.standardDeviation(ns)),
              min: safeAggregation(ns => Stats.min(ns)),
              max: safeAggregation(ns => Stats.max(ns))
            },
            nulls: {
              count: nullCount
            }
          };
        }
      }

      var UAParser = lazyLoader('ua-parser.min.js', 'UAParser');

      function getUserAgent() {
        return getWindowAPIAsync().then(win => win.navigator.userAgent);
      }

      function getDistribution() {
        return Promise.resolve(getPref('distribution', ''));
      }

      function getInstallDate() {
        return Promise.resolve(getPref('install_date', ''));
      }

      function getChannel() {
        return Promise.resolve(config.settings.channel);
      }

      function getSynchronizedDate() {
        const formatted = prefs.get('config_ts', null);
        if (formatted !== null) {
          const year = formatted.substr(0, 4);
          const month = formatted.substr(4, 2);
          const day = formatted.substr(6, 2);
          return moment(`${year}-${month}-${day}`, 'YYYY-MM-DD');
        }

        return null;
      }

      var _slicedToArray$18 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const logger$7 = Logger({
        level: 'log',
        prefix: '[demographics]'
      });

      const ARCHITECTURE = new Set(['amd64', 'i386', 'x86_64']);

      const BSD_OS = new Set(['FreeBSD', 'NetBSD', 'OpenBSD', 'DragonFly']);

      const LINUX_OS = new Set(['Arch', 'CentOS', 'Fedora', 'Debian', 'Gentoo', 'GNU', 'Mageia', 'Mandriva', 'Mint', 'RedHat', 'Slackware', 'SUSE', 'Ubuntu', 'VectorLinux']);

      const CHANNELS = {
        CHIP: new Set(['01', '02', '06', '07', '08', '20', '21', '22']),
        MOBILE: new Set(['MA00', 'MA02', 'MA10', 'MA12', 'MI00', 'MI01', 'MI02']),
        CLIQZ: new Set(['00', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '40']),
        COMPUTER_BILD: new Set(['23']),
        FACEBOOK: new Set(['30']),
        AMO: new Set(['04']),
        SOFTRONIC: new Set(['03']),
        FOCUS: new Set([]),
        APP_STORE: new Set(['MI00']),
        PLAY_STORE: new Set(['MA00'])
      };

      function isString(value) {
        return typeof value === 'string' || value instanceof String;
      }

      // TODO: define 'campaign'
      function parseDemographics(signal) {
        const uaParser = new UAParser();
        logger$7.debug('parse demographics');
        const channel = signal.channel;

        // ---------------------------------------------------------------------- //
        // Parse distribution
        // ---------------------------------------------------------------------- //
        let distribution = `Other/c=${channel || ''} d=${signal.distribution || ''}`;
        if (signal.distribution !== undefined && isString(signal.distribution)) {
          const rawDistribution = signal.distribution;

          // TODO: Use brands.json to generate/update this data
          // TODO: Make this implementation nicer by using a loop and extraction the
          // data about each distribution separately.
          if (CHANNELS.COMPUTER_BILD.has(channel) || channel === '40' && rawDistribution.startsWith('CB0')) {
            // TODO: Check interval CB0001
            distribution = 'third-party/portal/ComputerBild';
          } else if (CHANNELS.CHIP.has(channel) || channel === '40' && rawDistribution.startsWith('C0')) {
            // TODO: Check interval: C0001-C0022
            distribution = 'third-party/portal/Chip';
          } else if (CHANNELS.FOCUS.has(channel) || channel === '40' && rawDistribution.startsWith('F0')) {
            // TODO: Check interval: F0001-F0009
            distribution = 'third-party/portal/Focus';
          } else if (channel === '40' && rawDistribution.startsWith('BU0')) {
            // TODO: Check interval: BU0001-BU0003
            distribution = 'third-party/portal/BrowserUpdate';
          } else if (channel === '40' && rawDistribution.startsWith('TW0')) {
            // TODO: Check interval: TW0001-TW0020
            distribution = 'third-party/portal/Twitter';
          } else if (channel === '40' && rawDistribution.startsWith('AP0')) {
            // TODO: Check interval: AP0001
            distribution = 'third-party/portal/Androidpit';
          } else if (channel === '40' && rawDistribution.startsWith('TN0')) {
            // TODO: Check interval: TN0001-TN0002
            distribution = 'third-party/portal/T3N';
          } else if (channel === '40' && rawDistribution.startsWith('XI0')) {
            // TODO: Check interval: XI0001-XI0002
            distribution = 'third-party/portal/Xing';
          } else if (channel === '40' && rawDistribution.startsWith('BI0')) {
            // TODO: Check interval: BI0001-BI0040
            distribution = 'third-party/portal/Bing';
          } else if (channel === '40' && rawDistribution.startsWith('Y0')) {
            // TODO: Check interval: Y0001-Y0020
            distribution = 'third-party/portal/Yahoo';
          } else if (channel === '40' && rawDistribution.startsWith('GA0')) {
            // TODO: Check interval: GA0001-GA0120
            distribution = 'third-party/portal/Google_AdWords';
          } else if (channel === '40' && rawDistribution.startsWith('FB0')) {
            // TODO: Check interval: FB0001-FB0055
            distribution = 'third-party/portal/Facebook';
          } else if (channel === '40' && rawDistribution.startsWith('MS0')) {
            // TODO: Check interval: MS0001-MS0002
            distribution = 'third-party/portal/Meinestadt';
          } else if (channel === '40' && rawDistribution.startsWith('HA0')) {
            // TODO: Check interval: HA0001-HA0002
            distribution = 'third-party/portal/Heise';
          } else if (channel === '40' && rawDistribution.startsWith('MSI0')) {
            // TODO: What is the interval here?
            distribution = 'third-party/portal/MSI_Installer';
          } else if (CHANNELS.SOFTRONIC.has(channel)) {
            distribution = 'third-party/portal/Softonic';

            // CLIQZ
          } else if (rawDistribution.startsWith('web0001')) {
            distribution = 'CLIQZ/website';
          } else if (rawDistribution.startsWith('web01')) {
            distribution = 'CLIQZ/website (old)';
          } else if (rawDistribution.startsWith('cliqz')) {
            distribution = 'CLIQZ/testing';

            // third-party/app store
          } else if (rawDistribution === '' && CHANNELS.AMO.has(channel)) {
            distribution = 'third-party/app store/AMO';
          } else if (CHANNELS.PLAY_STORE.has(channel)) {
            distribution = 'third-party/app store/PlayStore';
          } else if (rawDistribution === '' && CHANNELS.APP_STORE.has(channel)) {
            distribution = 'third-party/app store/AppStore';
          }
        }

        logger$7.debug(`distribution ${JSON.stringify(distribution)}`);

        // ---------------------------------------------------------------------- //
        // Parse installDate
        // ---------------------------------------------------------------------- //
        let installDate = `Other/${signal.install_date || ''}`;
        if (signal.install_date) {
          const installDateMs = signal.install_date * 86400000;
          const momentInstallDate = moment(installDateMs);
          // This date format is expected by the gid backend. '/' is used as a
          // separator to split demographics into sub-trees. Do not use another
          // format there.
          installDate = momentInstallDate.format('YYYY/MM/DD');
          const currentDate = getSynchronizedDate();
          if (signal.install_date < 16129 || momentInstallDate.isAfter(currentDate, 'day')) {
            // Some install date are not possible and should be considered as
            // outlier:
            // - In the past (before Cliqz existed)
            // - In the future
            installDate = `Other/${installDate}`;
          }
        }
        logger$7.debug(`installDate ${JSON.stringify(installDate)}`);

        // ---------------------------------------------------------------------- //
        // Parse platform
        // ---------------------------------------------------------------------- //
        let platform = `Other/${signal.agent}`;
        if (signal.agent === 'ios') {
          platform = 'Mobile/iOS';
        } else if (signal.agent === 'android') {
          platform = 'Mobile/Android';
        } else if (signal.agent) {
          uaParser.setUA(signal.agent);

          // Possible osFamily:
          // AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, CentOS, Chromium OS, Contiki,
          // Fedora, Firefox OS, FreeBSD, Debian, DragonFly, Gentoo, GNU, Haiku, Hurd, iOS,
          // Joli, Linpus, Linux, Mac OS, Mageia, Mandriva, MeeGo, Minix, Mint, Morph OS, NetBSD,
          // Nintendo, OpenBSD, OpenVMS, OS/2, Palm, PCLinuxOS, Plan9, Playstation, QNX, RedHat,
          // RIM Tablet OS, RISC OS, Sailfish, Series40, Slackware, Solaris, SUSE, Symbian, Tizen,
          // Ubuntu, UNIX, VectorLinux, WebOS, Windows [Phone/Mobile], Zenwalk

          var _uaParser$getOS = uaParser.getOS();

          const osName = _uaParser$getOS.name,
                osVersion = _uaParser$getOS.version;

          // Indicate if we should append osVersion to platform

          let shouldAppendVersion = false;

          if (osName === 'Windows') {
            platform = 'Desktop/Windows';
            shouldAppendVersion = true;
          } else if (osName === 'Mac OS') {
            platform = 'Desktop/Mac OS';
            shouldAppendVersion = true;
          } else if (BSD_OS.has(osName)) {
            platform = `Desktop/BSD/${osName}`;
          } else if (osName === 'Linux' || osName === 'linux') {
            platform = 'Desktop/Linux';
          } else if (LINUX_OS.has(osName)) {
            platform = `Desktop/Linux/${osName}`;
            shouldAppendVersion = true;
          } else if (osName === 'Android') {
            platform = 'Mobile/Android';
            shouldAppendVersion = true;
          } else if (osName === 'iOS') {
            platform = 'Mobile/iOS';
            shouldAppendVersion = true;
          } else if (osName !== undefined) {
            platform = `Other/${osName}`;
          }

          // Ignore architecture and truncate version if needed
          if (shouldAppendVersion && !ARCHITECTURE.has(osVersion) && osVersion !== undefined) {
            // Only keep first part of the version by splitting on first space
            // eg: 10.6 Leopard, we are only interested in 10.6 here.
            let splittedVersion;
            if (osVersion.indexOf(' ') !== -1) {
              splittedVersion = osVersion.split(' ', 1)[0].split('.');
            } else {
              splittedVersion = osVersion.split('.');
            }

            if (splittedVersion.length > 2) {
              splittedVersion = splittedVersion.slice(0, 2);
            }

            platform = `${platform}/${splittedVersion.join('.').trim()}`;
          }
        }
        logger$7.debug(`platform ${JSON.stringify(platform)}`);

        // ---------------------------------------------------------------------- //
        // Parse product
        // ---------------------------------------------------------------------- //
        let product = `Other/${channel || ''}`; // Default value
        try {
          // Try to convert channel to an int
          // channel < 40 is extension.
          let intChannel = null;
          try {
            intChannel = Number(channel);
          } catch (ex) {}
          /* Ignore if the channel is not an integer */

          // TODO: Should we create a set of possible values at the top of the file?
          if (channel === '40') {
            const prefix = 'CLIQZ/desktop';
            // Desktop browser
            if (platform.includes('Windows')) {
              product = `${prefix}/Cliqz for Windows`;
            } else if (platform.includes('Mac')) {
              product = `${prefix}/Cliqz for Mac OS`;
            } else {
              product = `${prefix}/Cliqz for Linux`;
            }
          } else if (intChannel !== null && intChannel < 40) {
            // Navigation extension
            product = 'CLIQZ/add-on/Cliqz for Firefox';
          } else if (CHANNELS.PLAY_STORE.has(channel)) {
            product = 'CLIQZ/mobile/Cliqz for Android';
          } else if (CHANNELS.APP_STORE.has(channel)) {
            product = 'CLIQZ/mobile/Cliqz for iOS';
          } else if (channel === 'CH50') {
            product = 'third-party/desktop/Avira Scout';
          } else if (channel === 'MA10') {
            product = 'third-party/mobile/Telefonica';
          }

          logger$7.debug(`product ${JSON.stringify(product)}`);
        } catch (ex) {
          /* Wrong data for product */
          logger$7.error(`exception ${ex} ${ex.stack}`);
        }

        // ---------------------------------------------------------------------- //
        // Parse campaign
        // ---------------------------------------------------------------------- //
        // TODO: This factor is not yet clearly defined.

        return {
          // NOTE: AB Tests will be sent separately, and should not be
          // part of the GID of a user. The reason is that the combinations
          // are most of the time unique (or with low cardinality), and will
          // be discarded by the safe reporting algorithm.
          // abtests,
          distribution,
          install_date: installDate,
          platform,
          product
        };
      }

      /**
       * Returns the demographics of a user in a cross-platform way, in a format that
       * is expected and understood by modules such as `anolysis` and `abtests`.
       */
      function getDemographics() {
        return Promise.all([getChannel(), getUserAgent(), getDistribution(), getInstallDate()]).then(_ref => {
          var _ref2 = _slicedToArray$18(_ref, 4);

          let channel = _ref2[0],
              userAgent = _ref2[1],
              distribution = _ref2[2],
              installDate = _ref2[3];
          return parseDemographics({
            channel,
            distribution,
            install_date: installDate,
            agent: userAgent
          });
        });
      }

      var network = {
        type: 'wifi'
      };

      function post(url, payload) {
        return new Promise((resolve, reject) => {
          CliqzUtils.httpPost(url, req => {
            try {
              const json = JSON.parse(req.response);
              resolve(json);
            } catch (ex) {
              reject(`Backend ${url} could not parse JSON: ${req.response}`);
            }
          }, JSON.stringify(payload), reject, 1000 * 15 // Request timeout = 15 seconds
          );
        });
      }

      /**
       * Takes care of the communications with the backend
       *
       */

      const GID_BACKEND_URL = 'https://anolysis-gid.cliqz.com';
      const TELEMETRY_BACKEND_URL = 'https://anolysis-telemetry.cliqz.com/collect';

      function sendDemographics(demographics, endpoint) {
        logger$6.debug(endpoint, demographics);
        return post(`${GID_BACKEND_URL}/${endpoint}`, { id: demographics }).then(result => {
          // Extract id returned by the backend. This is important because both
          // the backend and the client must agree on a common format. This will
          // be used later to update the GID.
          if (result.id) {
            // Check that id contains the same values than the `demographics`
            // we sent, to prevent the backend from changing this. Which could
            // allow tracking.
            const id = JSON.parse(result.id);
            const original = JSON.parse(demographics);

            const idKeys = Object.keys(id);
            const originalKeys = Object.keys(original);

            if (idKeys.length !== originalKeys.length) {
              return Promise.reject('Returned id contains different keys:' + ` sent ${demographics}, received ${result.id}`);
            }

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = originalKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                const key = _step.value;

                if (original[key] !== id[key]) {
                  return Promise.reject(`The value for key ${key} differs:` + `sent ${original[key]}, received ${id[key]}`);
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            return result.id;
          }

          return Promise.reject('No id returned by the backend.');
        });
      }

      /**
       * Send a new_install signal to the backend, with granular demographics.
       */
      function newInstall(demographics) {
        return sendDemographics(demographics, 'new_install');
      }

      /**
       * Send a reappearing_user signal to the backend, with granular demographics.
       */
      function reappearingUser(demographics) {
        return sendDemographics(demographics, 'reappearing_user');
      }

      /**
       * Once during each month (except during the same month as the new_install),
       * sends the granular demographic factors again to the backend.
       */
      function activeUserSignal(demographics) {
        return sendDemographics(demographics, 'active_user');
      }

      /**
       * Signal a demographics update of the client to the backend.
       *
       * To avoid having to send the granular demographics to the backend
       * every time we update our GID, we only send a prefix of the hash of
       * the demographics instead. If the prefix is small enough (3 or 4
       * characters), then a few users will share this prefix, and the
       * backend won't know which was the real one.
       *
       * The backend will check what pairs { full_hash, GID } it has
       * available, and will return a list of all the pairs for which
       * the prefix sent by the client also matches the prefix of `full_prefix`.
       *
       * The client is then able to get its true GID by selecting the one
       * attached to its original hash.
       *
       * Right now it should naver happen that a client does not find its
       * GID using this method, because every month every clients will send
       * again their granular combination. This is not satisfactory and
       * another method, with better privacy preservation, will be implemented
       * in the future.
       */
      function updateGID(demographics) {
        logger$6.log('updateDemographics', demographics);
        const hash = cachedMD5(demographics);

        // TODO: What is the right size?
        const prefix = hash.slice(0, 3);

        // Send a prefix of the hash to the backend
        return post(`${GID_BACKEND_URL}/update_gid`, { hash_prefix: prefix }).then(data => {
          logger$6.log('updateGID response', data);
          if (data.candidates) {
            const candidates = data.candidates;
            let gid = null;

            // Check if our granular demographics are in the list of candidates
            candidates.forEach(candidate => {
              if (candidate.hash === hash) {
                gid = candidate.gid;
              }
            });

            if (gid !== null) {
              return Promise.resolve(gid);
            }
          }

          return Promise.reject(`No valid GID found ${hash}`);
        });
      }

      /**
       * Sends a behavioral signal to the backend
       */
      function sendSignal(signal) {
        logger$6.log('sendSignal', signal);
        if (network.type === 'wifi') {
          return post(TELEMETRY_BACKEND_URL, signal);
        }
        return Promise.reject('Device is not connected to WiFi');
      }

      var Backend = {
        newInstall,
        reappearingUser,
        activeUserSignal,
        updateGID,
        sendSignal
      };

      /**
       * Define standard date formats in anolysis module
       * @constant
       */
      const DATE_FORMAT = 'YYYY-MM-DD';
      const DAY_FORMAT = 'YYYY-DDD';
      const WEEK_FORMAT = 'YYYY-WW';
      const MONTH_FORMAT = 'YYYY-M';

      const CLIENT_STATE = {
        NEW_INSTALL: 0,
        REAPPEARING_USER: 1,
        FIRST_DAY: 2,
        SAFE: 3,
        SHOULD_UPDATE: 4,
        UNSAFE: 5
      };

      const NEW_INSTALL_SIGNAL_SENT_PREF = 'anolysisSentNewInstall';
      const NEW_INSTALL_DATE_PREF = 'anolysisInstalled';
      const LAST_TIME_SENT_PREF = 'anolysisLastAliveSignal';
      const LAST_TIME_GID_UPDATE_PREF = 'anolysisLastGIDUpdate';
      const CURRENT_SAFE_GID_PREF = 'anolysisGID';
      const CURRENT_DEMOGRAPHICS_PREF = 'anolysisDemographics';
      const NEXT_DEMOGRAPHICS_PREF = 'anolysisLatestDemographics';

      /**
       * This class is in charge of managing the safe group id of the user.
       * At any point of time, the `getGID` method will be used to get the
       * most up-to-date version of the GID, included in signals that will
       * be sent to the backend.
       *
       * The user can be in several states:
       * 1. new install
       * 2. first day
       * 3. safe
       * 4. should update its GID
       * 5. unsafe
       *
       * The GID manager should make sure that in any of the possible states,
       * the correct course of action is choosen when we call the `getGID`.
       *
       * It should also be invoked when new demographics are available.
       *
       * This manager is also responsible for reporting, once a month, the granular
       * combination of factors once again, with a certain probability. This is to
       * ensure that the backend is able to keep track of active users (and forget
       * about non-active ones), while still preserving privacy (cf. paper for more
       * information on this mechanism).
       */
      class GidManager {
        constructor(storage) {
          this.isReadyPromise = null;
          this.storage = storage;
        }

        reset() {
          // Clear all prefs
          const prefs = [NEW_INSTALL_SIGNAL_SENT_PREF, NEW_INSTALL_DATE_PREF, LAST_TIME_SENT_PREF, LAST_TIME_GID_UPDATE_PREF, CURRENT_SAFE_GID_PREF, CURRENT_DEMOGRAPHICS_PREF, NEXT_DEMOGRAPHICS_PREF];

          prefs.forEach(pref => this.storage.clear(pref));
        }

        /**
         * Init is a method what will perform the following actions:
         * 1. Check if granular demographics factors are available (prefs, pouchdb)
         * 2. Perform actions if needed: new install, update GID
         * 3. Check if alive signal should be sent (and send it if necessary)
         *
         * Moreover, the method is implemented in such a way that it cannot be called
         * two times concurrently. If `init` is called twice in a row, and the first
         * call did not resolve yet, then the second call will be ignored and will
         * return the promise created by the first call.
         */
        init() {
          if (this.isReadyPromise === null) {
            this.isReadyPromise = getDemographics().then(demographics => this.setLatestDemographics(JSON.stringify(demographics))).then(() => this.registerDemographicsFirstTime()).then(demographics => this.updateClientState(demographics).then(() => this.handleActiveUserSignal(demographics))).catch(ex => {
              logger$6.log('Exception while initializing gid manager', ex);
            }).then(() => {
              // Delete reference as init is done.
              this.isReadyPromise = null;
            });
          }

          return this.isReadyPromise;
        }

        /**
         * Manage the date at which we last updated the GID.
         */
        setLastGIDUpdateDate(date) {
          this.storage.set(LAST_TIME_GID_UPDATE_PREF, date);
        }

        getLastGIDUpdateDate() {
          return this.storage.get(LAST_TIME_GID_UPDATE_PREF);
        }

        /**
         * setter and getter to manage the granular combination of
         * demographics for the user.
         */
        setCurrentDemographics(demographics) {
          this.storage.set(CURRENT_DEMOGRAPHICS_PREF, demographics);
        }

        getCurrentDemographics() {
          return this.storage.get(CURRENT_DEMOGRAPHICS_PREF);
        }

        /** Store latest demographics available, this might be more up-to-date than
         *  what is used for the GID.
         */
        setLatestDemographics(demographics) {
          this.storage.set(NEXT_DEMOGRAPHICS_PREF, demographics);
        }

        getLatestDemographics() {
          return this.storage.get(NEXT_DEMOGRAPHICS_PREF);
        }

        /**
         * setter and getter to manage the safe group ID for the user.
         */
        setCurrentGID(gid) {
          this.storage.set(CURRENT_SAFE_GID_PREF, gid);
        }

        getCurrentGID() {
          return this.storage.get(CURRENT_SAFE_GID_PREF);
        }

        /**
         * setter and getter to manage the timestamp of the 'new install' event for the user.
         * This can be either the first day the user installed Cliqz, or the day telemetry
         * without ID was enabled for the an existing user.
         */
        setNewInstallDate(date) {
          this.storage.set(NEW_INSTALL_DATE_PREF, date);
        }

        getNewInstallDate() {
          return this.storage.get(NEW_INSTALL_DATE_PREF);
        }

        /**
         * setter and getter to keep track of weather or not the client sent a new
         * install or reappearing user signal to the backend. This is used only for
         * initialization of the gid manager (will happen once when user first install
         * Cliqz with Anolysis enabled)
         */
        setSentNewInstall(date) {
          this.storage.set(NEW_INSTALL_SIGNAL_SENT_PREF, date);
        }

        getSentNewInstall() {
          return this.storage.get(NEW_INSTALL_SIGNAL_SENT_PREF);
        }

        /**
         * setter and getter to manage the last time the granular combination of
         * demographics factors was sent to the backend.
         */
        setLastTimeDemographicSent(date) {
          this.storage.set(LAST_TIME_SENT_PREF, date);
        }

        getLastTimeDemographicSent() {
          return this.storage.get(LAST_TIME_SENT_PREF);
        }

        /**
         * Check if the user already has a granular combination of demographic
         * factors stored in prefs. If not, try to get it from storage. And if
         * none is present, then the user is set as UNSAFE, until one is present.
         */
        registerDemographicsFirstTime() {
          const currentDemographics = this.getCurrentDemographics();
          if (currentDemographics === undefined) {
            // If it's the first time, it might be that there is no granular
            // demographic factors yet. Check if there is a candidate in latest
            // demographics.
            logger$6.debug('try to get latest demographics from storage');
            const candidate = this.getLatestDemographics();
            if (candidate !== undefined) {
              logger$6.log('registerDemographicsFirstTime returns', candidate);
              return Promise.resolve(candidate);
            }

            // If no demographic factors are present in storage, the user is
            // unsafe, until the GID manager is updated with a new id.
            return Promise.reject();
          }

          return Promise.resolve(currentDemographics);
        }

        currentState(demographics) {
          // If no demographics, then the client is unsafe
          if (!demographics) {
            return CLIENT_STATE.UNSAFE;
          }

          const currentDate = getSynchronizedDate();
          const currentDateFormatted = currentDate.format(DATE_FORMAT);

          // Check if we already stored an install date in the pref
          if (!this.getNewInstallDate()) {
            this.setNewInstallDate(currentDateFormatted);
          }

          // Extract real install date from env signal.
          let cliqzInstallDate = demographics.install_date;
          try {
            cliqzInstallDate = moment(JSON.parse(demographics).install_date, 'YYYY/MM/DD').format(DATE_FORMAT);
          } catch (ex) {}
          /* Ignore ex since `demographics` might already be an obj */

          // If we did not register any install date yet, it means that this is the
          // first time the user uses Cliqz with anolysis, or that the previous
          // attempt to contact the backend failed.
          if (!this.getSentNewInstall()) {
            if (currentDateFormatted !== cliqzInstallDate) {
              // This is a reappearing user.
              return CLIENT_STATE.REAPPEARING_USER;
            }

            // This is a new install.
            return CLIENT_STATE.NEW_INSTALL;
          }

          // Get new install date
          const installDate = moment(this.getSentNewInstall(), DATE_FORMAT);

          // If we sent the new install or reappearing user this day, we are in a
          // FIRST_DAY state and will send granular demographics.
          if (installDate.isSame(currentDate, 'day')) {
            return CLIENT_STATE.FIRST_DAY;
          }

          // If we are more than one day after the install then we should query the
          // backend to get our safe GID.
          if (this.getCurrentGID() === undefined && currentDate.isAfter(installDate, 'day')) {
            return CLIENT_STATE.SHOULD_UPDATE;
          }

          // If a GID is already present, check if it's not out-of-date.
          if (this.getLastGIDUpdateDate() !== undefined) {
            const gidUpdateDate = moment(this.getLastGIDUpdateDate(), DATE_FORMAT);

            // If we did not update the GID for the current month, then
            // we should query the backend again to check for update.
            if (!currentDate.isSame(gidUpdateDate, 'month')) {
              return CLIENT_STATE.SHOULD_UPDATE;
            }

            // If we have GID and it has been updated during the current month
            // then we are safe!
            if (this.getCurrentGID() !== undefined && gidUpdateDate.isSame(currentDate, 'month')) {
              return CLIENT_STATE.SAFE;
            }
          }

          return CLIENT_STATE.UNSAFE;
        }

        updateClientState(demographics) {
          logger$6.debug('update client state from', this.currentState(demographics), demographics);
          switch (this.currentState(demographics)) {
            case CLIENT_STATE.REAPPEARING_USER:
              return this.handleReappearingUser(demographics);
            case CLIENT_STATE.NEW_INSTALL:
              return this.handleNewInstall(demographics);
            case CLIENT_STATE.SHOULD_UPDATE:
              return this.handleUpdate(demographics);
            case CLIENT_STATE.SAFE:
            case CLIENT_STATE.FIRST_DAY:
            case CLIENT_STATE.UNSAFE:
              // Nothing should be done
              break;
            default:
              // Should never happen
              break;
          }

          return Promise.resolve();
        }

        // --------------------------------------------------------------------------
        // Handle state transition:
        // * handleNewInstall
        // * handleReappearingUser
        // * handleUpdate
        // * handleActiveSignal
        // --------------------------------------------------------------------------

        handleNewInstall(demographics) {
          logger$6.debug('handleNewInstall');
          return Backend.newInstall(demographics).then(formattedDemographics => {
            logger$6.debug('Success handleNewInstall');
            const currentDate = getSynchronizedDate().format(DATE_FORMAT);

            this.setLastTimeDemographicSent(currentDate);
            this.setCurrentDemographics(formattedDemographics);
            this.setSentNewInstall(currentDate);

            return formattedDemographics;
          }).catch(ex => {
            // TODO: This could be a security problem for the user
            logger$6.error('Could not send newInstall signal', ex);

            return '';
          });
        }

        handleReappearingUser(demographics) {
          logger$6.debug('handleReappearingUser');
          return Backend.reappearingUser(demographics).then(formattedDemographics => {
            logger$6.debug('Success handleReappearingUser');
            const currentDate = getSynchronizedDate().format(DATE_FORMAT);

            this.setLastTimeDemographicSent(currentDate);
            this.setCurrentDemographics(formattedDemographics);
            this.setSentNewInstall(currentDate);

            return formattedDemographics;
          }).catch(ex => {
            // TODO: This could be a security problem for the user
            logger$6.error('Could not send reappearingUser signal', ex);

            return '';
          });
        }

        handleUpdate(demographics) {
          logger$6.debug('handleUpdate');
          return Backend.updateGID(demographics).then(gid => {
            logger$6.log('success handleUpdate', gid);
            this.setLastGIDUpdateDate(getSynchronizedDate().format(DATE_FORMAT));
            this.setCurrentGID(gid);

            return gid;
          }).catch(() => {
            // If we were not able to retrieve a valid GID, then the user
            // is marked as UNSAFE and won't send sensitive information.
          });
        }

        handleActiveUserSignal(demographics) {
          // TODO: Right now all user will send this once a month (except
          // if it's the same month as the install date), but in the future
          // we might want to send it only with a given probability. eg: 75%.

          // Check if we should send the 'alive signal' along with
          // the most granular demographic factors.
          const lastTimeDemographicsSent = this.getLastTimeDemographicSent();
          if (lastTimeDemographicsSent !== undefined) {
            logger$6.debug('handleActiveUserSignal has already been sent before');

            const currentDate = getSynchronizedDate();
            const lastDemographicSentDate = moment(lastTimeDemographicsSent, DATE_FORMAT);

            if (currentDate.isSame(lastDemographicSentDate.add(6, 'months'), 'month')) {
              logger$6.debug('handleActiveUserSignal send again');
              // Get latest demographics available
              let candidate = this.getLatestDemographics();
              if (candidate === undefined) {
                candidate = demographics;
              }

              return Backend.activeUserSignal(candidate).then(formattedDemographics => {
                this.setCurrentDemographics(formattedDemographics);
                this.setLastTimeDemographicSent(currentDate.format(DATE_FORMAT));
                return formattedDemographics;
              });
            }
          }

          // The demographics have already been sent before
          return Promise.resolve(demographics);
        }

        /**
         * Returns the GID with which the user should report to
         * the backend.
         *
         * On the first day after installation, this will be the granular
         * combination of demographics.
         *
         * On subsequent days, this will be a safe group ID returned by
         * the back-end.
         */
        getGID() {
          logger$6.debug('getGID');
          return this.init().then(() => {
            switch (this.currentState(this.getCurrentDemographics())) {
              case CLIENT_STATE.FIRST_DAY:
                return this.getCurrentDemographics();
              case CLIENT_STATE.SAFE:
                return this.getCurrentGID();
              case CLIENT_STATE.NEW_INSTALL:
              case CLIENT_STATE.SHOULD_UPDATE:
              case CLIENT_STATE.UNSAFE:
              case CLIENT_STATE.REAPPEARING_USER:
                break;
              default:
                break;
            }

            // Any state which is not FIRST_DAY or SAFE, should not
            // report with any ID that could be unsafe for the user.
            return '';
          }).catch(ex => {
            logger$6.error('Exception', ex, ex.stack);
          });
        }
      }

      function getSelectionType(signal) {
        const positionType = (signal.position_type || [''])[0];
        if (positionType === 'inbar_url') {
          if (signal.source || signal.autocompleted) {
            return 'autocomplete';
          }
          return 'url';
        } else if (positionType === 'inbar_query') {
          return 'query';
        }
        return 'enter';
      }

      // TODO: keys need to be updated if getId() function in preprocessor changes
      const preprocessors = {
        activity_result_click: signal => ({
          type: 'result_selection_click',
          behavior: {
            current_position: signal.current_position,
            query_length: signal.query_length,
            reaction_time: signal.reaction_time,
            display_time: signal.display_time,
            urlbar_time: signal.urlbar_time
          }
        }),
        activity_result_enter: signal => ({
          type: `result_selection_${getSelectionType(signal)}`,
          behavior: {
            current_position: signal.current_position,
            query_length: signal.query_length,
            reaction_time: signal.reaction_time,
            display_time: signal.display_time,
            urlbar_time: signal.urlbar_time
          }
        })
      };

      class Preprocessor {
        constructor() {
          let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { channel: 99 };

          this.idComponents = ['type', 'action'];
          this.settings = settings;
          this.isDev = prefs.get('developer', false);
        }

        process(signal, schema, schemaName) {
          if (this.isDemographics(signal)) {
            // This is just a way to ignore environment signals from legacy telemetry.
            // Anolysis now has another way to access the latest demographics of the
            // device. This could be deleted in the future if we suppress the
            // environment signal.
            return Promise.resolve({
              demographics: null
            });
          }

          // Legacy behavior signal
          if (schema === undefined) {
            // This is a legacy signal that should be aggregated
            const type = this.getId(signal);

            if (preprocessors[type] !== undefined) {
              const newSignal = preprocessors[type](signal);
              return Promise.resolve({
                type: newSignal.type || type,
                behavior: newSignal.behavior
              });
            }

            const behavior = {};
            Object.keys(signal).filter(key => this.idComponents.indexOf(key) === -1).filter(key => !this.isObject(signal[key])).filter(key => key !== 'seq' && key !== 'ts' && key !== 'session').forEach(key => {
              behavior[key] = signal[key];
            });

            return Promise.resolve({ type, behavior });
          }

          // Check JSON schema using Ajv library if it is `instantPush`.
          // We currently perform the schema validation only in developper mode.
          if (this.isDev && schema.instantPush) {
            const valid = schema.validate(signal);
            if (!valid) {
              logger$6.error('Signal does not respect schema', schemaName, JSON.stringify(signal, undefined, 2), JSON.stringify(schema.validate.errors, undefined, 2));

              return Promise.reject('Signal could not be validated');
            }
          }

          // New signal, with a schema provided.
          return Promise.resolve({
            type: schemaName,
            behavior: signal,
            meta: {}
          });
        }

        isObject(value) {
          return value !== null && typeof value === 'object';
        }

        isDemographics(signal) {
          return signal.type === 'environment';
        }

        getId(signal) {
          return this.idComponents.map(c => signal[c]).filter(c => c !== undefined).join('_');
        }
      }

      /**
       * Messages to be sent are persisted in Dexie to make sure we don't lose
       * anything. When popped from the queue, they are sent one by one to the backend.
       * Only when the response is 'ok' we remove the message from Dexie.
       *
       * [Dexie] -> backend -> deleted from [Dexie]
       *
       * The messages are sent by batch.
       *
       * A new batch should not be sent unless the previous batch is completely sent.
       * Moreover, signals should have a maximum number of retries and should be
       * dropped after a few trials.
       */
      class SignalsQueue {
        constructor() {
          this.db = null;

          // Send signals by chunks, at regular intervals
          // Make throughput customizable
          this.initialized = false;
          this.batchSize = 5;
          this.sendInterval = 15 * 1000;
          this.maxAttempts = 5;
          // Max throughput = 30 messages per minute

          // Current timeout that should be used after a failed batch
          this.failureTimeout = 1000 * 60;
        }

        init(db) {
          this.db = db;
          return this.db.deleteOlderThan(getSynchronizedDate().subtract(1, 'months').format(DATE_FORMAT)).then(() => this.startListening());
        }

        unload() {
          this.initialized = false;
          CliqzUtils.clearInterval(this.interval);
          CliqzUtils.clearTimeout(this.sleepTimeout);
        }

        sleep(time) {
          return new Promise(resolve => {
            logger$6.debug('signal queue sleeps for', time, 'ms');
            this.sleepTimeout = CliqzUtils.setTimeout(resolve, time);
          });
        }

        /**
         * Send signals by batch.
         */
        startListening() {
          let ongoingBatch = false;
          this.initialized = true;
          this.interval = CliqzUtils.setInterval(() => {
            // Only try to send a new batch if the signal queue is initialized and
            // we are not already sending a batch
            if (!ongoingBatch && this.initialized) {
              ongoingBatch = true;
              this.processNextBatch(this.batchSize).then(() => {
                // Reset failure timeout after we could send a batch successfuly
                this.failureTimeout = 1000 * 60;
                // Wait a bit before next batch
                return this.sleep(this.sendInterval);
              }).catch(err => {
                if (this.initialized) {
                  logger$6.error('error while sending batch', err);
                  // In case of error, sleep for longer and increase the timeout
                  const timeout = this.failureTimeout;
                  this.failureTimeout *= 5;
                  return this.sleep(timeout);
                }

                return Promise.resolve();
              }).catch(() => {}).then(() => {
                ongoingBatch = false;
              });
            }
          }, this.sendInterval);
        }

        /**
         * Try to send a given signal to the backend.
         *  - If it *succeeds*, then remove the document from the persistent queue.
         *  - If it *fails*, then increment the `attempts` counter. If the attempts is
         *  greater than the maximum allowed, we drop the message completely.
         */
        sendSignal(_ref) {
          let signal = _ref.signal,
              attempts = _ref.attempts,
              id = _ref.id;

          // Check if the message queue is currently initialized before sending anything
          if (!this.initialized) {
            return Promise.reject('signal-queue has been unloaded, cancel message sending');
          }

          logger$6.debug('send signal', signal);
          return Backend.sendSignal(signal).then(() => this.db.remove(id)).catch(ex => {
            // We don't remove the document from the db since it will be retried
            // later. This way we avoid loosing signals because of server's
            // errors.
            const reason = `failed to send signal with exception ${ex} [${attempts}]`;
            let resultPromise;

            // Check number of attempts and remove if > this.maxAttempts
            if (attempts < this.maxAttempts) {
              resultPromise = this.db.remove(id).then(() => this.db.push(signal, attempts + 1)).then(() => logger$6.error('update number of attemps of signal', signal));
            } else {
              // Otherwise, remove the document from the queue
              resultPromise = this.db.remove(id).then(() => logger$6.error('removed failed signal', signal));
            }

            // Returns a failed promise to notify a failure
            return resultPromise.then(() => Promise.reject(reason));
          });
        }

        /**
         * Given a batch of signals to be sent, try to send them one by one but stop
         * as soon as we have a failure.
         */
        sendBatch(batch) {
          if (batch && batch.length > 0) {
            // Try to send first signal, then send the rest.
            const doc = batch[0];
            return this.sendSignal(doc).then(() => this.sendBatch(batch.slice(1)));
          }

          return Promise.resolve();
        }

        /**
         * Get the next batch of documents to be sent to the backend.
         */
        getNextBatch(n) {
          return this.db.getN(n).catch(ex => {
            logger$6.error('signal-queue could not get next batch', ex);
            return []; // Returns empty batch
          });
        }

        /**
         * Try to send a new batch of signals to the backend:
         * 1. Get a batch of signals from the queue
         * 2. Try to send it
         * 3. Sleep before next batch
         */
        processNextBatch(size) {
          return this.getNextBatch(size).then(batch => this.sendBatch(batch));
        }

        /**
         * Push a new signal in the queue. It will be persisted and sent to the
         * backend as soon as possible.
         */
        push(signal) {
          return this.db.push(signal).catch(ex => {
            logger$6.log('Could not persist signal in queue, sending directly', ex, signal);
            // Indicate that this signal was pushed directly, without going through
            // the persistent signal queue.

            /* eslint-disable no-param-reassign */
            signal.meta.forcePushed = true;
            /* eslint-enable no-param-reassign */
            return this.sendSignal({ signal });
          });
        }
      }

      let Dexie;
      let loadingPromise;

      var getDexie = function () {
        if (Dexie) {
          return Promise.resolve(Dexie);
        }
        if (!loadingPromise) {
          loadingPromise = getWindowAPIAsync().then(wAPI => {
            if (!global.IDBKeyRange) {
              global.IDBKeyRange = wAPI.IDBKeyRange;
            }
            const url = 'chrome://cliqz/content/vendor/dexie.min.js';
            const target = { global };
            Services.scriptloader.loadSubScriptWithOptions(url, {
              target,
              ignoreCache: true
            });
            return target.Dexie;
          });
        }
        return loadingPromise;
      };

      /**
       * Equivalent to Python's default dict, but in Javascript with a Map!
       * It behaves exactly like a map, but allows you to specify a callback to be
       * used when a `key` does not exist in the Map yet.
       *
       * >>> const myMap = new DefaultMap(() => [])
       * >>> myMap.get('foo')
       * []
       * >> myMap.update('bar', v => v.push(42))
       * >> myMap
       * DefaultMap { 'foo' => [], 'bar' => [ 42 ] }
       */
      class DefaultMap {
        constructor(valueCtr) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          this.map = new Map(...args);
          this.valueCtr = valueCtr;
        }

        toMap() {
          return this.map;
        }

        toObj() {
          const obj = Object.create(null);
          this.forEach((v, k) => {
            obj[k] = v;
          });
          return obj;
        }

        get size() {
          return this.map.size;
        }

        clear() {
          return this.map.clear();
        }

        delete() {
          return this.map.delete(...arguments);
        }

        entries() {
          return this.map.entries(...arguments);
        }

        forEach() {
          return this.map.forEach(...arguments);
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.valueCtr());
          }

          return this.map.get(key);
        }

        has() {
          return this.map.has(...arguments);
        }

        keys() {
          return this.map.keys(...arguments);
        }

        set() {
          return this.map.set(...arguments);
        }

        values() {
          return this.map.values(...arguments);
        }

        // Extra API

        update(key, updateFn) {
          const value = this.get(key);
          const result = updateFn(value);
          this.set(key, result === undefined ? value : result);
        }
      }

      /**
       * Clean-up all past storage of anolysis.
       */
      function migrate$1() {
        return Promise.all(['cliqz-anolysis-aggregated-behavior', 'cliqz-anolysis-aggregation-log', 'cliqz-anolysis-behavior', 'cliqz-anolysis-demographics', 'cliqz-anolysis-retention-log', 'cliqz-anolysis-signals', 'cliqz-telemetry-behavior', 'cliqz-telemetry-demographics'].map(name => new DB(name).destroy().catch(() => {})));
      }

      class AggregatedView {
        constructor(db) {
          this.db = db;
        }

        ifNotAlreadyAggregated(date, fn) {
          return this.db.get({ date }).then(aggregation => {
            if (aggregation === undefined) {
              return fn();
            }

            return Promise.resolve();
          });
        }

        getAggregatedDates() {
          return this.db.toCollection().primaryKeys();
        }

        storeAggregation(date, aggregation) {
          return this.db.add({ date, aggregation });
        }

        getAggregation(date) {
          return this.db.get(date).then(v => v && v.aggregation);
        }

        deleteOlderThan(date) {
          return this.db.where('date').below(date).delete();
        }
      }

      class BehaviorView {
        constructor(db) {
          this.db = db;
        }

        getTypesForDate(date) {
          return this.db.where('date').equals(date).toArray().then(signals => {
            const types = new DefaultMap(() => []);
            for (let i = 0; i < signals.length; i += 1) {
              var _signals$i = signals[i];
              const type = _signals$i.type,
                    behavior = _signals$i.behavior;

              types.update(type, values => {
                values.push(behavior);
              });
            }
            return types;
          });
        }

        add(_ref) {
          let type = _ref.type,
              behavior = _ref.behavior;

          const date = getSynchronizedDate().format(DATE_FORMAT);

          const doc = {
            behavior,
            date,
            type
          };

          logger$6.debug('add', doc);

          return this.db.add(doc);
        }

        deleteByDate(date) {
          return this.db.where('date').equals(date).delete();
        }
      }

      class RetentionView {
        constructor(db) {
          this.db = db;
          this.key = 'state';
        }

        getState() {
          return this.db.get(this.key).then(state => {
            if (!state) {
              return {
                daily: {},
                weekly: {},
                monthly: {}
              };
            }

            return state.value;
          });
        }

        setState(state) {
          return this.db.put({
            key: this.key,
            value: state
          });
        }
      }

      class SignalQueueView {
        constructor(db) {
          this.db = db;
        }

        push(signal) {
          let attempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          return this.db.add({
            signal,
            attempts,
            date: getSynchronizedDate().format(DATE_FORMAT)
          });
        }

        remove(id) {
          if (typeof id !== 'number') {
            return Promise.resolve();
          }

          return this.db.delete(id);
        }

        getN(n) {
          return this.db.limit(n).toArray();
        }

        getAll() {
          return this.db.toArray();
        }

        deleteOlderThan(date) {
          return this.db.where('date').below(date).delete();
        }
      }

      class AnolysisStorage {
        constructor() {
          this.db = null;

          this.aggregated = null;
          this.behavior = null;
          this.retention = null;
          this.signals = null;
        }

        init() {
          if (this.db !== null) return Promise.resolve();

          return getDexie().then(Dexie => {
            this.db = new Dexie('anolysis');
            this.db.version(1).stores({
              aggregated: 'date',
              behavior: '++id,date',
              retention: 'key',
              signals: '++id,date'
            });

            this.db.on('populate', () => {
              // populate is only called the first time the database is created, which
              // is the only time we would want to call `migrate()` to delete previous
              // storage.
              migrate$1();
            });

            return this.db.open();
          }).then(() => {
            this.aggregated = new AggregatedView(this.db.aggregated);
            this.behavior = new BehaviorView(this.db.behavior);
            this.retention = new RetentionView(this.db.retention);
            this.signals = new SignalQueueView(this.db.signals);
          });
        }

        destroy() {
          if (this.db !== null) {
            return this.db.delete();
          }

          return Promise.resolve();
        }

        unload() {
          if (this.db !== null) {
            this.db.close();
            this.db = null;
          }
        }
      }

      var _slicedToArray$19 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint-disable no-param-reassign */

      /**
       *
       *
       */
      function generateRetention(_ref) {
        let state = _ref.state,
            date = _ref.date,
            timeframe = _ref.timeframe,
            schema = _ref.schema,
            getPreviousUnit = _ref.getPreviousUnit,
            initialOffset = _ref.initialOffset;

        const getLength = offset => (state[getPreviousUnit(date, offset)] || []).length;

        const signals = [{
          offset: initialOffset,
          units_active: getLength(initialOffset)
        }];

        for (let i = 1; i < timeframe; i += 1) {
          signals.push({
            units_active: getLength(1),
            offset: i + initialOffset
          });
        }

        // Decorate each signal with its schema name (eg: retention_daily)
        return signals.map(signal => [schema, signal]);
      }

      function generateDailyRetention(state, formattedDate) {
        const date = moment(formattedDate, DATE_FORMAT);
        const currentDay = date.format(DAY_FORMAT);
        logger$6.debug(`Retention daily for ${currentDay}`);

        if (state[currentDay] === undefined) {
          state[currentDay] = [formattedDate];

          return generateRetention({
            state,
            date,
            timeframe: 10,
            schema: 'retention_daily',
            getPreviousUnit: (d, offset) => d.subtract(offset, 'days').format(DAY_FORMAT),
            initialOffset: 0
          });
        }

        return [];
      }

      function generateWeeklyRetention(state, formattedDate) {
        const date = moment(formattedDate, DATE_FORMAT);
        const currentWeek = date.format(WEEK_FORMAT);
        logger$6.debug(`Retention weekly for ${currentWeek}`);

        if (state[currentWeek] === undefined) {
          state[currentWeek] = [formattedDate];

          return generateRetention({
            state,
            date,
            timeframe: 10,
            schema: 'retention_weekly',
            getPreviousUnit: (d, offset) => d.subtract(offset, 'weeks').format(WEEK_FORMAT),
            initialOffset: 1
          });
        } else if (state[currentWeek].indexOf(formattedDate) === -1) {
          state[currentWeek].push(formattedDate);
        }

        return [];
      }

      function generateMonthlyRetention(state, formattedDate) {
        const date = moment(formattedDate, DATE_FORMAT);
        const currentWeek = date.format(WEEK_FORMAT);
        const currentMonth = date.format(MONTH_FORMAT);
        logger$6.debug(`Retention monthly for ${currentMonth}`);

        if (state[currentMonth] === undefined) {
          state[currentMonth] = [currentWeek];

          return generateRetention({
            state,
            date,
            timeframe: 12,
            schema: 'retention_monthly',
            getPreviousUnit: (d, offset) => d.subtract(offset, 'months').format(MONTH_FORMAT),
            initialOffset: 1
          });
        } else if (state[currentMonth].indexOf(currentWeek) === -1) {
          state[currentMonth].push(currentWeek);
        }

        return [];
      }

      function generateRetentionSignals(retentionState) {
        const date = getSynchronizedDate();
        const formattedDate = date.format(DATE_FORMAT);
        const signals = [];
        logger$6.debug(`Retention for ${formattedDate}`);

        // Generate all kinds of retentions.
        [['daily', generateDailyRetention], ['weekly', generateWeeklyRetention], ['monthly', generateMonthlyRetention]].forEach(_ref2 => {
          var _ref3 = _slicedToArray$19(_ref2, 2);

          let name = _ref3[0],
              generator = _ref3[1];

          const state = retentionState[name] || {};
          generator(state, formattedDate).forEach(signal => {
            signals.push(signal);
          });
          retentionState[name] = state;
        });

        return signals;
      }

      var _extends$14 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _slicedToArray$17 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint { "no-param-reassign": "off" } */

      // TODO - introduce an in-memory short-lived cache to store signals to behavior
      // db and signal db. Then use one bulkAdd to insert all of them at once.
      // TODO - ease addition of new analyses
      class Anolysis {
        constructor(settings) {
          // Store available schemas for telemetry signals.
          // New schemas can be added using 'registerSchemas', which is
          // needed before they can be used using the telemetry function.
          this.availableSchemas = new Map();

          // The preprocessor is used to process incoming telemetry signals (from
          // `log` method). It is able to: convert environment signals to new
          // demographics, create legacy signals if no schema is provided, check
          // telemetry schema if provided. It will also handle instantPush signals so
          // that they are sent straight away.
          this.preprocessor = new Preprocessor(settings);

          // Storage manages databases for all Anolysis storage.
          this.storage = new AnolysisStorage();

          // This is used to aggregate telemetry signals over 1 day. The result is
          // passed as an argument to the different analyses to generate telemetry
          // signals.
          this.behaviorAggregator = new Aggregator();

          // Async message queue used to send telemetry signals to the backend
          // (telemetry server). It is persisted on disk, and will make sure that
          // messages are sent by batch, so that we can control the throughput.
          this.signalQueue = new SignalsQueue();

          // Manage demographics and safe group ids. This will ensure that the user
          // reports safely at any point of time. The `getGID` method of this object
          // will be called before sending any telemetry to check for an existing GID.
          this.gidManager = new GidManager({ get: CliqzUtils.getPref, set: CliqzUtils.setPref, clear: CliqzUtils.clearPref });
        }

        init() {
          return this.storage.init().then(() => this.signalQueue.init(this.storage.signals)).then(() => {
            // Check everytime we switch to a new day, and trigger the generation of
            // aggregated telemetry signals (analyses).
            let currentDate = CliqzUtils.getPref('config_ts');
            this.onNewDate = CliqzEvents.subscribe('prefchange', pref => {
              if (pref === 'config_ts') {
                const newValue = CliqzUtils.getPref('config_ts');
                if (newValue !== currentDate) {
                  currentDate = newValue;
                  logger$6.log('Generate aggregated signals (new day)', currentDate, newValue);
                  this.generateAnalysesSignalsFromAggregation();
                }
              }
            });
          }).then(() => this.removeOldDataFromDB()).then(() => {
            // This can be run async since calling two times the same method will
            // resolve to the same Promise object. It's not returned here to not
            // delay the loading of the module.
            this.gidManager.init();
          });
        }

        unload() {
          if (this.onNewDate) {
            this.onNewDate.unsubscribe();
            this.onNewDate = undefined;
          }

          CliqzUtils.clearTimeout(this.generateAggregationSignalsTimeout);
          this.signalQueue.unload();
          this.storage.unload();
        }

        /**
         * WARNING: This method will only be used during the release of the system. It
         * will only be triggered on a version change, to allow existing
         * users (who could be using a previously buggy version of anolysis) to be
         * updated completely and be put in a safe state.
         */
        reset() {
          // Clear state related to gid management + out-going messages that could be
          // sent with a GID that does not exist anymore.
          return Promise.all([this.gidManager.reset(), this.storage.destroy()]);
        }

        registerSchemas(schemas) {
          Object.keys(schemas).forEach(name => {
            logger$6.debug('Register schema', name);
            if (!this.availableSchemas.has(name)) {
              this.availableSchemas.set(name, schemas[name]);
            } else {
              throw new Error(`Schema ${name} already exists with value ${JSON.stringify(schemas[name])}`);
            }
          });
        }

        /**
         * Get rid of data older than 30 days.
         */
        removeOldDataFromDB() {
          const today = getSynchronizedDate().format(DATE_FORMAT);
          return this.storage.aggregated.deleteOlderThan(today);
        }

        sendRetentionSignals() {
          return this.storage.retention.getState().then(state => {
            logger$6.log('generate retention signals', state);

            const promise = Promise.all(generateRetentionSignals(state).map(_ref => {
              var _ref2 = _slicedToArray$17(_ref, 2);

              let schema = _ref2[0],
                  signal = _ref2[1];
              return this.handleTelemetrySignal(signal, schema);
            }));

            // `state` is updated by the `generateRetentionSignals` function to keep
            // track of the current activity, and avoid generating the signals
            // several times.
            return this.storage.retention.setState(state).then(() => promise);
          });
        }

        generateAnalysesSignalsFromAggregation() {
          const startDay = getSynchronizedDate().subtract(1, 'days');
          const stopDay = moment.max(moment(this.gidManager.getNewInstallDate(), DATE_FORMAT), getSynchronizedDate().subtract(1, 'months'));

          const checkPast = formattedDate => {
            const date = moment(formattedDate, DATE_FORMAT);
            return this.storage.aggregated.ifNotAlreadyAggregated(formattedDate, () => this.generateAndSendAnalysesSignalsForDay(formattedDate).catch(ex => logger$6.error('Could not generate aggregated signals for day', formattedDate, ex)).then(() => {
              // Recursively check previous day until we reach `stopDay`
              if (stopDay.isBefore(date, 'day')) {
                // Wait a few seconds between each aggregation, to not overload
                // the browser.
                // NOTE: This could be done in a worker, asynchronously.
                return new Promise((resolve, reject) => {
                  this.generateAggregationSignalsTimeout = CliqzUtils.setTimeout(() => checkPast(date.subtract(1, 'days').format(DATE_FORMAT)).catch(reject).then(resolve), 5000);
                });
              }

              return Promise.resolve();
            }));
          };

          return checkPast(startDay.format(DATE_FORMAT));
        }

        /**
         * This function is triggered every day, once a day (and can be triggered
         * later if it was missed for a given day). It will read one day of behavioral
         * signals, aggregate it, and then invoke different analyses to generate
         * messages to be sent to the backend. The messages will be stored temporarily
         * in a queue (persisted on disk), and then sent async.
         */
        generateAndSendAnalysesSignalsForDay(date) {
          // 1. Aggregate messages for one day
          return this.storage.behavior.getTypesForDate(date).then(records => {
            let aggregation = {};
            const signals = [];
            const numberOfSignals = records.size;
            logger$6.log('generateSignals', date, numberOfSignals);

            // Generate signals from analyses which do not require an aggregation
            // first. This can happen if the data is coming from other sources such
            // as preferences, but we still want to trigger those only once a day.
            this.availableSchemas.forEach((schema, name) => {
              if (schema.generate !== undefined && schema.generate.length === 0) {
                logger$6.debug('generateSignals for', name);
                schema.generate().forEach(signal => signals.push({
                  schema: _extends$14({}, schema, { instantPush: true }),
                  signal,
                  meta: { date }
                }));
              }
            });

            // Aggregate signals if there is at least one, then generate anolysis
            // signals based on this aggregation.
            if (numberOfSignals > 0) {
              const t0 = Date.now();
              aggregation = this.behaviorAggregator.aggregate(records);
              const total = Date.now() - t0;

              // Extract AB Tests
              // This is not used at the moment, so let's not do useless work
              // const abtests = new Set(parseABTests(utils.getPref('ABTests')));

              this.availableSchemas.forEach((schema, name) => {
                // Only consider schemas having a signal generator specified.
                if (schema.generate !== undefined && schema.generate.length > 0) {
                  logger$6.debug('generateSignals for', name);
                  schema.generate(aggregation /* , abtests */).forEach(signal => signals.push({
                    schema: _extends$14({}, schema, { instantPush: true }),
                    signal,
                    meta: {
                      date,
                      // TODO: This will be removed in the future. The aggregation
                      // time could also be sent separately in its own signal.
                      aggregation_time: total
                    }
                  }));
                }
              });
            }

            // Push all signals to telemetry queue
            return Promise.all(signals.map(_ref3 => {
              let signal = _ref3.signal,
                  schema = _ref3.schema,
                  meta = _ref3.meta;
              return this.handleTelemetrySignal(signal, schema, meta);
            })).then(() => this.storage.aggregated.storeAggregation(date, aggregation)).then(() => this.storage.behavior.deleteByDate(date));
          });
        }

        /**
         * Process a new incoming telemetry signal from `core`. It will be
         * transformed to new telemetry (without ID) format and stored. The
         * data will then be available for aggregation and sent as part of
         * daily analyses.
         *
         * @param {Object} signal - The telemetry signal.
         */
        handleTelemetrySignal(signal, schemaName) {
          let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          logger$6.debug('handleTelemetrySignal', schemaName, signal);

          // Try to fetch the schema definition from the name.
          let schema;
          let name;
          if (typeof schemaName === 'string') {
            schema = this.availableSchemas.get(schemaName);
            if (schema === undefined) {
              return Promise.reject(`Telemetry schema ${schemaName} was not found`);
            }
            name = schemaName;
          } else if (schemaName !== undefined) {
            // A schema object can be given directly as argument
            schema = schemaName;
            name = schema.name;
          }

          return this.preprocessor.process(signal, schema, name).then(processedSignal => {
            const isDemographics = processedSignal.demographics !== undefined;
            const isLegacy = schema === undefined;
            const isInstantPush = !isLegacy && schema.instantPush;

            if (isDemographics) {
              // The environment signal from legacy telemetry is ignored, since we
              // now have a cross-platform mechanism to get demographics.
              return Promise.resolve();
            } else if (isInstantPush && !isLegacy) {
              logger$6.debug('Signal is instantPush', processedSignal);

              return (schema.needsGid ? this.gidManager.getGID() : Promise.resolve('')).then(gid => {
                processedSignal.meta = meta;

                // NOTE: If `gid` is empty, it's also fine, as we still want
                // to receive signals for users not having a safe GID. In
                // this case, such users will form a group on their own.
                processedSignal.meta.gid = gid;

                // TODO - it might be enough to hash the signal + date of
                // generation to detect exact duplicates (could be done in the
                // backend). But this seed can allow us to detect issues in
                // the client.
                //
                // We add a random seed to each message to allow deduplication
                // from the backend. This should not be a privacy concern, as each
                // message will include a different number.
                processedSignal.meta.seed = randomInt();

                // TODO: This is temporary! Should be removed before
                // putting in production. This will be there as long
                // as we test both telemetry systems side by side, to
                // be able to compare results meaningfully.
                processedSignal.meta.session = CliqzUtils.getPref('session');

                processedSignal.meta.date = processedSignal.meta.date || getSynchronizedDate().format(DATE_FORMAT);

                // Push signal to be sent as soon as possible.
                return this.signalQueue.push(processedSignal);
              });
            }

            // if (!isInstantPush || isLegacy) {
            // This signal is stored and will be aggregated with other signals from
            // the same day to generate 'analyses' signals.
            return this.storage.behavior.add(processedSignal).catch(ex => {
              logger$6.error('behavior exception', ex, processedSignal);
            });
            // }
          });
        }
      }

      /* eslint { "object-shorthand": "off" } */

      /* TODO - use the new kord module
       * import inject from '../core/kord/inject';
       * const controlCenter = inject.module('control-center');
       * controlCenter.windowAction(window, 'setBadge', 17);
       */

      const ENABLE_PREF = 'telemetryNoSession';
      const LATEST_VERSION_USED_PREF = 'anolysisVersion';

      /**
       * VERSION is used to signal major changes in Anolysis. Its purpose so far is to
       * only signal when the state of the client should be reset, which is a
       * temporary thing.
       */
      const VERSION$2 = 4;

      function versionWasUpdated() {
        return CliqzUtils.getPref(LATEST_VERSION_USED_PREF, null) !== VERSION$2;
      }

      function storeNewVersionInPrefs() {
        CliqzUtils.setPref(LATEST_VERSION_USED_PREF, VERSION$2);
      }

      function isTelemetryEnabled() {
        return CliqzUtils.getPref(ENABLE_PREF, false);
      }

      /**
       * This function will instantiate an Anolysis class. It will also check if the
       * internal states need to be reset (on version bump).
       */
      function instantiateAnolysis(settings) {
        const anolysis = new Anolysis(settings);

        // Check if we should reset
        if (versionWasUpdated()) {
          logger$6.log('reset anolysis state because of update');
          return anolysis.storage.init().then(() => anolysis.reset()).then(() => anolysis.storage.unload()).then(() => anolysis.unload()).then(() => storeNewVersionInPrefs()).then(() => new Anolysis(settings));
        }

        return Promise.resolve(anolysis);
      }

      /**
       * Manages new telemetry.
       */
      var Background$19 = background({
        isRunning: false,
        settings: {},

        enabled() {
          return true;
        },

        init(settings) {
          if (settings !== undefined) {
            this.settings = settings;
          }

          if (!isTelemetryEnabled()) {
            return Promise.resolve();
          }

          if (getSynchronizedDate() === null) {
            // TODO - temporary signal for debugging purpose. This allows us to detect
            // users not having anolysis enabled because `config_ts` is not available.
            CliqzUtils.telemetry({
              type: 'anolysis.no_sync_time_available'
            });

            // If `config_ts` arrives later, we can delay the loading of anolysis
            this.onPrefChange = CliqzEvents.subscribe('prefchange', pref => {
              if (pref === 'config_ts') {
                this.onPrefChange.unsubscribe();
                this.onPrefChange = undefined;

                // Init anolysis
                this.init(this.settings);
              }
            });
          } else {
            // Initialize the module - we only do that if a sync date is available

            // TODO - send ping_anolysis signal with legacy telemetry system
            // This is only meant for testing purposes and will be remove in
            // the future.
            CliqzUtils.telemetry({
              type: 'anolysis.start_init'
            });

            return this.start().then(() => {
              // TODO - send ping_anolysis signal with legacy telemetry system
              // This is only meant for testing purposes and will be remove in
              // the future.
              CliqzUtils.telemetry({
                type: 'anolysis.start_end'
              });
            }).catch(ex => {
              // TODO - send ping_anolysis signal with legacy telemetry system
              // This is only meant for testing purposes and will be remove in
              // the future.
              logger$6.error('Exception while init anolysis', ex);
              CliqzUtils.telemetry({
                type: 'anolysis.start_exception',
                exception: `${ex}`
              });
            });
          }

          return Promise.resolve();
        },

        start() {
          if (this.isRunning) return Promise.resolve();

          // Used for testing
          // this.intervalTimer = utils.setInterval(
          //   () => this.actions.generateSignals(Date.now()),
          //   ONE_MINUTE);

          return instantiateAnolysis(this.settings).then(anolysis => {
            this.anolysis = anolysis;

            // TODO
            // Register legacy telemetry signals listener. In the future this should
            // not be needed as the `utils.telemetry` function should directly call
            // the action `log` of this background (using the kord mechanism).
            this.telemetryHandler = this.events['telemetry:handleTelemetrySignal'].bind(this);
            CliqzUtils.telemetryHandlers.push(this.telemetryHandler);

            return this.actions.registerSchemas(telemetrySchemas).then(() => this.anolysis.init()).then(() => {
              this.isRunning = true;
            }).then(() => {
              // 1. Trigger sending of retention signals if needed
              // This can be done as soon as possible, the first time
              // the user starts the browser, at most once a day.
              //
              // 2. Then we check previous days (30 days max) to aggregate and send
              // telemetry if the user was not active. This task is async and will try to
              // not overload the browser.
              this.anolysis.sendRetentionSignals().then(() => {
                logger$6.log('Generate aggregated signals');
                return this.anolysis.generateAnalysesSignalsFromAggregation();
              });
            });
          });
        },

        stop() {
          if (!this.isRunning) return;

          this.isRunning = false;

          if (this.onPrefChange) {
            this.onPrefChange.unsubscribe();
            this.onPrefChange = undefined;
          }

          // TODO - this will be removed when the telemetry function makes use of this
          // module exclusively.
          // Unsubscribe telemetry listener
          const index = CliqzUtils.telemetryHandlers.indexOf(this.telemetryHandler);
          if (index !== -1) {
            CliqzUtils.telemetryHandlers.splice(index, 1);
            delete this.telemetryHandler;
          }

          this.anolysis.unload();
        },

        unload(quick) {
          if (quick === undefined) {
            // Generate uninstall signal
            // TODO: Find a way to do this, as it's hard to do it fast.
            // We need to get the GID or demographics to send with the
            // new signal + by-pass the message queue/preprocessing.
            //
            // Also, how to make sure that the message is actually sent
            // to the backend, as this is done in an async way.
          }

          this.stop();
        },

        beforeBrowserShutdown() {},

        events: {
          /**
           * @event telemetry:handleTelemetrySignal
           * @param data
           */
          'telemetry:handleTelemetrySignal'(data) {
            if (!this.isRunning) return;

            // No telemetry in private windows
            if (data.type !== 'environment' && CliqzUtils.isPrivateMode()) {
              return;
            }

            this.actions.handleTelemetrySignal(data);
          },

          /**
           * Monitor preference changes in about:config and check if we should
           * enable or disable the telemetry module.
           */
          'prefchange'(pref) {
            if (pref !== ENABLE_PREF) return;

            if (isTelemetryEnabled()) {
              this.init(this.settings);
            } else {
              this.stop();
            }
          }
        },

        actions: {
          registerSchemas(schemas) {
            return Promise.resolve().then(() => this.anolysis.registerSchemas(schemas));
          },

          handleTelemetrySignal() {
            if (!this.anolysis) {
              return Promise.resolve();
            }
            return this.anolysis.handleTelemetrySignal(...arguments);
          }
        }
      });

      class Win$20 {
        init() {}

        unload() {}
      }

      var anolysisModule = {
        Background: Background$19,
        Window: Win$20
      };

      const MAConfigs = {

        //------------------------------------------------------------
        //  GLOBAL
        //------------------------------------------------------------
        // module version
        CURRENT_VERSION: 0.6,

        // cut-off value for url length
        // any url has length more than MAX_URL_LENGTH will be ignored
        MAX_URL_LENGTH: 500,

        // is this module enabled?
        IS_ENABLED: CliqzUtils.getPref('MarketAnalysisEnabled', false),

        IS_LOGGING_ENABLED: CliqzUtils.getPref('showConsoleLogs', false),

        LOG_LEVEL: CliqzUtils.getPref('MA.LogLevel', 'log'), // log, debug

        //------------------------------------------------------------
        //  SIGNALS
        //------------------------------------------------------------

        // backend server address
        SIGNALS_BE_ADDR: CliqzUtils.getPref('MA.BackendAddr', 'https://offers-api.cliqz.com/api/v1/savemasignal'),

        // need this action to pass through hpn
        SIGNALS_HPN_BE_ACTION: 'offers-signal',

        // the code of signal type for market analysis signal
        SIGNALS_MA_TYPE: 'ma',

        // the version number of the market analysis signal structure that we are using
        SIGNALS_VERSION: 0.6,

        // how often we want to check & send (if has) the signals to the backend
        // eg: 10 minutes: 10 * 60
        SIGNALS_SEND_INTERVAL_SECS: CliqzUtils.getPref('MA.SendIntervalSecs', 600)
      };

      /**
       * the only logger you should use in this module
       * Methods: logger.debug, logger.log, logger.err, logger.logObject
       * @type {Logger}
       */
      const logger$8 = new Logger({
        useDump: false,
        level: MAConfigs.LOG_LEVEL,
        prefix: '[market-analysis]'
      });

      logger$8.logObject = obj => {
        if (MAConfigs.IS_LOGGING_ENABLED) {
          // log object while keeping its state
          // since this is an expensive operation, we do it only if logging is enabled
          logger$8.debug(JSON.parse(JSON.stringify(obj)));
        }
      };

      /* eslint-disable */

      /**
       * Get timestamp required by HPN
       * @return {String} date in string
       */
      function getHpnTimeStamp() {
        // TODO: this is the copy function from `modules/offers-v2/signals_handler`
        // Since the method is not public for external modules, at the moment, we just copy the implementation
        // Be aware that there might be problem with HPN
        return new Date().toISOString().slice(0, 10).replace(/-/g, '');
      }

      function getTopLevelCategory(category) {
        const pos = category.indexOf('.');
        if (pos !== -1) {
          return category.substring(0, pos);
        }
        return category;
      }

      function joinKeyVal(key, val) {
        return `${key}|${val}`;
      }

      function splitKeyVal(str) {
        return str.split('|');
      }

      /**
       * generator for a list
       * @param {List} list
       */
      function* generateItems(list) {
        for (var i = 0; i < list.length; i++) {
          yield list[i];
        }
      }

      /**
       * Return the Date object of now
       * should be easy to mock
       * @returns {Date}
       */
      function now() {
        return new Date();
      }

      /**
       * Class for testing a regular expression string on an url
       * regexes are also cached
       */
      class RegexHelper {
        constructor() {
          // mapping from regexString to (compiled) RegEx object of that regexString
          this.cachedRegExps = new LRU(1000);
        }

        /**
         * test a regular expression string on a given url
         * @param  {String} regexStr
         * @param  {String} url
         * @return {Boolean} match oor not
         */
        test(regexStr, url) {
          let regex = this.cachedRegExps.get(regexStr);
          if (!regex) {
            // cache missed
            regex = new RegExp(regexStr);
            this.cachedRegExps.set(regexStr, regex);
          }
          return regex.test(url);
        }
      }

      /* eslint-disable key-spacing */

      const MAGroups = {
        TL_CATEGORY: 'tlcat',
        CATEGORY: 'cat',
        DOMAIN: 'domain',
        TELEMETRY: 'tel'
      };

      const MATimeFrames = {
        DAY_OF_YEAR: 'doy',
        WEEK_OF_YEAR: 'woy',
        MONTH: 'm'
      };

      const MAMetrics = {
        //------------------------------------------------------------
        // per user metrics
        //------------------------------------------------------------
        U_VISITOR: 'uVisitor', // unique visitor
        U_REGISTRANT: 'uRegistrant', // unique registrant
        U_SHOPPER: 'uShopper', // unique shopper
        U_POT_BUYER: 'uPotBuyer', // unique potential buyer
        U_BUYER: 'uBuyer', // unique buyer

        U_IMP: 'uImp', // (unique visitor) deprecated, use U_VISITOR
        CR1_IMP: 'cr1Imp', // deprecated, to be removed
        CR1_U_IMP: 'cr1UImp', // (unique shopper) deprecated, use U_SHOPPER
        CR2_IMP: 'cr2Imp', // deprecated, to be removed
        CR2_U_IMP: 'cr2UImp', // (unique potential buyer) deprecated, use U_POT_BUYER

        //------------------------------------------------------------
        // per activity metrics
        // based on session: x-seconds inactivity on a particular domain, or browser is closed
        //------------------------------------------------------------
        IMP: 'imp', // an impression (5-second-session)
        VISIT: 'v', // a visit is at least an impression in 30-minute-session
        REGISTRATION: 'reg', // a registration (30-minute-session)
        SHOPPING: 'sho', // a shopping action (add item to basket, visit "my basket" page, ...) (5-minute-session)
        CHECKOUT: 'chk', // a checkout action (payment, coupons, shipping, ... pages) (30-minute-session)
        TRANSACTION: 'tra' // a successful transaction (30-minute-session)
      };

      /**
       * Class for building a "market analysis signal" to be sent to the backend
       */
      class MASignalBuilder {
        /**
         * Build signal object for non-unique metrics
         * Sample signal data
         * {
         *   "isUniqueMetrics": false,
         *   "groups": {
         *     "domain": "matratzen-concord.de",
         *     "cat": "Home.Bed",
         *     "tlcat": "Home"
         *   },
         *   "tfs": {
         *     "doy": "177"
         *   },
         *   "metrics": {
         *     "imp": 5,
         *     "v": 1,
         *     "reg": 1,
         *     "sho": 1,
         *     "chk": 1,
         *     "tra": 1
         *   }
         * }
         * @param  {String}     domain
         * @param  {String}     cat
         * @param  {String}     tlcat
         * @param  {Number}     dayOfYearVal
         * @param  {Object}     stats
         * @return {Object}
         */
        static buildSignalForNonUniqueMetrics(domain, cat, tlcat, dayOfYearVal, stats) {
          const dict = {};
          dict.isUniqueMetrics = false;
          const groupContainer = {};
          groupContainer[MAGroups.DOMAIN] = domain;
          groupContainer[MAGroups.CATEGORY] = cat;
          groupContainer[MAGroups.TL_CATEGORY] = tlcat;
          dict.groups = groupContainer;

          const tfContainer = {};
          tfContainer[MATimeFrames.DAY_OF_YEAR] = dayOfYearVal;
          dict.tfs = tfContainer;

          const metrics = [MAMetrics.IMP, MAMetrics.VISIT, MAMetrics.REGISTRATION, MAMetrics.SHOPPING, MAMetrics.CHECKOUT, MAMetrics.TRANSACTION];
          const metricsContainer = {};
          metrics.forEach(metric => {
            if (stats[metric]) {
              metricsContainer[metric] = stats[metric];
            }
          });

          dict.metrics = metricsContainer;
          return dict;
        }

        /**
         * Build signal object for unique metrics
         * Sample signal:
         * {
         *   "isUniqueMetrics": true,
         *   "group": {
         *     "domain": "matratzen-concord.de"
         *   },
         *   "records": [{
         *     "metrics": {
         *       "uVisitor": 1,
         *       "uRegistrant": 1,
         *       "uPotBuyer": 1,
         *       "uBuyer": 1,
         *       "uShopper": 1
         *     },
         *     "tf": {
         *       "doy": "177"
         *     }
         *   }, {
         *     "metrics": {
         *       "uVisitor": 1,
         *       "uRegistrant": 1,
         *       "uPotBuyer": 1,
         *       "uBuyer": 1,
         *       "uShopper": 1
         *     },
         *     "tf": {
         *       "woy": "26"
         *     }
         *   }, {
         *     "metrics": {
         *       "uVisitor": 1,
         *       "uRegistrant": 1,
         *       "uPotBuyer": 1,
         *       "uBuyer": 1,
         *       "uShopper": 1
         *     },
         *     "tf": {
         *       "m": "6"
         *     }
         *   }]
         * }
         * @param  {String} group
         * @param  {String} groupVal
         * @param  {Object} records
         * @return {Object}
         */
        static buildSignalForUniqueMetrics(group, groupVal, records) {
          const dict = {};
          dict.isUniqueMetrics = true;
          const groupContainer = {};
          groupContainer[group] = groupVal;
          dict.group = groupContainer;

          dict.records = records;
          return dict;
        }
      }

      /**
       * Class for storing visit history { domain: timestamp_of_last_visit }
       */
      class SessionChecker {
        constructor() {
          // mapping from domain to timestamp of the latest visit
          this.domainToLastVisit = new LRU(1000);
        }

        /**
         * check if an impression on a given (domain, metric, date) is a new session or not
         * a session: x-minute inactivity on a particular (domain, metric) or browser is closed
         * @param {string} domain        tldomain (registered domain)
         * @param {string} metric        session-based metric
         * @param {Date}   visitDate
         * @returns {boolean}
         */
        isNewSession(domain, metric, visitDate) {
          const key = domain + metric;
          const lastVisitTime = this.domainToLastVisit.get(key);
          this.domainToLastVisit.set(key, visitDate.getTime());
          if (lastVisitTime) {
            const diffSeconds = (visitDate.getTime() - lastVisitTime) / 1000;
            switch (metric) {
              case MAMetrics.VISIT:
              case MAMetrics.REGISTRATION:
              case MAMetrics.SHOPPING:
              case MAMetrics.CHECKOUT:
              case MAMetrics.TRANSACTION:
                {
                  // 30-minute session
                  return diffSeconds >= 1800;
                }
              case MAMetrics.IMP:
                {
                  return true;
                }

              default:
                {
                  logger$8.error(`Unrecognized metric: ${metric}`);
                  break;
                }
            }
            return false;
          }
          return true;
        }
      }

      /**
       * Class representing different time frames for a particular date
       */
      class TimeFrames {
        constructor(date) {
          const daysDiff = (date - new Date(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1000;
          this.dayOfYear = Math.floor(daysDiff);
          this.month = date.getMonth() + 1; // month in JS starts from zero

          const d = new Date(+date);
          d.setHours(0, 0, 0, 0);
          d.setDate(d.getDate() + 4 - (d.getDay() || 7));
          this.weekOfYear = Math.ceil(((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7 + 1) / 7);
        }

        /**
         * get a new TimeFrames object representing today
         * @return {TimeFrames}
         */
        static fromToday() {
          const serverDateStr = prefs.get('config_ts', null);
          if (serverDateStr) {
            const year = Number(serverDateStr.substr(0, 4));
            const month = Number(serverDateStr.substr(4, 2));
            const day = Number(serverDateStr.substr(6, 2));
            return new TimeFrames(new Date(year, month - 1, day, 1));
          }
          return new TimeFrames(new Date());
        }

        /**
         * get time frame value`
         * @param  {MATimeFrames} tf
         * @return {Number}
         */
        getTFValue(tf) {
          switch (tf) {
            case MATimeFrames.DAY_OF_YEAR:
              return this.dayOfYear;
            case MATimeFrames.WEEK_OF_YEAR:
              return this.weekOfYear;
            case MATimeFrames.MONTH:
              return this.month;
            default:
              return undefined;
          }
        }
      }

      /**
       * Using PouchDB
       */
      class DataAccessProvider {
        constructor() {
          this.db = new DB('market-analysis', { revs_limit: 1, auto_compaction: true });
          this.STORAGE_KEY = 'webstats';

          this.db.info().then(info => {
            logger$8.log(`Current Database Info: ${JSON.stringify(info)}`);
          });
        }

        /**
        * load MATable from local storage database
        * @param  {Function} callback - callback function
        */
        loadMATable(callback) {
          this._getDocData(this.STORAGE_KEY).then(docData => {
            if (!docData) {
              logger$8.log(`Warning: ${this.STORAGE_KEY} does not exist`);
            }
            callback(docData);
          });
        }

        /**
        * save MATable to local storage database
        * @param  {Object} maTable MATable
        */
        saveMATable(maTable) {
          if (!maTable) {
            logger$8.log('Skipping the load of storage data');
            return;
          }
          this._saveDocData(this.STORAGE_KEY, maTable);
        }

        removeMATable() {
          this._removeDocData(this.STORAGE_KEY);
        }

        _saveDocData(docID, docData) {
          const self = this;
          return this.db.get(docID).catch(() => ({ _id: docID, doc_data: {} })).then(data => {
            const doc = Object.assign({}, data, {
              doc_data: Object.assign({}, data.doc_data, docData)
            });
            return self.db.put(doc);
          });
        }

        _getDocData(docID) {
          return this.db.get(docID).then(doc => doc.doc_data).catch(err => {
            logger$8.debug(`Error getting doc ${docID} with err: ${err}`);
            return null;
          });
        }

        _removeDocData(docID) {
          const self = this;
          return self.db.get(docID).then(doc => {
            logger$8.debug(`Removing doc ${docID}`);
            return self.db.remove(doc);
          }).then(() => {
            // nothing to do
            logger$8.debug(`Doc ${docID} removed properly`);
          }).catch(err => {
            // nothing to do there
            logger$8.error(`Something happened removing the doc: ${docID} - err: ${err}`);
          });
        }
      }

      /**
       * Class communicating with backend server
       */
      class CommunicationProvider {
        constructor(endPointAddress) {
          this.endPointAddress = endPointAddress;
          this.channel = config.settings.HW_CHANNEL;
        }

        /**
         * send a signal to backend
         * @param  {Object} signalObject      signal object to be sent
         * @param  {Function} successCallback
         * @param  {Function} errCallback
         */
        sendSignalToBE(signalObject, successCallback, errCallback) {
          const hpnSignal = {
            action: MAConfigs.SIGNALS_HPN_BE_ACTION,
            signal_id: 'ma', // TODO: not very useful at the moment
            timestamp: getHpnTimeStamp(),
            payload: {
              v: MAConfigs.SIGNALS_VERSION,
              channel: this.channel,
              type: MAConfigs.SIGNALS_MA_TYPE,
              data: signalObject
            }
          };

          const hpnStrSignal = JSON.stringify(hpnSignal);
          CliqzUtils.httpPost(this.endPointAddress, succ => {
            successCallback(signalObject, succ);
          }, hpnStrSignal, err => {
            errCallback(signalObject, err);
          });
          logger$8.log(`Sending signal to BE: ${hpnStrSignal}`);
        }
      }

      var _slicedToArray$20 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      // import utilities
      // import configuration
      // import models
      // import services
      /**
       * Entry point of the module
       * @type {Object}
       */
      const CliqzMarketAnalyzer = {
        // data access provider
        dataAccessProvider: new DataAccessProvider(),
        // communication provider
        communicationProvider: new CommunicationProvider(MAConfigs.SIGNALS_BE_ADDR),
        // object recording ma stats, will be saved to ma database
        maTable: {},
        // json file of regexes for checkouts & categories
        regexMappings: null,
        // database is modified
        dbModified: false,

        regexHelper: new RegexHelper(),

        sessionChecker: new SessionChecker(),

        logCurrentMATable() {
          logger$8.debug('Current MATable:');
          logger$8.logObject(this.maTable);
        },

        /**
         * this function is called whenever the browser starts
         */
        init() {
          const self = this;
          self.dataAccessProvider.loadMATable(docData => {
            if (docData) {
              self.maTable = docData;
              logger$8.log('>>> Loaded MATable <<<');
              self.logCurrentMATable();
              self._upgradeMATable();
              logger$8.log('>>> Upgraded MATable <<<');
              self.logCurrentMATable();
            } else {
              logger$8.log('>>> No Database to Load <<<');
            }
            self._startSendSignalsLoop(MAConfigs.SIGNALS_SEND_INTERVAL_SECS);
          });
        },

        /**
         * upgrade MATable from v0.1 to v0.2
         * since there are some changes in the metric names and metric codes
         * this will be removed at some point
         * @private
         */
        _upgradeMATable() {
          const self = this;
          Object.keys(self.maTable).forEach(maGroupStr => {
            Object.keys(self.maTable[maGroupStr]).forEach(timeFrameStr => {
              const maStats = self.maTable[maGroupStr][timeFrameStr];
              Object.keys(maStats).forEach(metric => {
                if (metric === MAMetrics.CR1_IMP || metric === MAMetrics.CR2_IMP) {
                  delete maStats[metric];
                  this.dbModified = true;
                }

                if (metric === MAMetrics.U_IMP) {
                  maStats[MAMetrics.U_VISITOR] = maStats[metric];
                  delete maStats[metric];
                  this.dbModified = true;
                }

                if (metric === MAMetrics.CR1_U_IMP) {
                  maStats[MAMetrics.U_SHOPPER] = maStats[metric];
                  delete maStats[metric];
                  this.dbModified = true;
                }

                if (metric === MAMetrics.CR2_U_IMP) {
                  maStats[MAMetrics.U_POT_BUYER] = maStats[metric];
                  delete maStats[metric];
                  this.dbModified = true;
                }
              });
            });
          });
          self._persistCurrentMATable();
        },

        _addTelemetryStats() {
          const telemetryGroupStr = joinKeyVal(MAGroups.TELEMETRY, 'any');
          const todayTFs = TimeFrames.fromToday();
          if (!(telemetryGroupStr in this.maTable)) {
            this.maTable[telemetryGroupStr] = {};
          }
          const groupContainer = this.maTable[telemetryGroupStr];
          Object.keys(MATimeFrames).forEach(tfKey => {
            const tf = MATimeFrames[tfKey];
            const todayTFStr = joinKeyVal(tf, todayTFs.getTFValue(tf));

            if (!(todayTFStr in groupContainer)) {
              groupContainer[todayTFStr] = this._newTelemetryRecord();
              this.dbModified = true;
            }
          });

          if (this.dbModified) {
            logger$8.debug('added telemetry stats');
            this._persistCurrentMATable();
          }
        },

        /**
         * persist current MATable
         */
        _persistCurrentMATable() {
          if (this.dbModified) {
            logger$8.debug('saving the current MATable:');
            logger$8.logObject(this.maTable);
            this.dataAccessProvider.saveMATable(this.maTable);
            this.dbModified = false;
          }
        },

        /**
         * Find old stats. This function runs periodically
         * If any, send them to the backend and then remove them from local database
         */
        _sendOldStats() {
          logger$8.debug('>>> Finding stats to send..');
          if (!this.maTable) return;

          const self = this;
          const todayTFs = TimeFrames.fromToday();
          const signalsToSend = [];

          // Looking for old stats in maTable
          // If has, send & remove the old stats
          Object.keys(self.maTable).forEach(maGroupStr => {
            const tfContainers = Object.keys(self.maTable[maGroupStr]);
            if (tfContainers.length === 0) {
              delete self.maTable[maGroupStr];
              self.dbModified = true;
              return;
            }

            var _splitKeyVal = splitKeyVal(maGroupStr),
                _splitKeyVal2 = _slicedToArray$20(_splitKeyVal, 2);

            const group = _splitKeyVal2[0],
                  groupVal = _splitKeyVal2[1];

            // used for accumulating (tf, unique metrics) of signal
            // send only one signal (with unique metrics) per maGroup
            // subject to changes. This is the fight between privacy & performance

            const uniqueRecords = [];
            tfContainers.forEach(timeFrameStr => {
              var _splitKeyVal3 = splitKeyVal(timeFrameStr),
                  _splitKeyVal4 = _slicedToArray$20(_splitKeyVal3, 2);

              const timeFrame = _splitKeyVal4[0],
                    timeFrameVal = _splitKeyVal4[1];

              const todayTFStr = joinKeyVal(timeFrame, todayTFs.getTFValue(timeFrame));
              if (todayTFStr) {
                const maStats = self.maTable[maGroupStr][timeFrameStr];

                if (group === MAGroups.DOMAIN && timeFrame === MATimeFrames.DAY_OF_YEAR) {
                  if (self._isNotEmptyNonUniqueStats(maStats)) {
                    // send only one signal (with nonunique metrics) per domain
                    // subject to changes. This is the fight between privacy vs performance
                    const domainMappings = self.regexMappings[groupVal];
                    let category = '';
                    if ('cat' in domainMappings) {
                      category = domainMappings.cat;
                    }
                    const tlCategory = getTopLevelCategory(category);
                    const signal = MASignalBuilder.buildSignalForNonUniqueMetrics(groupVal, category, tlCategory, timeFrameVal, maStats);
                    signalsToSend.push(signal);
                  }
                }

                const uniqueRecord = {};
                uniqueRecord.metrics = {};
                Object.keys(maStats).forEach(metric => {
                  if (this._isUniqueMetric(metric)) {
                    const metricVal = maStats[metric];
                    if (metricVal !== -1) {
                      // -1 is marked for delete
                      uniqueRecord.metrics[metric] = metricVal;
                    }
                  }
                });

                if (Object.keys(uniqueRecord.metrics).length > 0) {
                  uniqueRecord.tf = {};
                  uniqueRecord.tf[timeFrame] = timeFrameVal;
                  uniqueRecords.push(uniqueRecord);
                }

                // also remove empty records
                if (self._isOldAndEmptyTFRecord(todayTFStr, timeFrameStr, maStats)) {
                  delete self.maTable[maGroupStr][timeFrameStr];
                  self.dbModified = true;
                }
              } else {
                logger$8.error(`Cannot parse todayTFStr for ${timeFrameStr}`);
              }
            });

            if (Object.keys(uniqueRecords).length > 0) {
              const signal = MASignalBuilder.buildSignalForUniqueMetrics(group, groupVal, uniqueRecords);
              signalsToSend.push(signal);
            }
          });

          if (signalsToSend.length > 0) {
            this._sendSignals(signalsToSend);
          }
          self._persistCurrentMATable();
        },

        /**
         * send signals sequentially
         * @param  {List<Object>} signals
         */
        _sendSignals(signals) {
          const self = this;
          const generator = generateItems(signals);
          function sendNextSignal() {
            const nextItem = generator.next();
            if (nextItem.value) {
              const maSignal = nextItem.value;
              self.communicationProvider.sendSignalToBE(maSignal, (sentSig, succ) => {
                logger$8.log(`Signal sent successfully. Success: ${succ}`);
                // mark for delete or update the metricVal
                const isUniqueMetrics = sentSig.isUniqueMetrics;
                if (!isUniqueMetrics) {
                  const sentGroupStr = joinKeyVal(MAGroups.DOMAIN, sentSig.groups[MAGroups.DOMAIN]);
                  const sentTFStr = joinKeyVal(MATimeFrames.DAY_OF_YEAR, sentSig.tfs[MATimeFrames.DAY_OF_YEAR]);
                  Object.keys(sentSig.metrics).forEach(m => {
                    self.maTable[sentGroupStr][sentTFStr][m] -= sentSig.metrics[m];
                  });
                } else {
                  const sentGroup = Object.keys(sentSig.group)[0];
                  const sentGroupStr = joinKeyVal(sentGroup, sentSig.group[sentGroup]);
                  const records = sentSig.records;
                  records.forEach(rec => {
                    const sentTF = Object.keys(rec.tf)[0];
                    const sentTFStr = joinKeyVal(sentTF, rec.tf[sentTF]);
                    Object.keys(rec.metrics).forEach(m => {
                      if (rec.metrics[m] === 1) {
                        self.maTable[sentGroupStr][sentTFStr][m] = -1;
                      }
                    });
                  });
                }
                self.dbModified = true;
                self._persistCurrentMATable();
                self.sendSignalTO = CliqzUtils.setTimeout(sendNextSignal, 1000);
              }, (sentSig, err) => {
                logger$8.log(`Failed to send signal. Error: ${err}`);
                self.sendSignalTO = CliqzUtils.setTimeout(sendNextSignal, 1000);
              });
            }
          }
          sendNextSignal();
        },

        /**
         * start the SendSignalLoop process
         * @param  {number} timeToSendSecs - time to send in seconds
         */
        _startSendSignalsLoop(timeToSendSecs) {
          const self = this;
          function startNextSignalLoop() {
            self._addTelemetryStats();
            self._sendOldStats();
            self.sendSignalLoopTO = CliqzUtils.setTimeout(startNextSignalLoop, timeToSendSecs * 1000);
          }
          // start sending the first signals after 1 minute, just in case HPN hasn't been loaded yet
          self.sendSignalLoopTO = CliqzUtils.setTimeout(startNextSignalLoop, 60 * 1000);
        },

        /**
         * callback function whenever the current url changes
         * If a regex matches, we analyze that match
         * @param  {string} currentUrl
         */
        matchURL(currentUrl) {
          const url = currentUrl.toLowerCase();
          logger$8.debug(`current url: ${currentUrl}`);
          // cut-off on url's length
          if (url.length <= MAConfigs.MAX_URL_LENGTH) {
            // domain here is a top-level domain (registered domain)
            const domain = CliqzUtils.getDetailsFromUrl(url).domain;
            if (domain && this.regexMappings && this.regexMappings[domain]) {
              const domainMappings = this.regexMappings[domain];
              let category = '';
              if ('cat' in domainMappings) {
                category = domainMappings.cat;
              }
              if ('regexes' in domainMappings) {
                Object.keys(domainMappings.regexes).forEach(metric => {
                  const regexesForThisMetric = domainMappings.regexes[metric];
                  regexesForThisMetric.some(regexStr => {
                    // linear search, looking for the first match only in each metric
                    if (regexStr === '.' || this.regexHelper.test(regexStr, url)) {
                      logger$8.debug(`A pattern matches: url=${url}, domain=${domain}, category=${category}, regex=${regexStr}`);
                      CliqzMarketAnalyzer.analyzeMAMatch(domain, category, metric);
                      return true;
                    }
                    return false;
                  });
                });
              } else {
                logger$8.error(`Missing "regexes" for domain ${domain}`);
              }
            }
          }
        },

        /**
         * Handle a (url, regex pattern) match
         * Analyze the match, checking against current MATable
         * Update MATable accordingly
         * @param  {String} domain - domain of the url
         * @param  {String} category - category of domain
         * @param  {String} metric - metric matched in mappings.json
         */
        analyzeMAMatch(domain, category, metric) {
          const maGroups = [joinKeyVal(MAGroups.DOMAIN, domain)];
          if (category) {
            const tlCategory = getTopLevelCategory(category);
            maGroups.push(joinKeyVal(MAGroups.CATEGORY, category));
            maGroups.push(joinKeyVal(MAGroups.TL_CATEGORY, tlCategory));
          }
          const todayTFs = TimeFrames.fromToday();
          maGroups.forEach(maGroupStr => {
            if (!(maGroupStr in this.maTable)) {
              this.maTable[maGroupStr] = {};
              this.dbModified = true;
            }
            const groupContainer = this.maTable[maGroupStr];
            Object.keys(MATimeFrames).forEach(tfKey => {
              const tf = MATimeFrames[tfKey];
              // only store non-unique metrics when
              // time frame type is day of year and group is domain
              const uniqueOnly = tf !== MATimeFrames.DAY_OF_YEAR || splitKeyVal(maGroupStr)[0] !== MAGroups.DOMAIN;
              const todayTFStr = joinKeyVal(tf, todayTFs.getTFValue(tf));
              if (todayTFStr in groupContainer) {
                // there is an existing stats for this time frame
                // just increase the number of impression
                let maStats = groupContainer[todayTFStr];
                maStats = this._updateMetricRecord(domain, maStats, metric, uniqueOnly);
                groupContainer[todayTFStr] = maStats;
              } else {
                // never have stats for this time frame
                groupContainer[todayTFStr] = this._updateMetricRecord(domain, {}, metric, uniqueOnly);
              }
              this.dbModified = true;
            });
          });
          this._persistCurrentMATable();
        },

        /**
         * update stats record when there is a new impression on a given metric code
         * @param  {String} domain        domain (registered domain)
         * @param  {Object} maStats       stats record
         * @param  {String} metric        metric code in mappings.json
         * @param  {Boolean} uniqueOnly   whether to update nonUnique metrics
         * @param  {Boolean} isNewSession whether this impression is a new session or not
         * @return {Object}               updated maStats
         */
        _updateMetricRecord(domain, maStats, metric, uniqueOnly) {
          const dict = maStats;
          let nonUniqueMetricCodes = [],
              uniqueMetricCode = '';

          switch (metric) {
            case 'v':
              {
                nonUniqueMetricCodes.push(MAMetrics.IMP);
                nonUniqueMetricCodes.push(MAMetrics.VISIT);
                uniqueMetricCode = MAMetrics.U_VISITOR;
                break;
              }
            case 'reg':
              {
                nonUniqueMetricCodes = [MAMetrics.REGISTRATION];
                uniqueMetricCode = MAMetrics.U_REGISTRANT;
                break;
              }
            case 'sho':
              {
                nonUniqueMetricCodes = [MAMetrics.SHOPPING];
                uniqueMetricCode = MAMetrics.U_SHOPPER;
                break;
              }
            case 'chk':
              {
                nonUniqueMetricCodes = [MAMetrics.CHECKOUT];
                uniqueMetricCode = MAMetrics.U_POT_BUYER;
                break;
              }
            case 'tra':
              {
                nonUniqueMetricCodes = [MAMetrics.TRANSACTION];
                uniqueMetricCode = MAMetrics.U_BUYER;
                break;
              }
            default:
              {
                logger$8.error(`Unrecognized metric: ${metric}`);
                break;
              }
          }

          if (!uniqueOnly) {
            nonUniqueMetricCodes.forEach(nonUniqueMetricCode => {
              const isNewSession = this.sessionChecker.isNewSession(domain, nonUniqueMetricCode, now());
              if (maStats[nonUniqueMetricCode]) {
                if (isNewSession) {
                  dict[nonUniqueMetricCode] += 1;
                }
              } else {
                dict[nonUniqueMetricCode] = 1;
              }
            });
          }
          if (!maStats[uniqueMetricCode]) {
            // new impression
            dict[uniqueMetricCode] = 1;
          }
          return dict;
        },

        _newTelemetryRecord() {
          return { [MAMetrics.U_VISITOR]: 1 };
        },

        _isUniqueMetric(metric) {
          return metric === MAMetrics.U_VISITOR || metric === MAMetrics.U_REGISTRANT || metric === MAMetrics.U_SHOPPER || metric === MAMetrics.U_POT_BUYER || metric === MAMetrics.U_BUYER;
        },

        _isNotEmptyNonUniqueStats(maStats) {
          const imp = maStats[MAMetrics.IMP] || 0;
          const visit = maStats[MAMetrics.VISIT] || 0;
          const registration = maStats[MAMetrics.REGISTRATION] || 0;
          const shopping = maStats[MAMetrics.SHOPPING] || 0;
          const checkout = maStats[MAMetrics.CHECKOUT] || 0;
          const transaction = maStats[MAMetrics.TRANSACTION] || 0;
          return imp !== 0 || visit !== 0 || registration !== 0 || shopping !== 0 || checkout !== 0 || transaction !== 0;
        },

        _isOldAndEmptyTFRecord(todayTFStr, timeFrameStr, maStats) {
          if (todayTFStr !== timeFrameStr) {
            // TODO: should we check todayTFStr > timeFrameStr?
            let canDelete = true;
            Object.keys(maStats).forEach(metric => {
              const metricVal = maStats[metric];
              if (metricVal > 0) {
                canDelete = false;
              }
            });
            return canDelete;
          }
          return false;
        }
      };

      /**
        @namespace marker-analysis
        @module marker-analysis
        @class Background
       */
      var Background$20 = background({
        /**
          @method init
          @param settings
        */
        init() {
          if (MAConfigs.IS_ENABLED) {
            CliqzMarketAnalyzer.init();
            // The content of this file is subject to change
            // The file is shipped together with the releases
            const url = 'chrome://cliqz/content/market-analysis/mappings.json';
            CliqzUtils.httpGet(url, res => {
              CliqzMarketAnalyzer.regexMappings = JSON.parse(res.response);
              this.initialized = true;
              logger$8.log('>>> Loaded mappings.json <<<');

              // log configurations:
              if (MAConfigs.LOG_LEVEL === 'debug') {
                logger$8.log(`Backend Addresss: ${MAConfigs.SIGNALS_BE_ADDR}`);
                logger$8.log(`Signal version: ${MAConfigs.SIGNALS_VERSION}`);
                logger$8.log(`Send Signal Interval (s) : ${MAConfigs.SIGNALS_SEND_INTERVAL_SECS}`);
              }
            });
          }
        },

        unload() {
          if (CliqzMarketAnalyzer.sendSignalTO) {
            CliqzUtils.clearTimeout(CliqzMarketAnalyzer.sendSignalTO);
          }
          if (CliqzMarketAnalyzer.sendSignalLoopTO) {
            CliqzUtils.clearTimeout(CliqzMarketAnalyzer.sendSignalLoopTO);
          }
        },

        beforeBrowserShutdown() {},

        events: {
          'content:location-change': function onLocationChange(_ref) {
            let url = _ref.url,
                isPrivate = _ref.isPrivate;

            if (this.initialized && !isPrivate) {
              CliqzMarketAnalyzer.matchURL(url);
            }
          }
        },

        actions: {}
      });

      class Win$21 {
        init() {}

        unload() {}
      }

      var marketAnalysisModule = {
        Background: Background$20,
        Window: Win$21
      };

      const CORRECT_VERSION_PART = /^\d+$/;
      const CORRECT_OPTIONAL_PART = /^\w+$/;

      /*
       * Parse version in format A.B.C.1bN.
       */
      function getCoreVersion() {
        let version = CliqzUtils.extensionVersion;

        // Caused by a bug in versions, at some point
        if (version === '3.9.0-beta.3') {
          version = '3.9.0';
        }

        const parts = version.split('.');

        while (parts.length < 3) {
          parts.push('0');
        }

        let correctFormat = true;
        for (let i = 0; i < 3; i += 1) {
          if (!CORRECT_VERSION_PART.test(parts[i])) {
            correctFormat = false;
          }
        }

        // Check optional part x.y.z.optional
        if (parts.length > 3) {
          if (parts.length > 4) {
            correctFormat = false;
          } else if (!CORRECT_OPTIONAL_PART.test(parts[3])) {
            correctFormat = false;
          }
        }

        if (correctFormat) {
          return parts.join('.');
        }

        return null;
      }

      const ABTESTS_BACKEND_URL = 'https://abtests.cliqz.com/abtests';

      class Client {
        fetchJson(url, method, payload) {
          const headers = new Headers();
          headers.append('Content-Type', 'application/json');
          const request = new Request(url, {
            headers,
            method,
            body: JSON.stringify(payload) });
          return fetch(request).then(response => {
            if (!response.ok) {
              return Promise.reject(`Backend ${url} answered with code ${response.status}`);
            }
            return response.json();
          });
        }

        get(url, payload) {
          return this.fetchJson(url, 'GET', payload);
        }

        post(url, payload) {
          return this.fetchJson(url, 'POST', payload);
        }

        getAvailableTests() {
          return this.get(`${ABTESTS_BACKEND_URL}/get`);
        }

        enterTest(id, group) {
          return this.post(`${ABTESTS_BACKEND_URL}/enter`, { test_id: id, group }).then(data => data.success);
        }

        leaveTest(id, group) {
          return this.post(`${ABTESTS_BACKEND_URL}/leave`, { test_id: id, group }).then(data => data.success);
        }
      }

      var momentRange = lazyLoader('moment-range.js', 'moment-range');

      var logger$10 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[abtests]'
      });

      var _extends$16 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _slicedToArray$21 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint { "no-return-assign": "off" } */

      momentRange.extendMoment(moment);

      // only visible to this module
      const MODULE_STORAGE_RUNNING_KEY = 'abtests.running';
      const MODULE_STORAGE_COMPLETED_KEY = 'abtests.completed';
      // visible to other modules
      const SHARED_STORAGE_KEY = 'abtests_running';
      const DATE_FORMAT$1 = 'YYYY/MM/DD';

      const has = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      const now$1 = () => getSynchronizedDate().format(DATE_FORMAT$1);

      // TODO:
      // * support unlimited treatment lengths (?)

      /*
       * Manages AB tests.
       */
      class Manager {
        constructor(client, moduleStorage, sharedStorage) {
          this.client = client;
          this.moduleStorage = moduleStorage;
          this.sharedStorage = sharedStorage;
          this.runningTests = {};
          this.completedTests = {};
        }

        /*
         * Loads tests from persistent storage.
         */
        loadTests() {
          return Promise.all([this.moduleStorage.get(MODULE_STORAGE_RUNNING_KEY, {}).then(tests => this.runningTests = tests), this.moduleStorage.get(MODULE_STORAGE_COMPLETED_KEY, {}).then(tests => this.completedTests = tests)]);
        }

        /*
         * Saves tests to persistent storage.
         */
        saveTests() {
          return Promise.all([this.moduleStorage.set(MODULE_STORAGE_RUNNING_KEY, this.runningTests), this.moduleStorage.set(MODULE_STORAGE_COMPLETED_KEY, this.completedTests), this.sharedStorage.set(SHARED_STORAGE_KEY, JSON.stringify(Object.keys(this.runningTests).map(id => `${id}_${this.runningTests[id].group}`)))]);
        }

        /*
         * Fetches tests from remote, starts new tests, and stops expired tests.
         */
        updateTests() {
          // (1) get available tests from remote
          return this.client.getAvailableTests().then(availableTests => {
            // (2) update running tests
            this.updateRunningTests(availableTests);
            // (3) get new tests
            const newTests = this.getNewTests(availableTests);

            // (4) decide which tests to start and stop
            return Promise.all([this.getExpiredTests(),
            // `getUpcomingTests` calls `client.enterTest`
            this.getUpcomingTests(newTests)]);
          })
          // (5) start and stop selected tests; tell remote about stopped tests
          .then(_ref => {
            var _ref2 = _slicedToArray$21(_ref, 2);

            let expiredTests = _ref2[0],
                upcomingTests = _ref2[1];
            return Promise.all([...expiredTests.map(test => this.stopTest(test).then(stoppedTest => this.client.leaveTest(stoppedTest))), ...upcomingTests.map(test => this.startTest(test))]);
          })
          // (6) persist state
          .then(() => {
            this.saveTests();
            logger$10.log('Updated tests');
          });
        }

        /*
         * Sets test-specific prefs and adds test to running tests. Does not check
         * for eligibility and does not communicate with remote server. Overwrites
         * data if test with same id already exists.
         *
         * @param {Object} test - The test to start.
         * @returns {Object} test - The started test.
         */
        startTest(test) {
          const prefs = test.groups[test.group];
          return Promise.all(Object.keys(prefs).map(key => this.sharedStorage.set(key, prefs[key]))).then(() => {
            this.runningTests[test.id] = _extends$16({}, test, { started: now$1() });
            logger$10.log(`Started test ${test.id} (${test.name}) in group ${test.group}`);
            return test;
          });
        }

        /*
         * Clears test-specific prefs, removes test from running tests, and adds
         * test to completed tests. Does not check if test was actually running and
         * does not communicate with remote server.
         *
         * @param {Object} test - The test to stop.
         * @returns {Object} test - The stopped test.
         */
        stopTest(test) {
          const prefs = test.groups[test.group];
          return Promise.all(Object.keys(prefs).map(key => this.sharedStorage.remove(key))).then(() => {
            delete this.runningTests[test.id];
            this.completedTests[test.id] = _extends$16({}, test, { completed: now$1() });
            logger$10.log(`Stopped test ${test.id} (${test.name}) in group ${test.group}`);
            return test;
          });
        }

        /*
         * Updates 'status' and 'end date' of running tests from available tests.
         *
         * @param {Object[]} availableTests - The list of available tests.
         * @returns {Object} - The dictionary of running tests after updating.
         */
        updateRunningTests(availableTests) {
          availableTests.forEach(test => {
            if (has(this.runningTests, test.id)) {
              this.runningTests[test.id].status = test.status;
              this.runningTests[test.id].end_date = test.end_date;
            }
          });
        }

        /*
         * Gets tests from available tests that are neither currently running nor
         * have been running before (i.e., are not amongst the completed tests.)
         *
         * @param {Object[]} availableTests - The list of available tests.
         * @returns {Object[]} - The list of new tests.
         */
        getNewTests(availableTests) {
          return availableTests.filter(test => !has(this.runningTests, test.id) && !has(this.completedTests, test.id));
        }

        /*
         * Finds running tests that need to be stopped (e.g., because they have been
         * completed).
         *
         * @returns {Object[]} - The list of tests to leave.
         */
        getExpiredTests() {
          return Object.keys(this.runningTests).map(id => this.runningTests[id]).filter(test => this.shouldStopTest(test));
        }

        /*
         * Gets tests to start from new tests. A test is to be started if (1) all
         * local test criteria are fulfilled (see `shouldStartTest`) and (2) the
         * remote server accepts this user (see `client.enterTest`). Note that--when
         * this method returns--the remote server has already counted tests as
         * started, even though the tests have not yet been started locally.
         *
         * @param {Object[]} newTests - The list of new tests.
         * @returns {Object[]} - The list of tests to start.
         */
        getUpcomingTests(newTests) {
          return Promise.all(
          // (1) check (locally) which tests should start
          newTests.map(test => this.shouldStartTest(test).then(shouldStart => ({ test, shouldStart })))).then(reports => {
            const pendingTests = {};
            const upcomingTests = reports
            // (2) remove tests that should not start
            .filter(_ref3 => {
              let shouldStart = _ref3.shouldStart;
              return shouldStart;
            }).map(_ref4 => {
              let test = _ref4.test;
              return test;
            })
            // (3) remove competing tests
            .filter(test => {
              const isCompeting = this.isTestCompeting(test, _extends$16({}, pendingTests, this.runningTests, this.completedTests));
              if (!isCompeting) {
                pendingTests[test.id] = test;
              }
              return !isCompeting;
            })
            // (4) assign test groups
            .map(test => _extends$16({}, test, { group: this.chooseTestGroup(test) }));

            // (5) check (remotely) which tests can be entered
            return Promise.all(upcomingTests.map(test => this.client.enterTest(test.id, test.group).then(success => ({ test, success })).catch(() => ({ test, success: false }))));
          })
          // (6) remove tests that were not entered
          .then(reports => reports.filter(_ref5 => {
            let success = _ref5.success;
            return success;
          }).map(_ref6 => {
            let test = _ref6.test;
            return test;
          }));
        }

        /*
         * Chooses from available test groups with equal probability.
         *
         * @param {Object} test - The test.
         */
        chooseTestGroup(test) {
          const groups = Object.keys(test.groups);
          const index = parseInt(random() * groups.length, 10);
          return groups[index];
        }

        /*
         * Checks if user should start the rest based on user demographics, test-
         * -specfic enter probability, etc. Does not check remote or if user is
         * already in test.
         *
         * @param {Object} test - The test.
         * @returns {Boolean} - True, if the test should be started.
         */
        shouldStartTest(test) {
          if (!this.isTestActive(test) || !this.isVersionMatch(test)) {
            return Promise.resolve(false);
          }

          return this.isDemographicsMatch(test).then(isDemographicsMatch => {
            if (!isDemographicsMatch) {
              return false;
            }

            const shouldStart = random() < test.probability;
            return shouldStart;
          });
        }

        /*
         * Checks if a running test should be stopped because it is not marked as
         * 'Active' anymore or because its treatment period is over (i.e., it has)
         * been running long enough.
         *
         * @param {Object} test - The test.
         * @returns {Boolean} - True, if the test should be stopped.
         */
        shouldStopTest(test) {
          if (!this.isTestActive(test)) {
            return true;
          }

          const expirationDate = moment(test.started, DATE_FORMAT$1).add(test.treatment_length, 'days');
          if (!getSynchronizedDate().isBefore(expirationDate)) {
            return true;
          }

          return false;
        }

        /*
         * A test is active if its status is 'Active' and if its end date is in the
         * future.
         *
         * @param {Object} - The test to inspect.
         * @returns {Boolean} - True, if the test is active.
         */
        isTestActive(test) {
          return test.status === 'Active' && getSynchronizedDate().isBefore(moment(test.end_date, DATE_FORMAT$1));
        }

        /*
         * Checks if the client's core version matches the core version
         * required by the test.
         *
         * @param {Object} - The test.
         * @returns {Boolean}  True, if the core version matches.
         */
        isVersionMatch(test) {
          const version = getCoreVersion();
          return (version || '').startsWith(test.core_version || '');
        }

        /*
         * Uses demographics to check for match.
         *
         * @param {Object} test - The test.
         * @returns {Boolean} - True, if the test has matching demographics.
         */
        isDemographicsMatch(test) {
          return getDemographics().catch(ex => {
            logger$10.error('Error while retrieving demographics', ex);
            return {};
          }).then(userDemographics => Object.keys(test.demographic).every(factor => {
            const userValue = userDemographics[factor];
            const testValue = test.demographic[factor];

            if (factor === 'install_date') {
              const userDate = moment(userValue, DATE_FORMAT$1);

              var _testValue$split$map = testValue.split('-').map(date => moment(date)),
                  _testValue$split$map2 = _slicedToArray$21(_testValue$split$map, 2);

              const testFirstDate = _testValue$split$map2[0],
                    testLastDate = _testValue$split$map2[1];

              const testDateRange = moment.range(testFirstDate, testLastDate || testFirstDate);

              return testDateRange.contains(userDate);
            }

            return (userValue || '').startsWith(testValue);
          }));
        }

        /*
         * Checks if this test is competing because it lists another test as
         * competing or it is listed as competing by another test.
         *
         * @param {Object} test - The test.
         * @returns {Boolean} - True, if the test is competing.
         */
        isTestCompeting(test, otherTests) {
          // check if current tests lists a competing test
          const isListing = (test.competitors || []).some(id => has(otherTests, id));

          // check if current test is listed as competing
          const isListed = Object.keys(otherTests).some(key => (otherTests[key].competitors || []).some(id => id === test.id));

          return isListing || isListed;
        }
      }

      class ModuleStorage {
        constructor() {
          this.database = new DB('cliqz-abtests');
        }

        get(k, d) {
          return this.database.get(k).then(doc => doc.v).catch(error => {
            if (error.status === 404) {
              return d;
            }
            throw error;
          });
        }

        // replaces existing documents
        set(k, v) {
          return this.remove(k).catch(() => null).then(() => this.database.put({ _id: k, v }));
        }

        remove(k) {
          return this.database.get(k).then(doc => this.database.remove(doc));
        }
      }

      class SharedStorage {
        get(k, d) {
          return Promise.resolve(prefs.get(k, d));
        }

        set(k, v) {
          Promise.resolve(prefs.set(k, v));
        }

        remove(k) {
          Promise.resolve(prefs.clear(k));
        }
      }

      var _extends$15 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      // half an hour
      const UPDATE_INTERVAL = 30 * 60 * 1000;

      /**
        @namespace abtests
        @class Background
       */
      var Background$21 = background({
        init() {
          const client = new Client();

          const moduleStorage = new ModuleStorage();
          const sharedStorage = new SharedStorage();

          this.isRunning = false;
          this.manager = new Manager(client, moduleStorage, sharedStorage);
          return this.manager.loadTests().then(() => this.start());
        },

        start() {
          if (!this.isRunning) {
            this.isRunning = true;
            this.updateTests();
          }
        },

        stop() {
          if (this.isRunning) {
            this.isRunning = false;
            CliqzUtils.clearTimeout(this.runTimer);
          }
        },

        updateTests() {
          this.manager.updateTests();
          if (this.isRunning) {
            this.runTimer = CliqzUtils.setTimeout(this.updateTests.bind(this), UPDATE_INTERVAL);
          }
        },

        unload() {
          this.stop();
        },

        beforeBrowserShutdown() {},

        events: {},

        actions: {
          isRunning() {
            return this.isRunning;
          },
          start() {
            return this.start();
          },
          stop() {
            return this.stop();
          },
          getCompletedTests() {
            return this.manager.completedTests;
          },
          getRunningTests() {
            return this.manager.runningTests;
          },
          getDemographics() {
            return getDemographics();
          },
          getCoreVersion() {
            return getCoreVersion();
          },
          getAvailableTests() {
            return this.manager.client.getAvailableTests();
          },
          loadTests() {
            return this.manager.loadTests();
          },
          saveTests() {
            return this.manager.saveTests();
          },
          updateTests() {
            return this.manager.updateTests();
          },
          startTest(test, group) {
            return this.manager.startTest(_extends$15({}, test, { group }));
          },
          stopTest(test) {
            return this.manager.stopTest(test);
          },
          removeTest(test) {
            delete this.manager.completedTests[test.id];
          }
        }
      });

      class Win$22 {
        init() {}

        unload() {}
      }

      var abtestsModule = {
        Background: Background$21,
        Window: Win$22
      };

      var modules = { 'core': coreModule, 'core-cliqz': coreCliqzModule, 'dropdown': dropdownModule, 'firefox-specific': firefoxSpecificModule, 'static': staticModule, 'autocomplete': autocompleteModule, 'geolocation': geolocationModule, 'ui': uiModule, 'last-query': lastQueryModule, 'human-web': humanWebModule, 'anti-phishing': antiPhishingModule, 'context-menu': contextMenuModule, 'freshtab': freshtabModule, 'webrequest-pipeline': webrequestPipelineModule, 'antitracking': antitrackingModule, 'performance': performanceModule, 'hpn': hpnModule, 'control-center': controlCenterModule, 'offers-v2': offersV2Module, 'history-analyzer': historyAnalyzerModule, 'offers-cc': offersCcModule, 'browser-panel': browserPanelModule, 'message-center': messageCenterModule, 'offboarding': offboardingModule, 'anolysis': anolysisModule, 'market-analysis': marketAnalysisModule, 'abtests': abtestsModule };

      class DefaultWeakMap {
        constructor(generator) {
          this._map = new WeakMap();
          this._generator = generator;
        }

        get(key) {
          if (this._map.has(key)) {
            return this._map.get(key);
          }
          const val = this._generator(key);
          this._map.set(key, val);
          return val;
        }

        has(key) {
          return this._map.has(key);
        }

        set(key, val) {
          return this._map.set(key, val);
        }

        delete(key) {
          return this._map.delete(key);
        }
      }

      class Service {
        constructor(initializer) {
          this._initializer = initializer;
        }

        /*
         * Service is initialized only once
         * Multiple calls to init return same promise
         */
        init() {
          if (this._readyDefer) {
            return this._readyDefer.promise;
          }

          this._readyDefer = new Defer();

          // wrap in promise to catch exceptions
          Promise.resolve().then(() => this._initializer()).then(() => this._readyDefer.resolve(), e => {
            this._readyDefer.reject();
            throw e;
          });

          return this._readyDefer.promise;
        }
      }

      /**
       * @module core
       * @namespace core
       */

      /**
       * Abstract class for classes which want to allow consumers to listen to events
       * from the object.
       *
       * @class EventEmitter
       */
      class EventEmitter {
        /**
         * @constructor
         * @param {Array<String>} eventNames - Array of events which can be registered with the emitter
         */
        constructor(eventNames) {
          /**
           * @property {object} _eventListeners
           */
          this._eventListeners = eventNames.reduce((hash, val) => Object.assign(hash, { [val]: [] }), Object.create(null));
        }

        /**
         * Register to listen to events from this object.
         *
         * @method on
         * @param {String} eventName - Name of the event to listen to
         * @param {Function} callback - Listener function to call when the event is triggered
         */
        on(eventName, callback) {
          if (!(eventName in this._eventListeners)) {
            throw new Error(`${eventName} is not a valid app lifecycle event`);
          }
          this._eventListeners[eventName].push(callback);
        }

        /**
         * Emit an event. Calls all registered listeners to this event on this object
         *
         * @method emit
         * @param {String} eventName - Name of event to emit.
         * @param {Array} args - Arguments to pass to listeners.
         */
        emit(eventName) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          this._eventListeners[eventName].forEach(fn => CliqzUtils.setTimeout(fn.bind(...[null, ...args])), 0);
        }
      }

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const lifecycleEvents = {
        enabled: 'enabled',
        disabled: 'disabled'
      };
      const eventNames = Object.keys(lifecycleEvents).map(k => lifecycleEvents[k]);

      class Module extends EventEmitter {
        constructor(name, settings) {
          super(eventNames);
          this.name = name;
          this.loadingTime = null;
          this.settings = settings;
          this._bgReadyDefer = new Defer();
          this._state = 'disabled';
          this._stat = {
            init: 0,
            load: 0
          };
          this._windows = new DefaultWeakMap(() => ({
            windowModule: null,
            loadingDefer: new Defer(),
            loadingTime: null,
            loadingStarted: false
          }));
        }

        get providedServices() {
          if (this._services) {
            return this._services;
          }

          this._services = Object.create(null);

          Object.keys(this.backgroundModule.providesServices || {}).forEach(serviceName => {
            const initializer = this.backgroundModule.providesServices[serviceName];
            this._services[serviceName] = new Service(initializer);
          });

          return this._services;
        }

        get requiredServices() {
          return this.backgroundModule.requiresServices || [];
        }

        isReady() {
          return this._bgReadyDefer.promise;
        }

        get backgroundModule() {
          return modules[this.name].Background;
        }

        get WindowModule() {
          return modules[this.name].Window;
        }

        get isEnabled() {
          return this._state === 'enabled';
        }

        get isEnabling() {
          return this._state === 'enabling';
        }

        get isDisabled() {
          return this._state === 'disabled';
        }

        markAsEnabling() {
          this._state = 'enabling';
        }

        enable() {
          let app = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          console$1.log('Module', this.name, 'start loading');
          const loadingStartedAt = Date.now();
          return Promise.resolve(this.backgroundModule).then(background => {
            this.background = background;
            return background.init(this.settings, app);
          }).then(() => {
            this._state = 'enabled';
            this.loadingTime = Date.now() - loadingStartedAt;
            console$1.log('Module: ', this.name, ' -- Background loaded');
            this._bgReadyDefer.resolve();
            this.emit(lifecycleEvents.enabled);
          }).catch(e => {
            this._state = 'disabled';
            this._bgReadyDefer.reject();
            throw e;
          });
        }

        disable() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { quick: false };

          let quick = _ref.quick;

          console$1.log('Module', this.name, 'start unloading');
          const background = this.background;

          if (quick) {
            // background does not need to have beforeBrowserShutdown defined
            const quickShutdown = background.beforeBrowserShutdown || function beforeBrowserShutdown() {};
            quickShutdown.call(background);
          } else {
            background.unload();
            this._state = 'disabled';
            this.loadingTime = null;
            this._bgReadyDefer = new Defer();
          }
          console$1.log('Module', this.name, 'unloading finished');
          this.emit(lifecycleEvents.disabled);
        }

        /**
         * return window module
         */
        loadWindow(window) {
          if (this.isDisabled) {
            return Promise.reject('cannot load window of disabled module');
          }
          const windowModuleState = this._windows.get(window);
          const loadingDefer = windowModuleState.loadingDefer,
                loadingStarted = windowModuleState.loadingStarted;

          if (loadingStarted) {
            console$1.log('Module window:', `"${this.name}"`, 'already being loaded');
            return loadingDefer.promise;
          }

          console$1.log('Module window:', `"${this.name}"`, 'loading started');
          windowModuleState.loadingStarted = true;
          const loadingStartedAt = Date.now();
          let initStartedAt;
          return Promise.all([new this.WindowModule({
            settings: this.settings,
            window,
            windowId: new Window(window).id,
            background: this.backgroundModule
          }), this.isReady()]).then(_ref2 => {
            var _ref3 = _slicedToArray(_ref2, 1);

            let windowModule = _ref3[0];

            initStartedAt = Date.now();
            windowModuleState.windowModule = windowModule;
            return windowModule.init();
          }).then(() => {
            windowModuleState.initTime = Date.now() - initStartedAt;
            windowModuleState.loadingTime = Date.now() - loadingStartedAt;
            this._stat.init += windowModuleState.initTime;
            this._stat.load += windowModuleState.loadingTime;
            console$1.log('Module window:', `"${this.name}"`, 'loading finished');
            loadingDefer.resolve();
            return loadingDefer.promise;
          }).catch(e => {
            loadingDefer.reject(e);
            throw e;
          });
        }

        getWindowModule(window) {
          return this._windows.get(window).windowModule;
        }

        getWindowLoadingPromise(window) {
          return this._windows.get(window).loadingDefer.promise;
        }

        getLoadingTime(window) {
          return this._windows.get(window).loadingTime;
        }

        getInitTime(window) {
          return this._windows.get(window).initTime;
        }

        unloadWindow(window) {
          var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          let disable = _ref4.disable;

          const windowModule = this.getWindowModule(window);
          if (!windowModule) {
            return;
          }

          if (disable && windowModule.disable) {
            console$1.log('Module window', `"${this.name}"`, 'disabling');
            windowModule.disable();
          }

          console$1.log('Module window', `"${this.name}"`, 'unloading');
          windowModule.unload();
          this._windows.delete(window);
          console$1.log('Module window', `"${this.name}"`, 'unloading finished');
        }

        status() {
          return {
            isEnabled: this.isEnabled
          };
        }

        action(name) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return inject.module(this.name).action(name, ...args);
        }

        windowAction(window, name) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          return inject.module(this.name).windowAction(window, name, ...args);
        }
      }

      function setApp(app) {
        setGlobal(app);
      }

      function shouldEnableModule(name) {
        const pref = `modules.${name}.enabled`;
        return !prefs.has(pref) || prefs.get(pref) === true;
      }

      /**
       * @module core
       * @namespace core
       */

      /**
       * @class App
       */
      class App {
        /**
         * @constructor
         * @param {object} config
         */
        constructor() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          let version = _ref.version;

          /**
           * @property {string} version
           */
          this.version = version;
          CliqzUtils.VERSION = this.version;
          /**
           * @property {object} modules
           */
          this.modules = Object.create(null);

          /**
           * @property {object} services
           */
          this.services = Object.create(null);

          /**
           * @property {WeakSet} loadedWindows
           */
          this.loadedWindows = new WeakSet();

          this._startedDefer = new Defer();

          config.modules.forEach(moduleName => {
            const module = new Module(moduleName, Object.assign({}, config.settings, { version }));
            this.modules[moduleName] = module;

            // Keep reference to all module services by their name
            // Currently last one wins
            Object.assign(this.services, module.providedServices);
          });

          this.debugModules = App.debugModules;

          CliqzUtils.extensionVersion = version;
          setApp(this);
          this.isRunning = false;
          this.onMigrationEnded = (_, topic) => {
            if (topic === 'Migration:Ended') {
              this.extensionRestart();
            }
          };
        }

        /**
         * should be used only for testing!
         *
         * @method extensionRestart
         * @param {function} changes - function called between stop and start
         */
        extensionRestart(changes) {
          // unload windows
          forEachWindow(win => {
            if (win.CLIQZ && win.CLIQZ.Core) {
              this.unloadWindow(win);
            }
          });

          // unload background
          this.unload();

          // apply changes
          if (changes) {
            changes();
          }

          // load background
          return this.load().then(() => {
            // load windows
            const corePromises = [];
            forEachWindow(win => {
              corePromises.push(this.loadWindow(win));
            });
            return Promise.all(corePromises);
          });
        }

        /**
         * @method unloadIntoWindow
         * @private
         */
        unloadFromWindow(win, data) {
          // unload core even if the window closes to allow all modules to do their cleanup
          if (!mustLoadWindow(win)) {
            return;
          }

          try {
            this.unloadWindow(win, data);
            // count the number of opened windows here and send it to events
            // if the last window was closed then remaining == 0.
            let remainingWin = 0;
            forEachWindow(() => {
              remainingWin += 1;
            });
            CliqzEvents.pub('core.window_closed', { remaining: remainingWin });
          } catch (e) {
            reportError(e);
          }
        }

        /**
         * @method loadIntoWindow
         * @private
         */
        loadIntoWindow(win, source) {
          console$1.log('window loading -> source:', source);
          if (!win) return;
          if (this.loadedWindows.has(win)) {
            console$1.log('window loading -> stop: already loaded');
            return;
          }
          this.loadedWindows.add(win);

          waitWindowReady(win) // This takes a lot to fulfill...
          .then(() => {
            if (mustLoadWindow(win)) {
              return this.loadWindow(win);
            } else if (config.settings.id === 'funnelcake@cliqz.com' && win.location.href === 'chrome://browser/content/aboutDialog.xul') {
              // should be removed after the funnelcake experiment
              win.setTimeout(doc => {
                const privacyLink = doc.querySelectorAll('.bottom-link')[2];
                if (privacyLink) {
                  privacyLink.setAttribute('href', 'https://www.mozilla.org/de/privacy/firefox-cliqz/');
                }
              }, 100, win.document);
            }
            return null;
          }).catch(e => {
            console$1.error(e, 'Extension filed loaded window modules');
          });
        }

        /**
         * Starts the Cliqz App.
         * Loads all required services, module backgrounds and module windows.
         * Setup window observer to load window module into all future windows.
         *
         * Modules that are marked as disabled will not be loaded. To mark a module
         * as disabled set a preference `modules.<moduleName>.enabled` to `false`.
         *
         * @method start
         * @returns {Promise}
         */
        start() {
          this.isRunning = true;
          addMigrationObserver(this.onMigrationEnded);

          return this.setupPrefs().then(() => this.load().then(() => {
            enableChangeEvents$1();
            this.windowWatcher = (win, event) => {
              if (event === 'opened') {
                this.loadIntoWindow(win, 'windowWatcher');
              } else if (event === 'closed') {
                this.unloadFromWindow(win);
              }
            };

            addWindowObserver(this.windowWatcher);

            // Load into currently open windows
            forEachWindow(win => {
              this.loadIntoWindow(win, 'existing window');
            });

            this.sessionRestoreObserver = () => {
              // Load into all the open windows after session restore hits
              forEachWindow(win => {
                this.loadIntoWindow(win, 'session restore');
              });
            };

            addSessionRestoreObserver(this.sessionRestoreObserver);
          }));
        }

        /**
         * Stops the Cliqz App
         *
         * @method stop
         * @params {boolean} isShutdown
         * @params {boolean} disable
         * @params {string} telemetrySignal
         */
        stop(isShutdown, disable, telemetrySignal) {
          this.isRunning = false;
          removeMigrationObserver(this.onMigrationEnded);
          // NOTE: Disable this warning locally since the solution is hacky anyway.
          /* eslint-disable no-param-reassign */

          CliqzUtils.telemetry({
            type: 'activity',
            action: telemetrySignal,
            lifecyle: 'stop'
          }, true /* force push */);

          /*
           *
           *  There are different reasons on which extension does shutdown:
           *  https://developer.mozilla.org/en-US/Add-ons/Bootstrapped_extensions#Reason_constants
           *
           *  We handle them differently:
           *  * APP_SHUTDOWN - nothing need to be unloaded as browser shutdown, but
           *      there may be data that we may like to persist
           *  * ADDON_DISABLE, ADDON_UNINSTALL - full cleanup + bye bye messages
           *  * ADDON_UPGRADE, ADDON_DOWNGRADE - fast cleanup
           *
           */

          if (disable && config.settings.channel === '40') {
            // in the Cliqz browser the extension runns as a system addon and
            // the user cannot disable or uninstall it. Therefore we do not need
            // to consider an uninstall signal.
            //
            // we need this override to avoid an issue in FF52. Please check:
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1351617
            //
            // TODO: find a nicer way to detect if this runs in the Cliqz browser
            disable = false;
          }

          if (isShutdown) {
            this.unload({ quick: true });
            return;
          }

          // Unload from any existing windows
          forEachWindow(w => {
            this.unloadFromWindow(w, { disable });
          });

          this.unload();

          if (disable) {
            this.restorePrefs();
          }

          removeWindowObserver(this.windowWatcher);
          removeSessionRestoreObserver(this.sessionRestoreObserver);

          disableChangeEvents$1();
        }

        get moduleList() {
          const modules = this.modules;
          return Object.keys(modules).map(moduleName => modules[moduleName]);
        }

        enabledModules() {
          return config.modules.map(name => this.modules[name]).filter(module => module.isEnabled);
        }

        setupPrefs() {
          const initPrefs = prefs.init || Promise.resolve.bind(Promise);
          return initPrefs().then(() => {
            setInstallDatePref(CliqzUtils.getServerDay());

            if (config.environment === 'development') {
              prefs.set('developer', true);
            }

            // Ensure prefs are set to our custom values
            /** Change some prefs for a better cliqzperience -- always do a backup! */
            setOurOwnPrefs();

            if ('default_prefs' in config) {
              Object.keys(config.default_prefs).forEach(pref => {
                if (!prefs.has(pref)) {
                  console$1.log('App', 'set up preference', `"${pref}"`);
                  prefs.set(pref, config.default_prefs[pref]);
                }
              });
            }
            this.prefchangeEventListener = subscribe('prefchange', this.onPrefChange, this);
          });
        }

        restorePrefs() {
          resetOriginalPrefs();
        }

        prepareServices(serviceNames) {
          return Promise.all(serviceNames.map(
          // service is initialized only once, so calling init multiple times is fine
          serviceName => this.services[serviceName].init()));
        }

        /**
         * Enable module and it dependant services
         * Module will not load if dependant services fail to initialize
         *
         * @method loadModule
         * @private
         */
        loadModule(module) {
          if (module.isEnabled || module.isEnabling) {
            console$1.log('App', 'loadModule', 'module already loaded');
            return module.isReady();
          }

          module.markAsEnabling();

          return this.prepareServices(module.requiredServices).then(() => module.enable(this).catch(e => console$1.error('App', 'Error on loading module:', module.name, e)), e => console$1.error('App', 'Error on loading services', e));
        }

        /**
         * Triggers module loading
         */
        load() {
          console$1.log('App', 'Loading modules started');
          const allModules = this.moduleList;
          const core = allModules.find(x => x.name === 'core');
          const modules = allModules.filter(x => x.name !== 'core' && shouldEnableModule(x.name));

          // we load core first before any other module
          return this.loadModule(core)
          // loading of modules should be paralellized as much as possible
          .then(() => {
            // do not return - we trigger module loading and let window loading to
            // start as soon as possible
            Promise.all(modules.map(x => this.loadModule(x))).then(() => {
              console$1.log('App', 'Loading modules -- all loaded');
              this._startedDefer.resolve();
            }).catch(e => {
              console$1.error('App', 'Loading modules failed', e);
              this._startedDefer.reject(e);
            });
          });
        }

        unload() {
          var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { quick: false };

          let quick = _ref2.quick;

          if (this.prefchangeEventListener) {
            this.prefchangeEventListener.unsubscribe();
          }

          console$1.log('App', 'unload background modules');
          this.enabledModules().reverse().forEach(module => {
            try {
              console$1.log('App', 'unload background module: ', module.name);
              module.disable({ quick });
            } catch (e) {
              console$1.error(`Error unloading module: ${module.name}`, e);
            }
          });
          console$1.log('App', 'unload background modules finished');
        }

        loadWindow(window) {
          // TODO: remove Cliqz from window
          if (!window.CLIQZ) {
            const CLIQZ = {
              startedAt: Date.now(),
              app: this,
              Core: {} // TODO: remove and all clients
            };

            Object.defineProperty(window, 'CLIQZ', {
              configurable: true,
              value: CLIQZ
            });
          }

          const core = this.moduleList.find(x => x.name === 'core');
          const modules = this.moduleList.filter(x => x.name !== 'core' && !x.isDisabled);

          return core.loadWindow(window).then(() => Promise.all(modules.map(mod => mod.loadWindow(window).catch(e => console$1.error('App', 'error loading window module', mod.name, e))))).then(() => {
            console$1.log('App', 'Window loaded');
            const windowId = new Window(window).id;
            CliqzEvents.pub('app:window-loaded', { windowId });
            window.CLIQZ.loadedAt = Date.now();
            window.CLIQZ.loadingTime = window.CLIQZ.loadedAt - window.CLIQZ.startedAt;
            this.isFullyLoaded = true;
          }).catch(e => {
            console$1.error('App window', 'Error loading (should not happen!)', e);
          });
        }

        unloadWindow(window, data) {
          console$1.log('App window', 'unload window modules');
          this.enabledModules().reverse().forEach(module => {
            try {
              module.unloadWindow(window, data);
            } catch (e) {
              console$1.error('App window', `error on unload module ${module.name}`, e);
            }
          });
          /* eslint-disable */
          delete window.CLIQZ;
          /* eslint-enable */
        }

        onPrefChange(pref) {
          if (!pref.startsWith('modules.')) {
            return;
          }

          const prefParts = pref.split('.');
          if (prefParts.pop() !== 'enabled') {
            return;
          }

          const shouldEnable = prefs.get(pref) === true;
          const shouldDisable = !shouldEnable;
          const moduleName = prefParts.pop();
          const module = this.modules[moduleName];

          if (!module) {
            // pref for non-existing module - just ignore
            return;
          }

          if (shouldEnable && module.isDisabled) {
            this.enableModule(module.name);
          } else if (shouldDisable && !module.isDisabled) {
            this.disableModule(module.name);
          } else {
            // prefchange tends to fire with no change - just ignore
          }
        }

        /**
         * Enabled module background and then load into all windows.
         * Returns early if module is already enabled.
         *
         * It sets the `modules.<moduleName>.enabled` pref to true.
         *
         * @method enableModule
         * @params {string} moduleName - name of the module
         * @returns {Promise}
         */
        enableModule(moduleName) {
          const module = this.modules[moduleName];
          prefs.set(`modules.${moduleName}.enabled`, true);

          if (module.isEnabled || !this.isRunning) {
            return Promise.resolve();
          }

          // TODO: move this into the loadModule
          const moduleEnabled = module.isEnabling ? module.isReady() : this.loadModule(module);

          return moduleEnabled.then(() => Promise.all(mapWindows(module.loadWindow.bind(module))));
        }

        /**
         * Disable module windows and then the background.
         * Does nothing if module is already disabled.
         *
         * It sets the `modules.<moduleName>.enabled` pref to false. So if called
         * before startup, it will prevent module start.
         *
         * @todo check this is working fine with new module loading
         *
         * @method disableModule
         * @param {string} moduleName - name of a module
         * @returns {Promise}
         */
        disableModule(moduleName) {
          const module = this.modules[moduleName];
          prefs.set(`modules.${moduleName}.enabled`, false);

          if (module.isDisabled || !this.isRunning) {
            return;
          }

          // TODO: what if it was loading? Can we stop it?

          forEachWindow(module.unloadWindow.bind(module));
          module.disable();
        }

        ready() {
          return this._startedDefer.promise;
        }
      }

      global.App = App;
      global.App.debugModules = debugModules;
      global.CliqzUtils = CliqzUtils;
      global.config = config;
    }
  };
});
})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory();
  else
    CliqzGlobal = factory();
});